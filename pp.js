// ==========================================
// X Social App - 獨立JS整合文件
// 版本: 1.0
// 使用方式:
// 1. 在HTML中引入: <script src="x-social-app.js" defer></script>
// 2. 調用初始化: window.renderXSocialScreenProxy()
// ==========================================

(function (window) {
  ('use strict');

  // ============================================
  // 第一部分: CSS樣式注入
  // ============================================
  function injectStyles() {
    const styleId = 'x-social-app-styles';

    // 避免重複注入
    if (document.getElementById(styleId)) return;

    const style = document.createElement('style');
    style.id = styleId;
    style.textContent = `
      /* ========== X社交頁面主題變數 ========== */
      /* 將CSS變數限定在X應用容器內,避免影響其他頁面 */
      #x-social-screen {
        --x-bg-primary: #000;
        --x-bg-secondary: #1a1a1a;
        --x-bg-hover: rgba(255,255,255,0.03);
        --x-border-color: #2f3336;
        --x-text-primary: #fff;
        --x-text-secondary: #71767b;
        --x-text-tertiary: #8b98a5;
        --x-accent: #1d9bf0;
        --x-input-bg: #1a1a1a;
        --x-modal-overlay: rgba(91, 112, 131, 0.4);
      }

      /* 日間模式 */
      #x-social-screen.x-theme-light {
        --x-bg-primary: #fff;
        --x-bg-secondary: #f7f9f9;
        --x-bg-hover: rgba(0,0,0,0.03);
        --x-border-color: #eff3f4;
        --x-text-primary: #0f1419;
        --x-text-secondary: #536471;
        --x-text-tertiary: #5b7083;
        --x-accent: #1d9bf0;
        --x-input-bg: #f7f9f9;
        --x-modal-overlay: rgba(0, 0, 0, 0.4);
      }

      /* ========== X社交頁面基礎樣式 ========== */
      
                /* 自訂捲軸樣式 - X風格（細長短小亮藍色） */
      .tab-content::-webkit-scrollbar,
      #x-comments-page::-webkit-scrollbar,
      .comments-container::-webkit-scrollbar,
      .settings-content::-webkit-scrollbar,
      .profile-content::-webkit-scrollbar,
      .tweets-container::-webkit-scrollbar,
      #detail-comments-container::-webkit-scrollbar,
      .modal-body::-webkit-scrollbar,
      #identity-characters-list::-webkit-scrollbar,
      #characters-list::-webkit-scrollbar,
      #x-presets-list::-webkit-scrollbar,
      .tweet-media-scrollable::-webkit-scrollbar {
        width: 3px;
      }

      .tab-content::-webkit-scrollbar-track,
      #x-comments-page::-webkit-scrollbar-track,
      .comments-container::-webkit-scrollbar-track,
      .settings-content::-webkit-scrollbar-track,
      .profile-content::-webkit-scrollbar-track,
      .tweets-container::-webkit-scrollbar-track,
      #detail-comments-container::-webkit-scrollbar-track,
      .modal-body::-webkit-scrollbar-track,
      #identity-characters-list::-webkit-scrollbar-track,
      #characters-list::-webkit-scrollbar-track,
      #x-presets-list::-webkit-scrollbar-track,
      .tweet-media-scrollable::-webkit-scrollbar-track {
        background: transparent;
      }

      .tab-content::-webkit-scrollbar-thumb,
      #x-comments-page::-webkit-scrollbar-thumb,
      .comments-container::-webkit-scrollbar-thumb,
      .settings-content::-webkit-scrollbar-thumb,
      .profile-content::-webkit-scrollbar-thumb,
      .tweets-container::-webkit-scrollbar-thumb,
      #detail-comments-container::-webkit-scrollbar-thumb,
      .modal-body::-webkit-scrollbar-thumb,
      #identity-characters-list::-webkit-scrollbar-thumb,
      #characters-list::-webkit-scrollbar-thumb,
      #x-presets-list::-webkit-scrollbar-thumb,
      .tweet-media-scrollable::-webkit-scrollbar-thumb {
        background-color: color-mix(in srgb, var(--x-accent) 50%, transparent);
        border-radius: 10px;
        min-height: 30px;
        max-height: 80px;
      }

      .tab-content::-webkit-scrollbar-thumb:hover,
      #x-comments-page::-webkit-scrollbar-thumb:hover,
      .comments-container::-webkit-scrollbar-thumb:hover,
      .settings-content::-webkit-scrollbar-thumb:hover,
      .profile-content::-webkit-scrollbar-thumb:hover,
      .tweets-container::-webkit-scrollbar-thumb:hover,
      #detail-comments-container::-webkit-scrollbar-thumb:hover,
      .modal-body::-webkit-scrollbar-thumb:hover,
      #identity-characters-list::-webkit-scrollbar-thumb:hover,
      #characters-list::-webkit-scrollbar-thumb:hover,
      #x-presets-list::-webkit-scrollbar-thumb:hover,
      .tweet-media-scrollable::-webkit-scrollbar-thumb:hover {
        background-color: color-mix(in srgb, var(--x-accent) , 0.8);
      }

      .tab-content::-webkit-scrollbar-thumb:active,
      #x-comments-page::-webkit-scrollbar-thumb:active,
      .comments-container::-webkit-scrollbar-thumb:active,
      .settings-content::-webkit-scrollbar-thumb:active,
      .profile-content::-webkit-scrollbar-thumb:active,
      .tweets-container::-webkit-scrollbar-thumb:active,
      #detail-comments-container::-webkit-scrollbar-thumb:active,
      .modal-body::-webkit-scrollbar-thumb:active,
      #identity-characters-list::-webkit-scrollbar-thumb:active,
      #characters-list::-webkit-scrollbar-thumb:active,
      #x-presets-list::-webkit-scrollbar-thumb:active,
      .tweet-media-scrollable::-webkit-scrollbar-thumb:active {
        background-color: var(--x-accent);
      }

          /* 修復X社交頁面高度佈局問題 */
          #x-social-screen {
            height: 100vh !important;
            overflow: hidden !important;
            background-color: var(--x-bg-primary) !important;
            color: var(--x-text-primary) !important;
          }

          #x-social-screen .x-pages-container {
            min-height: 0 !important;
            background-color: var(--x-bg-primary) !important;
          }

          #x-social-screen .x-page {
            min-height: 0 !important;
            background-color: var(--x-bg-primary) !important;
          }

          #x-social-screen .x-bottom-nav {
            flex-shrink: 0 !important;
            background-color: var(--x-bg-primary) !important;
            border-top: 1px solid var(--x-border-color) !important;
          }
          
          /* 所有頁面容器使用主題背景色 */
          #x-home-page,
          #x-search-page,
          #x-notifications-page,
          #x-messages-page,
          #x-comments-page,
          #x-settings-page,
          #x-tweet-detail-page,
          #x-profile-page,
          #account-profile-page {
            background-color: var(--x-bg-primary) !important;
          }
          
          /* 頂部巡覽列 - 限定在X應用內 */
          #x-social-screen .x-top-bar,
          #x-social-screen .comments-header,
          #x-social-screen .settings-header,
          #x-social-screen .profile-header,
          #x-social-screen .tweet-detail-header {
            background-color: var(--x-bg-primary) !important;
            border-bottom: 1px solid var(--x-border-color) !important;
          }
          
          /* 標籤欄 - 限定在X應用內 */
          #x-social-screen .x-home-tabs,
          #x-social-screen .search-tabs,
          #x-social-screen .profile-tabs {
            background-color: var(--x-bg-primary) !important;
            border-bottom: 1px solid var(--x-border-color) !important;
          }
          
          /* 輸入區域 - 限定在X應用內 */
          #x-social-screen .comment-input-area,
          #x-social-screen .detail-comment-input-area {
            background-color: var(--x-bg-primary) !important;
            border-top: 1px solid var(--x-border-color) !important;
          }
          
          /* 設置頁面內容 - 限定在X應用內 */
          #x-social-screen .settings-content {
            background-color: var(--x-bg-primary) !important;
          }
          
          /* 搜索頭部 - 限定在X應用內 */
          #x-social-screen .search-header {
            background-color: var(--x-bg-primary) !important;
            border-bottom: 1px solid var(--x-border-color) !important;
          }
          
          /* 搜索框 - 限定在X應用內 */
          #x-social-screen .search-box {
            background-color: var(--x-input-bg) !important;
          }
          
          /* 熱搜視圖 - 限定在X應用內 */
          #trending-view,
          #x-social-screen .trending-list {
            background-color: var(--x-bg-primary) !important;
          }
          
          /* 搜索結果內容 */
          #search-results-content {
            background-color: var(--x-bg-primary) !important;
          }
          
          /* 彈窗和模態框 - 限定在X應用內 */
          #x-social-screen .modal-content,
          #x-social-screen .compose-modal-content,
          #x-social-screen #edit-profile-modal .modal-content,
          #x-social-screen #compose-tweet-modal .compose-modal-content,
          #character-x-profile-modal > div > div,
          #relationship-modal > div > div,
          #category-manager-modal > div,
          #character-relationship-graph-modal > div > div,
          #edit-relationship-detail-modal > div > div,
          #npc-edit-modal > div > div {
            background-color: var(--x-bg-primary) !important;
          }
          
          /* 模態框頭部 - 限定在X應用內 */
          #x-social-screen .modal-header,
          #x-social-screen .compose-header {
            background-color: var(--x-bg-primary) !important;
            border-bottom: 1px solid var(--x-border-color) !important;
          }
          
          /* 模態框主體內容區域 - 限定在X應用內 */
          #x-social-screen .modal-body,
          #x-social-screen .compose-body {
            background-color: var(--x-bg-primary) !important;
          }
          
          /* 表單元素 - 限定在X應用內 */
          #x-social-screen input[type="text"],
          #x-social-screen input[type="url"],
          #x-social-screen input[type="email"],
          #x-social-screen textarea,
          #x-social-screen select {
            background-color: var(--x-input-bg) !important;
            border-color: var(--x-border-color) !important;
            color: var(--x-text-primary) !important;
          }
          
          #x-social-screen input[type="text"]:focus,
          #x-social-screen input[type="url"]:focus,
          #x-social-screen input[type="email"]:focus,
          #x-social-screen textarea:focus,
          #x-social-screen select:focus {
            border-color: var(--x-accent) !important;
          }
          
          /* 引用推文 - 限定在X應用內 */
          #x-social-screen .quoted-tweet {
            border-color: var(--x-border-color) !important;
            background-color: var(--x-bg-hover) !important;
          }
          
          /* 回復連接線 - 限定在X應用內 */
          #x-social-screen .comment-item.has-replies::after,
          #x-social-screen .reply-item::before {
            background-color: var(--x-border-color) !important;
            border-color: var(--x-border-color) !important;
          }
          
          /* 卡片和容器 */
          #character-info-display,
          #character-relationships-list,
          #identity-characters-list,
          #characters-list,
          #npcs-list,
          #npc-bind-users {
            background-color: var(--x-input-bg) !important;
            border-color: var(--x-border-color) !important;
          }
          
          /* 內容容器 - 限定在X應用內 */
          #x-social-screen .tab-content,
          #x-social-screen .tweets-container,
          #x-social-screen .comments-container,
          #detail-comments-container,
          #tweet-detail-container,
          #x-profile-tweets-container,
          #account-tweets-container,
          #x-social-screen .profile-content {
            background-color: var(--x-bg-primary) !important;
          }
          
          /* 列表項懸停效果 - 限定在X應用內 */
          #x-social-screen .tweet-item:hover,
          #x-social-screen .comment-item:hover,
          #x-social-screen .trending-item:hover {
            background-color: var(--x-bg-hover) !important;
          }
          
          /* 帳戶資料頁面 - 限定在X應用內 */
          #x-social-screen .user-info-section,
          #x-social-screen .edit-avatar-section,
          #x-social-screen .edit-form-section {
            background-color: var(--x-bg-primary) !important;
          }
          
          /* 設置區域的卡片 */
          #character-binding-area > div,
          #relationship-binding-area > div,
          #npc-binding-area > div {
            background-color: var(--x-input-bg) !important;
            border-color: var(--x-border-color) !important;
          }
          
          /* 熱搜專案 - 限定在X應用內 */
          #x-social-screen .trending-item {
            background-color: var(--x-bg-primary) !important;
          }
          
          /* 推文詳情頁面 - 限定在X應用內 */
          #x-social-screen .tweet-detail-content {
            background-color: var(--x-bg-primary) !important;
          }
          
          /* 所有文本顏色 */
          #x-social-screen span,
          #x-social-screen div:not(.tweet-action):not(.comment-action) {
            color: inherit;
          }
          
          /* 標籤文本 - 限定在X應用內 */
          #x-social-screen .x-tab {
            color: var(--x-text-secondary) !important;
          }
          
          #x-social-screen .x-tab.active {
            color: var(--x-text-primary) !important;
          }
          
          /* SVG圖示顏色 - 非啟動狀態 */
          #x-social-screen .x-back-btn svg,
          #x-social-screen .x-settings svg,
          #x-social-screen .x-refresh-btn svg,
          #x-social-screen .settings-back-btn svg,
          #x-social-screen .comments-back-btn svg,
          #x-social-screen .profile-back-btn svg,
          #x-social-screen .tweet-detail-back-btn svg {
            fill: var(--x-text-primary) !important;
          }
          
          /* 次要SVG圖示 */
          #x-social-screen .tweet-more {
            color: var(--x-text-secondary) !important;
          }
          
          /* 按鈕文本顏色 */
          #x-social-screen button {
            color: inherit;
          }
          
          /* 預留位置文字 */
          #x-social-screen ::placeholder {
            color: var(--x-text-secondary) !important;
          }
          
                    /* 次要文本元素 */
          .tweet-time,
          .tweet-user-handle,
          .comment-time,
          .quoted-user-handle,
          .quoted-user-time {
            color: var(--x-text-secondary) !important;
          }

          /* 主要文本元素 */
          .tweet-user-name,
          .tweet-content,
          .comment-content,
          .quoted-user-name,
          .quoted-content {
            color: var(--x-text-primary) !important;
          }

          /* 熱搜標題和類別 */
          .trending-title {
            color: var(--x-text-primary) !important;
          }

          .trending-category,
          .trending-count {
            color: var(--x-text-secondary) !important;
          }

          /* 關係預覽區域 */
          #relationship-preview {
            background-color: var(--x-bg-secondary) !important;
            border-color: var(--x-border-color) !important;
          }

          /* 關係圖編輯器 */
          #relationship-graph-canvas {
            background-color: var(--x-bg-primary) !important;
          }
          
          /* ========== 帳戶主頁和詳情頁動態元素樣式 ========== */
          /* 帳戶主頁推文容器內的所有span（覆蓋內聯樣式） */
          #account-tweets-container span[style*="color: #fff"],
          #account-tweets-container span[style*="color:#fff"],
          #account-tweets-container span[style*="color: rgb(255, 255, 255)"] {
            color: var(--x-text-primary) !important;
          }
          
          #account-tweets-container span[style*="color: #71767b"],
          #account-tweets-container span[style*="color:#71767b"] {
            color: var(--x-text-secondary) !important;
          }
          
          /* 帳戶主頁推文容器內的div文本顏色 */
          #account-tweets-container div[style*="color: #fff"],
          #account-tweets-container div[style*="color:#fff"],
          #account-tweets-container div[style*="color: #e7e9ea"],
          #account-tweets-container div[style*="color:#e7e9ea"] {
            color: var(--x-text-primary) !important;
          }
          
          #account-tweets-container div[style*="color: #71767b"],
          #account-tweets-container div[style*="color:#71767b"] {
            color: var(--x-text-secondary) !important;
          }
          
          /* 帳戶主頁推文容器內的邊框 */
          #account-tweets-container > div[style*="border-bottom"] {
            border-bottom-color: var(--x-border-color) !important;
          }
          
          /* 帳戶主頁推文容器內的背景卡片 */
          #account-tweets-container div[style*="background-color: #202327"],
          #account-tweets-container div[style*="background-color:#202327"] {
            background-color: var(--x-bg-secondary) !important;
            border-color: var(--x-border-color) !important;
          }
          
          /* 帳戶主頁推文容器內的SVG圖示 */
          #account-tweets-container svg[style*="fill: currentColor"] {
            fill: currentColor !important;
          }
          
          #account-tweets-container svg[style*="fill: #71767b"],
          #account-tweets-container svg[style*="fill:#71767b"] {
            fill: var(--x-text-secondary) !important;
          }
          
          /* 推文詳情頁評論容器內的所有文本 */
          #detail-comments-container span[style*="color: #fff"],
          #detail-comments-container span[style*="color:#fff"] {
            color: var(--x-text-primary) !important;
          }
          
          #detail-comments-container span[style*="color: #71767b"],
          #detail-comments-container span[style*="color:#71767b"] {
            color: var(--x-text-secondary) !important;
          }
          
          #detail-comments-container div[style*="color: #fff"],
          #detail-comments-container div[style*="color:#fff"] {
            color: var(--x-text-primary) !important;
          }
          
          #detail-comments-container div[style*="color: #71767b"],
          #detail-comments-container div[style*="color:#71767b"] {
            color: var(--x-text-secondary) !important;
          }
          
          /* 推文詳情頁評論容器內的邊框和連接線 */
          #detail-comments-container div[style*="border-bottom"] {
            border-bottom-color: var(--x-border-color) !important;
          }
          
          #detail-comments-container div[style*="background-color: #2f3336"],
          #detail-comments-container div[style*="background-color:#2f3336"] {
            background-color: var(--x-border-color) !important;
          }
          
          /* 推文詳情頁評論容器內的卡片背景 */
          #detail-comments-container div[style*="background-color: #202327"],
          #detail-comments-container div[style*="background-color:#202327"],
          #detail-comments-container div[style*="background-color: #1a1a1a"],
          #detail-comments-container div[style*="background-color:#1a1a1a"] {
            background-color: var(--x-bg-secondary) !important;
            border-color: var(--x-border-color) !important;
          }
          
          /* 推文詳情容器內的所有文本 */
          #tweet-detail-container span[style*="color: #fff"],
          #tweet-detail-container span[style*="color:#fff"] {
            color: var(--x-text-primary) !important;
          }
          
          #tweet-detail-container span[style*="color: #71767b"],
          #tweet-detail-container span[style*="color:#71767b"] {
            color: var(--x-text-secondary) !important;
          }
          
          #tweet-detail-container div[style*="color: #fff"],
          #tweet-detail-container div[style*="color:#fff"] {
            color: var(--x-text-primary) !important;
          }
          
          #tweet-detail-container div[style*="color: #71767b"],
          #tweet-detail-container div[style*="color:#71767b"] {
            color: var(--x-text-secondary) !important;
          }
          
          /* 推文詳情容器內的邊框 */
          #tweet-detail-container div[style*="border-bottom"],
          #tweet-detail-container div[style*="border-top"] {
            border-color: var(--x-border-color) !important;
          }
          
          /* 所有動態生成的互動按鈕懸停效果 */
          #account-tweets-container div[style*="cursor: pointer"],
          #detail-comments-container div[style*="cursor: pointer"],
          #tweet-detail-container div[style*="cursor: pointer"] {
            color: inherit !important;
          }
          
          /* 藍色高亮文本（@提及、連結等） */
          span[style*="color: var(--x-accent)"],
          span[style*="color:#1d9bf0"],
          div[style*="color: var(--x-accent)"],
          div[style*="color:#1d9bf0"] {
            color: var(--x-accent) !important;
          }
          
          /* 帳戶主頁標籤欄的"已置頂"文本 */
          #account-tweets-container span[style*="color: #71767b"][style*="font-size: 13px"][style*="font-weight: 700"] {
            color: var(--x-text-secondary) !important;
          }
          
          /* 帳戶主頁的所有互動數字 */
          #account-tweets-container span[style*="font-size: 13px"]:not([style*="font-weight"]) {
            color: var(--x-text-secondary) !important;
          }
          
          /* ========== 角色X資料設置彈窗樣式修復 ========== */
          /* 彈窗背景遮罩 */
          #character-x-profile-modal[style*="background-color: rgba(0,0,0,0.8)"],
          #relationship-modal[style*="background-color: rgba(0,0,0,0.8)"] {
            background-color: rgba(0,0,0,0.6) !important;
          }
          
          /* 彈窗主容器 */
          #character-x-profile-modal > div > div[style*="background-color: #000"],
          #relationship-modal > div > div[style*="background-color: #000"] {
            background-color: var(--x-bg-primary) !important;
            border-color: var(--x-border-color) !important;
          }
          
          /* 彈窗頭部 */
          #character-x-profile-modal h2,
          #character-x-profile-modal h3,
          #relationship-modal h3 {
            color: var(--x-text-primary) !important;
          }
          
          /* 彈窗頭部關閉按鈕 */
          #character-x-profile-modal button[onclick*="close"] svg,
          #relationship-modal button[onclick*="close"] svg {
            fill: var(--x-text-secondary) !important;
          }
          
          /* 彈窗所有邊框 */
          #character-x-profile-modal div[style*="border-bottom: 1px solid #333"],
          #character-x-profile-modal div[style*="border: 1px solid #333"],
          #relationship-modal div[style*="border-bottom: 1px solid #333"] {
            border-color: var(--x-border-color) !important;
          }
          
          /* 角色資訊顯示區域 */
          #character-info-display[style*="background-color: #0a0a0a"] {
            background-color: var(--x-bg-secondary) !important;
          }
          
          /* 彈窗內所有label文字 */
          #character-x-profile-modal label,
          #relationship-modal label {
            color: var(--x-text-primary) !important;
          }
          
          /* 彈窗內所有次要文字 */
          #character-x-profile-modal div[style*="color: #71767b"],
          #relationship-modal div[style*="color: #71767b"] {
            color: var(--x-text-secondary) !important;
          }
          
          /* 彈窗內所有輸入框 */
          #character-x-profile-modal input[type="text"],
          #character-x-profile-modal input[type="url"],
          #character-x-profile-modal textarea,
          #character-x-profile-modal select,
          #relationship-modal input[type="text"],
          #relationship-modal textarea,
          #relationship-modal select {
            background-color: var(--x-input-bg) !important;
            border-color: var(--x-border-color) !important;
            color: var(--x-text-primary) !important;
          }
          
          /* 輸入框焦點狀態 */
          #character-x-profile-modal input:focus,
          #character-x-profile-modal textarea:focus,
          #character-x-profile-modal select:focus,
          #relationship-modal input:focus,
          #relationship-modal textarea:focus,
          #relationship-modal select:focus {
            border-color: var(--x-accent) !important;
          }
          
          /* 彈窗內的頭像預覽 */
          #character-x-avatar,
          #character-x-cover-preview {
            border-color: var(--x-border-color) !important;
          }
          
          /* 角色X資料彈窗頭像填充 */
          #character-x-avatar {
            object-fit: cover !important;
            overflow: hidden !important;
            box-sizing: border-box !important;
          }
          
          /* 彈窗內的span文字 */
          #character-x-profile-modal span[style*="color: #fff"],
          #relationship-modal span[style*="color: #fff"] {
            color: var(--x-text-primary) !important;
          }
          
          #character-x-profile-modal span[style*="color: #71767b"],
          #relationship-modal span[style*="color: #71767b"] {
            color: var(--x-text-secondary) !important;
          }
          
          /* 提示框背景 */
          #character-x-profile-modal div[style*="background-color: color-mix(in srgb, var(--x-accent) , 0.1)"] {
            background-color: color-mix(in srgb, var(--x-accent) , 0.1) !important;
            border-color: var(--x-accent) !important;
          }
          
          /* 提示框內的文字 */
          #character-x-profile-modal div[style*="color: var(--x-accent)"] {
            color: var(--x-accent) !important;
          }
          
          /* 彈窗內的按鈕 */
          #character-x-profile-modal button[type="button"][style*="background-color: transparent"],
          #relationship-modal button[type="button"][style*="background-color: transparent"] {
            border-color: var(--x-border-color) !important;
            color: var(--x-text-primary) !important;
          }
          
          /* ========== X設置頁面樣式修復 ========== */
          /* 設置頁面頭部 */
          .settings-header[style*="background-color: #000"] {
            background-color: var(--x-bg-primary) !important;
            border-bottom-color: var(--x-border-color) !important;
          }
          
          /* 設置頁面標題和返回按鈕 */
          .settings-header span[style*="color: #fff"] {
            color: var(--x-text-primary) !important;
          }
          
          .settings-back-btn svg[style*="fill: #fff"] {
            fill: var(--x-text-primary) !important;
          }
          
          /* 主題切換按鈕圖示 */
          #theme-icon-dark[style*="fill: #fff"] {
            fill: var(--x-text-primary) !important;
          }
          
          #theme-icon-light[style*="fill: #000"] {
            fill: var(--x-text-primary) !important;
          }
          
          /* 設置頁面所有label */
          #x-settings-page label {
            color: var(--x-text-primary) !important;
          }
          
          /* 設置頁面所有次要文字 */
          #x-settings-page p[style*="color: #71767b"],
          #x-settings-page div[style*="color: #71767b"] {
            color: var(--x-text-secondary) !important;
          }
          
          /* 設置頁面所有輸入框和文本域 */
          #x-settings-page textarea,
          #x-settings-page input[type="text"] {
            background-color: var(--x-input-bg) !important;
            border-color: var(--x-border-color) !important;
            color: var(--x-text-primary) !important;
          }
          
          /* 設置頁面輸入框焦點狀態 */
          #x-settings-page textarea:focus,
          #x-settings-page input:focus {
            border-color: var(--x-accent) !important;
          }
          
          /* 設置頁面所有容器背景 */
          #x-settings-page div[style*="background-color: #1a1a1a"] {
            background-color: var(--x-bg-secondary) !important;
            border-color: var(--x-border-color) !important;
          }
          
          /* 設置頁面所有容器邊框 */
          #x-settings-page div[style*="border: 1px solid #333"],
          #x-settings-page div[style*="border-bottom: 1px solid #333"],
          #x-settings-page div[style*="border-top: 1px solid #333"] {
            border-color: var(--x-border-color) !important;
          }
          
          /* 角色關係預覽區域 */
          #relationship-preview[style*="background-color: #0a0a0a"] {
            background-color: var(--x-bg-secondary) !important;
            border-color: var(--x-border-color) !important;
          }
          
          /* 關係預覽預留位置文字 */
          #relationship-preview-placeholder {
            color: var(--x-text-secondary) !important;
          }
          
          /* 關係統計框 */
          #relationship-stats[style*="background-color: color-mix(in srgb, var(--x-accent) , 0.1)"] {
            background-color: color-mix(in srgb, var(--x-accent) , 0.1) !important;
          }
          
          #relationship-stats div[style*="color: var(--x-accent)"] {
            color: var(--x-accent) !important;
          }
          
          /* 切換開關背景 - 限定在X應用內 */
          #x-social-screen .toggle-switch[style*="background-color: #333"] {
            background-color: var(--x-border-color) !important;
          }
          
          /* 切換開關圓圈 - 限定在X應用內 */
          #x-social-screen .toggle-circle[style*="background-color: #fff"] {
            background-color: var(--x-text-primary) !important;
          }
          
          /* 設置頁面標題文字 */
          #x-settings-page div[style*="color: #fff"] {
            color: var(--x-text-primary) !important;
          }
          
          /* 預設管理區域 - 限定在X應用內 */
          #x-social-screen .preset-management h3 {
            color: var(--x-text-primary) !important;
          }
          
          /* NPC列表和角色列表容器 */
          #npcs-list,
          #characters-list {
            background-color: transparent !important;
          }
          
          /* 底部巡覽列圖示顏色 - 限定在X應用內 */
          #x-social-screen .x-nav-item svg {
            fill: var(--x-text-secondary) !important;
          }
          
          #x-social-screen .x-nav-item.active svg {
            fill: var(--x-accent) !important;
          }
          
          /* 底部巡覽列的高亮點 - 限定在X應用內 */
          #x-social-screen .x-nav-item .nav-highlight {
            background-color: var(--x-accent) !important;
          }
          
          /* 浮動按鈕 - 限定在X應用內 */
          #x-social-screen .compose-btn {
            background-color: var(--x-accent) !important;
          }
          
          /* ========== 用戶主頁樣式修復 ========== */
          /* 用戶頭像邊框顏色和填充 - 更強制性地覆蓋 */
          #x-profile-main-avatar {
            border: 5px solid var(--x-bg-primary) !important;
            object-fit: cover !important;
            background-color: var(--x-bg-primary) !important;
            box-sizing: border-box !important;
            overflow: hidden !important;
          }
          
          #edit-main-avatar {
            border: 4px solid var(--x-bg-primary) !important;
            object-fit: cover !important;
            background-color: var(--x-bg-primary) !important;
            box-sizing: border-box !important;
            overflow: hidden !important;
          }
          
          /* 用戶頭像在帳戶主頁 */
          #account-avatar-image {
            border: 4px solid var(--x-bg-primary) !important;
            object-fit: cover !important;
            background-color: var(--x-bg-primary) !important;
            box-sizing: border-box !important;
            overflow: hidden !important;
          }
          
          /* 用戶名和關注資料 */
          #x-profile-user-name,
          #x-profile-following-count,
          #x-profile-followers-count {
            color: var(--x-text-primary) !important;
          }
          
          /* 用戶簡介 */
          #x-profile-bio {
            color: var(--x-text-primary) !important;
          }
          
          /* 編輯資料按鈕 */
          .user-info-section button {
            color: var(--x-text-primary) !important;
            border-color: var(--x-border-color) !important;
          }
          
          /* ========== 角色資訊顯示區域修復 ========== */
          /* 角色資訊顯示區域內的所有文字 */
          #character-info-display div[style*="color: #fff"] {
            color: var(--x-text-primary) !important;
          }
          
          #character-info-display div[style*="color: #71767b"] {
            color: var(--x-text-secondary) !important;
          }
          
          /* ========== 搜索結果使用者卡片修復 ========== */
          /* 搜索結果中的使用者卡片邊框 */
          #search-results-content > div[style*="border-bottom: 1px solid #2f3336"] {
            border-bottom-color: var(--x-border-color) !important;
          }
          
          /* 搜索結果中的用戶名 */
          #search-results-content span[style*="color: #fff"] {
            color: var(--x-text-primary) !important;
          }
          
          /* 搜索結果中的用戶控制碼 */
          #search-results-content div[style*="color: #71767b"] {
            color: var(--x-text-secondary) !important;
          }
          
          /* 搜索結果中的用戶簡介 */
          #search-results-content div[style*="color: #e7e9ea"] {
            color: var(--x-text-primary) !important;
          }
          
          /* ========== NPC編輯彈窗修復 ========== */
          /* NPC彈窗背景 */
          #npc-edit-modal > div[style*="background-color: #000"] {
            background-color: var(--x-bg-primary) !important;
          }
          
          /* NPC彈窗頭部邊框 */
          #npc-edit-modal div[style*="border-bottom: 1px solid #2f3336"] {
            border-bottom-color: var(--x-border-color) !important;
          }
          
          /* NPC彈窗標題 */
          #npc-modal-title {
            color: var(--x-text-primary) !important;
          }
          
          /* NPC彈窗關閉按鈕圖示 */
          #npc-edit-modal svg[style*="fill: #fff"] {
            fill: var(--x-text-primary) !important;
          }
          
          /* NPC彈窗所有label */
          #npc-edit-modal label {
            color: var(--x-text-secondary) !important;
          }
          
          /* NPC彈窗所有輸入框和文本域 */
          #npc-edit-modal input,
          #npc-edit-modal textarea {
            background-color: var(--x-bg-secondary) !important;
            border-color: var(--x-border-color) !important;
            color: var(--x-text-primary) !important;
          }
          
          /* NPC彈窗輸入框焦點狀態 */
          #npc-edit-modal input:focus,
          #npc-edit-modal textarea:focus {
            border-color: var(--x-accent) !important;
          }
          
          /* NPC綁定用戶列表容器 */
          #npc-bind-users {
            background-color: var(--x-bg-secondary) !important;
            border-color: var(--x-border-color) !important;
          }
          
          /* ========== NPC列表修復 ========== */
          /* NPC列表項背景和邊框 */
          #npcs-list > div[style*="background-color: #0a0a0a"] {
            background-color: var(--x-bg-secondary) !important;
            border-color: var(--x-border-color) !important;
          }
          
          /* NPC清單中的主要文字 */
          #npcs-list div[style*="color: #fff"] {
            color: var(--x-text-primary) !important;
          }
          
          /* NPC清單中的次要文字 */
          #npcs-list div[style*="color: #71767b"] {
            color: var(--x-text-secondary) !important;
          }
          
          /* NPC列表項邊框 */
          #npcs-list > div[style*="border: 1px solid #2f3336"] {
            border-color: var(--x-border-color) !important;
          }
          
          /* NPC清單空狀態文字 */
          #npcs-list p[style*="color: #71767b"] {
            color: var(--x-text-secondary) !important;
          }
          
          /* ========== 角色關係冊修復 ========== */
          /* 角色關係冊管理區域容器 */
          #relationship-binding-area > div[style*="background-color: #1a1a1a"] {
            background-color: var(--x-bg-secondary) !important;
            border-color: var(--x-border-color) !important;
          }
          
          /* 角色關係冊標題 */
          #relationship-binding-area div[style*="color: #fff"] {
            color: var(--x-text-primary) !important;
          }
          
          /* 角色關係冊次要文字 */
          #relationship-binding-area div[style*="color: #71767b"] {
            color: var(--x-text-secondary) !important;
          }
          
          /* 角色關係列表項 */
          #relationship-links-list > div[style*="background-color: #1a1a1a"] {
            background-color: var(--x-bg-secondary) !important;
            border-color: var(--x-border-color) !important;
          }
          
          /* 角色關係清單中的文字 */
          #relationship-links-list span[style*="color: #fff"] {
            color: var(--x-text-primary) !important;
          }
          
          #relationship-links-list span[style*="color: #71767b"] {
            color: var(--x-text-secondary) !important;
          }
          
          #relationship-links-list div[style*="color: #71767b"] {
            color: var(--x-text-secondary) !important;
          }
          
          /* 角色關係列表項的邊框 */
          #relationship-links-list div[style*="border-top: 1px solid #2f3336"] {
            border-top-color: var(--x-border-color) !important;
          }
          
          /* 角色關係清單空狀態 */
          #relationship-links-list > div[style*="color: #71767b"] {
            color: var(--x-text-secondary) !important;
          }
          
          /* 角色關係詳情彈窗背景 */
          #relationship-detail-modal > div > div[style*="background-color: #000"] {
            background-color: var(--x-bg-primary) !important;
            border-color: var(--x-border-color) !important;
          }
          
          /* 角色關係詳情彈窗標題和label */
          #relationship-detail-modal h3,
          #relationship-detail-modal label {
            color: var(--x-text-primary) !important;
          }
          
          /* 角色關係詳情彈窗次要文字 */
          #relationship-detail-modal div[style*="color: #71767b"] {
            color: var(--x-text-secondary) !important;
          }
          
          /* 角色關係詳情彈窗輸入框 */
          #relationship-detail-modal input,
          #relationship-detail-modal textarea,
          #relationship-detail-modal select {
            background-color: var(--x-input-bg) !important;
            border-color: var(--x-border-color) !important;
            color: var(--x-text-primary) !important;
          }
          
          /* 角色關係詳情彈窗輸入框焦點 */
          #relationship-detail-modal input:focus,
          #relationship-detail-modal textarea:focus,
          #relationship-detail-modal select:focus {
            border-color: var(--x-accent) !important;
          }
          
          /* 角色關係詳情彈窗邊框 */
          #relationship-detail-modal div[style*="border: 1px solid #333"],
          #relationship-detail-modal div[style*="border-bottom: 1px solid #333"] {
            border-color: var(--x-border-color) !important;
          }
          
          /* 角色關係詳情彈窗關閉按鈕 */
          #relationship-detail-modal button[onclick*="close"] svg {
            fill: var(--x-text-secondary) !important;
          }
          
          /* ========== 角色關係圖編輯器彈窗修復 ========== */
          /* 角色關係圖彈窗背景 */
          #character-relationship-graph-modal > div[style*="background-color: #000"] {
            background-color: var(--x-bg-primary) !important;
            border-color: var(--x-border-color) !important;
          }
          
          /* 角色關係圖彈窗頭部 */
          #character-relationship-graph-modal h2 {
            color: var(--x-text-primary) !important;
          }
          
          /* 角色關係圖彈窗統計文字 */
          #character-relationship-graph-modal div[style*="color: #71767b"] {
            color: var(--x-text-secondary) !important;
          }
          
          /* 角色關係圖彈窗關閉按鈕圖示 */
          #character-relationship-graph-modal svg[style*="fill: #fff"] {
            fill: var(--x-text-primary) !important;
          }
          
          /* 角色關係圖工具列 */
          #character-relationship-graph-modal div[style*="background-color: #0a0a0a"] {
            background-color: var(--x-bg-secondary) !important;
          }
          
          /* 角色關係圖工具列提示文字 */
          #character-relationship-graph-modal > div > div:nth-child(2) div[style*="color: #71767b"] {
            color: var(--x-text-secondary) !important;
          }
          
          /* 角色關係圖畫布區域背景 */
          #character-relationship-graph-modal div[style*="height: 500px"][style*="background-color: #000"] {
            background-color: var(--x-bg-primary) !important;
          }
          
          /* 角色關係圖空狀態圖示 */
          #graph-empty-state svg {
            fill: var(--x-border-color) !important;
          }
          
          /* 角色關係圖底部按鈕區域 */
          #character-relationship-graph-modal > div > div:last-child[style*="background-color: #000"] {
            background-color: var(--x-bg-primary) !important;
          }
          
          /* 角色關係圖底部取消按鈕 */
          #character-relationship-graph-modal button[onclick*="closeCharacter"] {
            border-color: var(--x-border-color) !important;
            color: var(--x-text-primary) !important;
          }
          
          /* 關係清單區域標題 */
          #character-relationship-graph-modal div[style*="padding: 12px 20px"] div[style*="color: #fff"] {
            color: var(--x-text-primary) !important;
          }
          
          /* 角色關係圖邊框 */
          #character-relationship-graph-modal div[style*="border: 1px solid #333"],
          #character-relationship-graph-modal div[style*="border-bottom: 1px solid #333"] {
            border-color: var(--x-border-color) !important;
          }
          
          /* 角色關係圖畫布容器 */
          #character-relationship-graph-modal > div[style*="border: 1px solid #333"] {
            border-color: var(--x-border-color) !important;
          }
          
          /* 角色關係圖空狀態 */
          #graph-empty-state div[style*="color: #71767b"] {
            color: var(--x-text-secondary) !important;
          }
          
          /* 關係清單標題文字 */
          #relationship-links-list-container h3 {
            color: var(--x-text-primary) !important;
          }
          
          /* 關係清單空狀態 */
          #relationship-links-list div[style*="color: #71767b"] {
            color: var(--x-text-secondary) !important;
          }
          
          /* 編輯關係詳情彈窗背景遮罩 */
          #edit-relationship-detail-modal[style*="background-color: rgba(0, 0, 0"] {
            background-color: rgba(0, 0, 0, 0.85) !important;
          }
          
          /* 編輯關係詳情彈窗主容器 */
          #edit-relationship-detail-modal > div > div[style*="background-color: #000"] {
            background-color: var(--x-bg-primary) !important;
            border-color: var(--x-border-color) !important;
          }
          
          /* 編輯關係詳情彈窗標題 */
          #edit-relationship-detail-modal h3 {
            color: var(--x-text-primary) !important;
          }
          
          /* 編輯關係詳情彈窗label */
          #edit-relationship-detail-modal label {
            color: var(--x-text-primary) !important;
          }
          
          /* 編輯關係詳情彈窗次要文字 */
          #edit-relationship-detail-modal div[style*="color: #71767b"] {
            color: var(--x-text-secondary) !important;
          }
          
          /* 編輯關係詳情彈窗角色資訊區域 */
          #relationship-characters-info {
            background-color: var(--x-bg-secondary) !important;
            border-color: var(--x-border-color) !important;
          }
          
          /* 編輯關係詳情彈窗角色名稱 */
          #char-a-name,
          #char-b-name {
            color: var(--x-text-primary) !important;
          }
          
          /* 編輯關係詳情彈窗箭頭符號 */
          #relationship-characters-info div[style*="color: #71767b"] {
            color: var(--x-text-secondary) !important;
          }
          
          /* 編輯關係詳情彈窗關閉按鈕圖示 */
          #edit-relationship-detail-modal svg[style*="fill: #fff"] {
            fill: var(--x-text-primary) !important;
          }
          
          /* 編輯關係詳情彈窗輸入框 */
          #edit-relationship-detail-modal input,
          #edit-relationship-detail-modal textarea {
            background-color: var(--x-input-bg) !important;
            border-color: var(--x-border-color) !important;
            color: var(--x-text-primary) !important;
          }
          
          /* 編輯關係詳情彈窗輸入框焦點 */
          #edit-relationship-detail-modal input:focus,
          #edit-relationship-detail-modal textarea:focus {
            border-color: var(--x-accent) !important;
          }
          
          /* 編輯關係詳情彈窗邊框 */
          #edit-relationship-detail-modal div[style*="border: 1px solid #333"],
          #edit-relationship-detail-modal div[style*="border-bottom: 1px solid #333"] {
            border-color: var(--x-border-color) !important;
          }
          
          /* 編輯關係詳情彈窗關閉按鈕 */
          #edit-relationship-detail-modal button[onclick*="close"] svg {
            fill: var(--x-text-secondary) !important;
          }
          
          /* 個人資料標籤欄 - 啟動狀態 - 限定在X應用內 */
          #x-social-screen .profile-tab.active {
            color: var(--x-text-primary) !important;
            font-weight: 700 !important;
          }
          
          /* 個人資料標籤欄 - 非啟動狀態 - 限定在X應用內 */
          #x-social-screen .profile-tab:not(.active) {
            color: var(--x-text-secondary) !important;
          }
          
          /* 個人資料頁面的其他文本 */
          #x-profile-header-name {
            color: var(--x-text-primary) !important;
          }
          
          /* 用戶主頁頂部功能按鈕圖示 - 限定在X應用內 */
          #x-social-screen .profile-header svg {
            fill: var(--x-text-primary) !important;
          }
          
          /* 返回按鈕 - 限定在X應用內 */
          #x-social-screen .profile-back-btn svg {
            fill: var(--x-text-primary) !important;
          }
          
          /* 提問箱和更多選項按鈕的圖示 */
          #x-profile-page .profile-header > div > div svg {
            fill: var(--x-text-primary) !important;
          }
          
          /* ========== 推文詳情頁樣式修復 ========== */
          /* 詳情頁頂欄背景和邊框 */
          .tweet-detail-header {
            background-color: var(--x-bg-primary) !important;
            border-bottom: 1px solid var(--x-border-color) !important;
          }
          
          /* 詳情頁頂欄標題和返回按鈕 */
          .tweet-detail-header span {
            color: var(--x-text-primary) !important;
          }
          
          .tweet-detail-header svg,
          .tweet-detail-back-btn svg {
            fill: var(--x-text-primary) !important;
          }
          
          /* 詳情頁主要內容區域 */
          #x-tweet-detail-page {
            background-color: var(--x-bg-primary) !important;
          }
          
          #tweet-detail-container {
            background-color: var(--x-bg-primary) !important;
          }
          
          /* 詳情頁推文內容區域 */
          .tweet-detail-content {
            background-color: var(--x-bg-primary) !important;
          }
          
          /* 詳情頁推文用戶名和內容 */
          #tweet-detail-container .tweet-user-name,
          #tweet-detail-container .tweet-content,
          #x-tweet-detail-page .tweet-user-name,
          #x-tweet-detail-page .tweet-content {
            color: var(--x-text-primary) !important;
          }
          
          /* 詳情頁評論區域背景 */
          #detail-comments-container {
            background-color: var(--x-bg-primary) !important;
          }
          
          /* 詳情頁評論內容 */
          #detail-comments-container .comment-content,
          #detail-comments-container .tweet-user-name,
          #x-tweet-detail-page .comment-user-name {
            color: var(--x-text-primary) !important;
          }
          
          /* 詳情頁時間和其他次要文本 */
          #tweet-detail-container .tweet-time,
          #tweet-detail-container .tweet-user-handle,
          #detail-comments-container .tweet-user-handle,
          #detail-comments-container .comment-time,
          #x-tweet-detail-page .tweet-time,
          #x-tweet-detail-page .tweet-user-handle {
            color: var(--x-text-secondary) !important;
          }
          
          /* 詳情頁評論輸入區域 */
          .detail-comment-input-area {
            background-color: var(--x-bg-primary) !important;
            border-top: 1px solid var(--x-border-color) !important;
          }
          
          .detail-comment-input-area textarea {
            background-color: var(--x-input-bg) !important;
            color: var(--x-text-primary) !important;
            border-color: var(--x-border-color) !important;
          }
          
          /* 詳情頁按鈕顏色 */
          #reroll-replies-btn svg,
          .refresh-btn svg,
          #x-tweet-detail-page .refresh-btn svg {
            fill: var(--x-text-primary) !important;
          }
          
          /* 詳情頁所有span元素 */
          #x-tweet-detail-page span,
          #tweet-detail-container span {
            color: inherit;
          }

          /* 確保所有可滾動容器都有正確的高度設置 */
          .comments-container,
          .settings-content,
          .profile-content,
          .tab-content {
            min-height: 0 !important;
          }

          /* 確保推文容器也有正確的滾動 */
          .tweets-container {
            overflow-y: auto;
            min-height: 0;
          }

          /* 使用者評論刪除功能樣式 */
          .comment-user-info {
            display: flex !important;
            align-items: center !important;
            gap: 4px !important;
          }

          .comment-delete-btn:hover {
            background-color: rgba(239, 68, 68, 0.1) !important;
          }

          .comment-delete-btn svg {
            transition: fill 0.2s ease;
          }

          .comment-delete-btn:hover svg {
            fill: #dc2626 !important;
          }

          /* 使用者人設設置按鈕樣式 */
          .persona-setting-btn {
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
          }

          .persona-setting-btn:hover {
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
          }

          .persona-setting-btn:active {
            transform: scale(0.95) !important;
          }

          /* 推文項目 */
          #x-social-screen .tweet-item {
            padding: 15px;
            border-bottom: 1px solid var(--x-border-color);
            display: flex;
            gap: 12px;
            background-color: var(--x-bg-primary);
          }

          /* 用戶頭像 */
          #x-social-screen .tweet-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            flex-shrink: 0;
          }

          /* 推文主要內容區域 */
          #x-social-screen .tweet-main {
            flex: 1;
            min-width: 0;
          }

          /* 使用者資訊行 */
          #x-social-screen .tweet-user-info {
            display: flex;
            align-items: center;
            gap: 5px;
            margin-bottom: 5px;
          }

          #x-social-screen .tweet-user-name {
            font-weight: 700;
            color: var(--x-text-primary);
            font-size: 15px;
          }

          #x-social-screen .tweet-verified {
            width: 18px;
            height: 18px;
            fill: var(--x-accent);
          }

          #x-social-screen .tweet-user-handle {
            color: var(--x-text-secondary);
            font-size: 15px;
          }

          #x-social-screen .tweet-time {
            color: var(--x-text-secondary);
            font-size: 15px;
          }

          #x-social-screen .tweet-more {
            margin-left: auto;
            color: #71767b;
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
          }

          #x-social-screen .tweet-more:hover {
            background-color: color-mix(in srgb, var(--x-accent) , 0.1);
            color: var(--x-accent);
          }

          /* 推文內容 */
          #x-social-screen .tweet-content {
            color: var(--x-text-primary);
            font-size: 15px;
            line-height: 1.3;
            margin-bottom: 12px;
            word-wrap: break-word;
          }

          /* 話題標籤和提及的高亮樣式 */
          #x-social-screen .hashtag,
          #x-social-screen .mention {
            color: var(--x-accent);
            text-decoration: none;
            cursor: pointer;
          }

          #x-social-screen .hashtag:hover,
          #x-social-screen .mention:hover {
            text-decoration: underline;
          }

          /* 媒體內容 */
          #x-social-screen .tweet-media {
            margin-bottom: 12px;
            border-radius: 16px;
            overflow: hidden;
            position: relative;
          }

          #x-social-screen .tweet-image {
            width: 100%;
            max-height: 300px;
            object-fit: cover;
            display: block;
          }

          /* 敏感內容遮罩 */
          #x-social-screen .sensitive-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff;
            cursor: pointer;
          }

          #x-social-screen .sensitive-text {
            font-size: 15px;
            font-weight: 700;
            margin-bottom: 8px;
          }

          #x-social-screen .sensitive-description {
            font-size: 13px;
            color: #71767b;
            text-align: center;
            padding: 0 20px;
          }

          /* 互動按鈕 - 限定在X應用內 */
          #x-social-screen .tweet-actions {
            display: flex;
            justify-content: space-between;
            max-width: 425px;
            margin-top: 5px;
          }

          #x-social-screen .tweet-action {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 8px;
            border-radius: 50%;
            cursor: pointer;
            color: #71767b;
            font-size: 13px;
            transition: all 0.2s;
          }

          #x-social-screen .tweet-action:hover {
            background-color: color-mix(in srgb, var(--x-accent) , 0.1);
          }

          #x-social-screen .tweet-action.comment:hover {
            color: var(--x-accent);
          }

          #x-social-screen .tweet-action.retweet:hover {
            color: #00ba7c;
          }

          #x-social-screen .tweet-action.like:hover,
          #x-social-screen .tweet-action.like.liked {
            color: #f91880;
          }

          #x-social-screen .tweet-action.bookmark:hover {
            color: var(--x-accent);
          }

          #x-social-screen .tweet-action.share:hover {
            color: var(--x-accent);
          }

          #x-social-screen .action-icon {
            width: 18px;
            height: 18px;
          }

          /* 點贊動畫效果 */
          #x-social-screen .like-animation {
            animation: likeHeartbeat 0.6s ease-in-out;
          }

          @keyframes likeHeartbeat {
            0% {
              transform: scale(1);
            }

            25% {
              transform: scale(1.2);
            }

            50% {
              transform: scale(1.4);
            }

            75% {
              transform: scale(1.2);
            }

            100% {
              transform: scale(1);
            }
          }

          #x-social-screen .tweet-action.like.liked .like-icon {
            fill: #f91880;
          }

          #x-social-screen .tweet-action.like.liked .like-count {
            color: #f91880;
          }

          /* 評論樣式 */
          #x-social-screen .comment-item {
            padding: 15px;
            border-bottom: 1px solid var(--x-border-color);
            display: flex;
            gap: 12px;
            position: relative;
            background-color: var(--x-bg-primary);
          }

          /* 主評論後有回復時的連接線 */
          #x-social-screen .comment-item.has-replies::after {
            content: '';
            position: absolute;
            left: 35px;
            /* 頭像中心位置 */
            bottom: -1px;
            width: 1px;
            height: 28px;
            background-color: #2f3336;
          }

          #x-social-screen .comment-main {
            flex: 1;
            min-width: 0;
          }

          #x-social-screen .comment-user-info {
            display: flex;
            align-items: center;
            gap: 5px;
            margin-bottom: 5px;
          }

          #x-social-screen .comment-content {
            color: var(--x-text-primary);
            font-size: 15px;
            line-height: 1.3;
            margin-bottom: 8px;
            word-wrap: break-word;
          }

          #x-social-screen .comment-actions {
            display: flex;
            justify-content: flex-start;
            gap: 60px;
            margin-top: 5px;
          }

          #x-social-screen .comment-action {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 8px;
            border-radius: 50%;
            cursor: pointer;
            color: #71767b;
            font-size: 13px;
            transition: all 0.2s;
          }

          /* 回復評論樣式 */
          #x-social-screen .reply-item {
            margin-left: 50px;
            /* 精確對齊主評論的頭像右側 */
            padding-left: 0;
            padding-top: 8px;
            padding-bottom: 8px;
            border-left: none;
            position: relative;
            display: flex;
            align-items: flex-start;
            gap: 12px;
          }

          #x-social-screen .reply-item::before {
            content: '';
            position: absolute;
            left: -30px;
            top: 16px;
            width: 14px;
            height: 14px;
            border-left: 1px solid #2f3336;
            border-bottom: 1px solid #2f3336;
            border-bottom-left-radius: 6px;
          }

          #x-social-screen .reply-to {
            color: var(--x-accent);
            margin-right: 5px;
            font-weight: 400;
          }

          /* 回復評論的頭像稍小一些 */
          #x-social-screen .reply-item .tweet-avatar {
            width: 32px;
            height: 32px;
          }

          /* 引用推文樣式 */
          #x-social-screen .quoted-tweet {
            border: 1px solid #2f3336;
            border-radius: 16px;
            margin: 12px 0;
            padding: 12px;
            background-color: rgba(0, 0, 0, 0.3);
            transition: background-color 0.2s ease;
            cursor: pointer;
          }

          #x-social-screen .quoted-tweet:hover {
            background-color: rgba(255, 255, 255, 0.03);
          }

          #x-social-screen .quoted-user-info {
            display: flex;
            align-items: center;
            gap: 5px;
            margin-bottom: 8px;
          }

          #x-social-screen .quoted-user-avatar {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            flex-shrink: 0;
          }

          #x-social-screen .quoted-user-name {
            font-weight: 600;
            color: #fff;
            font-size: 13px;
          }

          #x-social-screen .quoted-user-handle {
            color: #71767b;
            font-size: 13px;
          }

          #x-social-screen .quoted-user-time {
            color: #71767b;
            font-size: 13px;
          }

          #x-social-screen .quoted-content {
            color: #fff;
            font-size: 14px;
            line-height: 1.3;
            word-wrap: break-word;
          }

          #x-social-screen .quote-indicator {
            color: #71767b;
            font-size: 13px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 4px;
          }

          #x-social-screen .quote-indicator svg {
            width: 16px;
            height: 16px;
            fill: currentColor;
          }

          /* 搜尋網頁面樣式 */
          #x-social-screen .search-header {
            padding: 12px 16px;
            background: #000;
            border-bottom: 1px solid #2f3336;
          }

          #x-social-screen .search-box {
            display: flex;
            align-items: center;
            background: #202327;
            border-radius: 20px;
            padding: 10px 16px;
            gap: 12px;
          }

          #x-social-screen .search-box svg {
            width: 20px;
            height: 20px;
            fill: #71767b;
            flex-shrink: 0;
          }

          #x-social-screen .search-box input {
            flex: 1;
            background: transparent;
            border: none;
            outline: none;
            color: #fff;
            font-size: 15px;
          }

          #x-social-screen .search-box input::placeholder {
            color: #71767b;
          }

          #x-social-screen .search-tabs {
            display: flex;
            align-items: center;
            padding: 0 16px;
            border-bottom: 1px solid #2f3336;
            gap: 24px;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
          }

          #x-social-screen .search-tabs::-webkit-scrollbar {
            display: none;
          }

          #x-social-screen .search-tab {
            padding: 16px 0;
            cursor: pointer;
            color: #71767b;
            font-weight: 500;
            font-size: 15px;
            white-space: nowrap;
            position: relative;
            transition: color 0.2s;
          }

          #x-social-screen .search-tab.active {
            color: #fff;
            font-weight: 700;
          }

          #x-social-screen .search-tab.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: var(--x-accent);
            border-radius: 2px 2px 0 0;
          }

          #x-social-screen .search-tab:hover {
            color: #fff;
          }

          #x-social-screen .add-category-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            transition: background 0.2s;
          }

          #x-social-screen .add-category-btn svg {
            width: 20px;
            height: 20px;
            fill: #71767b;
          }

          #x-social-screen .add-category-btn:hover {
            background: color-mix(in srgb, var(--x-accent) , 0.1);
          }

          #x-social-screen .add-category-btn:hover svg {
            fill: var(--x-accent);
          }

          #x-social-screen .trending-list {
            flex: 1;
            overflow-y: auto;
          }

          #x-social-screen .trending-item {
            padding: 12px 16px;
            cursor: pointer;
            transition: background 0.2s;
            position: relative;
          }

          #x-social-screen .trending-item:hover {
            background: rgba(255, 255, 255, 0.03);
          }

          #x-social-screen .trending-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 2px;
          }

          #x-social-screen .trending-category {
            color: #71767b;
            font-size: 14px;
            font-weight: 800;
            line-height: 16px;
          }

          #x-social-screen .trending-more {
            padding: 4px;
            border-radius: 50%;
            cursor: pointer;
            transition: background 0.2s;
          }

          #x-social-screen .trending-more:hover {
            background: color-mix(in srgb, var(--x-accent) , 0.1);
          }

          #x-social-screen .trending-more svg {
            width: 18px;
            height: 18px;
            fill: #71767b;
          }

          #x-social-screen .trending-title {
            color: #fff;
            font-size: 15px;
            font-weight: 700;
            line-height: 20px;
            margin-bottom: 2px;
          }

          #x-social-screen .trending-count {
            color: #71767b;
            font-size: 13px;
            line-height: 16px;
            font-weight: 400;
          }

          #x-social-screen .refresh-trends-btn {
            position: fixed;
            right: 20px;
            bottom: 80px;
            width: 56px;
            height: 56px;
            background: var(--x-accent);
            border-radius: 50%;
            border: none;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
            display: none;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s, background 0.2s;
            z-index: 100;
          }

          #x-social-screen .refresh-trends-btn:hover {
            background: #1a8cd8;
            transform: scale(1.05);
          }

          #x-social-screen .refresh-trends-btn:active {
            transform: scale(0.95);
          }

          #x-social-screen .refresh-trends-btn svg {
            width: 24px;
            height: 24px;
            fill: #fff;
          }

          #x-social-screen .refresh-trends-btn.spinning svg {
            animation: spin 1s linear infinite;
          }

          @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
          }
            
        /* 脈衝動畫 */
        @keyframes pulse {
          0% {
            opacity: 1;
            transform: scale(1);
          }
          50% {
            opacity: 0.6;
            transform: scale(1.2);
          }
          100% {
            opacity: 1;
            transform: scale(1);
          }
        }
          
        /* 錢包成功彈窗入場動畫 */
        @keyframes walletSuccessIn {
          from {
            opacity: 0;
            transform: scale(0.7) translateY(30px);
          }
          to {
            opacity: 1;
            transform: scale(1) translateY(0);
          }
        }

        /* 錢包成功圖示檢查動畫 */
        @keyframes walletSuccessCheck {
          0% {
            opacity: 0;
            transform: scale(0.3);
          }
          50% {
            opacity: 1;
            transform: scale(1.1);
          }
          100% {
            opacity: 1;
            transform: scale(1);
          }
        }

        /* 錢包啟動按鈕載入動畫 */
        @keyframes walletActivating {
          0% {
            background-position: 0% 50%;
          }
          50% {
            background-position: 100% 50%;
          }
          100% {
            background-position: 0% 50%;
          }
        }
          
    `;

    document.head.appendChild(style);
    console.log('✅ X Social App: 樣式已注入');
  }

  // ============================================
  // 第二部分: HTML結構生成
  // ============================================
  function createXSocialHTML() {
    // 檢查是否已經存在
    if (document.getElementById('x-social-screen')) {
      console.log('⚠️ X Social Screen 已存在，跳過創建');
      return;
    }

    const container = document.createElement('div');
    container.id = 'x-social-screen';
    container.className = 'screen';
    container.style.cssText =
      'background-color: var(--x-bg-primary); color: var(--x-text-primary); display: flex; flex-direction: column; height: 100vh; overflow: hidden;';

    // 這裡使用字串範本或DOM操作創建完整的HTML結構
    container.innerHTML = `
    <!-- 頂部欄 -->
    <div class="x-top-bar"
        style="display: flex; justify-content: space-between; align-items: center; padding: 55px 15px 15px 15px; border-bottom: 1px solid #333; position: relative;">
      <!-- 返回按鈕 -->
      <div class="x-back-btn" onclick="showScreen('home-screen')" style="cursor: pointer;">
        <svg viewBox="0 0 24 24" aria-hidden="true" style="width: 20px; height: 20px; fill: #fff;">
          <g>
            <path d="M7.414 13l5.043 5.04-1.414 1.42L3.586 12l7.457-7.46 1.414 1.42L7.414 11H21v2H7.414z"></path>
          </g>
        </svg>
      </div>
      <!-- 頭像放中間 -->
      <div class="x-profile-pic"
        style="display: flex; justify-content: center; align-items: center; position: absolute; left: 50%; transform: translateX(-50%);">
        <img id="top-bar-avatar" 
             src="https://i.postimg.cc/pXxk1JXk/IMG-6442.jpg" 
             alt="Profile"
             onclick="switchXPage('profile')" 
             style="width: 36px; height: 36px; border-radius: 50%; cursor: pointer; transition: opacity 0.2s;"
             onmouseover="this.style.opacity='0.8'"
             onmouseout="this.style.opacity='1'">
      </div>
      <!-- 右側按鈕區域 -->
      <div style="display: flex; align-items: center; gap: 15px;">
        <!-- 刷新按鈕 -->
        <div class="x-refresh-btn" onclick="refreshXTweets()" style="cursor: pointer;">
          <svg viewBox="0 0 24 24" aria-hidden="true" style="width: 22px; height: 22px; fill: #fff;">
            <g>
              <path
                d="M19 8l-4 4h3c0 3.31-2.69 6-6 6-1.01 0-1.97-.25-2.8-.7l-1.46 1.46C8.97 19.54 10.43 20 12 20c4.42 0 8-3.58 8-8h3l-4-4zM6 12c0-3.31 2.69-6 6-6 1.01 0 1.97.25 2.8.7l1.46-1.46C15.03 4.46 13.57 4 12 4c-4.42 0-8 3.58-8 8H1l4 4 4-4H6z">
              </path>
            </g>
          </svg>
        </div>
        <!-- 設置按鈕 -->
        <div class="x-settings" onclick="switchXPage('settings')" style="cursor: pointer;">
          <svg viewBox="0 0 24 24" aria-hidden="true" style="width: 24px; height: 24px; fill: #fff;">
            <g>
              <path
                d="M10.54 1.75h2.92l1.57 2.36c.11.17.32.25.53.21l2.53-.59 2.17 2.17-.58 2.54c-.05.2.04.41.21.53l2.36 1.57v2.92l-2.36 1.57c-.17.12-.26.33-.21.53l.58 2.54-2.17 2.17-2.53-.59c-.21-.04-.42.04-.53.21l-1.57 2.36h-2.92l-1.58-2.36c-.11-.17-.32-.25-.52-.21l-2.54.59-2.17-2.17.58-2.54c.05-.2-.03-.41-.21-.53l-2.35-1.57v-2.92L4.1 8.97c.18-.12.26-.33.21-.53L3.73 5.9 5.9 3.73l2.54.59c.2.04.41-.04.52-.21l1.58-2.36zm1.07 2l-.98 1.47C10.05 6.08 9 6.5 7.99 6.27l-1.46-.34-.6.6.33 1.46c.24 1.01-.18 2.07-1.05 2.64l-1.46.98v.78l1.46.98c.87.57 1.29 1.63 1.05 2.64l-.33 1.46.6.6 1.46-.34c1.01-.23 2.06.19 2.64 1.05l.98 1.47h.78l.97-1.47c.58-.86 1.63-1.28 2.65-1.05l1.45.34.61-.6-.34-1.46c-.23-1.01.18-2.07 1.05-2.64l1.47-.98v-.78l-1.47-.98c-.87-.57-1.28-1.63-1.05-2.64l.34-1.46-.61-.6-1.45.34c-1.02.23-2.07-.19-2.65-1.05l-.97-1.47h-.78zM12 10.5c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5c.82 0 1.5-.67 1.5-1.5s-.68-1.5-1.5-1.5zM8.5 12c0-1.93 1.56-3.5 3.5-3.5 1.93 0 3.5 1.57 3.5 3.5s-1.57 3.5-3.5 3.5c-1.94 0-3.5-1.57-3.5-3.5z">
              </path>
            </g>
          </svg>
        </div>
      </div>
    </div>

    <!-- 各個頁面容器 -->
    <div class="x-pages-container"
      style="flex: 1; display: flex; flex-direction: column; overflow: hidden; min-height: 0; position: relative;">
      <!-- 主頁頁面 - 預設顯示 -->
      <div id="x-home-page" class="x-page active"
        style="flex: 1; display: flex; flex-direction: column; overflow: hidden; min-height: 0;">

        <!-- 主頁標籤欄 -->
        <div class="x-home-tabs" style="display: flex; border-bottom: 1px solid #333;">
          <!-- "為你推薦"標籤 -->
          <div class="x-tab active" onclick="switchHomeTab('for-you')"
            style="flex: 1; text-align: center; padding: 15px 0; font-weight: 600; cursor: pointer; position: relative;">
            <span data-i18n="homeForYou">為你推薦</span>
            <div class="tab-indicator"
              style="position: absolute; bottom: 0; left: 10%; width: 80%; height: 2px; background-color: var(--x-accent); border-radius: 2px;">
            </div>
          </div>

          <!-- "正在關注"標籤 -->
          <div class="x-tab" onclick="switchHomeTab('following')"
            style="flex: 1; text-align: center; padding: 15px 0; font-weight: 600; cursor: pointer; position: relative; color: #71767b;">
            <span data-i18n="homeFollowing">正在關注</span>
            <div class="tab-indicator"
              style="position: absolute; bottom: 0; left: 10%; width: 80%; height: 2px; background-color: var(--x-accent); border-radius: 2px; display: none;">
            </div>
          </div>
        </div>

        <!-- 內容區域 - 為你推薦 -->
        <div id="for-you-content" class="tab-content active"
          style="flex: 1; display: flex; flex-direction: column; overflow-y: auto; min-height: 0;">
          <!-- 推文列表容器 -->
          <div class="tweets-container" style="padding: 0;">
            <!-- 推文將通過JavaScript動態生成在這裡 -->
          </div>
        </div>

        <!-- 內容區域 - 正在關注 -->
        <div id="following-content" class="tab-content"
          style="flex: 1; display: none; flex-direction: column; overflow-y: auto; min-height: 0;">
          <!-- 推文列表容器 -->
          <div class="tweets-container" style="padding: 0;">
            <!-- 推文將通過JavaScript動態生成在這裡 -->
          </div>
        </div>
  
        
  
        <!-- 添加浮動發佈按鈕 -->
        <div class="compose-btn" onclick="openComposeTweetModal()"
          style="position: fixed; bottom: 80px; right: 20px; width: 56px; height: 56px; background-color: var(--x-accent); border-radius: 50%; display: flex; justify-content: center; align-items: center; box-shadow: 0 2px 10px rgba(0,0,0,0.3); cursor: pointer;">
          <svg viewBox="0 0 24 24" aria-hidden="true" style="width: 24px; height: 24px; fill: #fff; stroke-width: 2;">
            <g>
              <path d="M12 4L12 20M4 12L20 12" stroke="white" stroke-linecap="round"></path>
            </g>
          </svg>
        </div>
      </div>

      <!-- 角色X資料設置彈窗 -->
      <div id="character-x-profile-modal"
        style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.8); z-index: 30; backdrop-filter: blur(8px);">
        <div style="display: flex; justify-content: center; align-items: center; height: 100%; padding: 20px;">
          <div
            style="background-color: #000; border: 1px solid #333; border-radius: 16px; width: 100%; max-width: 600px; max-height: 90vh; overflow-y: auto;">

            <!-- 彈窗頭部 -->
            <div
              style="display: flex; align-items: center; justify-content: space-between; padding: 20px 20px 16px 20px; border-bottom: 1px solid #333;">
              <h2 style="color: #fff; font-size: 20px; font-weight: 700; margin: 0;">設置X資料</h2>
              <button onclick="closeCharacterXProfileModal()"
                style="background: none; border: none; color: #71767b; cursor: pointer; padding: 8px;">
                <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: currentColor;">
                  <path
                    d="M18.36 6.64c.39.39.39 1.02 0 1.41L13.41 12l4.95 4.95c.39.39.39 1.02 0 1.41-.39.39-1.02.39-1.41 0L12 13.41l-4.95 4.95c-.39.39-1.02.39-1.41 0-.39-.39-.39-1.02 0-1.41L10.59 12 5.64 7.05c-.39-.39-.39-1.02 0-1.41.39-.39 1.02-.39 1.41 0L12 10.59l4.95-4.95c.39-.39 1.02-.39 1.41 0z" />
                </svg>
              </button>
            </div>

            <!-- 角色基本資訊顯示 -->
            <div id="character-info-display"
              style="padding: 20px; border-bottom: 1px solid #333; background-color: #0a0a0a;">
              <!-- 角色資訊將動態填充 -->
            </div>

            <!-- 表單內容 -->
            <div style="padding: 20px;">
              <form id="character-x-profile-form">

                <!-- X頭像設置 -->
                <div style="margin-bottom: 24px;">
                  <label
                    style="display: block; color: #fff; font-size: 15px; font-weight: 600; margin-bottom: 12px;">X頭像</label>
                  <div style="display: flex; align-items: center; gap: 16px; margin-bottom: 12px;">
                    <img id="character-x-avatar" src="" alt="X頭像"
                      style="width: 80px; height: 80px; border-radius: 50%; border: 3px solid #333; object-fit: cover; overflow: hidden; box-sizing: border-box;">
                    <div style="flex: 1;">
                      <div style="color: #71767b; font-size: 13px; margin-bottom: 8px;">頭像連結</div>
                      <input type="url" id="character-x-avatar-url" placeholder="https://example.com/avatar.jpg"
                        style="width: 100%; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px; font-size: 14px; outline: none;"
                        oninput="updateCharacterXAvatar(this.value)" onfocus="this.style.borderColor='var(--x-accent)'"
                        onblur="this.style.borderColor='#333'">
                    </div>
                  </div>
                  <div style="color: #71767b; font-size: 12px;">
                    請輸入圖片連結URL，支援JPG、PNG、GIF格式
                  </div>
                </div>

                <!-- X用戶名 -->
                <div style="margin-bottom: 20px;">
                  <label
                    style="display: block; color: #fff; font-size: 15px; font-weight: 600; margin-bottom: 8px;">X用戶名</label>
                  <input type="text" id="character-x-name" placeholder="顯示名稱"
                    style="width: 100%; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px; font-size: 15px; outline: none;"
                    maxlength="50">
                </div>

                <!-- X控制碼 -->
                <div style="margin-bottom: 20px;">
                  <label
                    style="display: block; color: #fff; font-size: 15px; font-weight: 600; margin-bottom: 8px;">X控制碼</label>
                  <div style="position: relative;">
                    <span
                      style="position: absolute; left: 12px; top: 50%; transform: translateY(-50%); color: #71767b; font-size: 15px;">@</span>
                    <input type="text" id="character-x-handle" placeholder="username"
                      style="width: 100%; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px 12px 12px 30px; font-size: 15px; outline: none;"
                      maxlength="15">
                  </div>
                </div>

                <!-- 認證狀態 -->
                <div style="margin-bottom: 20px;">
                  <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                    <input type="checkbox" id="character-x-verified"
                      style="width: 18px; height: 18px; accent-color: var(--x-accent);">
                    <span style="color: #fff; font-size: 15px; font-weight: 600;">認證用戶</span>
                    <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: var(--x-accent);">
                      <path
                        d="M22.5 12.5c0-1.58-.875-2.95-2.148-3.6.154-.435.238-.905.238-1.4 0-2.21-1.71-3.998-3.818-3.998-.47 0-.92.084-1.336.25C14.818 2.415 13.51 1.5 12 1.5s-2.816.917-3.437 2.25c-.415-.165-.866-.25-1.336-.25-2.11 0-3.818 1.79-3.818 4 0 .494.083.964.237 1.4-1.272.65-2.147 2.018-2.147 3.6 0 1.495.782 2.798 1.942 3.486-.02.17-.032.34-.032.514 0 2.21 1.708 4 3.818 4 .47 0 .92-.086 1.335-.25.62 1.334 1.926 2.25 3.437 2.25 1.512 0 2.818-.916 3.437-2.25.415.163.865.248 1.336.248 2.11 0 3.818-1.79 3.818-4 0-.174-.012-.344-.033-.513 1.158-.687 1.943-1.99 1.943-3.484zm-6.616-3.334l-4.334 6.5c-.145.217-.382.334-.625.334-.143 0-.288-.04-.416-.126l-2.5-1.668c-.326-.217-.413-.656-.196-.982.217-.326.656-.414.982-.196l1.875 1.25 3.75-5.625c.22-.33.66-.418.99-.196.33.22.418.66.196.99z" />
                    </svg>
                  </label>
                </div>

                <!-- 背景圖設置 -->
                <div style="margin-bottom: 24px;">
                  <label style="display: block; color: #fff; font-size: 15px; font-weight: 600; margin-bottom: 12px;">背景圖（封面圖）</label>
                  <div style="margin-bottom: 12px;">
                    <img id="character-x-cover-preview" src="https://i.postimg.cc/qRzMB6nQ/default-cover.jpg" alt="背景圖預覽"
                      style="width: 100%; height: 120px; border-radius: 8px; object-fit: cover; border: 1px solid #333;">
                  </div>
                  <div style="color: #71767b; font-size: 13px; margin-bottom: 8px;">背景圖連結</div>
                  <input type="url" id="character-x-cover-url" placeholder="https://example.com/cover.jpg"
                    style="width: 100%; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px; font-size: 14px; outline: none;"
                    oninput="updateCharacterXCover(this.value)" onfocus="this.style.borderColor='var(--x-accent)'"
                    onblur="this.style.borderColor='#333'">
                  <div style="color: #71767b; font-size: 12px; margin-top: 4px;">
                    請輸入圖片連結URL，支援JPG、PNG、GIF格式
                  </div>
                </div>

                <!-- 自訂標籤1 -->
                <div style="margin-bottom: 24px;">
                  <label style="display: block; color: #fff; font-size: 15px; font-weight: 600; margin-bottom: 8px;">自訂標籤1</label>
                  <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                    <input type="text" id="character-tag1-icon" placeholder="✨" maxlength="2" style="
                      width: 50px;
                      background-color: #1a1a1a;
                      border: 1px solid #333;
                      border-radius: 4px;
                      color: #fff;
                      padding: 12px;
                      font-size: 17px;
                      outline: none;
                      text-align: center;
                    " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'">
                    <input type="text" id="character-custom-tag1" placeholder="例如：科技博主" maxlength="30" style="
                      flex: 1;
                      background-color: #1a1a1a;
                      border: 1px solid #333;
                      border-radius: 4px;
                      color: #fff;
                      padding: 12px;
                      font-size: 15px;
                      outline: none;
                    " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'">
                  </div>
                  <div style="display: flex; gap: 8px; align-items: center;">
                    <label style="color: #71767b; font-size: 12px; min-width: 40px;">顏色:</label>
                    <input type="color" id="character-tag1-color" value="#71767b" style="
                      width: 40px;
                      height: 32px;
                      border: 1px solid #333;
                      border-radius: 4px;
                      background: transparent;
                      cursor: pointer;
                      outline: none;
                    ">
                  </div>
                </div>

                <!-- 自訂標籤2 -->
                <div style="margin-bottom: 24px;">
                  <label style="display: block; color: #fff; font-size: 15px; font-weight: 600; margin-bottom: 8px;">自訂標籤2</label>
                  <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                    <input type="text" id="character-tag2-icon" placeholder="📅" maxlength="2" style="
                      width: 50px;
                      background-color: #1a1a1a;
                      border: 1px solid #333;
                      border-radius: 4px;
                      color: #fff;
                      padding: 12px;
                      font-size: 17px;
                      outline: none;
                      text-align: center;
                    " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'">
                    <input type="text" id="character-custom-tag2" placeholder="例如：2024年加入" maxlength="30" style="
                      flex: 1;
                      background-color: #1a1a1a;
                      border: 1px solid #333;
                      border-radius: 4px;
                      color: #fff;
                      padding: 12px;
                      font-size: 15px;
                      outline: none;
                    " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'">
                  </div>
                  <div style="display: flex; gap: 8px; align-items: center;">
                    <label style="color: #71767b; font-size: 12px; min-width: 40px;">顏色:</label>
                    <input type="color" id="character-tag2-color" value="#71767b" style="
                      width: 40px;
                      height: 32px;
                      border: 1px solid #333;
                      border-radius: 4px;
                      background: transparent;
                      cursor: pointer;
                      outline: none;
                    ">
                  </div>
                </div>

                <!-- 正在關注數量 -->
                <div style="margin-bottom: 20px;">
                  <label style="display: block; color: #fff; font-size: 15px; font-weight: 600; margin-bottom: 8px;">正在關注數量</label>
                  <input type="text" id="character-following-count" placeholder="156, 1.2K, 2.5M等" maxlength="20" style="
                    width: 100%;
                    background-color: #1a1a1a;
                    border: 1px solid #333;
                    border-radius: 8px;
                    color: #fff;
                    padding: 12px;
                    font-size: 15px;
                    outline: none;
                  " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'">
                  <div style="color: #71767b; font-size: 12px; margin-top: 4px;">可輸入任意數位、字母、符號組合</div>
                </div>

                <!-- 關注者數量 -->
                <div style="margin-bottom: 20px;">
                  <label style="display: block; color: #fff; font-size: 15px; font-weight: 600; margin-bottom: 8px;">關注者數量</label>
                  <input type="text" id="character-followers-count" placeholder="89, 1.5K, 3.2M等" maxlength="20" style="
                    width: 100%;
                    background-color: #1a1a1a;
                    border: 1px solid #333;
                    border-radius: 8px;
                    color: #fff;
                    padding: 12px;
                    font-size: 15px;
                    outline: none;
                  " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'">
                  <div style="color: #71767b; font-size: 12px; margin-top: 4px;">可輸入任意數位、字母、符號組合</div>
                </div>

                <!-- X簡介 -->
                <div style="margin-bottom: 20px;">
                  <label
                    style="display: block; color: #fff; font-size: 15px; font-weight: 600; margin-bottom: 8px;">X簡介</label>
                  <textarea id="character-x-bio" placeholder="介紹一下這個角色在X上的身份..."
                    style="width: 100%; min-height: 80px; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px; font-size: 15px; resize: vertical; outline: none; font-family: inherit;"
                    maxlength="160"></textarea>
                  <div style="text-align: right; color: #71767b; font-size: 13px; margin-top: 4px;">
                    <span id="character-bio-count">0</span>/160
                  </div>
                </div>

                <!-- 公眾身份設置 -->
                <div style="margin-bottom: 20px;">
                  <label
                    style="display: block; color: #fff; font-size: 15px; font-weight: 600; margin-bottom: 8px;">公眾身份</label>
                  <div style="color: #71767b; font-size: 13px; margin-bottom: 8px; line-height: 1.4;">
                    描述角色在X平臺的公眾身份（如明星、網紅、博主等）。這將影響其他用戶對該角色的討論幾率，身份越知名可能引起更多關注和討論。此資訊完全公開。
                  </div>

                  <!-- 重要提醒 -->
                  <div
                    style="background-color: color-mix(in srgb, var(--x-accent) , 0.1); border: 1px solid var(--x-accent); border-radius: 8px; padding: 12px; margin-bottom: 12px;">
                    <div style="color: var(--x-accent); font-size: 13px; line-height: 1.4;">
                      <strong>📌 重要提醒：</strong>角色將根據完整人設進行扮演，但<strong
                        style="color: var(--x-accent);">X平臺其他用戶無法讀取角色人設</strong>，僅能看到此公眾身份資訊。如需讓其他用戶瞭解的角色特點、背景故事等內容，請全部詳細填寫至公眾身份中。
                    </div>
                  </div>

                  <textarea id="character-public-identity"
                    placeholder="例如：知名演員、歌手、網路紅人、專業博主等... 可詳細描述角色的公開背景、成就、特點等，無字數限制"
                    style="width: 100%; min-height: 120px; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px; font-size: 15px; resize: vertical; outline: none; font-family: inherit;"></textarea>
                  <div style="color: #71767b; font-size: 12px; margin-top: 4px;">
                    💡 無字數限制，可詳細描述角色的公開信息
                  </div>
                </div>

                <!-- 真名公開設置 -->
                <div style="margin-bottom: 20px;">
                  <label
                    style="display: block; color: #fff; font-size: 15px; font-weight: 600; margin-bottom: 8px;">真名設置</label>
                  <div style="color: #71767b; font-size: 13px; margin-bottom: 12px; line-height: 1.4;">
                    選擇是否公開角色的真實姓名。公開後，其他用戶都能看到角色真名，情侶認證時也會顯示雙方真名。
                  </div>

                  <!-- 是否公開真名核取方塊 -->
                  <div style="margin-bottom: 12px;">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                      <input type="checkbox" id="character-show-real-name" style="
                        width: 16px;
                        height: 16px;
                        accent-color: var(--x-accent);
                      " onchange="toggleCharacterRealNameInput()">
                      <span style="color: #fff; font-size: 15px;">公開真實姓名</span>
                    </label>
                  </div>

                  <!-- 真名輸入框 -->
                  <div id="character-real-name-input-container" style="display: none;">
                    <input type="text" id="character-real-name" placeholder="請輸入角色的真實姓名"
                      style="width: 100%; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px; font-size: 15px; outline: none;"
                      maxlength="50">
                    <div style="text-align: right; color: #71767b; font-size: 13px; margin-top: 4px;">
                      <span id="character-real-name-count">0</span>/50
                    </div>
                  </div>
                </div>

                <!-- NPC關係綁定 -->
                <div style="margin-bottom: 20px;">
                  <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                    <label style="color: #fff; font-size: 15px; font-weight: 600;">NPC關係綁定</label>
                    <button type="button" onclick="openAddRelationshipModal()"
                      style="background-color: var(--x-accent); color: #fff; border: none; border-radius: 16px; padding: 6px 12px; font-size: 12px; cursor: pointer;">
                      + 添加關係
                    </button>
                  </div>
                  <div style="color: #71767b; font-size: 13px; margin-bottom: 12px;">
                    綁定NPC角色作為朋友、親人等，讓角色能夠識別和互動
                  </div>

                  <!-- 關係列表 -->
                  <div id="character-relationships-list" style="max-height: 200px; overflow-y: auto;">
                    <!-- 關係清單將動態生成 -->
                  </div>
                </div>

                <!-- 自動發消息設置 -->
                <div style="margin-bottom: 20px; border-top: 1px solid #333; padding-top: 20px;">
                  <label style="display: block; color: #fff; font-size: 15px; font-weight: 600; margin-bottom: 8px;">🤖 後臺自動活動</label>
                  <div style="color: #71767b; font-size: 13px; margin-bottom: 12px; line-height: 1.4;">
                    啟用後，當與該角色在X平臺私信達到設定的無互動時間後，角色將主動在後臺發送消息和推文
                  </div>

                  <!-- 啟用開關 -->
                  <div style="margin-bottom: 16px;">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                      <input type="checkbox" id="character-auto-message-enabled" style="
                        width: 16px;
                        height: 16px;
                        accent-color: var(--x-accent);
                      " onchange="toggleAutoMessageSettings()">
                      <span style="color: #fff; font-size: 15px;">啟用後臺自動發消息</span>
                    </label>
                  </div>

                  <!-- 時間設置 -->
                  <div id="auto-message-time-settings" style="display: none;">
                    <label style="display: block; color: #fff; font-size: 14px; font-weight: 600; margin-bottom: 8px;">無互動觸發時間</label>
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                      <input type="number" id="character-auto-message-interval" placeholder="60" min="10" max="3600" style="
                        width: 100px;
                        background-color: #1a1a1a;
                        border: 1px solid #333;
                        border-radius: 8px;
                        color: #fff;
                        padding: 8px 12px;
                        font-size: 14px;
                        outline: none;
                      ">
                      <span style="color: var(--x-text-primary); font-size: 14px;">秒</span>
                    </div>
                    <div style="color: #71767b; font-size: 12px; line-height: 1.4;">
                      設置無互動多少秒後角色會主動發消息（建議60-300秒，最少10秒，最多3600秒）
                    </div>
                  </div>
                </div>

                <!-- 保存按鈕 -->
                <div style="display: flex; gap: 12px; margin-top: 32px;">
                  <button type="button" onclick="closeCharacterXProfileModal()"
                    style="flex: 1; background-color: transparent; color: #fff; border: 1px solid #536471; border-radius: 20px; padding: 12px 24px; font-size: 15px; font-weight: 700; cursor: pointer;">
                    取消
                  </button>
                  <button type="submit"
                    style="flex: 1; background-color: var(--x-accent); color: #fff; border: none; border-radius: 20px; padding: 12px 24px; font-size: 15px; font-weight: 700; cursor: pointer;">
                    保存X資料
                  </button>
                </div>

              </form>
            </div>
          </div>
        </div>
      </div>

      <!-- NPC關係編輯彈窗 -->
      <div id="relationship-modal"
        style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.8); z-index: 40; backdrop-filter: blur(8px);">
        <div style="display: flex; justify-content: center; align-items: center; height: 100%; padding: 20px;">
          <div
            style="background-color: #000; border: 1px solid #333; border-radius: 16px; width: 100%; max-width: 500px;">

            <!-- 彈窗頭部 -->
            <div
              style="display: flex; align-items: center; justify-content: space-between; padding: 20px 20px 16px 20px; border-bottom: 1px solid #333;">
              <h3 id="relationship-modal-title" style="color: #fff; font-size: 18px; font-weight: 700; margin: 0;">
                添加NPC關係</h3>
              <button onclick="closeRelationshipModal()"
                style="background: none; border: none; color: #71767b; cursor: pointer; padding: 8px;">
                <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: currentColor;">
                  <path
                    d="M18.36 6.64c.39.39.39 1.02 0 1.41L13.41 12l4.95 4.95c.39.39.39 1.02 0 1.41-.39.39-1.02.39-1.41 0L12 13.41l-4.95 4.95c-.39.39-1.02.39-1.41 0-.39-.39-.39-1.02 0-1.41L10.59 12 5.64 7.05c-.39-.39-.39-1.02 0-1.41.39-.39 1.02-.39 1.41 0L12 10.59l4.95-4.95c.39-.39 1.02-.39 1.41 0z" />
                </svg>
              </button>
            </div>

            <!-- 表單內容 -->
            <div style="padding: 20px;">
              <form id="relationship-form">

                <!-- NPC名稱 -->
                <div style="margin-bottom: 16px;">
                  <label
                    style="display: block; color: #fff; font-size: 14px; font-weight: 600; margin-bottom: 8px;">NPC名稱</label>
                  <input type="text" id="relationship-npc-name" placeholder="輸入NPC的名稱"
                    style="width: 100%; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px; font-size: 14px; outline: none;"
                    maxlength="30">
                </div>

                <!-- NPC控制碼 -->
                <div style="margin-bottom: 16px;">
                  <label
                    style="display: block; color: #fff; font-size: 14px; font-weight: 600; margin-bottom: 8px;">NPC控制碼</label>
                  <div style="position: relative;">
                    <span
                      style="position: absolute; left: 12px; top: 50%; transform: translateY(-50%); color: #71767b; font-size: 14px;">@</span>
                    <input type="text" id="relationship-npc-handle" placeholder="npc_username"
                      style="width: 100%; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px 12px 12px 30px; font-size: 14px; outline: none;"
                      maxlength="15">
                  </div>
                </div>

                <!-- 關係類型 -->
                <div style="margin-bottom: 16px;">
                  <label
                    style="display: block; color: #fff; font-size: 14px; font-weight: 600; margin-bottom: 8px;">關係類型</label>
                  <select id="relationship-type"
                    style="width: 100%; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px; font-size: 14px; outline: none;">
                    <option value="朋友">朋友</option>
                    <option value="親人">親人</option>
                    <option value="戀人">戀人</option>
                    <option value="同事">同事</option>
                    <option value="同學">同學</option>
                    <option value="鄰居">鄰居</option>
                    <option value="其他">其他</option>
                  </select>
                </div>

                <!-- 關係描述 -->
                <div style="margin-bottom: 20px;">
                  <label
                    style="display: block; color: #fff; font-size: 14px; font-weight: 600; margin-bottom: 8px;">關係描述</label>
                  <textarea id="relationship-description" placeholder="詳細描述兩人的關係，如何認識的，相處模式等..."
                    style="width: 100%; min-height: 80px; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px; font-size: 14px; resize: vertical; outline: none; font-family: inherit;"
                    maxlength="200"></textarea>
                  <div style="text-align: right; color: #71767b; font-size: 12px; margin-top: 4px;">
                    <span id="relationship-desc-count">0</span>/200
                  </div>
                </div>

                <!-- 操作按鈕 -->
                <div style="display: flex; gap: 12px;">
                  <button type="button" onclick="closeRelationshipModal()"
                    style="flex: 1; background-color: transparent; color: #fff; border: 1px solid #536471; border-radius: 20px; padding: 10px 20px; font-size: 14px; font-weight: 700; cursor: pointer;">
                    取消
                  </button>
                  <button type="submit"
                    style="flex: 1; background-color: var(--x-accent); color: #fff; border: none; border-radius: 20px; padding: 10px 20px; font-size: 14px; font-weight: 700; cursor: pointer;">
                    保存關係
                  </button>
                </div>

              </form>
            </div>
          </div>
        </div>
      </div>

      <!-- 搜尋網頁面 -->
      <div id="x-search-page" class="x-page"
        style="flex: 1; display: none; flex-direction: column; overflow: hidden; min-height: 0;">
        
        <!-- 搜索框 -->
        <div class="search-header">
          <button id="search-back-btn" onclick="backToTrending()" style="
            display: none;
            background: none;
            border: none;
            padding: 8px;
            cursor: pointer;
            margin-right: 8px;
            border-radius: 50%;
            transition: background-color 0.2s;
          " onmouseover="this.style.backgroundColor='rgba(239,243,244,0.1)'"
            onmouseout="this.style.backgroundColor='transparent'">
            <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: #fff;">
              <g><path d="M7.414 13l5.043 5.04-1.414 1.42L3.586 12l7.457-7.46 1.414 1.42L7.414 11H21v2H7.414z"></path></g>
            </svg>
          </button>
          <div class="search-box">
            <svg viewBox="0 0 24 24" aria-hidden="true">
              <g><path d="M10.25 3.75c-3.59 0-6.5 2.91-6.5 6.5s2.91 6.5 6.5 6.5c1.795 0 3.419-.726 4.596-1.904 1.178-1.177 1.904-2.801 1.904-4.596 0-3.59-2.91-6.5-6.5-6.5zm-8.5 6.5c0-4.694 3.806-8.5 8.5-8.5s8.5 3.806 8.5 8.5c0 1.986-.682 3.815-1.824 5.262l4.781 4.781-1.414 1.414-4.781-4.781c-1.447 1.142-3.276 1.824-5.262 1.824-4.694 0-8.5-3.806-8.5-8.5z"></path></g>
            </svg>
            <input type="text" placeholder="搜索 X" id="search-input" 
              oninput="toggleSearchButton()" 
              onkeydown="if(event.key==='Enter') performSearch()">
            <button id="search-submit-btn" onclick="performSearch()" style="
              display: none;
              background: none;
              border: none;
              padding: 8px;
              cursor: pointer;
              border-radius: 50%;
              transition: background-color 0.2s;
            " onmouseover="this.style.backgroundColor='rgba(29,155,240,0.1)'"
              onmouseout="this.style.backgroundColor='transparent'">
              <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-accent);">
                <g><path d="M2.504 21.866l.526-2.108C3.04 19.719 4 15.823 4 12s-.96-7.719-.97-7.757l-.527-2.109L22.236 12 2.504 21.866zM5.981 13c-.072 1.962-.34 3.833-.583 5.183L17.764 12 5.398 5.818c.242 1.349.51 3.221.583 5.183H10v2H5.981z"></path></g>
              </svg>
            </button>
          </div>
        </div>

        <!-- 熱搜視圖 -->
        <div id="trending-view" style="display: flex; flex-direction: column; flex: 1; overflow: hidden;">
          <!-- 分類標籤 -->
          <div class="search-tabs">
            <div class="search-tab active" onclick="switchSearchTab('recommended')">為你推薦</div>
            <div class="search-tab" onclick="switchSearchTab('trending')">當前趨勢</div>
            <div class="add-category-btn" onclick="openAddCategoryModal()" title="添加自訂分類">
              <svg viewBox="0 0 24 24" aria-hidden="true">
                <g><path d="M19.5 12.75h-6.75V19.5h-1.5v-6.75H4.5v-1.5h6.75V4.5h1.5v6.75h6.75v1.5z"></path></g>
              </svg>
            </div>
          </div>

          <!-- 熱搜列表 -->
          <div class="trending-list" id="trending-list">
            <!-- 熱搜專案將通過JavaScript動態生成 -->
          </div>
        </div>

        <!-- 搜索結果視圖 -->
        <div id="search-results-view" style="display: none; flex-direction: column; flex: 1; overflow: hidden;">
          <!-- 搜索結果標籤欄 -->
          <div class="search-tabs">
            <div class="search-tab active" onclick="switchSearchResultTab('top')">熱門</div>
            <div class="search-tab" onclick="switchSearchResultTab('latest')">最新</div>
            <div class="search-tab" onclick="switchSearchResultTab('users')">用戶</div>
          </div>

          <!-- 搜索結果內容 -->
          <div id="search-results-content" style="
            flex: 1;
            overflow-y: auto;
            background: #000;
          ">
            <!-- 搜索結果將動態生成 -->
          </div>
        </div>

        <!-- 刷新按鈕 -->
        <button class="refresh-trends-btn" onclick="refreshTrends()" title="刷新熱搜">
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <g><path d="M4.5 3.88l4.432 4.14-1.364 1.46L5.5 7.55V16c0 1.1.896 2 2 2H13v2H7.5c-2.209 0-4-1.79-4-4V7.55L1.432 9.48.068 8.02 4.5 3.88zM16.5 6H11V4h5.5c2.209 0 4 1.79 4 4v8.45l2.068-1.93 1.364 1.46-4.432 4.14-4.432-4.14 1.364-1.46 2.068 1.93V8c0-1.1-.896-2-2-2z"></path></g>
          </svg>
        </button>
      </div>

      <!-- 自訂分類管理模態框 -->
      <div id="category-manager-modal" style="
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8);
        z-index: 30;
        overflow-y: auto;
        backdrop-filter: blur(8px);
      " onclick="closeCategoryModal(event)">
        <div style="
          background-color: #000;
          margin: 40px auto;
          border-radius: 16px;
          max-width: 600px;
          width: calc(100% - 40px);
          border: 1px solid #333;
        " onclick="event.stopPropagation()">
          <!-- 模態框頭部 -->
          <div style="
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 20px;
            border-bottom: 1px solid #333;
          ">
            <h2 style="color: #fff; font-size: 20px; font-weight: 700; margin: 0;">管理熱搜分類</h2>
            <div onclick="closeCategoryModal()" style="
              cursor: pointer;
              padding: 8px;
              border-radius: 50%;
              transition: background-color 0.2s;
            " onmouseover="this.style.backgroundColor='rgba(239,243,244,0.1)'"
              onmouseout="this.style.backgroundColor='transparent'">
              <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: #fff;">
                <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
              </svg>
            </div>
          </div>

          <!-- 模態框內容 -->
          <div style="padding: 20px; max-height: calc(100vh - 200px); overflow-y: auto;">
            <!-- 說明 -->
            <div style="
              background-color: color-mix(in srgb, var(--x-accent) , 0.1);
              border: 1px solid var(--x-accent);
              border-radius: 8px;
              padding: 12px;
              margin-bottom: 20px;
            ">
              <p style="color: var(--x-accent); font-size: 13px; line-height: 1.4; margin: 0;">
                💡 自訂分類將在刷新熱搜時生成相應內容。可以添加任意分類（如"動漫"、"二次元"等），並描述該分類下的內容類別型。
              </p>
            </div>

            <!-- 自訂分類列表 -->
            <div style="margin-bottom: 20px;">
              <div style="
                display: flex;
                align-items: center;
                justify-content: space-between;
                margin-bottom: 12px;
              ">
                <h3 style="color: #fff; font-size: 16px; font-weight: 600; margin: 0;">自訂分類</h3>
                <button onclick="addNewCategory()" style="
                  background-color: var(--x-accent);
                  color: #fff;
                  border: none;
                  border-radius: 20px;
                  padding: 6px 16px;
                  font-size: 14px;
                  font-weight: 600;
                  cursor: pointer;
                  transition: all 0.2s;
                " onmouseover="this.style.backgroundColor='#1a8cd8'"
                  onmouseout="this.style.backgroundColor='var(--x-accent)'">
                  + 添加分類
                </button>
              </div>

              <!-- 分類列表容器 -->
              <div id="custom-categories-list" style="display: flex; flex-direction: column; gap: 12px;">
                <!-- 分類項將動態生成 -->
              </div>
            </div>

            <!-- 保存按鈕 -->
            <button onclick="saveCustomCategories()" style="
              width: 100%;
              background-color: var(--x-accent);
              color: #fff;
              border: none;
              border-radius: 25px;
              padding: 14px;
              font-size: 16px;
              font-weight: 700;
              cursor: pointer;
              transition: all 0.2s;
            " onmouseover="this.style.backgroundColor='#1a8cd8'"
              onmouseout="this.style.backgroundColor='var(--x-accent)'">
              保存設置
            </button>
          </div>
        </div>
      </div>

      <!-- 通知頁面 -->
      <div id="x-notifications-page" class="x-page"
        style="flex: 1; display: none; flex-direction: column; overflow: hidden; min-height: 0;">
        
        <!-- 通知標籤欄 -->
        <div class="notifications-tabs" style="display: flex; border-bottom: 1px solid var(--x-border-color); background-color: var(--x-bg-primary);">
          <!-- All 標籤 -->
          <div class="notification-tab active" onclick="switchNotificationTab('all')" style="
            flex: 1;
            text-align: center;
            padding: 15px 0;
            font-weight: 700;
            font-size: 15px;
            cursor: pointer;
            position: relative;
            color: var(--x-text-primary);
            transition: background-color 0.2s;
          ">
            <span data-i18n="notificationsTabAll">全部</span>
            <div class="tab-indicator" style="
              position: absolute;
              bottom: 0;
              left: 0;
              right: 0;
              height: 4px;
              background-color: var(--x-accent);
              border-radius: 2px;
            "></div>
          </div>

          <!-- Mentions 標籤 -->
          <div class="notification-tab" onclick="switchNotificationTab('mentions')" style="
            flex: 1;
            text-align: center;
            padding: 15px 0;
            font-weight: 700;
            font-size: 15px;
            cursor: pointer;
            position: relative;
            color: var(--x-text-secondary);
            transition: background-color 0.2s;
          ">
            <span data-i18n="notificationsTabMentions">提及</span>
            <div class="tab-indicator" style="
              position: absolute;
              bottom: 0;
              left: 0;
              right: 0;
              height: 4px;
              background-color: var(--x-accent);
              border-radius: 2px;
              display: none;
            "></div>
          </div>
        </div>

        <!-- All 通知內容區域 -->
        <div id="notifications-all-content" class="notification-content" style="
          flex: 1;
          overflow-y: auto;
          background-color: var(--x-bg-primary);
        ">
          <!-- 通知列表容器 -->
          <div id="notifications-all-list" class="notifications-list">
            <!-- 通知項將通過 JavaScript 動態生成 -->
          </div>
        </div>

        <!-- Mentions 通知內容區域 -->
        <div id="notifications-mentions-content" class="notification-content" style="
          flex: 1;
          overflow-y: auto;
          background-color: var(--x-bg-primary);
          display: none;
        ">
          <!-- 提及列表容器 -->
          <div id="notifications-mentions-list" class="notifications-list">
            <!-- 提及項將通過 JavaScript 動態生成 -->
          </div>
        </div>

        <!-- 刷新陌生人私信按鈕（羽毛筆，僅在All頁面顯示） -->
        <div id="refresh-messages-btn" class="refresh-messages-btn" onclick="refreshStrangerMessages()" style="
          position: fixed;
          bottom: 80px;
          right: 16px;
          width: 56px;
          height: 56px;
          background-color: var(--x-accent);
          border-radius: 50%;
          display: flex;
          align-items: center;
          justify-content: center;
          cursor: pointer;
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
          transition: all 0.2s;
          z-index: 100;
        " onmouseover="this.style.transform='scale(1.1)'"
           onmouseout="this.style.transform='scale(1)'">
          <svg viewBox="0 0 24 24" style="width: 24px; height: 24px; fill: #fff;">
            <g><path d="M8.8 7.2H5.6V3.9c0-.4-.3-.8-.8-.8s-.7.4-.7.8v3.3H.8c-.4 0-.8.3-.8.8s.3.8.8.8h3.3v3.3c0 .4.3.8.8.8s.8-.3.8-.8V8.7H9c.4 0 .8-.3.8-.8s-.5-.7-1-.7zm15-4.9v-.1h-.1c-.1 0-9.2 1.2-14.4 11.7-3.8 7.6-3.6 9.9-3.3 9.9.3.1 3.4-6.5 6.7-9.2 5.2-1.1 6.6-3.6 6.6-3.6s-1.5.2-2.1.2c-.8 0-1.4-.2-1.7-.3 1.3-1.2 2.4-1.5 3.5-1.7.9-.2 1.8-.4 3-1.2 2.2-1.6 1.9-5.5 1.8-5.7z"></path></g>
          </svg>
        </div>
      </div>

      <!-- 私信頁面 -->
      <div id="x-messages-page" class="x-page"
        style="flex: 1; display: none; flex-direction: column; overflow: hidden; min-height: 0;">
        
        <!-- 私信列表容器 -->
        <div id="messages-list-container" class="messages-list-container" style="
          flex: 1;
          overflow-y: auto;
          background-color: var(--x-bg-primary);
        ">
          <!-- 私信清單將通過 JavaScript 動態生成 -->
        </div>

        <!-- 新建私信浮動按鈕 -->
        <div id="compose-message-btn" class="compose-message-btn" onclick="openNewMessageModal()" style="
          position: fixed;
          bottom: 80px;
          right: 16px;
          width: 56px;
          height: 56px;
          background-color: var(--x-accent);
          border-radius: 50%;
          display: flex;
          align-items: center;
          justify-content: center;
          cursor: pointer;
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
          transition: all 0.2s;
          z-index: 100;
        " onmouseover="this.style.transform='scale(1.1)'"
           onmouseout="this.style.transform='scale(1)'">
          <svg viewBox="0 0 24 24" style="width: 24px; height: 24px; fill: #fff;">
            <g><path d="M1.998 5.5c0-1.381 1.119-2.5 2.5-2.5h15c1.381 0 2.5 1.119 2.5 2.5v13c0 1.381-1.119 2.5-2.5 2.5h-15c-1.381 0-2.5-1.119-2.5-2.5v-13zm2.5-.5c-.276 0-.5.224-.5.5v2.764l8 3.638 8-3.636V5.5c0-.276-.224-.5-.5-.5h-15zm15.5 5.463l-8 3.636-8-3.638V18.5c0 .276.224.5.5.5h15c.276 0 .5-.224.5-.5v-8.037z"></path></g>
          </svg>
        </div>
      </div>

      <!-- 私信詳情頁面 -->
      <div id="x-message-detail-page" class="x-page"
        style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; display: none; flex-direction: column; overflow: hidden; z-index: 20; background-color: var(--x-bg-primary);">
        
        <!-- 私信頁面頂部欄 -->
        <div class="message-detail-header" style="
          display: flex;
          align-items: center;
          padding: 55px 16px 12px 16px;
          background-color: var(--x-bg-primary);
        ">
          <!-- 返回按鈕 -->
          <div onclick="closeMessageDetail()" style="
            cursor: pointer;
            margin-right: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 34px;
            height: 34px;
            border-radius: 50%;
            transition: background-color 0.2s;
          " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
             onmouseout="this.style.backgroundColor='transparent'">
            <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);">
              <g><path d="M7.414 13l5.043 5.04-1.414 1.42L3.586 12l7.457-7.46 1.414 1.42L7.414 11H21v2H7.414z"></path></g>
          </svg>
          </div>

          <!-- 用戶頭像和昵稱 -->
          <div style="flex: 1; display: flex; align-items: center; gap: 12px; min-width: 0;">
            <img id="message-detail-top-avatar" src="https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg" 
              alt="User" 
              style="width: 32px; height: 32px; border-radius: 50%; cursor: pointer; transition: opacity 0.2s;"
              onmouseover="this.style.opacity='0.8'"
              onmouseout="this.style.opacity='1'"
              onclick="handleMessageDetailAvatarClick()">
            <span id="message-detail-top-name" style="
                  font-size: 16px;
                  font-weight: 700;
                  color: var(--x-text-primary);
                  overflow: hidden;
                  text-overflow: ellipsis;
                  white-space: nowrap;
                ">用戶名</span>
          </div>

          <!-- 右側操作按鈕 -->
          <div style="display: flex; gap: 8px;">
            <!-- 視頻通話按鈕 -->
            <div style="
              width: 34px;
              height: 34px;
              display: flex;
              align-items: center;
              justify-content: center;
              border-radius: 50%;
              cursor: pointer;
              transition: background-color 0.2s;
            " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
               onmouseout="this.style.backgroundColor='transparent'">
              <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);">
                <g><path d="M3 5.5C3 4.119 4.119 3 5.5 3h6C12.881 3 14 4.119 14 5.5v13c0 1.381-1.119 2.5-2.5 2.5h-6C4.119 21 3 19.881 3 18.5v-13zM5.5 5c-.276 0-.5.224-.5.5v13c0 .276.224.5.5.5h6c.276 0 .5-.224.5-.5v-13c0-.276-.224-.5-.5-.5h-6zM15.5 6l5.5-3v18l-5.5-3v-12z"></path></g>
              </svg>
            </div>

            <!-- 語音通話按鈕 -->
            <div style="
              width: 34px;
              height: 34px;
              display: flex;
              align-items: center;
              justify-content: center;
              border-radius: 50%;
              cursor: pointer;
              transition: background-color 0.2s;
            " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
               onmouseout="this.style.backgroundColor='transparent'">
              <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);">
                <g><path d="M6.62 10.79c1.44 2.83 3.76 5.14 6.59 6.59l2.2-2.2c.27-.27.67-.36 1.02-.24 1.12.37 2.33.57 3.57.57.55 0 1 .45 1 1V20c0 .55-.45 1-1 1-9.39 0-17-7.61-17-17 0-.55.45-1 1-1h3.5c.55 0 1 .45 1 1 0 1.25.2 2.45.57 3.57.11.35.03.74-.25 1.02l-2.2 2.2z"></path></g>
              </svg>
            </div>
          </div>
        </div>

        <!-- 可滾動內容區域（包含使用者資訊和消息） -->
        <div id="message-detail-scrollable" style="
          flex: 1;
          overflow-y: auto;
          background-color: var(--x-bg-primary);
        ">
          <!-- 使用者詳細資訊區域 -->
          <div style="
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px 16px;
            background-color: var(--x-bg-primary);
            border-bottom: 1px solid var(--x-border-color);
          ">
            <!-- 大頭像 -->
            <img id="message-detail-avatar" src="https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg" 
              alt="User" 
              style="width: 64px; height: 64px; border-radius: 50%; margin-bottom: 12px;">
            
            <!-- 昵稱 -->
            <div style="display: flex; align-items: center; gap: 4px; margin-bottom: 4px;">
              <span id="message-detail-name" style="
                font-size: 20px;
                font-weight: 700;
                color: var(--x-text-primary);
              ">用戶名</span>
            </div>
            
            <!-- 控制碼 -->
            <div id="message-detail-handle" style="
              font-size: 15px;
              color: var(--x-text-secondary);
              margin-bottom: 12px;
            ">@handle</div>
            
            <!-- 簡介 -->
            <div id="message-detail-bio" style="
              font-size: 15px;
              color: var(--x-text-primary);
              text-align: center;
              line-height: 1.4;
              margin-bottom: 12px;
              display: none;
            "></div>
            
            <!-- 關注者數量 -->
            <div id="message-detail-followers" style="
              font-size: 14px;
              color: var(--x-text-secondary);
            " data-i18n-template="messageFollowers">0 位關注者</div>
          </div>

          <!-- 消息內容區域 -->
          <div id="message-detail-content" class="message-detail-content" style="
            padding: 16px;
            background-color: var(--x-bg-primary);
            min-height: 300px;
          ">
            <!-- 消息將通過 JavaScript 動態生成 -->
          </div>
        </div>

        <!-- 底部輸入區域 -->
        <div class="message-input-area" style="
          padding: 12px 16px;
          background-color: var(--x-bg-primary);
        ">
          <!-- 全包裹輸入框容器 -->
          <div style="
            display: flex;
            align-items: center;
            gap: 8px;
            background-color: var(--x-bg-secondary);
            border-radius: 20px;
            padding: 8px 12px;
            position: relative;
          ">
            <!-- 左側功能圖示 - 加號按鈕 -->
            <div style="position: relative;">
              <!-- 加號主按鈕 -->
              <div id="message-add-btn" onclick="toggleMessageFunctionMenu()" style="
                cursor: pointer;
                padding: 4px;
                border-radius: 50%;
                transition: all 0.2s;
                display: flex;
                align-items: center;
                justify-content: center;
              " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
                onmouseout="this.style.backgroundColor='transparent'">
                <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-accent); transition: transform 0.2s;">
                  <g><path d="M12 4C11.4477 4 11 4.44772 11 5V11H5C4.44772 11 4 11.4477 4 12C4 12.5523 4.44772 13 5 13H11V19C11 19.5523 11.4477 20 12 20C12.5523 20 13 19.5523 13 19V13H19C19.5523 13 20 12.5523 20 12C20 11.4477 19.5523 11 19 11H13V5C13 4.44772 12.5523 4 12 4Z"></path></g>
                </svg>
              </div>

              <!-- 功能功能表 -->
              <div id="message-function-menu" style="
                position: absolute;
                bottom: 100%;
                left: 0;
                margin-bottom: 8px;
                background-color: var(--x-bg-primary);
                border: 1px solid var(--x-border-color);
                border-radius: 12px;
                padding: 4px;
                display: none;
                flex-direction: row;
                gap: 4px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                z-index: 100;
              ">
                <!-- 圖片上傳 -->
                <div onclick="openImageTypeSelector(); toggleMessageFunctionMenu();" style="
                  cursor: pointer;
                  padding: 8px;
                  border-radius: 8px;
                transition: background-color 0.2s;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
                onmouseout="this.style.backgroundColor='transparent'">
                <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-accent);">
                  <g><path d="M3 5.5C3 4.119 4.119 3 5.5 3h13C19.881 3 21 4.119 21 5.5v13c0 1.381-1.119 2.5-2.5 2.5h-13C4.119 21 3 19.881 3 18.5v-13zM5.5 5c-.276 0-.5.224-.5.5v9.086l3-3 3 3 5-5 3 3V5.5c0-.276-.224-.5-.5-.5h-13zM19 15.414l-3-3-5 5-3-3-3 3V18.5c0 .276.224.5.5.5h13c.276 0 .5-.224.5-.5v-3.086zM9.75 7C8.784 7 8 7.784 8 8.75s.784 1.75 1.75 1.75 1.75-.784 1.75-1.75S10.716 7 9.75 7z"></path></g>
                </svg>
              </div>

                                <!-- 表情包按鈕 -->
                <div onclick="openStickerPicker(); toggleMessageFunctionMenu();" style="
                  cursor: pointer;
                  padding: 8px;
                  border-radius: 8px;
                  transition: background-color 0.2s;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
                  onmouseout="this.style.backgroundColor='transparent'">
                  <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-accent);">
                    <g><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm3.5-9c.83 0 1.5-.67 1.5-1.5S16.33 8 15.5 8 14 8.67 14 9.5s.67 1.5 1.5 1.5zm-7 0c.83 0 1.5-.67 1.5-1.5S9.33 8 8.5 8 7 8.67 7 9.5 7.67 11 8.5 11zm3.5 6.5c2.33 0 4.31-1.46 5.11-3.5H6.89c.8 2.04 2.78 3.5 5.11 3.5z"></path></g>
                  </svg>
                </div>

                <!-- 重回按鈕 -->
                <div onclick="regenerateAIResponse(); toggleMessageFunctionMenu();" style="
                  cursor: pointer;
                  padding: 8px;
                  border-radius: 8px;
                  transition: background-color 0.2s;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
                  onmouseout="this.style.backgroundColor='transparent'">
                  <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: none; stroke: var(--x-accent); stroke-width: 2; stroke-linecap: round; stroke-linejoin: round;">
                    <path d="M20 11a8.1 8.1 0 0 0 -15.5 -2m-.5 -4v4h4" />
                    <path d="M4 13a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4" />
                </svg>
              </div>

              <!-- 語音按鈕 -->
                <div onclick="openVoiceMessageDialog(); toggleMessageFunctionMenu();" style="
                cursor: pointer;
                  padding: 8px;
                  border-radius: 8px;
                transition: background-color 0.2s;
                  display: flex;
                  align-items: center;
                  justify-content: center;
              " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
                onmouseout="this.style.backgroundColor='transparent'">
                <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-accent);">
                  <g><path d="M12 3c-1.66 0-3 1.34-3 3v6c0 1.66 1.34 3 3 3s3-1.34 3-3V6c0-1.66-1.34-3-3-3zm0 2c.55 0 1 .45 1 1v6c0 .55-.45 1-1 1s-1-.45-1-1V6c0-.55.45-1 1-1zm5 7c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-2.08c3.39-.49 6-3.39 6-6.92h-2z"></path></g>
                </svg>
                </div>

                <!-- 轉帳按鈕 -->
                <div onclick="openTransferDialog(); toggleMessageFunctionMenu();" style="
                cursor: pointer;
                  padding: 8px;
                  border-radius: 8px;
                transition: background-color 0.2s;
                  display: flex;
                  align-items: center;
                  justify-content: center;
              " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
                onmouseout="this.style.backgroundColor='transparent'">
                <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-accent);">
                  <g><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zM6.64 15.748L12 10.388l5.36 5.36c-.48.32-1.04.56-1.68.72L12 12.78l-3.68 3.69c-.64-.16-1.2-.4-1.68-.72zM12 4c4.41 0 8 3.59 8 8 0 1.85-.63 3.55-1.69 4.9L12 10.59 5.69 16.9C4.63 15.55 4 13.85 4 12c0-4.41 3.59-8 8-8z"></path></g>
                </svg>
                </div>
              </div>
            </div>

            <!-- 輸入框 -->
              <textarea id="message-input" placeholder="開始寫私信" 
                data-i18n-placeholder="messageInputPlaceholder"
                style="
                flex: 1;
                min-height: 36px;
                max-height: 100px;
                background-color: transparent;
                  border: none;
                  color: var(--x-text-primary);
                  font-size: 15px;
                  resize: none;
                  outline: none;
                  font-family: inherit;
                padding: 4px 0;
                  line-height: 1.4;
                "
              oninput="autoResizeMessageInput(this)"
              onkeydown="handleMessageInputKeydown(event)"></textarea>

            <!-- 發送按鈕 -->
            <button id="message-send-btn" onclick="getAIResponse()" style="
              display: flex;
                background-color: var(--x-accent);
                color: #fff;
                border: none;
                border-radius: 50%;
                width: 32px;
                height: 32px;
                cursor: pointer;
                transition: opacity 0.2s;
                padding: 0;
                align-items: center;
                justify-content: center;
              flex-shrink: 0;
              ">
              <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: #fff;">
                  <g><path d="M2.504 21.866l.526-2.108C3.04 19.719 4 15.823 4 12s-.96-7.719-.97-7.757l-.527-2.109L22.236 12 2.504 21.866zM5.981 13c-.072 1.962-.34 3.833-.583 5.183L17.764 12 5.398 5.818c.242 1.349.51 3.221.583 5.183H10v2H5.981z"></path></g>
                </svg>
              </button>
          </div>

          <!-- 隱藏的圖片上傳輸入（支援多圖） -->
          <input type="file" id="message-image-input" accept="image/*" multiple style="display: none;" onchange="handleMessageImageUpload(event)">
        </div>

        <!-- 表情包選擇器彈窗 -->
        <div id="sticker-picker-modal" style="
          position: fixed;
          top: 0;
          left: 0;
          width: 100vw;
          height: 100vh;
          background-color: rgba(0, 0, 0, 0.5);
          display: none;
          align-items: center;
          justify-content: center;
          z-index: 30;
        " onclick="closeStickerPicker()">
          <div style="
            background-color: var(--x-bg-primary);
            border-radius: 16px;
            max-width: 500px;
            width: 95%;
            max-height: 75vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
          " onclick="event.stopPropagation()">
            <!-- 標題列 -->
            <div style="
              padding: 16px;
              border-bottom: 1px solid var(--x-border-color);
              display: flex;
              align-items: center;
              justify-content: space-between;
            ">
              <div style="font-size: 18px; font-weight: 700; color: var(--x-text-primary);">選擇表情包</div>
              <div onclick="closeStickerPicker()" style="
                cursor: pointer;
                padding: 4px;
                border-radius: 50%;
                transition: background-color 0.2s;
              " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
                onmouseout="this.style.backgroundColor='transparent'">
                <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);">
                  <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
                </svg>
              </div>
            </div>

            <!-- 分類標籤 -->
            <div style="
              padding: 12px 16px 0 16px;
              display: flex;
              gap: 8px;
              border-bottom: 1px solid var(--x-border-color);
            ">
              <div id="sticker-tab-frequent" onclick="switchStickerTab('frequent')" style="
                padding: 8px 16px;
                cursor: pointer;
                border-bottom: 2px solid var(--x-accent);
                color: var(--x-text-primary);
                font-size: 14px;
                font-weight: 600;
                transition: all 0.2s;
              ">常用</div>
              <div id="sticker-tab-all" onclick="switchStickerTab('all')" style="
                padding: 8px 16px;
                cursor: pointer;
                border-bottom: 2px solid transparent;
                color: var(--x-text-secondary);
                font-size: 14px;
                font-weight: 600;
                transition: all 0.2s;
              ">全部</div>
            </div>

            <!-- 表情包列表 -->
            <div id="sticker-list" style="
              flex: 1;
              overflow-y: auto;
              overflow-x: hidden;
              padding: 16px;
              display: grid;
              grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
              gap: 12px;
              align-content: start;
              align-items: start;
            ">
              <!-- 表情包將動態載入 -->
            </div>

            <!-- 底部按鈕 -->
            <div style="
              padding: 16px;
              border-top: 1px solid var(--x-border-color);
              display: flex;
              justify-content: space-between;
              gap: 8px;
            ">
              <button onclick="openAddStickerDialog()" style="
                background-color: var(--x-bg-secondary);
                color: var(--x-text-primary);
                border: none;
                border-radius: 20px;
                padding: 8px 16px;
                font-size: 14px;
                font-weight: 600;
                cursor: pointer;
                transition: background-color 0.2s;
                flex: 1;
              " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
                onmouseout="this.style.backgroundColor='var(--x-bg-secondary)'">
                + 導入表情包
              </button>
              <button onclick="openStickerManager()" style="
                background-color: var(--x-bg-secondary);
                color: var(--x-text-primary);
                border: none;
                border-radius: 20px;
                padding: 8px 16px;
                font-size: 14px;
                font-weight: 600;
                cursor: pointer;
                transition: background-color 0.2s;
              " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
                onmouseout="this.style.backgroundColor='var(--x-bg-secondary)'">
                管理
              </button>
            </div>
          </div>
        </div>

        <!-- 表情包管理器 -->
        <div id="sticker-manager-dialog" style="
          position: fixed;
          top: 0;
          left: 0;
          width: 100vw;
          height: 100vh;
          background-color: rgba(0, 0, 0, 0.5);
          display: none;
          align-items: center;
          justify-content: center;
          z-index: 32;
        " onclick="closeStickerManager()">
          <div style="
            background-color: var(--x-bg-primary);
            border-radius: 16px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
          " onclick="event.stopPropagation()">
            <div style="
              padding: 16px;
              border-bottom: 1px solid var(--x-border-color);
              display: flex;
              align-items: center;
              justify-content: space-between;
            ">
              <div style="font-size: 18px; font-weight: 700; color: var(--x-text-primary);">表情包管理</div>
              <div onclick="closeStickerManager()" style="
                cursor: pointer;
                padding: 4px;
                border-radius: 50%;
                transition: background-color 0.2s;
              " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
                onmouseout="this.style.backgroundColor='transparent'">
                <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);">
                  <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
                </svg>
              </div>
            </div>

            <div id="sticker-manager-list" style="
              flex: 1;
              overflow-y: auto;
              padding: 16px;
            ">
              <!-- 表情包清單將動態生成 -->
            </div>

            <div style="
              padding: 16px;
              border-top: 1px solid var(--x-border-color);
              display: flex;
              gap: 8px;
              justify-content: flex-end;
            ">
              <button onclick="clearAllStickers()" style="
                background-color: rgba(239, 68, 68, 0.1);
                color: rgb(239, 68, 68);
                border: none;
                border-radius: 20px;
                padding: 8px 16px;
                font-size: 14px;
                font-weight: 600;
                cursor: pointer;
              ">清空全部</button>
            </div>
          </div>
        </div>

        <!-- 語音訊息輸入彈窗 -->
        <div id="voice-message-dialog" style="
          position: fixed;
          top: 0;
          left: 0;
          width: 100vw;
          height: 100vh;
          background-color: rgba(0, 0, 0, 0.5);
          display: none;
          align-items: center;
          justify-content: center;
          z-index: 31;
        " onclick="closeVoiceMessageDialog()">
          <div style="
            background-color: var(--x-bg-primary);
            border-radius: 16px;
            max-width: 500px;
            width: 90%;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
          " onclick="event.stopPropagation()">
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 16px;">
              <div style="font-size: 18px; font-weight: 700; color: var(--x-text-primary);">發送語音訊息</div>
              <div onclick="closeVoiceMessageDialog()" style="
                cursor: pointer;
                padding: 4px;
                border-radius: 50%;
                transition: background-color 0.2s;
              " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
                onmouseout="this.style.backgroundColor='transparent'">
                <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);">
                  <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
                </svg>
              </div>
            </div>
            
            <div style="font-size: 13px; color: var(--x-text-secondary); margin-bottom: 12px;">
              輸入要轉換為語音的文字內容
            </div>
            
            <div style="margin-bottom: 16px;">
              <textarea id="voice-message-text-input" placeholder="輸入文字內容..." style="
                width: 100%;
                min-height: 100px;
                padding: 12px;
                background-color: var(--x-bg-secondary);
                border: 1px solid var(--x-border-color);
                border-radius: 8px;
                color: var(--x-text-primary);
                font-size: 14px;
                outline: none;
                resize: vertical;
                font-family: inherit;
                line-height: 1.5;
              " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='var(--x-border-color)'"></textarea>
            </div>

            <div style="display: flex; gap: 8px; justify-content: flex-end;">
              <button onclick="closeVoiceMessageDialog()" style="
                background-color: var(--x-bg-secondary);
                color: var(--x-text-primary);
                border: none;
                border-radius: 20px;
                padding: 8px 16px;
                font-size: 14px;
                font-weight: 600;
                cursor: pointer;
              ">取消</button>
              <button onclick="sendVoiceMessage()" style="
                background-color: var(--x-accent);
                color: #fff;
                border: none;
                border-radius: 20px;
                padding: 8px 16px;
                font-size: 14px;
                font-weight: 600;
                cursor: pointer;
              ">發送語音</button>
            </div>
          </div>
        </div>

        <!-- 轉帳彈窗 -->
        <div id="transfer-dialog" style="
          position: fixed;
          top: 0;
          left: 0;
          width: 100vw;
          height: 100vh;
          background-color: rgba(0, 0, 0, 0.5);
          display: none;
          align-items: center;
          justify-content: center;
          z-index: 31;
          overflow-y: auto;
        " onclick="closeTransferDialog()">
          <div style="
            background-color: var(--x-bg-primary);
            border-radius: 16px;
            max-width: 400px;
            width: 90%;
            max-height: 85vh;
            margin: 20px auto;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
            display: flex;
            flex-direction: column;
          " onclick="event.stopPropagation()">
            <!-- 固定頭部 -->
            <div style="display: flex; align-items: center; justify-content: space-between; padding: 20px 20px 16px; flex-shrink: 0;">
              <div style="font-size: 18px; font-weight: 700; color: var(--x-text-primary);">發起轉帳</div>
              <div onclick="closeTransferDialog()" style="
                cursor: pointer;
                padding: 4px;
                border-radius: 50%;
                transition: background-color 0.2s;
              " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
                onmouseout="this.style.backgroundColor='transparent'">
                <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);">
                  <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
                </svg>
              </div>
            </div>
            
            <!-- 可滾動內容區域 -->
            <div style="flex: 1; overflow-y: auto; padding: 0 20px; min-height: 0;">
              <!-- 轉帳類型切換 -->
              <div style="margin-bottom: 20px; padding-bottom: 16px; border-bottom: 1px solid var(--x-border-color);">
                <div style="display: flex; gap: 8px;">
                  <button id="transfer-type-normal-btn" onclick="switchTransferType('normal')" style="
                    flex: 1;
                    padding: 8px 16px;
                    border: 1px solid var(--x-border-color);
                    background-color: var(--x-accent);
                    color: #fff;
                    border-radius: 8px;
                    font-size: 13px;
                    font-weight: 600;
                    cursor: pointer;
                    transition: all 0.2s;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    gap: 6px;
                  ">
                    <svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: currentColor;">
                      <g><path d="M21 18v1c0 1.1-.9 2-2 2H5c-1.11 0-2-.9-2-2V5c0-1.1.89-2 2-2h14c1.1 0 2 .9 2 2v1h-9c-1.11 0-2 .9-2 2v8c0 1.1.89 2 2 2h9zm-9-2h10V8H12v8zm4-2.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"/></g>
                    </svg>
                    普通轉帳
                  </button>
                  <button id="transfer-type-business-btn" onclick="switchTransferType('business')" style="
                    flex: 1;
                    padding: 8px 16px;
                    border: 1px solid var(--x-border-color);
                    background-color: transparent;
                    color: var(--x-text-primary);
                    border-radius: 8px;
                    font-size: 13px;
                    font-weight: 600;
                    cursor: pointer;
                    transition: all 0.2s;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    gap: 6px;
                  ">
                    <svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: currentColor;">
                      <g><path d="M20 6h-3V4c0-1.1-.9-2-2-2H9c-1.1 0-2 .9-2 2v2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zM9 4h6v2H9V4zm11 16H4V8h16v12z"></path><path d="M12 10L14.5 14L17 10L14.5 12L12 10ZM10 10L7.5 12L10 14L7.5 14L10 10Z"></path></g>
                    </svg>
                    商業轉帳
                  </button>
                </div>
              </div>
            
              <!-- 轉帳金額 -->
            <div style="margin-bottom: 16px;">
              <label style="display: block; font-size: 14px; font-weight: 600; color: var(--x-text-primary); margin-bottom: 8px;">
                轉帳金額
              </label>
              <div style="position: relative;">
                <input type="number" id="transfer-amount-input" placeholder="0.00" min="0.01" step="0.01" style="
                  width: 100%;
                  padding: 12px 16px 12px 36px;
                  background-color: var(--x-bg-secondary);
                  border: 1px solid var(--x-border-color);
                  border-radius: 8px;
                  color: var(--x-text-primary);
                  font-size: 16px;
                  outline: none;
                  font-family: inherit;
                " onfocus="this.style.borderColor='var(--x-accent)'" 
                   onblur="this.style.borderColor='var(--x-border-color)'">
                <div style="
                  position: absolute;
                  left: 16px;
                  top: 50%;
                  transform: translateY(-50%);
                  color: var(--x-text-secondary);
                  font-weight: 600;
                  font-size: 16px;
                ">$</div>
              </div>
            </div>

              <!-- 轉帳備註 -->
              <div style="margin-bottom: 16px;">
              <label style="display: block; font-size: 14px; font-weight: 600; color: var(--x-text-primary); margin-bottom: 8px;">
                轉帳備註（可選）
              </label>
              <textarea id="transfer-note-input" placeholder="添加轉帳說明..." maxlength="100" style="
                width: 100%;
                  min-height: 60px;
                padding: 12px;
                background-color: var(--x-bg-secondary);
                border: 1px solid var(--x-border-color);
                border-radius: 8px;
                color: var(--x-text-primary);
                font-size: 14px;
                outline: none;
                resize: vertical;
                font-family: inherit;
                line-height: 1.5;
              " onfocus="this.style.borderColor='var(--x-accent)'" 
                 onblur="this.style.borderColor='var(--x-border-color)'"
                 oninput="updateTransferNoteCounter()"></textarea>
              <div style="text-align: right; margin-top: 4px;">
                <span id="transfer-note-counter" style="font-size: 12px; color: var(--x-text-secondary);">0 / 100</span>
              </div>
            </div>

              <!-- 商業轉帳專屬區域 -->
              <div id="business-transfer-section" style="display: none;">
                <!-- 定金比例 -->
                <div style="margin-bottom: 16px;">
                  <label style="display: block; font-size: 14px; font-weight: 600; color: var(--x-text-primary); margin-bottom: 8px;">
                    定金比例
                  </label>
                  <select id="transfer-deposit-ratio" style="
                    width: 100%;
                    padding: 12px;
                    background-color: var(--x-bg-secondary);
                    border: 1px solid var(--x-border-color);
                    border-radius: 8px;
                    color: var(--x-text-primary);
                    font-size: 14px;
                    outline: none;
                    font-family: inherit;
                  " onfocus="this.style.borderColor='var(--x-accent)'" 
                     onblur="this.style.borderColor='var(--x-border-color)'">
                    <option value="0">0% - 無定金（任務完成後全額支付）</option>
                    <option value="20" selected>20% - 先付20%定金</option>
                    <option value="30">30% - 先付30%定金</option>
                    <option value="50">50% - 先付50%定金</option>
                  </select>
                  <div style="font-size: 12px; color: var(--x-text-secondary); margin-top: 4px;">
                    定金會在對方接受轉帳時立即支付，餘款在任務完成後支付
                  </div>
                </div>

                <!-- 任務描述 -->
                <div style="margin-bottom: 16px;">
                  <label style="display: block; font-size: 14px; font-weight: 600; color: var(--x-text-primary); margin-bottom: 8px;">
                    任務描述 <span style="color: #ef4444;">*</span>
                  </label>
                  <textarea id="transfer-task-description" placeholder="例如：發佈一條關於XX產品的宣傳推文，需包含產品連結..." maxlength="500" style="
                    width: 100%;
                    min-height: 100px;
                    padding: 12px;
                    background-color: var(--x-bg-secondary);
                    border: 1px solid var(--x-border-color);
                    border-radius: 8px;
                    color: var(--x-text-primary);
                    font-size: 14px;
                    outline: none;
                    resize: vertical;
                    font-family: inherit;
                    line-height: 1.5;
                  " onfocus="this.style.borderColor='var(--x-accent)'" 
                     onblur="this.style.borderColor='var(--x-border-color)'"
                     oninput="updateTaskDescriptionCounter()"></textarea>
                  <div style="text-align: right; margin-top: 4px;">
                    <span id="transfer-task-counter" style="font-size: 12px; color: var(--x-text-secondary);">0 / 500</span>
                  </div>
                </div>

                <!-- 任務期限 -->
                <div style="margin-bottom: 16px;">
                  <label style="display: block; font-size: 14px; font-weight: 600; color: var(--x-text-primary); margin-bottom: 8px;">
                    任務期限 <span style="color: #ef4444;">*</span>
                  </label>
                  <input type="number" id="transfer-task-deadline" placeholder="小時數" min="1" max="720" value="24" style="
                    width: 100%;
                    padding: 12px;
                    background-color: var(--x-bg-secondary);
                    border: 1px solid var(--x-border-color);
                    border-radius: 8px;
                    color: var(--x-text-primary);
                    font-size: 14px;
                    outline: none;
                    font-family: inherit;
                  " onfocus="this.style.borderColor='var(--x-accent)'" 
                     onblur="this.style.borderColor='var(--x-border-color)'">
                  <div style="font-size: 12px; color: var(--x-text-secondary); margin-top: 4px;">
                    從對方接受轉帳起計算，建議1-72小時（最長30天）
                  </div>
                </div>

                <!-- 商業轉帳提示 -->
                <div style="
                  background-color: var(--x-bg-secondary);
                  border: 1px solid var(--x-border-color);
                  border-radius: 8px;
                  padding: 12px;
                  margin-bottom: 16px;
                ">
                  <div style="display: flex; gap: 8px; align-items: flex-start;">
                    <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: var(--x-text-secondary); flex-shrink: 0; margin-top: 2px;">
                      <g><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"></path></g>
                    </svg>
                    <div style="font-size: 12px; color: var(--x-text-primary); line-height: 1.5;">
                      <strong>商業轉帳說明：</strong><br>
                      • 對方接受後必須完成任務才能獲得全款<br>
                      • AI會自動檢測任務完成情況<br>
                      • 對方也可能拒絕或接受但不完成任務
                    </div>
                  </div>
                </div>
              </div>
            </div>

            <!-- 固定底部按鈕 -->
            <div style="padding: 16px 20px 20px; border-top: 1px solid var(--x-border-color); flex-shrink: 0;">
            <div style="display: flex; gap: 8px; justify-content: flex-end;">
              <button onclick="closeTransferDialog()" style="
                background-color: var(--x-bg-secondary);
                color: var(--x-text-primary);
                border: none;
                border-radius: 20px;
                  padding: 10px 20px;
                font-size: 14px;
                font-weight: 600;
                cursor: pointer;
              ">取消</button>
              <button onclick="sendTransfer()" style="
                background-color: var(--x-accent);
                color: #fff;
                border: none;
                border-radius: 20px;
                  padding: 10px 20px;
                font-size: 14px;
                font-weight: 600;
                cursor: pointer;
              ">發送轉帳</button>
              </div>
            </div>
          </div>
        </div>

        <!-- 轉帳詳情彈窗 - 票根樣式 -->
        <div id="transfer-details-modal" style="
          position: fixed;
          top: 0;
          left: 0;
          width: 100vw;
          height: 100vh;
          background-color: rgba(0, 0, 0, 0.5);
          display: none;
          align-items: center;
          justify-content: center;
          z-index: 32;
        " onclick="closeTransferDetails()">
          <div style="
            background-color: var(--x-bg-primary);
            border-radius: 16px;
            max-width: 360px;
            width: 90%;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
            overflow: hidden;
          " onclick="event.stopPropagation()">
            <!-- 轉帳詳情內容 -->
            <div id="transfer-details-content">
              <!-- 動態生成轉帳詳情 -->
            </div>
          </div>
        </div>

        <!-- 圖片類型選擇器 -->
        <div id="image-type-selector-dialog" style="
          position: fixed;
          top: 0;
          left: 0;
          width: 100vw;
          height: 100vh;
          background-color: rgba(0, 0, 0, 0.5);
          display: none;
          align-items: center;
          justify-content: center;
          z-index: 31;
        " onclick="closeImageTypeSelector()">
          <div style="
            background-color: var(--x-bg-primary);
            border-radius: 16px;
            max-width: 360px;
            width: 90%;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
          " onclick="event.stopPropagation()">
            <div style="font-size: 18px; font-weight: 700; color: var(--x-text-primary); margin-bottom: 16px;">選擇圖片類型</div>
            
            <div style="display: flex; flex-direction: column; gap: 12px;">
              <!-- 真實圖片 -->
              <div onclick="selectImageType('real')" style="
                padding: 16px;
                border: 2px solid var(--x-border-color);
                border-radius: 12px;
                cursor: pointer;
                transition: all 0.2s;
                display: flex;
                align-items: center;
                gap: 12px;
              " onmouseover="this.style.borderColor='var(--x-accent)'; this.style.backgroundColor='var(--x-bg-hover)'"
                onmouseout="this.style.borderColor='var(--x-border-color)'; this.style.backgroundColor='transparent'">
                <svg viewBox="0 0 24 24" style="width: 24px; height: 24px; fill: var(--x-accent); flex-shrink: 0;">
                  <g><path d="M3 5.5C3 4.119 4.119 3 5.5 3h13C19.881 3 21 4.119 21 5.5v13c0 1.381-1.119 2.5-2.5 2.5h-13C4.119 21 3 19.881 3 18.5v-13zM5.5 5c-.276 0-.5.224-.5.5v9.086l3-3 3 3 5-5 3 3V5.5c0-.276-.224-.5-.5-.5h-13zM19 15.414l-3-3-5 5-3-3-3 3V18.5c0 .276.224.5.5.5h13c.276 0 .5-.224.5-.5v-3.086zM9.75 7C8.784 7 8 7.784 8 8.75s.784 1.75 1.75 1.75 1.75-.784 1.75-1.75S10.716 7 9.75 7z"></path></g>
                </svg>
                <div>
                  <div style="font-size: 15px; font-weight: 600; color: var(--x-text-primary); margin-bottom: 4px;">上傳真實圖片</div>
                  <div style="font-size: 13px; color: var(--x-text-secondary);">從設備中選擇圖片檔</div>
                </div>
              </div>
              
              <!-- 文字圖片 -->
              <div onclick="selectImageType('text')" style="
                padding: 16px;
                border: 2px solid var(--x-border-color);
                border-radius: 12px;
                cursor: pointer;
                transition: all 0.2s;
                display: flex;
                align-items: center;
                gap: 12px;
              " onmouseover="this.style.borderColor='var(--x-accent)'; this.style.backgroundColor='var(--x-bg-hover)'"
                onmouseout="this.style.borderColor='var(--x-border-color)'; this.style.backgroundColor='transparent'">
                <svg viewBox="0 0 24 24" style="width: 24px; height: 24px; fill: var(--x-accent); flex-shrink: 0;">
                  <g><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"></path></g>
                </svg>
                <div>
                  <div style="font-size: 15px; font-weight: 600; color: var(--x-text-primary); margin-bottom: 4px;">發送文字圖片</div>
                  <div style="font-size: 13px; color: var(--x-text-secondary);">用文字描述圖片內容</div>
                </div>
              </div>
            </div>

            <div style="margin-top: 16px; display: flex; justify-content: flex-end;">
              <button onclick="closeImageTypeSelector()" style="
                background-color: var(--x-bg-secondary);
                color: var(--x-text-primary);
                border: none;
                border-radius: 20px;
                padding: 8px 16px;
                font-size: 14px;
                font-weight: 600;
                cursor: pointer;
              ">取消</button>
            </div>
          </div>
        </div>

        <!-- 文字圖片輸入對話方塊 -->
        <div id="text-image-dialog" style="
          position: fixed;
          top: 0;
          left: 0;
          width: 100vw;
          height: 100vh;
          background-color: rgba(0, 0, 0, 0.5);
          display: none;
          align-items: center;
          justify-content: center;
          z-index: 32;
        " onclick="closeTextImageDialog()">
          <div style="
            background-color: var(--x-bg-primary);
            border-radius: 16px;
            max-width: 500px;
            width: 90%;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
          " onclick="event.stopPropagation()">
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 16px;">
              <div style="font-size: 18px; font-weight: 700; color: var(--x-text-primary);">發送文字圖片</div>
              <div onclick="closeTextImageDialog()" style="
                cursor: pointer;
                padding: 4px;
                border-radius: 50%;
                transition: background-color 0.2s;
              " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
                onmouseout="this.style.backgroundColor='transparent'">
                <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);">
                  <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
                </svg>
              </div>
            </div>
            
            <div style="font-size: 13px; color: var(--x-text-secondary); margin-bottom: 12px;">
              用文字描述你想發送的圖片內容（例如：一張美麗的日落照片）
            </div>
            
            <div style="margin-bottom: 16px;">
              <textarea id="text-image-description-input" placeholder="輸入圖片描述..." maxlength="500" style="
                width: 100%;
                min-height: 120px;
                padding: 12px;
                background-color: var(--x-bg-secondary);
                border: 1px solid var(--x-border-color);
                border-radius: 8px;
                color: var(--x-text-primary);
                font-size: 14px;
                outline: none;
                resize: vertical;
                font-family: inherit;
                line-height: 1.5;
              " onfocus="this.style.borderColor='var(--x-accent)'" 
                 onblur="this.style.borderColor='var(--x-border-color)'"
                 oninput="updateTextImageCounter()"></textarea>
              <div style="text-align: right; margin-top: 4px;">
                <span id="text-image-counter" style="font-size: 12px; color: var(--x-text-secondary);">0 / 500</span>
              </div>
            </div>

            <div style="display: flex; gap: 8px; justify-content: flex-end;">
              <button onclick="closeTextImageDialog()" style="
                background-color: var(--x-bg-secondary);
                color: var(--x-text-primary);
                border: none;
                border-radius: 20px;
                padding: 8px 16px;
                font-size: 14px;
                font-weight: 600;
                cursor: pointer;
              ">取消</button>
              <button onclick="sendTextImage()" style="
                background-color: var(--x-accent);
                color: #fff;
                border: none;
                border-radius: 20px;
                padding: 8px 16px;
                font-size: 14px;
                font-weight: 600;
                cursor: pointer;
              ">發送</button>
            </div>
          </div>
        </div>

        <!-- 添加表情包對話方塊 -->
        <div id="add-sticker-dialog" style="
          position: fixed;
          top: 0;
          left: 0;
          width: 100vw;
          height: 100vh;
          background-color: rgba(0, 0, 0, 0.5);
          display: none;
          align-items: center;
          justify-content: center;
          z-index: 31;
        " onclick="closeAddStickerDialog()">
          <div style="
            background-color: var(--x-bg-primary);
            border-radius: 16px;
            max-width: 500px;
            width: 90%;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
          " onclick="event.stopPropagation()">
            <div style="font-size: 18px; font-weight: 700; color: var(--x-text-primary); margin-bottom: 8px;">批量導入表情包</div>
            <div style="font-size: 13px; color: var(--x-text-secondary); margin-bottom: 16px;">
              每行一個表情包，格式：描述 連結<br>
              例如：開心 https://example.com/happy.gif
            </div>
            
            <div style="margin-bottom: 16px;">
              <textarea id="sticker-batch-input" placeholder="開心 https://example.com/happy.gif
難過 https://example.com/sad.gif
驚訝 https://example.com/wow.gif" style="
                width: 100%;
                min-height: 150px;
                padding: 12px;
                background-color: var(--x-bg-secondary);
                border: 1px solid var(--x-border-color);
                border-radius: 8px;
                color: var(--x-text-primary);
                font-size: 14px;
                outline: none;
                resize: vertical;
                font-family: inherit;
                line-height: 1.5;
              "></textarea>
            </div>

            <div style="display: flex; gap: 8px; justify-content: flex-end;">
              <button onclick="closeAddStickerDialog()" style="
                background-color: var(--x-bg-secondary);
                color: var(--x-text-primary);
                border: none;
                border-radius: 20px;
                padding: 8px 16px;
                font-size: 14px;
                font-weight: 600;
                cursor: pointer;
              ">取消</button>
              <button onclick="batchAddStickers()" style="
                background-color: var(--x-accent);
                color: #fff;
                border: none;
                border-radius: 20px;
                padding: 8px 16px;
                font-size: 14px;
                font-weight: 600;
                cursor: pointer;
              ">批量導入</button>
            </div>
          </div>
        </div>
      </div>

      <!-- 推文評論頁面 - 已廢棄，現在首頁推文使用統一的詳情頁 (x-tweet-detail-page) -->
      <!-- 保留HTML結構以防其他代碼引用，但不再使用 -->
      <div id="x-comments-page" class="x-page"
        style="flex: 1; display: none; flex-direction: column; overflow: hidden; min-height: 0;">
      </div>

      <!-- X設置頁面 -->
      <div id="x-settings-page" class="x-page"
        style="flex: 1; display: none; flex-direction: column; overflow: hidden; min-height: 0;">

        <!-- 設置頁面頂部欄 -->
        <div class="settings-header"
          style="display: flex; align-items: center; justify-content: space-between; padding: 10px 15px; border-bottom: 1px solid #333; background-color: #000;">
          <div style="display: flex; align-items: center;">
          <div class="settings-back-btn" onclick="switchXPage('home')" style="cursor: pointer; margin-right: 15px;">
            <svg viewBox="0 0 24 24" aria-hidden="true" style="width: 20px; height: 20px; fill: #fff;">
              <g>
                <path d="M7.414 13l5.043 5.04-1.414 1.42L3.586 12l7.457-7.46 1.414 1.42L7.414 11H21v2H7.414z"></path>
              </g>
            </svg>
          </div>
          <span style="font-size: 20px; font-weight: 700; color: #fff;">設置</span>
          </div>
          <div style="display: flex; align-items: center; gap: 8px;">
            <!-- 主題色切換按鈕 -->
            <div id="accent-color-toggle-btn" onclick="openAccentColorPicker()" 
              style="cursor: pointer; padding: 8px; border-radius: 50%; transition: background-color 0.2s; display: flex; align-items: center; justify-content: center;"
              onmouseover="this.style.backgroundColor='rgba(255,255,255,0.1)'"
              onmouseout="this.style.backgroundColor='transparent''"
              title="更改主題色">
              <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="var(--x-accent)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M12 21a9 9 0 0 1 0 -18c4.97 0 9 3.582 9 8c0 1.06 -.474 2.078 -1.318 2.828c-.844 .75 -1.989 1.172 -3.182 1.172h-2.5a2 2 0 0 0 -1 3.75a1.3 1.3 0 0 1 -1 2.25" />
                <path d="M8.5 10.5m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0" />
                <path d="M12.5 7.5m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0" />
                <path d="M16.5 10.5m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0" />
              </svg>
            </div>

            <!-- 語言切換按鈕 -->
            <div id="language-toggle-btn" onclick="toggleXLanguage()" 
              style="cursor: pointer; padding: 8px 12px; border-radius: 20px; transition: background-color 0.2s; display: flex; align-items: center; justify-content: center; gap: 4px; background-color: rgba(255,255,255,0.05);"
              onmouseover="this.style.backgroundColor='rgba(255,255,255,0.15)'"
              onmouseout="this.style.backgroundColor='rgba(255,255,255,0.05)'"
              title="切換語言">
              <span id="language-text" style="font-size: 13px; font-weight: 600; color: var(--x-text-primary);">中文</span>
            </div>
            
          <!-- 主題切換按鈕 -->
          <div id="theme-toggle-btn" onclick="toggleXTheme()" 
            style="cursor: pointer; padding: 8px; border-radius: 50%; transition: background-color 0.2s; display: flex; align-items: center; justify-content: center;"
            onmouseover="this.style.backgroundColor='rgba(255,255,255,0.1)'"
            onmouseout="this.style.backgroundColor='transparent'"
            title="切換主題">
            <!-- 月亮圖示（夜間模式） -->
            <svg id="theme-icon-dark" viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: #fff; display: block;">
              <g><path d="M20.742 13.045a8.088 8.088 0 0 1-2.077.271c-2.135 0-4.14-.83-5.646-2.336a8.025 8.025 0 0 1-2.064-7.723A1 1 0 0 0 9.73 2.034a10.014 10.014 0 0 0-4.489 2.582c-3.898 3.898-3.898 10.243 0 14.143a9.937 9.937 0 0 0 7.072 2.93 9.93 9.93 0 0 0 7.07-2.929 10.007 10.007 0 0 0 2.583-4.491 1.001 1.001 0 0 0-1.224-1.224zm-2.772 4.301a7.947 7.947 0 0 1-5.656 2.343 7.953 7.953 0 0 1-5.658-2.344c-3.118-3.119-3.118-8.195 0-11.314a7.923 7.923 0 0 1 2.06-1.483 10.027 10.027 0 0 0 2.89 7.848 9.972 9.972 0 0 0 7.848 2.891 8.036 8.036 0 0 1-1.484 2.059z"></path></g>
            </svg>
            <!-- 太陽圖示（日間模式） -->
            <svg id="theme-icon-light" viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: #000; display: none;">
              <g><path d="M12 2.5a1 1 0 0 1 1 1V5a1 1 0 1 1-2 0V3.5a1 1 0 0 1 1-1zm0 15a4.5 4.5 0 1 0 0-9 4.5 4.5 0 0 0 0 9zm0 2a6.5 6.5 0 1 1 0-13 6.5 6.5 0 0 1 0 13zM12 18a1 1 0 0 1 1 1v1.5a1 1 0 1 1-2 0V19a1 1 0 0 1 1-1zm9.5-6a1 1 0 0 1-1 1H19a1 1 0 1 1 0-2h1.5a1 1 0 0 1 1 1zM5 12a1 1 0 0 1-1 1H2.5a1 1 0 1 1 0-2H4a1 1 0 0 1 1 1zm12.864-6.864a1 1 0 0 1 0 1.414l-1.06 1.06a1 1 0 1 1-1.415-1.414l1.061-1.06a1 1 0 0 1 1.414 0zm-11.728 0a1 1 0 0 1 1.414 0l1.061 1.06A1 1 0 1 1 7.197 7.61l-1.06-1.06a1 1 0 0 1 0-1.415zM18.925 17.804a1 1 0 0 1 0 1.414l-1.061 1.061a1 1 0 1 1-1.414-1.414l1.06-1.061a1 1 0 0 1 1.415 0zm-13.85 0a1 1 0 0 1 1.414 0l1.061 1.061a1 1 0 0 1-1.414 1.414l-1.061-1.06a1 1 0 0 1 0-1.415z"></path></g>
            </svg>
            </div>
          </div>
        </div>

        <!-- 設置內容區域 -->
        <div class="settings-content"
          style="flex: 1; padding: 15px; width: 100%; box-sizing: border-box; overflow-y: auto; min-height: 0;">

          <!-- 提示詞設置 -->
          <div class="settings-section" style="margin-bottom: 30px;">
            <label style="display: block; color: #fff; font-size: 17px; font-weight: 600; margin-bottom: 10px;" data-i18n="settingsPrompt">
              提示詞
            </label>
            <textarea id="x-system-prompt" placeholder="輸入系統提示詞..." data-i18n="settingsPromptPlaceholder"
              style="width: 100%; min-height: 120px; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px; font-size: 15px; resize: vertical; outline: none; font-family: inherit; line-height: 1.4;"
              onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'"></textarea>
          </div>

          <!-- 世界觀設定 -->
          <div class="settings-section" style="margin-bottom: 30px;">
            <label style="display: block; color: #fff; font-size: 17px; font-weight: 600; margin-bottom: 10px;" data-i18n="settingsWorldView">
              世界觀設定
            </label>
            <textarea id="x-world-setting" placeholder="描述角色所在的世界觀、背景設定..." data-i18n="settingsWorldViewPlaceholder"
              style="width: 100%; min-height: 100px; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px; font-size: 15px; resize: vertical; outline: none; font-family: inherit; line-height: 1.4;"
              onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'"></textarea>
          </div>

          <!-- 世界書管理 -->
          <div class="settings-section" style="margin-bottom: 30px;">
            <label style="color: #fff; font-size: 17px; font-weight: 600; display: block; margin-bottom: 10px;" data-i18n="settingsWorldBooks">
              世界書管理
            </label>
            <p style="color: #71767b; font-size: 14px; margin: 0 0 15px 0; line-height: 1.4;" data-i18n="settingsWorldBooksDesc">
              世界書可以為AI提供額外的知識庫，支援綁定到不同場景和角色
            </p>
            <button onclick="openWorldBooksManageModal()" style="
              width: 100%;
              background-color: var(--x-bg-secondary);
              border: 1px solid var(--x-border-color);
              border-radius: 12px;
              padding: 16px;
              color: var(--x-text-primary);
              font-size: 15px;
              font-weight: 600;
              cursor: pointer;
              transition: all 0.2s;
              display: flex;
              align-items: center;
              justify-content: center;
              gap: 8px;
            " onmouseover="this.style.borderColor='var(--x-accent)'" onmouseout="this.style.borderColor='var(--x-border-color)'">
              <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-accent);">
                <g><path d="M3 5.5C3 4.119 4.119 3 5.5 3h13C19.881 3 21 4.119 21 5.5v13c0 1.381-1.119 2.5-2.5 2.5h-13C4.119 21 3 19.881 3 18.5v-13zM5.5 5c-.276 0-.5.224-.5.5v13c0 .276.224.5.5.5h13c.276 0 .5-.224.5-.5v-13c0-.276-.224-.5-.5-.5h-13zM16 10H13V7h-2v3H8v2h3v3h2v-3h3v-2z"></path></g>
              </svg>
              <span data-i18n="settingsWorldBooksButton">打開世界書管理面板</span>
            </button>
          </div>

          <!-- 智慧發推檢測 -->
          <div class="settings-section" style="margin-bottom: 30px;">
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
              <label style="color: #fff; font-size: 17px; font-weight: 600;" data-i18n="settingsAutoTweetDetection">
                智慧發推檢測
              </label>
              <div class="x-toggle" onclick="toggleChatHistoryDetection()" style="cursor: pointer;">
                <div id="chat-history-detection-toggle" class="toggle-switch"
                  style="width: 50px; height: 30px; background-color: #333; border-radius: 15px; position: relative; transition: all 0.3s ease;">
                  <div class="toggle-circle"
                    style="width: 26px; height: 26px; background-color: #fff; border-radius: 50%; position: absolute; top: 2px; left: 2px; transition: all 0.3s ease;">
                  </div>
                </div>
              </div>
            </div>
            <p style="color: #71767b; font-size: 14px; margin: 0 0 15px 0; line-height: 1.4;">
              <span data-i18n="settingsAutoTweetDetectionDesc">開啟後，每隔5分鐘自動檢測已綁定角色的聊天記憶，生成New Tweet通知</span><br>
              <span style="color: var(--x-accent); font-size: 13px;" data-i18n="settingsAutoTweetDetectionNote">僅對設置了"角色身份識別"和"專屬用戶人設"的角色生效</span>
            </p>
            <div id="chat-history-detection-status" style="
              padding: 12px;
              border-radius: 8px;
              background-color: #1a1a1a;
              border: 1px solid #333;
              color: #71767b;
              font-size: 14px;
              display: none;
            ">
              <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                <div id="detection-status-indicator" style="
                  width: 8px;
                  height: 8px;
                  border-radius: 50%;
                  background-color: #10b981;
                  animation: pulse 2s infinite;
                "></div>
                <span style="color: var(--x-accent); font-weight: 600;" data-i18n="settingsDetectionRunning">檢測服務運行中</span>
              </div>
              <div style="font-size: 13px;">
                <span data-i18n="settingsNextDetectionTime">下次檢測時間</span>: <span id="next-detection-time">--</span>
              </div>
            </div>
          </div>

          <!-- 智能刷新主頁 -->
          <div class="settings-section" style="margin-bottom: 30px;">
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
              <label style="color: #fff; font-size: 17px; font-weight: 600;" data-i18n="settingsAutoRefreshFeed">
                智能刷新主頁
              </label>
              <div class="x-toggle" onclick="toggleAutoRefreshFeed()" style="cursor: pointer;">
                <div id="auto-refresh-feed-toggle" class="toggle-switch"
                  style="width: 50px; height: 30px; background-color: #333; border-radius: 15px; position: relative; transition: all 0.3s ease;">
                  <div class="toggle-circle"
                    style="width: 26px; height: 26px; background-color: #fff; border-radius: 50%; position: absolute; top: 2px; left: 2px; transition: all 0.3s ease;">
                  </div>
                </div>
              </div>
            </div>
            <p style="color: #71767b; font-size: 14px; margin: 0 0 15px 0; line-height: 1.4;">
              <span data-i18n="settingsAutoRefreshFeedDesc">開啟後，每隔10分鐘自動刷新主頁推文</span>
            </p>
            <div id="auto-refresh-feed-status" style="
              padding: 12px;
              border-radius: 8px;
              background-color: #1a1a1a;
              border: 1px solid #333;
              color: #71767b;
              font-size: 14px;
              display: none;
            ">
              <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                <div id="refresh-status-indicator" style="
                  width: 8px;
                  height: 8px;
                  border-radius: 50%;
                  background-color: #10b981;
                  animation: pulse 2s infinite;
                "></div>
                <span style="color: var(--x-accent); font-weight: 600;" data-i18n="settingsRefreshRunning">刷新服務運行中</span>
              </div>
              <div style="font-size: 13px;">
                <span data-i18n="settingsNextRefreshTime">下次刷新時間</span>: <span id="next-refresh-time">--</span>
              </div>
            </div>
          </div>

          <!-- 角色綁定設置 -->
          <div class="settings-section" style="margin-bottom: 40px;">
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
              <label style="color: #fff; font-size: 17px; font-weight: 600;" data-i18n="settingsCharacterBinding">
                綁定角色
              </label>
              <div class="x-toggle" onclick="toggleCharacterBinding()" style="cursor: pointer;">
                <div id="x-character-toggle" class="toggle-switch"
                  style="width: 50px; height: 30px; background-color: #333; border-radius: 15px; position: relative; transition: all 0.3s ease;">
                  <div class="toggle-circle"
                    style="width: 26px; height: 26px; background-color: #fff; border-radius: 50%; position: absolute; top: 2px; left: 2px; transition: all 0.3s ease;">
                  </div>
                </div>
              </div>
            </div>
            <p style="color: #71767b; font-size: 14px; margin: 0 0 15px 0; line-height: 1.4;" data-i18n="settingsCharacterBindingDesc">
              開啟後，綁定的角色可以在X上發佈推文
            </p>

            <!-- 角色選擇區域 -->
            <div id="character-binding-area" style="display: none;">
              <div style="background-color: #1a1a1a; border: 1px solid #333; border-radius: 12px; padding: 16px;">
                <div style="color: #fff; font-size: 15px; font-weight: 600; margin-bottom: 12px;" data-i18n="settingsSelectCharacter">選擇要綁定的角色</div>
                <div id="characters-list" style="max-height: 300px; overflow-y: auto;">
                  <!-- 角色清單將通過JavaScript動態生成 -->
                </div>
              </div>
            </div>
          </div>

          <!-- 角色關係冊設置 -->
          <div class="settings-section" style="margin-bottom: 40px;">
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
              <label style="color: #fff; font-size: 17px; font-weight: 600;" data-i18n="settingsRelationship">
                角色關係冊
              </label>
              <div class="x-toggle" onclick="toggleCharacterRelationship()" style="cursor: pointer;">
                <div id="x-relationship-toggle" class="toggle-switch"
                  style="width: 50px; height: 30px; background-color: #333; border-radius: 15px; position: relative; transition: all 0.3s ease;">
                  <div class="toggle-circle"
                    style="width: 26px; height: 26px; background-color: #fff; border-radius: 50%; position: absolute; top: 2px; left: 2px; transition: all 0.3s ease;">
                  </div>
                </div>
              </div>
            </div>
            <p style="color: #71767b; font-size: 14px; margin: 0 0 15px 0; line-height: 1.4;" data-i18n="settingsRelationshipDesc">
              開啟後，可以為已綁定的角色建立關係網絡，設置角色之間的雙向關係
            </p>

            <!-- 角色關係冊管理區域 -->
            <div id="relationship-binding-area" style="display: none;">
              <div style="background-color: #1a1a1a; border: 1px solid #333; border-radius: 12px; padding: 16px;">
                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                  <div style="color: #fff; font-size: 15px; font-weight: 600;" data-i18n="settingsRelationshipGraph">角色關係圖</div>
                  <button onclick="openCharacterRelationshipGraph()" style="
                    background-color: var(--x-accent);
                    color: #fff;
                    border: none;
                    border-radius: 20px;
                    padding: 6px 16px;
                    font-size: 14px;
                    font-weight: 600;
                    cursor: pointer;
                    transition: all 0.2s;
                  " onmouseover="this.style.backgroundColor='#1a8cd8'" onmouseout="this.style.backgroundColor='var(--x-accent)'" data-i18n="settingsEditGraph">
                    編輯關係圖
                  </button>
                </div>
                
                <!-- 關係圖預覽 -->
                <div id="relationship-preview" style="
                  background-color: #0a0a0a;
                  border: 1px solid #2f3336;
                  border-radius: 8px;
                  padding: 20px;
                  min-height: 150px;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  position: relative;
                ">
                  <canvas id="relationship-preview-canvas" width="400" height="150" style="width: 100%; height: 100%;"></canvas>
                  <div id="relationship-preview-placeholder" style="
                    color: #71767b;
                    font-size: 14px;
                    text-align: center;
                  ">
                    <span data-i18n="relationshipNoData">暫無關係數據</span><br>
                    <span style="font-size: 12px;" data-i18n="relationshipNoDataHint">點擊上方按鈕開始創建角色關係</span>
                  </div>
                </div>

                <!-- 關係統計 -->
                <div id="relationship-stats" style="
                  margin-top: 12px;
                  padding: 12px;
                  background-color: color-mix(in srgb, var(--x-accent) , 0.1);
                  border-radius: 8px;
                  display: none;
                ">
                  <div style="color: var(--x-accent); font-size: 13px; display: flex; justify-content: space-around;">
                    <div style="text-align: center;">
                      <div style="font-weight: 700; font-size: 18px;" id="relationship-character-count">0</div>
                      <div style="opacity: 0.8;" data-i18n="relationshipCharacterCount">角色數</div>
                    </div>
                    <div style="text-align: center;">
                      <div style="font-weight: 700; font-size: 18px;" id="relationship-link-count">0</div>
                      <div style="opacity: 0.8;" data-i18n="relationshipLinkCount">關係數</div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- NPC綁定設置 -->
          <div class="settings-section" style="margin-bottom: 40px;">
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
              <label style="color: #fff; font-size: 17px; font-weight: 600;" data-i18n="settingsNPCBinding">
                綁定NPC
              </label>
              <div class="x-toggle" onclick="toggleNPCBinding()" style="cursor: pointer;">
                <div id="x-npc-toggle" class="toggle-switch"
                  style="width: 50px; height: 30px; background-color: #333; border-radius: 15px; position: relative; transition: all 0.3s ease;">
                  <div class="toggle-circle"
                    style="width: 26px; height: 26px; background-color: #fff; border-radius: 50%; position: absolute; top: 2px; left: 2px; transition: all 0.3s ease;">
                  </div>
                </div>
              </div>
            </div>
            <p style="color: #71767b; font-size: 14px; margin: 0 0 15px 0; line-height: 1.4;" data-i18n="settingsNPCBindingDesc">
              開啟後，可以創建和管理自訂NPC，設置其人設、發帖習慣和綁定用戶
            </p>

            <!-- NPC管理區域 -->
            <div id="npc-binding-area" style="display: none;">
              <div style="background-color: #1a1a1a; border: 1px solid #333; border-radius: 12px; padding: 16px;">
                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                  <div style="color: #fff; font-size: 15px; font-weight: 600;" data-i18n="settingsNPCList">NPC列表</div>
                  <button onclick="openCreateNPCModal()" style="
                    background-color: var(--x-accent);
                    color: #fff;
                    border: none;
                    border-radius: 20px;
                    padding: 6px 16px;
                    font-size: 14px;
                    font-weight: 600;
                    cursor: pointer;
                    transition: all 0.2s;
                  " onmouseover="this.style.backgroundColor='#1a8cd8'" onmouseout="this.style.backgroundColor='var(--x-accent)'" data-i18n="settingsCreateNPC">
                    + 創建NPC
                  </button>
                </div>
                <div id="npcs-list" style="max-height: 300px; overflow-y: auto;">
                  <!-- NPC清單將通過JavaScript動態生成 -->
                </div>
              </div>
            </div>
          </div>

          <!-- 按鈕區域 -->
          <div class="settings-buttons" style="display: flex; flex-direction: column; gap: 12px;">
            <!-- 保存按鈕 -->
            <button onclick="saveXSettings()"
              style="width: 100%; background-color: var(--x-accent); color: #fff; border: none; border-radius: 25px; padding: 12px 24px; font-size: 16px; font-weight: 700; cursor: pointer; transition: all 0.2s;"
              onmouseover="this.style.backgroundColor='#1a8cd8'" onmouseout="this.style.backgroundColor='var(--x-accent)'" data-i18n="settingsSave">
              保存設置
            </button>

            <!-- 保存預設按鈕 -->
            <button onclick="saveXPreset()"
              style="width: 100%; background-color: var(--x-accent); color: #fff; border: none; border-radius: 25px; padding: 12px 24px; font-size: 16px; font-weight: 700; cursor: pointer; transition: all 0.2s;"
              onmouseover="this.style.backgroundColor='#1a8cd8'" onmouseout="this.style.backgroundColor='var(--x-accent)'" data-i18n="settingsSavePreset">
              保存為預設
            </button>

            <!-- 導入匯出按鈕組 -->
            <div style="display: flex; gap: 12px;">
              <button onclick="importXData()"
                style="flex: 1; background-color: var(--x-accent); color: #fff; border: none; border-radius: 25px; padding: 12px 20px; font-size: 15px; font-weight: 600; cursor: pointer; transition: all 0.2s;"
                onmouseover="this.style.backgroundColor='#1a8cd8'" onmouseout="this.style.backgroundColor='var(--x-accent)'" data-i18n="settingsImport">
                導入數據
              </button>
              <button onclick="exportXData()"
                style="flex: 1; background-color: var(--x-accent); color: #fff; border: none; border-radius: 25px; padding: 12px 20px; font-size: 15px; font-weight: 600; cursor: pointer; transition: all 0.2s;"
                onmouseover="this.style.backgroundColor='#1a8cd8'" onmouseout="this.style.backgroundColor='var(--x-accent)'" data-i18n="settingsExport">
                匯出數據
              </button>
            </div>
          </div>

          <!-- 預設管理區域 -->
          <div class="preset-management" style="margin-top: 40px; padding-top: 30px; border-top: 1px solid #333;">
            <h3 style="color: #fff; font-size: 18px; font-weight: 700; margin-bottom: 15px;" data-i18n="settingsPresetManagement">預設管理</h3>
            <div id="x-presets-list" style="display: flex; flex-direction: column;">
              <!-- 預設清單將通過JavaScript動態生成 -->
            </div>
          </div>
        </div>
      </div>

      <!-- 推文詳情頁面 -->
      <div id="x-tweet-detail-page" class="x-page"
        style="flex: 1; display: none; flex-direction: column; overflow: hidden;">

        <!-- 詳情頁面頂部欄 -->
        <div class="tweet-detail-header"
          style="display: flex; align-items: center; justify-content: space-between; padding: 10px 15px; border-bottom: 1px solid #333; background-color: rgba(0,0,0,0.8); backdrop-filter: blur(12px); position: sticky; top: 0; z-index: 5;">
          <div style="display: flex; align-items: center;">
            <div class="tweet-detail-back-btn" onclick="goBackFromTweetDetail()"
              style="cursor: pointer; margin-right: 15px;">
              <svg viewBox="0 0 24 24" aria-hidden="true" style="width: 20px; height: 20px; fill: #fff;">
                <g>
                  <path d="M7.414 13l5.043 5.04-1.414 1.42L3.586 12l7.457-7.46 1.414 1.42L7.414 11H21v2H7.414z"></path>
                </g>
              </svg>
            </div>
            <span style="font-size: 20px; font-weight: 700; color: #fff;" data-i18n="tweetDetailTitle">帖子</span>
          </div>

          <!-- 重回/推進按鈕 -->
          <div id="reroll-replies-btn" 
               onclick="rerollAIReplies()" 
               onmousedown="handleTweetRerollButtonMouseDown()"
               onmouseup="handleTweetRerollButtonMouseUp()"
               onmouseleave="handleTweetRerollButtonMouseUp()"
               ontouchstart="handleTweetRerollButtonMouseDown()"
               ontouchend="handleTweetRerollButtonMouseUp()"
               ontouchcancel="handleTweetRerollButtonMouseUp()"
               style="
             display: flex;
             align-items: center;
             justify-content: center;
             width: 32px;
             height: 32px;
             background-color: transparent;
             border: none;
             border-radius: 50%;
             cursor: pointer;
             transition: all 0.2s;
                 user-select: none;
                 -webkit-user-select: none;
               " 
               onmouseover="this.style.backgroundColor='rgba(255,255,255,0.1)'"
               onmouseout="this.style.backgroundColor='transparent'"
               title="重新生成回復">
            <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);">
              <g>
                <path
                  d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z" />
              </g>
            </svg>
          </div>
        </div>

        <!-- 推文詳情內容 -->
        <div class="tweet-detail-content" style="flex: 1; overflow-y: auto;">
          <div id="tweet-detail-container" style="padding: 0;">
            <!-- 推文詳情將通過JavaScript動態生成在這裡 -->
          </div>

          <!-- 評論區域 -->
          <div style="border-top: 1px solid var(--x-border-color);">
            <!-- 評論列表容器 -->
            <div id="detail-comments-container" style="padding: 0; padding-bottom: 70px;">
              <!-- 評論將通過JavaScript動態生成在這裡 -->
            </div>
          </div>
            
            <!-- 評論輸入區域 - 移到底部 -->
            <div class="detail-comment-input-area"
              style="border-top: 1px solid var(--x-border-color); padding: 10px 15px; background-color: var(--x-bg-primary); position: fixed; bottom: 0; left: 0; right: 0; z-index: 10;">
              <div style="display: flex; align-items: flex-start; gap: 12px; max-width: 100%;">
                <!-- 用戶頭像 -->
                <img id="detail-comment-user-avatar" src="https://i.postimg.cc/pXxk1JXk/IMG-6442.jpg" alt="Your avatar"
                  style="width: 32px; height: 32px; border-radius: 50%; flex-shrink: 0;">

                <!-- 輸入框容器 -->
                <div style="flex: 1;">
                  <textarea id="detail-comment-input" placeholder="發佈你的回復" data-i18n="tweetDetailReplyPlaceholder"
                    style="width: 100%; min-height: 18px; max-height: 100px; background: transparent; border: none; color: #fff; font-size: 15px; resize: none; outline: none; font-family: inherit; line-height: 1.3;"
                    onkeydown="handleDetailCommentInput(event)" oninput="autoResizeDetail(this)"></textarea>

                  <!-- 輸入框底部工具列 -->
                  <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 8px;">
                    <!-- 左側工具圖示 -->
                    <div style="display: flex; gap: 12px;">
                      <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-accent); cursor: pointer;" onclick="triggerDetailCommentImageUpload()">
                        <g>
                          <path
                            d="M3 5.5C3 4.119 4.119 3 5.5 3h13C19.881 3 21 4.119 21 5.5v13c0 1.381-1.119 2.5-2.5 2.5h-13C4.119 21 3 19.881 3 18.5v-13zM5.5 5c-.276 0-.5.224-.5.5v9.086l3-3 3 3 5-5 3 3V5.5c0-.276-.224-.5-.5-.5h-13zM19 15.414l-3-3-5 5-3-3-3 3V18.5c0 .276.224.5.5.5h13c.276 0 .5-.224.5-.5v-3.086zM9.75 7C8.784 7 8 7.784 8 8.75s.784 1.75 1.75 1.75 1.75-.784 1.75-1.75S10.716 7 9.75 7z">
                          </path>
                        </g>
                      </svg>
                      <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-accent); cursor: pointer; opacity: 0.5;">
                        <g>
                          <path
                            d="M3 5.5C3 4.119 4.12 3 5.5 3h13C19.88 3 21 4.119 21 5.5v13c0 1.381-1.12 2.5-2.5 2.5h-13C4.12 21 3 19.881 3 18.5v-13zM5.5 5c-.28 0-.5.224-.5.5v13c0 .276.22.5.5.5h13c.28 0 .5-.224.5-.5v-13c0-.276-.22-.5-.5-.5h-13zM18 10.711V9.25h-3.74v5.5h1.44v-1.719h1.7V11.57h-1.7v-.859H18zM11.79 9.25h1.44v5.5h-1.44v-5.5zm-3.07 1.375c.34 0 .77.172 1.02.43l1.03-.86c-.51-.601-1.28-.945-2.05-.945C7.19 9.25 6 10.453 6 12s1.19 2.75 2.72 2.75c.77 0 1.54-.344 2.05-.945l-1.03-.86c-.25.258-.68.43-1.02.43-.76 0-1.29-.546-1.29-1.375S8.03 10.625 8.79 10.625z">
                          </path>
                        </g>
                      </svg>
                      <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-accent); cursor: pointer; opacity: 0.5;">
                        <g>
                          <path
                            d="M8 9.5C8 8.119 8.672 7 9.5 7S11 8.119 11 9.5 10.328 12 9.5 12 8 10.881 8 9.5zm6.5 2.5c.828 0 1.5-1.119 1.5-2.5S15.328 7 14.5 7 13 8.119 13 9.5s.672 2.5 1.5 2.5zM12 16c-2.224 0-3.021-2.227-3.051-2.316l-1.897.633c.05.15 1.271 3.684 4.949 3.684s4.898-3.533 4.949-3.684l-1.896-.638c-.033.095-.83 2.322-3.053 2.322zm10.25-4.001c0 5.652-4.598 10.25-10.25 10.25S1.75 17.652 1.75 12 6.348 1.75 12 1.75 22.25 6.348 22.25 12zm-2 0c0-4.549-3.701-8.25-8.25-8.25S3.75 7.451 3.75 12s3.701 8.25 8.25 8.25 8.25-3.701 8.25-8.25z">
                          </path>
                        </g>
                      </svg>
                    </div>

                    <!-- 右側發送按鈕 -->
                    <button id="detail-reply-btn" onclick="submitDetailComment()"
                      style="background-color: var(--x-accent); color: #fff; border: none; border-radius: 18px; padding: 6px 16px; font-size: 14px; font-weight: 700; cursor: pointer; opacity: 0.5;"
                      disabled data-i18n="tweetDetailReply">
                      回復
                    </button>
                  </div>
                  
                  <!-- 圖片預覽區域 -->
                  <div id="detail-comment-image-preview" style="display: none; margin-top: 10px; position: relative;">
                    <img id="detail-comment-image-preview-img" src="" style="max-width: 180px; max-height: 180px; border-radius: 12px; display: block;">
                    <button onclick="removeDetailCommentImage()" 
                      style="position: absolute; top: 4px; right: 4px; background: rgba(0,0,0,0.75); border: none; border-radius: 50%; width: 26px; height: 26px; color: #fff; cursor: pointer; display: flex; align-items: center; justify-content: center;">
                      <svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: #fff;">
                        <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
                      </svg>
                    </button>
                  </div>
                  
                  <!-- 隱藏的檔輸入 -->
                  <input type="file" id="detail-comment-image-input" accept="image/*" style="display: none;" onchange="handleDetailCommentImageUpload(event)">
                </div>
            </div>
          </div>
        </div>
      </div>

      <!-- 用戶主頁 -->
      <div id="x-profile-page" class="x-page" style="flex: 1; display: none; flex-direction: column; overflow-y: auto; padding: 0; margin: 0;">

        <!-- 主頁頂部欄 -->
        <div class="profile-header"
          style="display: flex; align-items: center; padding: 10px 15px; background-color: rgba(0,0,0,0.8); backdrop-filter: blur(12px); position: relative; z-index: 5; margin: 0;">
          <div class="profile-back-btn" onclick="switchXPage('home')" style="cursor: pointer; margin-right: 15px;">
            <svg viewBox="0 0 24 24" aria-hidden="true" style="width: 20px; height: 20px; fill: #fff;">
              <g>
                <path d="M7.414 13l5.043 5.04-1.414 1.42L3.586 12l7.457-7.46 1.414 1.42L7.414 11H21v2H7.414z"></path>
              </g>
            </svg>
          </div>
          <div style="flex: 1;">
            <div id="x-profile-header-name" style="font-size: 20px; font-weight: 700; color: #fff;">我</div>
            <div id="x-profile-header-count" style="font-size: 13px; color: #71767b;">0 帖子</div>
          </div>
          <div style="display: flex; gap: 15px;">
            <!-- 提問箱按鈕 -->
            <div onclick="switchXPage('askbox')" style="cursor: pointer; padding: 8px; border-radius: 50%; transition: background-color 0.2s;"
              onmouseover="this.style.backgroundColor='rgba(255,255,255,0.1)'"
              onmouseout="this.style.backgroundColor='transparent'"
              title="提問箱">
              <svg viewBox="0 0 24 24" aria-hidden="true" style="width: 20px; height: 20px; fill: #fff;">
                <g>
                  <path d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z"/>
                </g>
              </svg>
            </div>
            <!-- 更多選項按鈕 -->
            <div id="profile-menu-btn" onclick="toggleProfileMenu()"
              style="cursor: pointer; padding: 8px; border-radius: 50%; transition: background-color 0.2s; position: relative;"
              onmouseover="this.style.backgroundColor='rgba(255,255,255,0.1)'"
              onmouseout="this.style.backgroundColor='transparent'">
              <svg viewBox="0 0 24 24" aria-hidden="true" style="width: 20px; height: 20px; fill: #fff;">
                <g>
                  <path
                    d="M3 12c0-1.1.9-2 2-2s2 .9 2 2-.9 2-2 2-2-.9-2-2zm9 2c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm7 0c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2z">
                  </path>
                </g>
              </svg>
              <!-- 下拉式功能表 -->
              <div id="profile-dropdown-menu" style="
                display: none;
                position: absolute;
                top: 100%;
                right: 0;
                background-color: #1a1a1a;
                border: 1px solid #333;
                border-radius: 12px;
                box-shadow: 0 8px 32px rgba(0,0,0,0.3);
                min-width: 200px;
                z-index: 50;
                margin-top: 8px;
                overflow: hidden;
              ">
                <div onclick="openAccountManager()" style="
                  padding: 12px 16px;
                  color: #fff;
                  font-size: 15px;
                  cursor: pointer;
                  transition: background-color 0.2s;
                  display: flex;
                  align-items: center;
                  gap: 12px;
                " onmouseover="this.style.backgroundColor='rgba(255,255,255,0.03)'"
                  onmouseout="this.style.backgroundColor='transparent'">
                  <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;">
                    <g>
                      <path
                        d="M12 2C13.1 2 14 2.9 14 4C14 5.1 13.1 6 12 6C10.9 6 10 5.1 10 4C10 2.9 10.9 2 12 2ZM21 9V7L19 6.5C18.5 4.4 16.6 2.5 14.5 2L14 0H10L9.5 2C7.4 2.5 5.5 4.4 5 6.5L3 7V9L5 9.5C5.5 11.6 7.4 13.5 9.5 14L10 16H14L14.5 14C16.6 13.5 18.5 11.6 19 9.5L21 9ZM12 8C13.66 8 15 9.34 15 11C15 12.66 13.66 14 12 14C10.34 14 9 12.66 9 11C9 9.34 10.34 8 12 8ZM19 17H5V19H19V17ZM12 20C10.9 20 10 20.9 10 22H14C14 20.9 13.1 20 12 20Z">
                      </path>
                    </g>
                  </svg>
                  <span data-i18n="profileAccountManager">帳號管理</span>
                </div>
                <div onclick="openAccountWallet()" style="
                  padding: 12px 16px;
                  color: #fff;
                  font-size: 15px;
                  cursor: pointer;
                  transition: background-color 0.2s;
                  display: flex;
                  align-items: center;
                  gap: 12px;
                " onmouseover="this.style.backgroundColor='rgba(255,255,255,0.03)'"
                  onmouseout="this.style.backgroundColor='transparent'">
                  <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;">
                    <g>
                      <path d="M21 18v1c0 1.1-.9 2-2 2H5c-1.11 0-2-.9-2-2V5c0-1.1.89-2 2-2h14c1.1 0 2 .9 2 2v1h-9c-1.11 0-2 .9-2 2v8c0 1.1.89 2 2 2h9zm-9-2h10V8H12v8zm4-2.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"/>
                    </g>
                  </svg>
                  <span data-i18n="profileAccountWallet">帳戶錢包</span>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- 封面圖區域 -->
        <div class="cover-section" style="position: relative; height: 140px; background-color: #333; margin: 0; padding: 0; margin-top: -1px;">
          <img id="x-profile-cover-image" src="https://i.postimg.cc/qRzMB6nQ/default-cover.jpg"
            style="width: 100%; height: 100%; object-fit: cover; display: block; margin: 0; padding: 0; vertical-align: top;" alt="封面圖">
        </div>

        <!-- 使用者資訊區域 -->
        <div class="user-info-section" style="padding: 8px 16px 0; position: relative;">
          <!-- 用戶頭像 -->
          <div style="position: relative; margin-bottom: 8px;">
            <img id="x-profile-main-avatar" src="https://i.postimg.cc/pXxk1JXk/IMG-6442.jpg"
              style="width: 88px; height: 88px; border-radius: 50%; border: 5px solid #000; position: absolute; top: -44px; left: 0; object-fit: cover; overflow: hidden; box-sizing: border-box;"
              alt="用戶頭像">
          </div>

          <!-- 編輯資料按鈕 -->
          <div style="display: flex; justify-content: flex-end; margin: 8px 0;">
            <button onclick="editProfile()"
              style="background-color: transparent; color: #fff; border: 1px solid #536471; border-radius: 20px; padding: 6px 16px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s;"
              onmouseover="this.style.backgroundColor='rgba(255,255,255,0.1)'"
              onmouseout="this.style.backgroundColor='transparent'" data-i18n="profileEditProfile">
              編輯個人資料
            </button>
          </div>

          <!-- 用戶名和認證 -->
          <div style="margin-top: 8px; margin-bottom: 0px; padding-left: 8px;">
            <div style="display: flex; align-items: center; gap: 2px; margin-bottom: 4px;">
              <span id="x-profile-user-name" style="font-size: 20px; font-weight: 700; color: #fff;">我</span>
              <svg id="x-profile-verified-badge" viewBox="0 0 24 24"
                style="width: 20px; height: 20px; fill: var(--x-accent); display: none;">
                <g>
                  <path
                    d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.27 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.46 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z">
                  </path>
                </g>
              </svg>
            </div>
            <div id="x-profile-user-handle" style="font-size: 15px; color: #71767b; margin-bottom: 8px;">@me</div>
          </div>

          <!-- 個人簡介 -->
          <div id="x-profile-bio" style="font-size: 15px; color: #fff; line-height: 1.3; margin-bottom: 8px; padding-left: 8px;">
            歡迎來到我的X主頁！
          </div>

          <!-- 自訂標籤 -->
          <div class="profile-tags"
            style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px; flex-wrap: wrap; padding-left: 8px;">
            <div style="display: flex; align-items: center; gap: 4px;">
              <span id="x-profile-tag1-icon" style="font-size: 14px;">✨</span>
              <span id="x-profile-tag1" style="color: #71767b; font-size: 14px;">科技愛好者</span>
            </div>
            <div style="display: flex; align-items: center; gap: 4px;">
              <span id="x-profile-tag2-icon" style="font-size: 14px;">📅</span>
              <span id="x-profile-tag2" style="color: #71767b; font-size: 14px;">2024年加入</span>
            </div>
          </div>

          <!-- 關注資料 -->
          <div style="display: flex; gap: 16px; margin-bottom: 8px; padding-left: 8px;">
            <div style="cursor: pointer;" onmouseover="this.querySelector('span').style.textDecoration='underline'"
              onmouseout="this.querySelector('span').style.textDecoration='none'">
              <span id="x-profile-following-count" style="color: #fff; font-weight: 700; font-size: 14px;">156</span>
              <span style="color: #71767b; margin-left: 2px; font-size: 14px; font-weight: 400;" data-i18n="profileFollowing">正在關注</span>
            </div>
            <div style="cursor: pointer;" onmouseover="this.querySelector('span').style.textDecoration='underline'"
              onmouseout="this.querySelector('span').style.textDecoration='none'">
              <span id="x-profile-followers-count" style="color: #fff; font-weight: 700; font-size: 14px;">89</span>
              <span style="color: #71767b; margin-left: 2px; font-size: 14px; font-weight: 400;" data-i18n="profileFollowers">關注者</span>
            </div>
          </div>
        </div>

        <!-- 標籤欄 -->
        <div class="profile-tabs" style="display: flex; border-bottom: 1px solid #2f3336;">
          <div class="profile-tab active" onclick="switchProfileTab('posts')"
            style="flex: 1; text-align: center; padding: 14px 0; font-weight: 600; font-size: 15px; cursor: pointer; position: relative; color: #fff;">
            <span data-i18n="profilePosts">帖子</span>
            <div class="tab-indicator"
              style="position: absolute; bottom: 0; left: 25%; width: 50%; height: 3px; background-color: var(--x-accent); border-radius: 2px;">
            </div>
          </div>
          <div class="profile-tab" onclick="switchProfileTab('likes')"
            style="flex: 1; text-align: center; padding: 14px 0; font-weight: 500; font-size: 15px; cursor: pointer; position: relative; color: #71767b;">
            <span data-i18n="profileLikes">喜歡</span>
            <div class="tab-indicator"
              style="position: absolute; bottom: 0; left: 25%; width: 50%; height: 3px; background-color: var(--x-accent); border-radius: 2px; display: none;">
            </div>
          </div>
          <div class="profile-tab" onclick="switchProfileTab('highlights')"
            style="flex: 1; text-align: center; padding: 14px 0; font-weight: 500; font-size: 15px; cursor: pointer; position: relative; color: #71767b;">
            <span data-i18n="profileHighlights">亮點</span>
            <div class="tab-indicator"
              style="position: absolute; bottom: 0; left: 25%; width: 50%; height: 3px; background-color: var(--x-accent); border-radius: 2px; display: none;">
            </div>
          </div>
          <div class="profile-tab" onclick="switchProfileTab('articles')"
            style="flex: 1; text-align: center; padding: 14px 0; font-weight: 500; font-size: 15px; cursor: pointer; position: relative; color: #71767b;">
            <span data-i18n="profileArticles">文章</span>
            <div class="tab-indicator"
              style="position: absolute; bottom: 0; left: 25%; width: 50%; height: 3px; background-color: var(--x-accent); border-radius: 2px; display: none;">
            </div>
          </div>
          <div class="profile-tab" onclick="switchProfileTab('media')"
            style="flex: 1; text-align: center; padding: 14px 0; font-weight: 500; font-size: 15px; cursor: pointer; position: relative; color: #71767b;">
            <span data-i18n="profileMedia">媒體</span>
            <div class="tab-indicator"
              style="position: absolute; bottom: 0; left: 25%; width: 50%; height: 3px; background-color: var(--x-accent); border-radius: 2px; display: none;">
            </div>
          </div>
        </div>

        <!-- 內容區域 -->
        <div class="profile-content" style="flex: 1;">
          <!-- 帖子內容 -->
          <div id="profile-posts-content" class="profile-tab-content" style="display: block;">
            <div id="x-profile-tweets-container" style="padding: 0;">
              <!-- 使用者的推文將在這裡顯示 -->
            </div>
          </div>

          <!-- 其他標籤內容 -->
          <div id="profile-likes-content" class="profile-tab-content" style="display: none;">
            <div style="padding: 60px 32px; text-align: center;">
              <div style="color: #71767b; font-size: 31px; font-weight: 800; margin-bottom: 8px;" data-i18n="profileNoLikes">還沒有喜歡的推文</div>
              <div style="color: #71767b; font-size: 15px;" data-i18n="profileNoLikesDesc">當你喜歡一條推文時，它會顯示在這裡。</div>
            </div>
          </div>

          <div id="profile-highlights-content" class="profile-tab-content" style="display: none;">
            <div style="padding: 60px 32px; text-align: center;">
              <div style="color: #71767b; font-size: 31px; font-weight: 800; margin-bottom: 8px;" data-i18n="profileNoHighlights">還沒有亮點</div>
              <div style="color: #71767b; font-size: 15px;" data-i18n="profileNoHighlightsDesc">點贊最多的推文會顯示在這裡。</div>
            </div>
          </div>

          <div id="profile-articles-content" class="profile-tab-content" style="display: none;">
            <div style="padding: 60px 32px; text-align: center;">
              <div style="color: #71767b; font-size: 31px; font-weight: 800; margin-bottom: 8px;" data-i18n="profileNoArticles">還沒有文章</div>
              <div style="color: #71767b; font-size: 15px;" data-i18n="profileNoArticlesDesc">發佈的文章會顯示在這裡。</div>
            </div>
          </div>

          <div id="profile-media-content" class="profile-tab-content" style="display: none;">
            <div style="padding: 60px 32px; text-align: center;">
              <div style="color: #71767b; font-size: 31px; font-weight: 800; margin-bottom: 8px;" data-i18n="profileNoMedia">還沒有媒體</div>
              <div style="color: #71767b; font-size: 15px;" data-i18n="profileNoMediaDesc">包含照片和視頻的推文會顯示在這裡。</div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- 編輯個人資料彈窗 -->
    <div id="edit-profile-modal" class="profile-modal" onclick="closeEditProfileModal(event)" style="
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(91, 112, 131, 0.4);
      z-index: 20;
      overflow-y: auto;
    ">
      <div class="modal-content" onclick="event.stopPropagation()" style="
        background-color: #000;
        margin: 40px auto;
        border-radius: 16px;
        max-width: 600px;
        width: calc(100% - 40px);
        max-height: calc(100vh - 80px);
        position: relative;
        overflow: hidden;
      ">
        <!-- 彈窗頂部欄 -->
        <div class="modal-header" style="
          display: flex;
          align-items: center;
          justify-content: space-between;
          padding: 12px 16px;
          border-bottom: 1px solid #2f3336;
          position: sticky;
          top: 0;
          background-color: #000;
          z-index: 25;
        ">
          <div style="display: flex; align-items: center; gap: 24px;">
            <!-- 關閉按鈕 -->
            <div class="modal-close-btn" onclick="closeEditProfileModal()" style="
              cursor: pointer;
              padding: 8px;
              border-radius: 50%;
              transition: background-color 0.2s;
            " onmouseover="this.style.backgroundColor='rgba(239,243,244,0.1)'"
              onmouseout="this.style.backgroundColor='transparent'">
              <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: #fff;">
                <g>
                  <path
                    d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z">
                  </path>
                </g>
              </svg>
            </div>
            <!-- 標題 -->
            <h2 style="
              color: #fff;
              font-size: 20px;
              font-weight: 700;
              margin: 0;
            ">編輯個人資料</h2>
          </div>
          <!-- 保存按鈕 -->
          <button id="save-profile-btn" onclick="saveProfileChanges()" style="
            background-color: #fff;
            color: #000;
            border: none;
            border-radius: 20px;
            padding: 6px 16px;
            font-size: 15px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
          " onmouseover="this.style.backgroundColor='#d7dbdc'" onmouseout="this.style.backgroundColor='#fff'">
            保存
          </button>
        </div>

        <!-- 彈窗內容區域 -->
        <div class="modal-body" style="
          padding: 0;
          overflow-y: auto;
          max-height: calc(100vh - 140px);
        ">
          <!-- 封面圖編輯區域 -->
          <div class="edit-cover-section" style="
            position: relative;
            height: 200px;
            background-color: #333;
            overflow: hidden;
          ">
            <img id="edit-cover-image" src="https://i.postimg.cc/qRzMB6nQ/default-cover.jpg"
              style="width: 100%; height: 100%; object-fit: cover;" alt="封面圖">

            <!-- 封面圖編輯按鈕 -->
            <div class="cover-edit-overlay" style="
              position: absolute;
              top: 0;
              left: 0;
              right: 0;
              bottom: 0;
              background-color: rgba(0, 0, 0, 0.4);
              display: flex;
              justify-content: center;
              align-items: center;
              gap: 12px;
            ">
              <!-- 編輯按鈕 -->
              <div class="cover-edit-btn" onclick="editCoverImage()" style="
                background-color: rgba(0, 0, 0, 0.75);
                border-radius: 50%;
                padding: 12px;
                cursor: pointer;
                transition: background-color 0.2s;
              " onmouseover="this.style.backgroundColor='rgba(0,0,0,0.85)'"
                onmouseout="this.style.backgroundColor='rgba(0,0,0,0.75)'">
                <svg viewBox="0 0 24 24" style="width: 22px; height: 22px; fill: #fff;">
                  <g>
                    <path
                      d="M3 5.5C3 4.119 4.119 3 5.5 3h13C19.881 3 21 4.119 21 5.5v13c0 1.381-1.119 2.5-2.5 2.5h-13C4.119 21 3 19.881 3 18.5v-13zM5.5 5c-.276 0-.5.224-.5.5v9.086l3-3 3 3 5-5 3 3V5.5c0-.276-.224-.5-.5-.5h-13zM19 15.414l-3-3-5 5-3-3-3 3V18.5c0 .276.224.5.5.5h13c.276 0 .5-.224.5-.5v-3.086zM9.75 7C8.784 7 8 7.784 8 8.75s.784 1.75 1.75 1.75 1.75-.784 1.75-1.75S10.716 7 9.75 7z">
                    </path>
                  </g>
                </svg>
              </div>
              <!-- 刪除按鈕 -->
              <div class="cover-remove-btn" onclick="removeCoverImage()" style="
                background-color: rgba(0, 0, 0, 0.75);
                border-radius: 50%;
                padding: 12px;
                cursor: pointer;
                transition: background-color 0.2s;
              " onmouseover="this.style.backgroundColor='rgba(0,0,0,0.85)'"
                onmouseout="this.style.backgroundColor='rgba(0,0,0,0.75)'">
                <svg viewBox="0 0 24 24" style="width: 22px; height: 22px; fill: #fff;">
                  <g>
                    <path
                      d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z">
                    </path>
                  </g>
                </svg>
              </div>
            </div>
          </div>

          <!-- 頭像編輯區域 -->
          <div class="edit-avatar-section" style="
            padding: 12px 16px;
            position: relative;
            margin-top: -67px;
            z-index: 3;
          ">
            <div style="position: relative; width: 134px;">
              <img id="edit-main-avatar" src="https://i.postimg.cc/pXxk1JXk/IMG-6442.jpg"
                style="width: 134px; height: 134px; border-radius: 50%; border: 4px solid #000; object-fit: cover; overflow: hidden; box-sizing: border-box;" alt="用戶頭像">

              <!-- 頭像編輯按鈕 -->
              <div class="avatar-edit-btn" onclick="editAvatarImage()" style="
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background-color: rgba(0, 0, 0, 0.75);
                border-radius: 50%;
                padding: 12px;
                cursor: pointer;
                transition: background-color 0.2s;
              " onmouseover="this.style.backgroundColor='rgba(0,0,0,0.85)'"
                onmouseout="this.style.backgroundColor='rgba(0,0,0,0.75)'">
                <svg viewBox="0 0 24 24" style="width: 22px; height: 22px; fill: #fff;">
                  <g>
                    <path
                      d="M3 5.5C3 4.119 4.119 3 5.5 3h13C19.881 3 21 4.119 21 5.5v13c0 1.381-1.119 2.5-2.5 2.5h-13C4.119 21 3 19.881 3 18.5v-13zM5.5 5c-.276 0-.5.224-.5.5v9.086l3-3 3 3 5-5 3 3V5.5c0-.276-.224-.5-.5-.5h-13zM19 15.414l-3-3-5 5-3-3-3 3V18.5c0 .276.224.5.5.5h13c.276 0 .5-.224.5-.5v-3.086zM9.75 7C8.784 7 8 7.784 8 8.75s.784 1.75 1.75 1.75 1.75-.784 1.75-1.75S10.716 7 9.75 7z">
                    </path>
                  </g>
                </svg>
              </div>
            </div>
          </div>

          <!-- 表單輸入區域 -->
          <div class="edit-form-section" style="padding: 24px 16px;">
            <!-- 用戶名輸入 -->
            <div class="form-group" style="margin-bottom: 20px;">
              <label style="
                display: block;
                color: #8b98a5;
                font-size: 13px;
                font-weight: 400;
                margin-bottom: 2px;
              ">名稱</label>
              <input type="text" id="edit-user-name" placeholder="名稱" style="
                width: 100%;
                background-color: transparent;
                border: 1px solid #333;
                border-radius: 4px;
                color: #fff;
                padding: 12px;
                font-size: 17px;
                outline: none;
                transition: border-color 0.2s;
                box-sizing: border-box;
              " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'" maxlength="50"
                oninput="updateCharacterCounts()">
              <div style="color: #8b98a5; font-size: 13px; margin-top: 4px;">0 / 50</div>
            </div>

            <!-- 用戶控制碼輸入 -->
            <div class="form-group" style="margin-bottom: 20px;">
              <label style="
                display: block;
                color: #8b98a5;
                font-size: 13px;
                font-weight: 400;
                margin-bottom: 2px;
              ">用戶名</label>
              <input type="text" id="edit-user-handle" placeholder="用戶名" style="
                width: 100%;
                background-color: transparent;
                border: 1px solid #333;
                border-radius: 4px;
                color: #fff;
                padding: 12px;
                font-size: 17px;
                outline: none;
                transition: border-color 0.2s;
                box-sizing: border-box;
              " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'" maxlength="15"
                oninput="updateCharacterCounts()">
              <div style="color: #8b98a5; font-size: 13px; margin-top: 4px;">0 / 15</div>
            </div>

            <!-- 個人簡介輸入 -->
            <div class="form-group" style="margin-bottom: 20px;">
              <label style="
                display: block;
                color: #8b98a5;
                font-size: 13px;
                font-weight: 400;
                margin-bottom: 2px;
              ">自我介紹</label>
              <textarea id="edit-user-bio" placeholder="自我介紹" style="
                width: 100%;
                background-color: transparent;
                border: 1px solid #333;
                border-radius: 4px;
                color: #fff;
                padding: 12px;
                font-size: 17px;
                outline: none;
                transition: border-color 0.2s;
                box-sizing: border-box;
                resize: vertical;
                min-height: 80px;
                max-height: 150px;
                font-family: inherit;
                line-height: 1.3;
              " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'" maxlength="160"
                oninput="updateCharacterCounts()"></textarea>
              <div style="color: #8b98a5; font-size: 13px; margin-top: 4px;">0 / 160</div>
            </div>

            <!-- 自訂標籤1 -->
            <div class="form-group" style="margin-bottom: 25px;">
              <label style="
                display: block;
                color: #8b98a5;
                font-size: 13px;
                font-weight: 400;
                margin-bottom: 8px;
              ">自訂標籤1</label>

              <!-- 圖示和文本輸入行 -->
              <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                <!-- 圖示輸入 -->
                <input type="text" id="edit-tag1-icon" placeholder="✨" maxlength="2" style="
                  width: 50px;
                  background-color: transparent;
                  border: 1px solid #333;
                  border-radius: 4px;
                  color: #fff;
                  padding: 12px;
                  font-size: 17px;
                  outline: none;
                  transition: border-color 0.2s;
                  box-sizing: border-box;
                  text-align: center;
                " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'">

                <!-- 文本輸入 -->
                <input type="text" id="edit-custom-tag1" placeholder="例如：科技愛好者" style="
                  flex: 1;
                  background-color: transparent;
                  border: 1px solid #333;
                  border-radius: 4px;
                  color: #fff;
                  padding: 12px;
                  font-size: 17px;
                  outline: none;
                  transition: border-color 0.2s;
                  box-sizing: border-box;
                " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'" maxlength="30"
                  oninput="updateCharacterCounts()">
              </div>

              <!-- 顏色選擇行 -->
              <div style="display: flex; gap: 8px; align-items: center; margin-bottom: 4px;">
                <label style="color: #8b98a5; font-size: 12px; min-width: 40px;">顏色:</label>
                <input type="color" id="edit-tag1-color" value="#71767b" style="
                  width: 40px;
                  height: 32px;
                  border: 1px solid #333;
                  border-radius: 4px;
                  background: transparent;
                  cursor: pointer;
                  outline: none;
                " onchange="updateTag1ColorFromPicker()">
                <input type="text" id="edit-tag1-color-text" placeholder="#71767b" maxlength="7" style="
                  flex: 1;
                  background-color: transparent;
                  border: 1px solid #333;
                  border-radius: 4px;
                  color: #fff;
                  padding: 8px 12px;
                  font-size: 14px;
                  outline: none;
                  font-family: monospace;
                  transition: border-color 0.2s;
                " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'"
                  oninput="updateTag1ColorFromText()" onchange="updateTag1ColorFromText()">
              </div>

              <div style="color: #8b98a5; font-size: 13px;">0 / 30</div>
            </div>

            <!-- 自訂標籤2 -->
            <div class="form-group" style="margin-bottom: 25px;">
              <label style="
                display: block;
                color: #8b98a5;
                font-size: 13px;
                font-weight: 400;
                margin-bottom: 8px;
              ">自訂標籤2</label>

              <!-- 圖示和文本輸入行 -->
              <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                <!-- 圖示輸入 -->
                <input type="text" id="edit-tag2-icon" placeholder="📅" maxlength="2" style="
                  width: 50px;
                  background-color: transparent;
                  border: 1px solid #333;
                  border-radius: 4px;
                  color: #fff;
                  padding: 12px;
                  font-size: 17px;
                  outline: none;
                  transition: border-color 0.2s;
                  box-sizing: border-box;
                  text-align: center;
                " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'">

                <!-- 文本輸入 -->
                <input type="text" id="edit-custom-tag2" placeholder="例如：2024年加入" style="
                  flex: 1;
                  background-color: transparent;
                  border: 1px solid #333;
                  border-radius: 4px;
                  color: #fff;
                  padding: 12px;
                  font-size: 17px;
                  outline: none;
                  transition: border-color 0.2s;
                  box-sizing: border-box;
                " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'" maxlength="30"
                  oninput="updateCharacterCounts()">
              </div>

              <!-- 顏色選擇行 -->
              <div style="display: flex; gap: 8px; align-items: center; margin-bottom: 4px;">
                <label style="color: #8b98a5; font-size: 12px; min-width: 40px;">顏色:</label>
                <input type="color" id="edit-tag2-color" value="#71767b" style="
                  width: 40px;
                  height: 32px;
                  border: 1px solid #333;
                  border-radius: 4px;
                  background: transparent;
                  cursor: pointer;
                  outline: none;
                " onchange="updateTag2ColorFromPicker()">
                <input type="text" id="edit-tag2-color-text" placeholder="#71767b" maxlength="7" style="
                  flex: 1;
                  background-color: transparent;
                  border: 1px solid #333;
                  border-radius: 4px;
                  color: #fff;
                  padding: 8px 12px;
                  font-size: 14px;
                  outline: none;
                  font-family: monospace;
                  transition: border-color 0.2s;
                " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'"
                  oninput="updateTag2ColorFromText()" onchange="updateTag2ColorFromText()">
              </div>

              <div style="color: #8b98a5; font-size: 13px;">0 / 30</div>
            </div>

            <!-- 關注數輸入 -->
            <div class="form-group" style="margin-bottom: 20px;">
              <label style="
                display: block;
                color: #8b98a5;
                font-size: 13px;
                font-weight: 400;
                margin-bottom: 2px;
              ">正在關注數量</label>
              <input type="text" id="edit-following-count" placeholder="156, 1.2K, 2.5M等" maxlength="20" style="
                width: 100%;
                background-color: transparent;
                border: 1px solid #333;
                border-radius: 4px;
                color: #fff;
                padding: 12px;
                font-size: 17px;
                outline: none;
                transition: border-color 0.2s;
                box-sizing: border-box;
              " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'">
              <div style="color: #8b98a5; font-size: 13px; margin-top: 4px;">可輸入任意數位、字母、符號組合</div>
            </div>

            <!-- 關注者數輸入 -->
            <div class="form-group" style="margin-bottom: 20px;">
              <label style="
                display: block;
                color: #8b98a5;
                font-size: 13px;
                font-weight: 400;
                margin-bottom: 2px;
              ">關注者數量</label>
              <input type="text" id="edit-followers-count" placeholder="89, 1.5K, 3.2M等" maxlength="20" style="
                width: 100%;
                background-color: transparent;
                border: 1px solid #333;
                border-radius: 4px;
                color: #fff;
                padding: 12px;
                font-size: 17px;
                outline: none;
                transition: border-color 0.2s;
                box-sizing: border-box;
              " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'">
              <div style="color: #8b98a5; font-size: 13px; margin-top: 4px;">可輸入任意數位、字母、符號組合</div>
            </div>

            <!-- 認證類型設置 -->
            <div class="form-group" style="margin-bottom: 25px;">
              <label style="
                display: block;
                color: #8b98a5;
                font-size: 13px;
                font-weight: 400;
                margin-bottom: 8px;
              ">認證類型</label>

              <div style="color: #71767b; font-size: 12px; margin-bottom: 12px; line-height: 1.4;">
                選擇您的認證類型，不同認證類型會顯示不同的圖示和含義。
              </div>

              <!-- 認證類型選擇 -->
              <div style="margin-bottom: 12px;">
                <select id="edit-verification-type" style="
                  width: 100%;
                  background-color: #000;
                  border: 1px solid #333;
                  border-radius: 4px;
                  color: #fff;
                  padding: 12px;
                  font-size: 17px;
                  outline: none;
                  transition: border-color 0.2s;
                  box-sizing: border-box;
                " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'"
                  onchange="updateVerificationTypeUI()">
                  <option value="none" style="background-color: #000; color: #fff;">無認證</option>
                  <option value="verified" style="background-color: #000; color: #fff;">已認證 - 藍色勾標</option>
                  <option value="couple" style="background-color: #000; color: #fff;">情侶認證 - 白色心形</option>
                  <option value="married" style="background-color: #000; color: #fff;">已婚認證 - 白色圓環</option>
                  <option value="vip" style="background-color: #000; color: #fff;">VIP認證 - 白色菱形</option>
                </select>
              </div>

              <!-- 情侶認證角色綁定 -->
              <div id="couple-binding-section" style="display: none;">
                <label style="
                  display: block;
                  color: #8b98a5;
                  font-size: 13px;
                  font-weight: 400;
                  margin-bottom: 8px;
                ">情侶物件角色</label>

                <div style="color: #71767b; font-size: 12px; margin-bottom: 8px; line-height: 1.4;">
                  選擇與您是情侶關係的角色。綁定後，其他推特觀眾都會知道你們的情侶關係。
                </div>

                <select id="edit-couple-character" style="
                  width: 100%;
                  background-color: #000;
                  border: 1px solid #333;
                  border-radius: 4px;
                  color: #fff;
                  padding: 12px;
                  font-size: 17px;
                  outline: none;
                  transition: border-color 0.2s;
                  box-sizing: border-box;
                " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'">
                  <option value="" style="background-color: #000; color: #fff;">未選擇角色</option>
                  <!-- 角色選項將動態生成 -->
                </select>
              </div>
            </div>

            <!-- 公眾身份設置 -->
            <div class="form-group" style="margin-bottom: 25px;">
              <label style="
                display: block;
                color: #8b98a5;
                font-size: 13px;
                font-weight: 400;
                margin-bottom: 8px;
              ">公眾身份</label>
              <div style="color: #71767b; font-size: 12px; margin-bottom: 8px; line-height: 1.4;">
                描述您在X平臺的公眾身份（如明星、網紅、博主等）。這將影響其他用戶對您的討論幾率，身份越知名可能引起更多關注和討論。此資訊完全公開。
              </div>

              <!-- 重要提醒 -->
              <div
                style="background-color: color-mix(in srgb, var(--x-accent) , 0.1); border: 1px solid var(--x-accent); border-radius: 6px; padding: 12px; margin-bottom: 12px;">
                <div style="color: var(--x-accent); font-size: 12px; line-height: 1.4;">
                  <strong>📌 重要提醒：</strong>您將以完整身份進行互動，但<strong
                    style="color: var(--x-accent);">X平臺其他用戶無法讀取您的個人設定</strong>，僅能看到此公眾身份資訊。如需讓其他用戶瞭解的個人特點、背景經歷等內容，請全部詳細填寫至公眾身份中。
                </div>
              </div>

              <textarea id="edit-public-identity" placeholder="例如：知名科技博主、演員、歌手、網路紅人等... 可詳細描述您的公開背景、成就、特點等，無字數限制" style="
                width: 100%;
                background-color: transparent;
                border: 1px solid #333;
                border-radius: 4px;
                color: #fff;
                padding: 12px;
                font-size: 17px;
                outline: none;
                transition: border-color 0.2s;
                box-sizing: border-box;
                resize: vertical;
                min-height: 120px;
                max-height: 200px;
                font-family: inherit;
                line-height: 1.3;
              " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'"></textarea>
              <div style="color: #8b98a5; font-size: 12px; margin-top: 4px;">💡 無字數限制，可詳細描述您的公開信息</div>
            </div>

            <!-- 真名公開設置 -->
            <div class="form-group" style="margin-bottom: 25px;">
              <label style="
                display: block;
                color: #8b98a5;
                font-size: 13px;
                font-weight: 400;
                margin-bottom: 8px;
              ">真名設置</label>
              <div style="color: #71767b; font-size: 12px; margin-bottom: 12px; line-height: 1.4;">
                選擇是否公開您的真實姓名。公開後，其他用戶和角色都能看到您的真名，情侶認證時也會顯示雙方真名。
              </div>

              <!-- 是否公開真名核取方塊 -->
              <div style="margin-bottom: 12px;">
                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                  <input type="checkbox" id="edit-show-real-name" style="
                    width: 16px;
                    height: 16px;
                    accent-color: var(--x-accent);
                  " onchange="toggleRealNameInput()">
                  <span style="color: #fff; font-size: 15px;">公開真實姓名</span>
                </label>
              </div>

              <!-- 真名輸入框 -->
              <div id="real-name-input-container" style="display: none;">
                <input type="text" id="edit-real-name" placeholder="請輸入您的真實姓名" style="
                  width: 100%;
                  background-color: transparent;
                  border: 1px solid #333;
                  border-radius: 4px;
                  color: #fff;
                  padding: 12px;
                  font-size: 17px;
                  outline: none;
                  transition: border-color 0.2s;
                  box-sizing: border-box;
                " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'" maxlength="50"
                  oninput="updateCharacterCounts()">
                <div style="color: #8b98a5; font-size: 13px; margin-top: 4px;">0 / 50</div>
              </div>
            </div>

            <!-- 角色身份識別設置 -->
            <div class="form-group" style="margin-bottom: 20px;">
              <label style="
                display: block;
                color: #8b98a5;
                font-size: 13px;
                font-weight: 400;
                margin-bottom: 8px;
              ">角色身份識別</label>
              <div style="color: #71767b; font-size: 12px; margin-bottom: 12px; line-height: 1.4;">
                選擇哪些角色知道您的真實身份。被選中的角色會認識您，在互動時會表現得像朋友一樣。
                <br><br>
                <strong style="color: var(--x-accent);">功能說明：</strong><br>
                • 知道您身份的角色會在評論區與您自然互動<br>
                • 您發帖時，這些角色可能會來留言<br>
                • 只有已綁定X資料的角色才能被選擇<br>
                • <strong style="color: var(--x-accent);">點擊右側按鈕</strong>可設置專屬的用戶人設<br>
                • 🔵 藍色<strong>+</strong>按鈕：未設置 | 🟢 綠色<strong>✏️</strong>按鈕：已設置
              </div>

              <!-- 角色選擇列表 -->
              <div id="identity-characters-list" style="
                background-color: #1a1a1a;
                border: 1px solid #333;
                border-radius: 8px;
                padding: 12px;
                max-height: 200px;
                overflow-y: auto;
              ">
                <!-- 角色清單將動態生成 -->
              </div>
            </div>

          </div>
        </div>
      </div>
    </div>

    <!-- 發帖彈窗 -->
    <div id="compose-tweet-modal" class="compose-modal" onclick="closeComposeTweetModal(event)" style="
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(91, 112, 131, 0.4);
      z-index: 20;
      overflow-y: auto;
    ">
      <div class="compose-modal-content" onclick="event.stopPropagation()" style="
        background-color: #000;
        margin: 40px auto;
        border-radius: 16px;
        max-width: 600px;
        width: calc(100% - 40px);
        max-height: calc(100vh - 80px);
        position: relative;
        overflow: hidden;
      ">
        <!-- 發帖彈窗頂部欄 -->
        <div class="compose-header" style="
          display: flex;
          align-items: center;
          justify-content: space-between;
          padding: 12px 16px;
          border-bottom: 1px solid #2f3336;
          position: sticky;
          top: 0;
          background-color: #000;
          z-index: 25;
        ">
          <div style="display: flex; align-items: center; gap: 24px;">
            <!-- 關閉按鈕 -->
            <div class="compose-close-btn" onclick="closeComposeTweetModal()" style="
              cursor: pointer;
              padding: 8px;
              border-radius: 50%;
              transition: background-color 0.2s;
            " onmouseover="this.style.backgroundColor='rgba(239,243,244,0.1)'"
              onmouseout="this.style.backgroundColor='transparent'">
              <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: #fff;">
                <g>
                  <path
                    d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z">
                  </path>
                </g>
              </svg>
            </div>
          </div>
          <!-- 發帖按鈕 -->
          <button id="compose-tweet-btn" onclick="publishTweet()" disabled style="
            background-color: var(--x-accent);
            color: #fff;
            border: none;
            border-radius: 20px;
            padding: 8px 20px;
            font-size: 15px;
            font-weight: 700;
            cursor: pointer;
            opacity: 0.5;
            transition: all 0.2s;
          ">
            發帖
          </button>
        </div>

        <!-- 發帖彈窗內容區域 -->
        <div class="compose-body" style="
          padding: 16px;
          overflow-y: auto;
          max-height: calc(100vh - 200px);
        ">
          <!-- 使用者資訊和輸入區域 -->
          <div style="display: flex; gap: 12px; margin-bottom: 20px;">
            <!-- 用戶頭像 -->
            <img id="compose-user-avatar" src="https://i.postimg.cc/pXxk1JXk/IMG-6442.jpg" alt="用戶頭像"
              style="width: 48px; height: 48px; border-radius: 50%; flex-shrink: 0;">

            <!-- 輸入區域 -->
            <div style="flex: 1; min-width: 0;">
              <!-- 主要文本輸入 -->
              <textarea id="compose-text-input" placeholder="有什麼新鮮事？" style="
                width: 100%;
                min-height: 120px;
                max-height: 300px;
                background: transparent;
                border: none;
                color: #fff;
                font-size: 20px;
                resize: none;
                outline: none;
                font-family: inherit;
                line-height: 1.3;
                box-sizing: border-box;
              " oninput="handleComposeInput()" onkeyup="processHashtagsAndMentions()"></textarea>

              <!-- 引用內容顯示區域 -->
              <div id="quote-content-preview"
                style="display: none; margin-top: 16px; border: 1px solid #2f3336; border-radius: 16px; padding: 12px; background-color: rgba(0,0,0,0.3);">
                <div
                  style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px;">
                  <div style="display: flex; align-items: center; gap: 4px;">
                    <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: #71767b;">
                      <g>
                        <path
                          d="M4.5 3.88l4.432 4.14-1.364 1.46L5.5 7.55V16c0 1.1.896 2 2 2H13v2H7.5c-2.209 0-4-1.791-4-4V7.55L1.432 9.48.068 8.02 4.5 3.88zM16.5 6H11V4h5.5c2.209 0 4 1.791 4 4v8.45l2.068-1.93 1.364 1.46-4.432 4.14-4.432-4.14 1.364-1.46 2.068 1.93V8c0-1.1-.896-2-2-2z">
                        </path>
                      </g>
                    </svg>
                    <span id="quote-type-text" style="color: #71767b; font-size: 13px;">引用推文</span>
                  </div>
                  <div onclick="removeQuoteContent()"
                    style="cursor: pointer; padding: 4px; border-radius: 50%; transition: background-color 0.2s;"
                    onmouseover="this.style.backgroundColor='rgba(239,243,244,0.1)'"
                    onmouseout="this.style.backgroundColor='transparent'">
                    <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: #71767b;">
                      <g>
                        <path
                          d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z">
                        </path>
                      </g>
                    </svg>
                  </div>
                </div>
                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                  <img id="quote-user-avatar" style="width: 20px; height: 20px; border-radius: 50%;" alt="用戶頭像">
                  <span id="quote-user-name" style="font-weight: 600; color: #fff; font-size: 13px;"></span>
                  <svg id="quote-user-verified" viewBox="0 0 24 24"
                    style="width: 14px; height: 14px; fill: var(--x-accent); display: none;">
                    <g>
                      <path
                        d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.27 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.46 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z">
                      </path>
                    </g>
                  </svg>
                  <span id="quote-user-handle" style="color: #71767b; font-size: 13px;"></span>
                  <span id="quote-user-time" style="color: #71767b; font-size: 13px;"></span>
                </div>
                <div id="quote-content-text"
                  style="color: #fff; font-size: 14px; line-height: 1.3; word-wrap: break-word;"></div>
                <!-- 引用圖片容器 -->
                <div id="quote-image-container" style="display: none;"></div>
              </div>

              <!-- 字元計數 -->
              <div style="display: flex; justify-content: flex-end; margin-top: 8px;">
                <div id="compose-char-count" style="
                  color: #71767b;
                  font-size: 13px;
                ">0 / 280</div>
              </div>

              <!-- 商業任務選擇區域 -->
              <div id="business-task-selection" style="display: none; margin-top: 16px; margin-bottom: 16px;">
                <div style="background-color: #1a1a1a; border: 2px solid #f59e0b; border-radius: 12px; padding: 16px;">
                  <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px;">
                    <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: #f59e0b;">
                      <g><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z" /></g>
                    </svg>
                    <div style="color: #f59e0b; font-size: 15px; font-weight: 700;">選擇商業任務</div>
                  </div>
                  <div id="business-tasks-list" style="display: flex; flex-direction: column; gap: 8px;">
                    <!-- 任務清單將動態生成 -->
                  </div>
                </div>
              </div>

              <!-- 功能區域 -->
              <div style="margin-top: 16px;">

                <!-- 圖片區域 -->
                <div id="compose-image-section" style="display: none; margin-bottom: 16px;">
                  <div style="background-color: #1a1a1a; border: 1px solid #333; border-radius: 12px; padding: 16px;">
                    <div style="color: #fff; font-size: 15px; font-weight: 600; margin-bottom: 12px;">添加圖片</div>

                    <!-- 圖片選擇方式 -->
                    <div style="display: flex; gap: 12px; margin-bottom: 16px;">
                      <button onclick="selectImageMethod('description')" id="img-desc-btn" style="
                        flex: 1;
                        background-color: #333;
                        color: #fff;
                        border: 1px solid #536471;
                        border-radius: 8px;
                        padding: 8px 12px;
                        font-size: 13px;
                        cursor: pointer;
                        transition: all 0.2s;
                      ">文字描述</button>
                      <button onclick="selectImageMethod('upload')" id="img-upload-btn" style="
                        flex: 1;
                        background-color: #333;
                        color: #fff;
                        border: 1px solid #536471;
                        border-radius: 8px;
                        padding: 8px 12px;
                        font-size: 13px;
                        cursor: pointer;
                        transition: all 0.2s;
                      ">本地上傳</button>
                    </div>

                    <!-- 文字描述輸入 -->
                    <div id="image-description-input" style="display: none;">
                      <textarea placeholder="描述圖片內容..." style="
                        width: 100%;
                        min-height: 80px;
                        background-color: #000;
                        border: 1px solid #333;
                        border-radius: 8px;
                        color: #fff;
                        padding: 12px;
                        font-size: 15px;
                        resize: vertical;
                        outline: none;
                        font-family: inherit;
                        box-sizing: border-box;
                      " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'"></textarea>
                    </div>

                    <!-- 本地上傳區域 -->
                    <div id="image-upload-area" style="display: none;">
                      <div style="
                        border: 2px dashed #333;
                        border-radius: 8px;
                        padding: 20px;
                        text-align: center;
                        cursor: pointer;
                        transition: all 0.2s;
                      " onclick="triggerImageUpload()" onmouseover="this.style.borderColor='var(--x-accent)'"
                        onmouseout="this.style.borderColor='#333'">
                        <svg viewBox="0 0 24 24" style="width: 32px; height: 32px; fill: #71767b; margin-bottom: 8px;">
                          <g>
                            <path
                              d="M3 5.5C3 4.119 4.119 3 5.5 3h13C19.881 3 21 4.119 21 5.5v13c0 1.381-1.119 2.5-2.5 2.5h-13C4.119 21 3 19.881 3 18.5v-13zM5.5 5c-.276 0-.5.224-.5.5v9.086l3-3 3 3 5-5 3 3V5.5c0-.276-.224-.5-.5-.5h-13zM19 15.414l-3-3-5 5-3-3-3 3V18.5c0 .276.224.5.5.5h13c.276 0 .5-.224.5-.5v-3.086zM9.75 7C8.784 7 8 7.784 8 8.75s.784 1.75 1.75 1.75 1.75-.784 1.75-1.75S10.716 7 9.75 7z">
                            </path>
                          </g>
                        </svg>
                        <div style="color: #71767b; font-size: 15px;">點擊選擇圖片檔</div>
                        <div style="color: #71767b; font-size: 13px; margin-top: 4px;">支持 JPG、PNG、GIF，最多4張，每張最大 5MB</div>
                      </div>
                      <input type="file" id="image-file-input" accept="image/*" multiple style="display: none;"
                        onchange="handleImageUpload(event)">
                      <div id="uploaded-image-preview" style="display: none; margin-top: 12px;">
                        <div id="preview-images-container" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 8px;"></div>
                      </div>
                    </div>

                    <!-- 操作按鈕 -->
                    <div style="display: flex; gap: 8px; margin-top: 12px;">
                      <button onclick="saveImageData()" style="
                        flex: 1;
                        background-color: var(--x-accent);
                        color: #fff;
                        border: none;
                        border-radius: 8px;
                        padding: 8px;
                        font-size: 13px;
                        cursor: pointer;
                        transition: all 0.2s;
                      " onmouseover="this.style.backgroundColor='#1a8cd8'"
                        onmouseout="this.style.backgroundColor='var(--x-accent)'">
                        保存圖片
                      </button>
                      <button onclick="removeImage()" style="
                        flex: 1;
                        background-color: transparent;
                        color: #f4212e;
                        border: 1px solid #f4212e;
                        border-radius: 8px;
                        padding: 8px;
                        font-size: 13px;
                        cursor: pointer;
                        transition: all 0.2s;
                      " onmouseover="this.style.backgroundColor='rgba(244,33,46,0.1)'"
                        onmouseout="this.style.backgroundColor='transparent'">
                        移除圖片
                      </button>
                    </div>
                  </div>
                </div>

                <!-- 定位區域 -->
                <div id="compose-location-section" style="display: none; margin-bottom: 16px;">
                  <div style="background-color: #1a1a1a; border: 1px solid #333; border-radius: 12px; padding: 16px;">
                    <div style="color: #fff; font-size: 15px; font-weight: 600; margin-bottom: 12px;">添加位置</div>
                    <input type="text" id="location-input" placeholder="輸入位置資訊..." style="
                      width: 100%;
                      background-color: #000;
                      border: 1px solid #333;
                      border-radius: 8px;
                      color: #fff;
                      padding: 12px;
                      font-size: 15px;
                      outline: none;
                      box-sizing: border-box;
                    " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'">
                    <div style="display: flex; gap: 8px; margin-top: 12px;">
                      <button onclick="saveLocationData()" style="
                        flex: 1;
                        background-color: var(--x-accent);
                        color: #fff;
                        border: none;
                        border-radius: 8px;
                        padding: 8px;
                        font-size: 13px;
                        cursor: pointer;
                        transition: all 0.2s;
                      " onmouseover="this.style.backgroundColor='#1a8cd8'"
                        onmouseout="this.style.backgroundColor='var(--x-accent)'">
                        保存位置
                      </button>
                      <button onclick="removeLocation()" style="
                        flex: 1;
                        background-color: transparent;
                        color: #f4212e;
                        border: 1px solid #f4212e;
                        border-radius: 8px;
                        padding: 8px;
                        font-size: 13px;
                        cursor: pointer;
                        transition: all 0.2s;
                      " onmouseover="this.style.backgroundColor='rgba(244,33,46,0.1)'"
                        onmouseout="this.style.backgroundColor='transparent'">
                        移除位置
                      </button>
                    </div>
                  </div>
                </div>

                <!-- 附帶連結區域 -->
                <div id="compose-link-section" style="display: none; margin-bottom: 16px;">
                  <div style="background-color: #1a1a1a; border: 1px solid #333; border-radius: 12px; padding: 16px;">
                    <div style="color: #fff; font-size: 15px; font-weight: 600; margin-bottom: 12px;">附帶連結</div>

                    <!-- 連結標題 -->
                    <input type="text" id="link-title-input" placeholder="連結標題..." style="
                      width: 100%;
                      background-color: #000;
                      border: 1px solid #333;
                      border-radius: 8px;
                      color: #fff;
                      padding: 12px;
                      font-size: 15px;
                      outline: none;
                      box-sizing: border-box;
                      margin-bottom: 12px;
                    " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'">

                    <!-- 連結位址 -->
                    <input type="text" id="link-url-input" placeholder="example.com" style="
                      width: 100%;
                      background-color: #000;
                      border: 1px solid #333;
                      border-radius: 8px;
                      color: #fff;
                      padding: 12px;
                      font-size: 15px;
                      outline: none;
                      box-sizing: border-box;
                      margin-bottom: 12px;
                    " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'">

                    <!-- 連結描述 -->
                    <textarea id="link-description-input" placeholder="簡述連結內容..." style="
                      width: 100%;
                      min-height: 60px;
                      background-color: #000;
                      border: 1px solid #333;
                      border-radius: 8px;
                      color: #fff;
                      padding: 12px;
                      font-size: 15px;
                      resize: vertical;
                      outline: none;
                      font-family: inherit;
                      box-sizing: border-box;
                      margin-bottom: 12px;
                    " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'"></textarea>

                    <!-- 連結首圖上傳 -->
                    <div style="margin-bottom: 12px;">
                      <label
                        style="display: block; color: #8b98a5; font-size: 13px; margin-bottom: 8px;">連結首圖（可選）</label>
                      <div style="
                        border: 2px dashed #333;
                        border-radius: 8px;
                        padding: 16px;
                        text-align: center;
                        cursor: pointer;
                        transition: all 0.2s;
                      " onclick="triggerLinkImageUpload()" onmouseover="this.style.borderColor='var(--x-accent)'"
                        onmouseout="this.style.borderColor='#333'">
                        <svg viewBox="0 0 24 24" style="width: 24px; height: 24px; fill: #71767b; margin-bottom: 4px;">
                          <g>
                            <path
                              d="M3 5.5C3 4.119 4.119 3 5.5 3h13C19.881 3 21 4.119 21 5.5v13c0 1.381-1.119 2.5-2.5 2.5h-13C4.119 21 3 19.881 3 18.5v-13zM5.5 5c-.276 0-.5.224-.5.5v9.086l3-3 3 3 5-5 3 3V5.5c0-.276-.224-.5-.5-.5h-13zM19 15.414l-3-3-5 5-3-3-3 3V18.5c0 .276.224.5.5.5h13c.276 0 .5-.224.5-.5v-3.086zM9.75 7C8.784 7 8 7.784 8 8.75s.784 1.75 1.75 1.75 1.75-.784 1.75-1.75S10.716 7 9.75 7z">
                            </path>
                          </g>
                        </svg>
                        <div style="color: #71767b; font-size: 13px;">點擊上傳連結首圖</div>
                      </div>
                      <input type="file" id="link-image-input" accept="image/*" style="display: none;"
                        onchange="handleLinkImageUpload(event)">
                      <div id="link-image-preview" style="display: none; margin-top: 8px;">
                        <img id="link-preview-image"
                          style="width: 100%; max-height: 120px; object-fit: cover; border-radius: 8px;" alt="連結首圖預覽">
                      </div>
                    </div>

                    <div style="display: flex; gap: 8px;">
                      <button onclick="saveLinkData()" style="
                        flex: 1;
                        background-color: var(--x-accent);
                        color: #fff;
                        border: none;
                        border-radius: 8px;
                        padding: 8px;
                        font-size: 13px;
                        cursor: pointer;
                        transition: all 0.2s;
                      " onmouseover="this.style.backgroundColor='#1a8cd8'"
                        onmouseout="this.style.backgroundColor='var(--x-accent)'">
                        保存連結
                      </button>
                      <button onclick="removeLink()" style="
                        flex: 1;
                        background-color: transparent;
                        color: #f4212e;
                        border: 1px solid #f4212e;
                        border-radius: 8px;
                        padding: 8px;
                        font-size: 13px;
                        cursor: pointer;
                        transition: all 0.2s;
                      " onmouseover="this.style.backgroundColor='rgba(244,33,46,0.1)'"
                        onmouseout="this.style.backgroundColor='transparent'">
                        移除連結
                      </button>
                    </div>
                  </div>
                </div>

                <!-- 功能按鈕欄 -->
                <div
                  style="display: flex; align-items: center; justify-content: space-between; border-top: 1px solid #2f3336; padding-top: 16px;">
                  <!-- 左側功能按鈕 -->
                  <div style="display: flex; gap: 16px;">
                    <!-- 圖片按鈕 -->
                    <div id="image-btn" onclick="toggleImageSection()" style="
                      padding: 8px;
                      border-radius: 50%;
                      cursor: pointer;
                      transition: background-color 0.2s;
                    " onmouseover="this.style.backgroundColor='rgba(29,155,240,0.1)'"
                      onmouseout="this.style.backgroundColor='transparent'">
                      <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-accent);">
                        <g>
                          <path
                            d="M3 5.5C3 4.119 4.119 3 5.5 3h13C19.881 3 21 4.119 21 5.5v13c0 1.381-1.119 2.5-2.5 2.5h-13C4.119 21 3 19.881 3 18.5v-13zM5.5 5c-.276 0-.5.224-.5.5v9.086l3-3 3 3 5-5 3 3V5.5c0-.276-.224-.5-.5-.5h-13zM19 15.414l-3-3-5 5-3-3-3 3V18.5c0 .276.224.5.5.5h13c.276 0 .5-.224.5-.5v-3.086zM9.75 7C8.784 7 8 7.784 8 8.75s.784 1.75 1.75 1.75 1.75-.784 1.75-1.75S10.716 7 9.75 7z">
                          </path>
                        </g>
                      </svg>
                    </div>

                    <!-- 定位按鈕 -->
                    <div id="location-btn" onclick="toggleLocationSection()" style="
                      padding: 8px;
                      border-radius: 50%;
                      cursor: pointer;
                      transition: background-color 0.2s;
                    " onmouseover="this.style.backgroundColor='rgba(29,155,240,0.1)'"
                      onmouseout="this.style.backgroundColor='transparent'">
                      <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-accent);">
                        <g>
                          <path
                            d="M12 7c-1.93 0-3.5 1.57-3.5 3.5S10.07 14 12 14s3.5-1.57 3.5-3.5S13.93 7 12 7zm0 5c-.827 0-1.5-.673-1.5-1.5S11.173 9 12 9s1.5.673 1.5 1.5S12.827 12 12 12zm0-10c-4.687 0-8.5 3.813-8.5 8.5 0 5.967 7.621 11.116 7.945 11.332l.555.37.555-.37C12.879 21.616 20.5 16.467 20.5 10.5 20.5 5.813 16.687 2 12 2zm0 17.77c-1.665-1.241-6.5-5.196-6.5-9.27C5.5 6.916 8.416 4 12 4s6.5 2.916 6.5 6.5c0 4.073-4.835 8.028-6.5 9.27z">
                          </path>
                        </g>
                      </svg>
                    </div>

                    <!-- 附帶按鈕 -->
                    <div id="attach-btn" onclick="toggleLinkSection()" style="
                      padding: 8px;
                      border-radius: 50%;
                      cursor: pointer;
                      transition: background-color 0.2s;
                    " onmouseover="this.style.backgroundColor='rgba(29,155,240,0.1)'"
                      onmouseout="this.style.backgroundColor='transparent'">
                      <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-accent);">
                        <g>
                          <path
                            d="M12 2C6.477 2 2 6.477 2 12s4.477 10 10 10 10-4.477 10-10S17.523 2 12 2zm5 11h-4v4h-2v-4H7v-2h4V7h2v4h4v2z">
                          </path>
                        </g>
                      </svg>
                    </div>
                  </div>

                  <!-- 右側隱私設置 -->
                  <div id="privacy-setting-btn" onclick="togglePrivacySettings()" style="
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    padding: 8px 12px;
                    border-radius: 20px;
                    cursor: pointer;
                    border: 1px solid #536471;
                    transition: background-color 0.2s;
                  " onmouseover="this.style.backgroundColor='rgba(255,255,255,0.03)'"
                    onmouseout="this.style.backgroundColor='transparent'">
                    <svg id="privacy-icon" viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: var(--x-accent);">
                      <g>
                        <path id="privacy-icon-path"
                          d="M12 1.75C6.34 1.75 1.75 6.34 1.75 12S6.34 22.25 12 22.25 22.25 17.66 22.25 12 17.66 1.75 12 1.75zm-.81 14.68l-4.1-3.27 1.25-1.57 2.47 1.98 3.97-5.47 1.62 1.18-5.21 7.15z">
                        </path>
                      </g>
                    </svg>
                    <span id="privacy-text" style="color: var(--x-accent); font-size: 13px; font-weight: 600;">所有人可以回復</span>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- 角色關係圖編輯器彈窗 -->
    <div id="character-relationship-graph-modal" style="
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.85);
      z-index: 25;
      overflow-y: auto;
      backdrop-filter: blur(8px);
    " onclick="closeCharacterRelationshipGraph(event)">
      <div style="
        background-color: #000;
        margin: 20px auto;
        border-radius: 16px;
        max-width: min(900px, calc(100vw - 20px));
        width: calc(100% - 40px);
        max-height: calc(100vh - 40px);
        position: relative;
        overflow: hidden;
        border: 1px solid #333;
      " onclick="event.stopPropagation()">
        <!-- 彈窗頭部 -->
        <div style="
          display: flex;
          align-items: center;
          justify-content: space-between;
          padding: 16px 20px;
          border-bottom: 1px solid #333;
          background-color: #000;
        ">
          <div style="display: flex; align-items: center; gap: 12px;">
            <h2 style="color: #fff; font-size: 20px; font-weight: 700; margin: 0;">角色關係圖編輯器</h2>
            <div style="color: #71767b; font-size: 13px; display: flex; align-items: center; gap: 8px;">
              <span id="graph-character-count">0 角色</span>
              <span>·</span>
              <span id="graph-link-count">0 關係</span>
            </div>
          </div>
          <div onclick="closeCharacterRelationshipGraph()" style="
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            transition: background-color 0.2s;
          " onmouseover="this.style.backgroundColor='rgba(239,243,244,0.1)'"
            onmouseout="this.style.backgroundColor='transparent'">
            <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: #fff;">
              <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
            </svg>
          </div>
        </div>

        <!-- 工具列 -->
        <div style="
          display: flex;
          align-items: center;
          gap: 12px;
          padding: 12px 20px;
          border-bottom: 1px solid #333;
          background-color: #0a0a0a;
        ">
          <button onclick="addRelationshipLink()" style="
            background-color: var(--x-accent);
            color: #fff;
            border: none;
            border-radius: 20px;
            padding: 8px 16px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
          " onmouseover="this.style.backgroundColor='#1a8cd8'"
            onmouseout="this.style.backgroundColor='var(--x-accent)'">
            <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: currentColor;">
              <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/>
            </svg>
            添加關係
          </button>
          
          <button onclick="clearAllRelationships()" style="
            background-color: transparent;
            color: #f4212e;
            border: 1px solid #f4212e;
            border-radius: 20px;
            padding: 8px 16px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
          " onmouseover="this.style.backgroundColor='rgba(244,33,46,0.1)'"
            onmouseout="this.style.backgroundColor='transparent'">
            <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: currentColor;">
              <path d="M5 20a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V8h2V6h-4V4a2 2 0 0 0-2-2H9a2 2 0 0 0-2 2v2H3v2h2zM9 4h6v2H9zM8 8h9v12H7V8z"/>
            </svg>
            清空所有
          </button>

          <div style="margin-left: auto; color: #71767b; font-size: 12px;">
            點擊角色頭像連線，點擊連線編輯關係
          </div>
        </div>

        <!-- 關係圖畫布區域 -->
        <div style="
          height: min(500px, 60vh);
          background-color: #000;
          position: relative;
          overflow: hidden;
        ">
          <canvas id="relationship-graph-canvas" style="
            width: 100%;
            height: 100%;
            display: block;
            cursor: grab;
          "></canvas>
          
          <!-- 空狀態提示 -->
          <div id="graph-empty-state" style="
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #71767b;
            pointer-events: none;
          ">
            <svg viewBox="0 0 24 24" style="width: 64px; height: 64px; fill: #2f3336; margin-bottom: 12px;">
              <path d="M16 11c1.66 0 2.99-1.34 2.99-3S17.66 5 16 5c-1.66 0-3 1.34-3 3s1.34 3 3 3zm-8 0c1.66 0 2.99-1.34 2.99-3S9.66 5 8 5C6.34 5 5 6.34 5 8s1.34 3 3 3zm0 2c-2.33 0-7 1.17-7 3.5V19h14v-2.5c0-2.33-4.67-3.5-7-3.5zm8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.97 1.97 3.45V19h6v-2.5c0-2.33-4.67-3.5-7-3.5z"/>
            </svg>
            <div style="font-size: 15px; margin-bottom: 4px;">暫無角色關係</div>
            <div style="font-size: 13px; opacity: 0.7;">請先綁定角色，然後點擊"添加關係"</div>
          </div>
        </div>

        <!-- 關係列表 -->
        <div style="
          max-height: 200px;
          overflow-y: auto;
          background-color: #0a0a0a;
          border-top: 1px solid #333;
        ">
          <div style="padding: 12px 20px; border-bottom: 1px solid #333;">
            <div style="color: #fff; font-size: 15px; font-weight: 600;">關係列表</div>
          </div>
          <div id="relationship-links-list" style="padding: 12px 20px;">
            <!-- 關係清單將動態生成 -->
          </div>
        </div>

        <!-- 底部按鈕 -->
        <div style="
          display: flex;
          gap: 12px;
          padding: 16px 20px;
          border-top: 1px solid #333;
          background-color: #000;
        ">
          <button onclick="closeCharacterRelationshipGraph()" style="
            flex: 1;
            background-color: transparent;
            color: #fff;
            border: 1px solid #536471;
            border-radius: 20px;
            padding: 12px;
            font-size: 15px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
          " onmouseover="this.style.backgroundColor='rgba(255,255,255,0.1)'"
            onmouseout="this.style.backgroundColor='transparent'">
            取消
          </button>
          <button onclick="saveRelationshipGraph()" style="
            flex: 1;
            background-color: var(--x-accent);
            color: #fff;
            border: none;
            border-radius: 20px;
            padding: 12px;
            font-size: 15px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
          " onmouseover="this.style.backgroundColor='#1a8cd8'"
            onmouseout="this.style.backgroundColor='var(--x-accent)'">
            保存關係圖
          </button>
        </div>
      </div>
    </div>

    <!-- 編輯關係詳情彈窗 -->
    <div id="edit-relationship-detail-modal" style="
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      z-index: 30;
      backdrop-filter: blur(4px);
    " onclick="closeEditRelationshipDetail(event)">
      <div style="
        background-color: #000;
        margin: 60px auto;
        border-radius: 16px;
        max-width: min(500px, calc(100vw - 20px));
        width: calc(100% - 40px);
        border: 1px solid #333;
      " onclick="event.stopPropagation()">
        <!-- 彈窗頭部 -->
        <div style="
          display: flex;
          align-items: center;
          justify-content: space-between;
          padding: 16px 20px;
          border-bottom: 1px solid #333;
        ">
          <h3 style="color: #fff; font-size: 18px; font-weight: 700; margin: 0;">編輯關係</h3>
          <div onclick="closeEditRelationshipDetail()" style="
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            transition: background-color 0.2s;
          " onmouseover="this.style.backgroundColor='rgba(239,243,244,0.1)'"
            onmouseout="this.style.backgroundColor='transparent'">
            <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: #fff;">
              <path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"/>
            </svg>
          </div>
        </div>

        <!-- 表單內容 -->
        <div style="padding: 20px;">
          <!-- 關係方向說明 -->
          <div id="relationship-characters-info" style="
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px;
            background-color: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            margin-bottom: 20px;
          ">
            <div style="flex: 1; text-align: center;">
              <div id="char-a-name" style="color: #fff; font-size: 14px; font-weight: 600;"></div>
            </div>
            <div style="color: #71767b; font-size: 20px; margin: 0 12px;">⇆</div>
            <div style="flex: 1; text-align: center;">
              <div id="char-b-name" style="color: #fff; font-size: 14px; font-weight: 600;"></div>
            </div>
          </div>

          <!-- A 對 B 的關係 -->
          <div style="margin-bottom: 20px;">
            <label style="display: block; color: #fff; font-size: 14px; font-weight: 600; margin-bottom: 8px;">
              <span id="char-a-to-b-label"></span>
            </label>
            <input type="text" id="relationship-a-to-b" placeholder="例如：好朋友、同事、哥哥等" style="
              width: 100%;
              background-color: #1a1a1a;
              border: 1px solid #333;
              border-radius: 8px;
              color: #fff;
              padding: 12px;
              font-size: 14px;
              outline: none;
              box-sizing: border-box;
            " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'">
          </div>

          <!-- B 對 A 的關係 -->
          <div style="margin-bottom: 20px;">
            <label style="display: block; color: #fff; font-size: 14px; font-weight: 600; margin-bottom: 8px;">
              <span id="char-b-to-a-label"></span>
            </label>
            <input type="text" id="relationship-b-to-a" placeholder="例如：好朋友、同事、妹妹等" style="
              width: 100%;
              background-color: #1a1a1a;
              border: 1px solid #333;
              border-radius: 8px;
              color: #fff;
              padding: 12px;
              font-size: 14px;
              outline: none;
              box-sizing: border-box;
            " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'">
          </div>

          <!-- 關係情節 -->
          <div style="margin-bottom: 24px;">
            <label style="display: block; color: #fff; font-size: 14px; font-weight: 600; margin-bottom: 8px;">
              關係情節 (可選)
            </label>
            <textarea id="relationship-story" placeholder="補充背景故事、相識經歷等..." style="
              width: 100%;
              min-height: 80px;
              background-color: #1a1a1a;
              border: 1px solid #333;
              border-radius: 8px;
              color: #fff;
              padding: 12px;
              font-size: 14px;
              outline: none;
              box-sizing: border-box;
              resize: vertical;
              font-family: inherit;
              line-height: 1.4;
            " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'"></textarea>
            <div style="color: #71767b; font-size: 12px; margin-top: 4px;">
              例如：如何相識、共同經歷、特殊事件等
            </div>
          </div>

          <!-- 操作按鈕 -->
          <div style="display: flex; gap: 12px;">
            <button onclick="deleteRelationshipLink()" style="
              flex: 1;
              background-color: transparent;
              color: #f4212e;
              border: 1px solid #f4212e;
              border-radius: 20px;
              padding: 10px;
              font-size: 14px;
              font-weight: 700;
              cursor: pointer;
              transition: all 0.2s;
            " onmouseover="this.style.backgroundColor='rgba(244,33,46,0.1)'"
              onmouseout="this.style.backgroundColor='transparent'">
              刪除關係
            </button>
            <button onclick="saveRelationshipDetail()" style="
              flex: 1;
              background-color: var(--x-accent);
              color: #fff;
              border: none;
              border-radius: 20px;
              padding: 10px;
              font-size: 14px;
              font-weight: 700;
              cursor: pointer;
              transition: all 0.2s;
            " onmouseover="this.style.backgroundColor='#1a8cd8'"
              onmouseout="this.style.backgroundColor='var(--x-accent)'">
              保存
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- NPC編輯彈窗 -->
    <div id="npc-edit-modal" style="
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(91, 112, 131, 0.4);
      z-index: 20;
      overflow-y: auto;
    " onclick="closeNPCEditModal(event)">
      <div style="
        background-color: #000;
        margin: 40px auto;
        border-radius: 16px;
        max-width: 600px;
        width: calc(100% - 40px);
        max-height: calc(100vh - 80px);
        position: relative;
        overflow: hidden;
      " onclick="event.stopPropagation()">
        <!-- 彈窗頭部 -->
        <div style="
          display: flex;
          align-items: center;
          justify-content: space-between;
          padding: 16px;
          border-bottom: 1px solid #2f3336;
        ">
          <div style="display: flex; align-items: center; gap: 24px;">
            <div onclick="closeNPCEditModal()" style="
              cursor: pointer;
              padding: 8px;
              border-radius: 50%;
              transition: background-color 0.2s;
            " onmouseover="this.style.backgroundColor='rgba(239,243,244,0.1)'"
              onmouseout="this.style.backgroundColor='transparent'">
              <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: #fff;">
                <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
              </svg>
            </div>
            <h2 style="color: #fff; font-size: 20px; font-weight: 700; margin: 0;" id="npc-modal-title">編輯NPC</h2>
          </div>
        </div>

        <!-- 彈窗內容 -->
        <div style="padding: 20px; overflow-y: auto; max-height: calc(100vh - 200px);">
          <!-- NPC姓名 -->
          <div style="margin-bottom: 20px;">
            <label style="display: block; color: #8b98a5; font-size: 13px; margin-bottom: 8px;">NPC姓名</label>
            <input type="text" id="npc-name" placeholder="輸入NPC姓名" style="
              width: 100%;
              background-color: #1a1a1a;
              border: 1px solid #333;
              border-radius: 8px;
              color: #fff;
              padding: 12px;
              font-size: 15px;
              outline: none;
              box-sizing: border-box;
            " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'" maxlength="50">
          </div>

          <!-- NPC控制碼 -->
          <div style="margin-bottom: 20px;">
            <label style="display: block; color: #8b98a5; font-size: 13px; margin-bottom: 8px;">NPC控制碼</label>
            <input type="text" id="npc-handle" placeholder="@控制碼" style="
              width: 100%;
              background-color: #1a1a1a;
              border: 1px solid #333;
              border-radius: 8px;
              color: #fff;
              padding: 12px;
              font-size: 15px;
              outline: none;
              box-sizing: border-box;
            " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'" maxlength="30">
          </div>

          <!-- NPC頭像 -->
          <div style="margin-bottom: 20px;">
            <label style="display: block; color: #8b98a5; font-size: 13px; margin-bottom: 8px;">NPC頭像URL</label>
            <input type="text" id="npc-avatar" placeholder="輸入頭像URL" style="
              width: 100%;
              background-color: #1a1a1a;
              border: 1px solid #333;
              border-radius: 8px;
              color: #fff;
              padding: 12px;
              font-size: 15px;
              outline: none;
              box-sizing: border-box;
            " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'">
          </div>

          <!-- NPC人設 -->
          <div style="margin-bottom: 20px;">
            <label style="display: block; color: #8b98a5; font-size: 13px; margin-bottom: 8px;">NPC人設</label>
            <textarea id="npc-personality" placeholder="描述NPC的性格、背景、行為特徵..." style="
              width: 100%;
              min-height: 120px;
              background-color: #1a1a1a;
              border: 1px solid #333;
              border-radius: 8px;
              color: #fff;
              padding: 12px;
              font-size: 15px;
              resize: vertical;
              outline: none;
              box-sizing: border-box;
            " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'"></textarea>
          </div>

          <!-- 發帖習慣 -->
          <div style="margin-bottom: 20px;">
            <label style="display: block; color: #8b98a5; font-size: 13px; margin-bottom: 8px;">發帖習慣</label>
            <textarea id="npc-posting-habits" placeholder="描述NPC的發帖風格、頻率、內容偏好..." style="
              width: 100%;
              min-height: 100px;
              background-color: #1a1a1a;
              border: 1px solid #333;
              border-radius: 8px;
              color: #fff;
              padding: 12px;
              font-size: 15px;
              resize: vertical;
              outline: none;
              box-sizing: border-box;
            " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'"></textarea>
          </div>

          <!-- 主頁內容 -->
          <div style="margin-bottom: 20px;">
            <label style="display: block; color: #8b98a5; font-size: 13px; margin-bottom: 8px;">主頁內容設置</label>
            <textarea id="npc-homepage" placeholder="描述NPC主頁的展示內容、簡介等..." style="
              width: 100%;
              min-height: 80px;
              background-color: #1a1a1a;
              border: 1px solid #333;
              border-radius: 8px;
              color: #fff;
              padding: 12px;
              font-size: 15px;
              resize: vertical;
              outline: none;
              box-sizing: border-box;
            " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'"></textarea>
          </div>

          <!-- 綁定用戶 -->
          <div style="margin-bottom: 20px;">
            <label style="display: block; color: #8b98a5; font-size: 13px; margin-bottom: 8px;">綁定用戶（可多選）</label>
            <div id="npc-bind-users" style="
              background-color: #1a1a1a;
              border: 1px solid #333;
              border-radius: 8px;
              padding: 12px;
              max-height: 200px;
              overflow-y: auto;
            ">
              <!-- 使用者清單將動態生成 -->
            </div>
          </div>

          <!-- 保存按鈕 -->
          <button onclick="saveNPC()" style="
            width: 100%;
            background-color: var(--x-accent);
            color: #fff;
            border: none;
            border-radius: 25px;
            padding: 14px;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
          " onmouseover="this.style.backgroundColor='#1a8cd8'" onmouseout="this.style.backgroundColor='var(--x-accent)'">
            保存NPC
          </button>
        </div>
      </div>
    </div>

    <!-- 提問箱頁面 -->
    <div id="x-askbox-page" class="x-page" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; display: none; flex-direction: column; overflow: hidden; z-index: 15;">
      <!-- 背景圖 -->
      <div id="askbox-background" style="
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-image: url('https://i.postimg.cc/7LqVqxt4/mmexport1759588659314.jpg');
        background-size: cover;
        background-position: center;
        z-index: 0;
      "></div>

      <!-- 主內容區域 -->
      <div style="position: relative; z-index: 1; width: 100%; height: 100%; display: flex; flex-direction: column; overflow-y: auto; padding-top: 20px;">
        <!-- 頂部按鈕欄 -->
        <div style="display: flex; justify-content: space-between; align-items: center; padding: 20px 16px 12px 16px;">
          <!-- 返回按鈕 -->
          <div onclick="switchXPage('profile')" style="cursor: pointer; padding: 8px; border-radius: 50%; background-color: rgba(255,255,255,0.2); backdrop-filter: blur(10px); transition: all 0.2s;"
            onmouseover="this.style.backgroundColor='rgba(255,255,255,0.3)'"
            onmouseout="this.style.backgroundColor='rgba(255,255,255,0.2)'">
            <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: #fff;">
              <path d="M7.414 13l5.043 5.04-1.414 1.42L3.586 12l7.457-7.46 1.414 1.42L7.414 11H21v2H7.414z"/>
            </svg>
          </div>

          <!-- 設置按鈕 -->
          <div onclick="openAskboxSettings()" style="cursor: pointer; padding: 8px; border-radius: 50%; background-color: rgba(255,255,255,0.2); backdrop-filter: blur(10px); transition: all 0.2s;"
            onmouseover="this.style.backgroundColor='rgba(255,255,255,0.3)'"
            onmouseout="this.style.backgroundColor='rgba(255,255,255,0.2)'">
            <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: #fff;">
              <path d="M19.14 12.94c.04-.3.06-.61.06-.94 0-.32-.02-.64-.07-.94l2.03-1.58c.18-.14.23-.41.12-.61l-1.92-3.32c-.12-.22-.37-.29-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54c-.04-.24-.24-.41-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.05.3-.09.63-.09.94s.02.64.07.94l-2.03 1.58c-.18.14-.23.41-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z"/>
            </svg>
          </div>
        </div>

        <!-- 頭像和昵稱區域 -->
        <div style="display: flex; flex-direction: column; align-items: center; padding: 20px 16px;">
          <!-- 頭像 -->
          <div onclick="changeAskboxAvatar()" style="cursor: pointer; margin-bottom: 12px; position: relative; transition: transform 0.2s;"
            onmouseover="this.style.transform='scale(1.05)'"
            onmouseout="this.style.transform='scale(1)'">
            <img id="askbox-avatar" src="https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg" 
              style="width: 80px; height: 80px; border-radius: 50%; border: 3px solid rgba(255,255,255,0.8); box-shadow: 0 4px 12px rgba(0,0,0,0.15);">
          </div>

          <!-- 昵稱/ID區域 -->
          <div style="display: flex; align-items: center; gap: 8px; background-color: rgba(255,255,255,0.15); backdrop-filter: blur(10px); padding: 6px 12px; border-radius: 20px;">
            <span id="askbox-nickname" 
              contenteditable="true"
              style="color: #fff; font-size: 14px; font-weight: 500; outline: none; cursor: text; min-width: 20px;"
              onblur="saveAskboxNickname()"
              onkeydown="if(event.key==='Enter'){event.preventDefault();this.blur();}">= =</span>
          </div>
        </div>

        <!-- 提問卡片 -->
        <div style="
          margin: 0 20px 24px 20px;
          background-color: rgba(255,255,255,0.9);
          backdrop-filter: blur(10px);
          border-radius: 16px;
          padding: 32px 24px;
          box-shadow: 0 4px 16px rgba(0,0,0,0.1);
          transition: all 0.2s;
          min-height: 120px;
          display: flex;
          align-items: center;
          justify-content: center;
        ">
          <div id="askbox-prompt" 
            contenteditable="true"
            style="
            color: #333;
            font-size: 16px;
            line-height: 1.6;
            text-align: center;
            word-break: break-word;
            outline: none;
            cursor: text;
            width: 100%;
          "
          onblur="saveAskboxPrompt()"
          onkeydown="if(event.key==='Enter'&&!event.shiftKey){event.preventDefault();this.blur();}">請向我匿名提問!waiting...</div>
        </div>

        <!-- 獲取新提問按鈕 -->
        <div onclick="getNewQuestion()" style="
          margin: 0 20px 32px 20px;
          background-color: rgba(255,255,255,0.85);
          backdrop-filter: blur(10px);
          border-radius: 24px;
          padding: 14px 24px;
          text-align: center;
          cursor: pointer;
          transition: all 0.2s;
          box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        " onmouseover="this.style.backgroundColor='rgba(255,255,255,0.95)'; this.style.transform='translateY(-1px)'"
          onmouseout="this.style.backgroundColor='rgba(255,255,255,0.85)'; this.style.transform='translateY(0)'">
          <span style="color: #333; font-size: 15px; font-weight: 600;">獲取新的提問</span>
        </div>

        <!-- 已回答的提問列表 -->
        <div style="padding: 0 20px 20px 20px;">
          <div id="answered-questions-title" style="
            color: rgba(255,255,255,0.8);
            font-size: 15px;
            font-weight: 500;
            margin-bottom: 16px;
            text-align: center;
            display: none;
          ">最新提問如下</div>
          <div id="answered-questions-list">
            <!-- 已回答的提問將動態載入在這裡 -->
          </div>
        </div>
      </div>
    </div>

    <!-- 文章查看頁面 -->
    <div id="x-article-page" class="x-page" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; display: none; flex-direction: column; overflow: hidden; z-index: 21; background-color: var(--x-bg-primary);">
      <style>
        @import url("https://fontsapi.zeoseven.com/256/main/result.css");
        @import url("data:text/css,%40font-face%7Bfont-family%3A%22ZSFT-685%22%3Bsrc%3Aurl(%22https%3A%2F%2Ffontsapi.zeoseven.com%2F685%2Fmain.woff2%22)%20format(%22woff2%22)%2Curl(%22https%3A%2F%2Ffontsapi-storage.zeoseven.com%2F685%2Fmain.woff2%22)%20format(%22woff2%22)%3Bfont-style%3Anormal%3Bfont-weight%3A400%3Bfont-display%3Aswap%3B%7D");
        
        .article-title {
          font-family: "Huiwen-mincho", serif;
        }
        
        .article-title-en {
          font-family: "ZSFT-685", serif;
        }
        
        .article-content {
          line-height: 1.8;
          word-break: break-word;
        }
        
        .article-content strong {
          font-weight: 600;
          color: var(--x-accent);
          word-break: break-word;
        }
        
        .article-content em {
          font-style: italic;
          border-bottom: 2px solid var(--x-accent);
          padding-bottom: 2px;
          word-break: break-word;
        }
        
        @media (max-width: 600px) {
          .article-title {
            font-size: 22px !important;
          }
          .article-content {
            font-size: 14px !important;
          }
        }
        
      </style>
      
      <!-- 主內容區域 -->
      <div style="position: relative; width: 100%; height: 100%; display: flex; flex-direction: column; overflow-y: auto;">
        <!-- 頂部按鈕欄 -->
        <div style="display: flex; justify-content: space-between; align-items: center; padding: 40px 16px 12px 16px; position: sticky; top: 0; background-color: var(--x-bg-primary); z-index: 10; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
          <!-- 返回按鈕 -->
          <div onclick="closeArticlePage()" style="cursor: pointer; padding: 8px; border-radius: 50%; background-color: var(--x-bg-secondary); transition: all 0.2s;"
            onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
            onmouseout="this.style.backgroundColor='var(--x-bg-secondary)'">
            <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);">
              <path d="M7.414 13l5.043 5.04-1.414 1.42L3.586 12l7.457-7.46 1.414 1.42L7.414 11H21v2H7.414z"/>
            </svg>
          </div>

          <!-- 轉發按鈕 -->
          <div onclick="shareArticle()" style="cursor: pointer; padding: 8px; border-radius: 50%; background-color: var(--x-bg-secondary); transition: all 0.2s;"
            onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
            onmouseout="this.style.backgroundColor='var(--x-bg-secondary)'">
            <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);">
              <g><path d="M17.53 7.47l-5-5c-.293-.293-.768-.293-1.06 0l-5 5c-.294.293-.294.768 0 1.06s.767.294 1.06 0l3.72-3.72V15c0 .414.336.75.75.75s.75-.336.75-.75V4.81l3.72 3.72c.146.147.338.22.53.22s.384-.072.53-.22c.293-.293.293-.767 0-1.06z"></path><path d="M19.708 21.944H4.292C3.028 21.944 2 20.916 2 19.652V14c0-.414.336-.75.75-.75s.75.336.75.75v5.652c0 .437.355.792.792.792h15.416c.437 0 .792-.355.792-.792V14c0-.414.336-.75.75-.75s.75.336.75.75v5.652c0 1.264-1.028 2.292-2.292 2.292z"></path></g>
            </svg>
          </div>
        </div>

        <!-- 封面圖 -->
        <div id="article-cover" style="
          width: 100%;
          height: 35vh;
          min-height: 250px;
          max-height: 400px;
          background-size: cover;
          background-position: center;
          background-repeat: no-repeat;
          margin-bottom: 20px;
        "></div>

        <!-- 文章內容容器 -->
        <div style="padding: 0 16px 40px 16px; max-width: 800px; margin: 0 auto; width: 100%; box-sizing: border-box;">
          <!-- 標題 -->
          <h1 id="article-title" class="article-title" style="
            font-size: 24px;
            font-weight: 700;
            color: var(--x-text-primary);
            margin-bottom: 16px;
            line-height: 1.3;
            word-wrap: break-word;
          "></h1>

          <!-- 元信息 -->
          <div style="
            display: flex;
            align-items: center;
            gap: 8px;
            padding-bottom: 12px;
            margin-bottom: 20px;
            border-bottom: 1px solid var(--x-border-color);
            flex-wrap: wrap;
          ">
            <span id="article-author" style="
              color: var(--x-text-secondary);
              font-size: 13px;
            "></span>
            <span style="color: var(--x-text-secondary);">·</span>
            <span id="article-source" style="
              color: var(--x-text-secondary);
              font-size: 13px;
              word-break: break-all;
            "></span>
          </div>

          <!-- 正文 -->
          <div id="article-body" class="article-content" style="
            color: var(--x-text-primary);
            font-size: 15px;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-wrap: break-word;
          "></div>
        </div>
      </div>
    </div>

    <!-- 帳戶主頁 -->
    <div id="account-profile-page" class="x-page" style="display: none; flex-direction: column; height: 100%; overflow: hidden;">
      <!-- 頂部巡覽列（簡化版，只顯示帳戶名和推文數） -->
      <div style="display: flex; align-items: center; justify-content: space-between; padding: 10px 15px; border-bottom: 1px solid var(--x-border-color); background-color: var(--x-bg-primary); backdrop-filter: blur(12px); position: sticky; top: 0; z-index: 10;">
        <div style="display: flex; align-items: center;">
          <div onclick="closeAccountProfile()" style="cursor: pointer; padding: 8px; margin-right: 30px; border-radius: 50%; transition: background-color 0.2s;" onmouseover="this.style.backgroundColor='rgba(239,243,244,0.1)'" onmouseout="this.style.backgroundColor='transparent'">
            <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);">
              <g><path d="M7.414 13l5.043 5.04-1.414 1.42L3.586 12l7.457-7.46 1.414 1.42L7.414 11H21v2H7.414z"></path></g>
            </svg>
          </div>
          <div>
            <div id="account-profile-nav-name" style="color: var(--x-text-primary); font-size: 20px; font-weight: 700; line-height: 1.2;"></div>
            <div id="account-profile-nav-count" style="color: var(--x-text-secondary); font-size: 13px; margin-top: 2px;">0 個帖子</div>
          </div>
        </div>
        
        <!-- 右側按鈕組 -->
        <div style="display: flex; align-items: center; gap: 8px;">
          <!-- 提問箱按鈕 -->
          <div onclick="openAccountAskbox()" style="cursor: pointer; padding: 8px; border-radius: 50%; transition: background-color 0.2s;" onmouseover="this.style.backgroundColor='rgba(239,243,244,0.1)'" onmouseout="this.style.backgroundColor='transparent'" title="提問箱">
            <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);">
              <path d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z"/>
            </svg>
          </div>
          
          <!-- 刷新按鈕 -->
          <div onclick="refreshAccountProfile()" onmousedown="handleRefreshButtonMouseDown()" onmouseup="handleRefreshButtonMouseUp()" ontouchstart="handleRefreshButtonMouseDown()" ontouchend="handleRefreshButtonMouseUp()" style="cursor: pointer; padding: 8px; border-radius: 50%; transition: background-color 0.2s;" onmouseover="this.style.backgroundColor='rgba(239,243,244,0.1)'" onmouseout="this.style.backgroundColor='transparent'" title="刷新帳戶主頁">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="var(--x-text-primary)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M9 4.55a8 8 0 0 1 6 14.9m0 -4.45v5h5" />
              <path d="M5.63 7.16l0 .01" />
              <path d="M4.06 11l0 .01" />
              <path d="M4.63 15.1l0 .01" />
              <path d="M7.16 18.37l0 .01" />
              <path d="M11 19.94l0 .01" />
            </svg>
          </div>
        </div>
      </div>

      <!-- 主內容區域 -->
      <div style="flex: 1; overflow-y: auto;">
        <!-- 背景圖 -->
        <div id="account-cover-image" style="width: 100%; height: 140px; background-color: var(--x-bg-secondary); background-size: cover; background-position: center; position: relative;"></div>

        <!-- 帳戶信息 -->
        <div style="padding: 8px 16px 0 16px;">
          <!-- 頭像和操作按鈕行 -->
          <div style="display: flex; justify-content: space-between; align-items: flex-start; position: relative; margin-bottom: 12px;">
            <!-- 頭像 -->
            <img id="account-avatar-image" src="" alt="帳戶頭像" style="width: 68px; height: 68px; border-radius: 50%; border: 4px solid var(--x-bg-primary); background-color: var(--x-bg-primary); position: absolute; top: -34px; left: 0; object-fit: cover; overflow: hidden; box-sizing: border-box;">
            
            <!-- 右側按鈕組 -->
            <div style="display: flex; gap: 8px; margin-left: auto; margin-top: 8px;">
              <!-- 私信按鈕 -->
              <button onclick="sendMessageToAccount()" style="
                width: 36px;
                height: 36px;
                border-radius: 50%;
                border: 1px solid var(--x-border-color);
                background: transparent;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                transition: background-color 0.2s;
              " onmouseover="this.style.backgroundColor='rgba(239,243,244,0.1)'" onmouseout="this.style.backgroundColor='transparent'">
                <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-text-primary);">
                  <g><path d="M1.998 5.5c0-1.381 1.119-2.5 2.5-2.5h15c1.381 0 2.5 1.119 2.5 2.5v13c0 1.381-1.119 2.5-2.5 2.5h-15c-1.381 0-2.5-1.119-2.5-2.5v-13zm2.5-.5c-.276 0-.5.224-.5.5v2.764l8 3.638 8-3.636V5.5c0-.276-.224-.5-.5-.5h-15zm15.5 5.463l-8 3.636-8-3.638V18.5c0 .276.224.5.5.5h15c.276 0 .5-.224.5-.5v-8.037z"></path></g>
                </svg>
              </button>

              <!-- 通知按鈕（關注後顯示） -->
              <button id="account-notify-btn" onclick="toggleAccountNotifications()" style="
                width: 36px;
                height: 36px;
                border-radius: 50%;
                border: 1px solid var(--x-border-color);
                background: transparent;
                display: none;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                transition: background-color 0.2s;
              " onmouseover="this.style.backgroundColor='rgba(239,243,244,0.1)'" onmouseout="this.style.backgroundColor='transparent'">
                <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-text-primary);">
                  <g><path d="M19.993 9.042C19.48 5.017 16.054 2 11.996 2s-7.49 3.021-7.999 7.051L2.866 18H7.1c.463 2.282 2.481 4 4.9 4s4.437-1.718 4.9-4h4.236l-1.143-8.958zM12 20c-1.306 0-2.417-.835-2.829-2h5.658c-.412 1.165-1.523 2-2.829 2zm-6.866-4l.847-6.698C6.364 6.272 8.941 4 11.996 4s5.627 2.268 6.013 5.295L18.864 16H5.134z"></path></g>
                </svg>
              </button>

              <!-- 關注按鈕 -->
              <button id="account-follow-btn" onclick="toggleAccountFollow()" style="
                min-width: 110px;
                height: 36px;
                border-radius: 18px;
                border: none;
                background: var(--x-text-primary);
                color: var(--x-bg-primary);
                font-size: 15px;
                font-weight: 700;
                cursor: pointer;
                transition: all 0.2s;
                padding: 0 16px;
              " onmouseover="if(this.textContent.includes('關注')||this.textContent.includes('Follow')){this.style.opacity='0.9';}" onmouseout="this.style.opacity='1';">
                關注
              </button>
            </div>
          </div>

          <!-- 帳戶名稱和認證 -->
          <div style="margin-bottom: 4px; margin-top: 8px; padding-left: 8px;">
            <div style="display: flex; align-items: center; gap: 4px;">
              <span id="account-display-name" style="color: var(--x-text-primary); font-size: 20px; font-weight: 800; line-height: 1.2;"></span>
              <div id="account-verified-badge" style="display: none;"></div>
            </div>
          </div>

          <!-- 帳戶控制碼 -->
          <div style="margin-bottom: 8px; padding-left: 8px;">
            <span id="account-handle-text" style="color: var(--x-text-secondary); font-size: 15px;"></span>
          </div>

          <!-- 簡介 -->
          <div id="account-bio-text" style="color: var(--x-text-primary); font-size: 15px; line-height: 20px; margin-bottom: 8px; padding-left: 8px; display: none;"></div>

          <!-- 自訂標籤 -->
          <div id="account-tags-container" style="display: flex; flex-wrap: wrap; gap: 12px; margin-bottom: 12px; padding-left: 8px;"></div>

          <!-- 關注資料 -->
          <div style="display: flex; gap: 20px; margin-bottom: 16px; padding-left: 8px;">
            <div style="cursor: pointer;" onmouseover="this.querySelector('span').style.textDecoration='underline'" onmouseout="this.querySelector('span').style.textDecoration='none'">
              <span id="account-following-count" style="color: var(--x-text-primary); font-weight: 700; font-size: 14px;">0</span>
              <span style="color: var(--x-text-secondary); margin-left: 4px; font-size: 14px;" data-i18n="accountFollowingLabel">正在關注</span>
            </div>
            <div style="cursor: pointer;" onmouseover="this.querySelector('span').style.textDecoration='underline'" onmouseout="this.querySelector('span').style.textDecoration='none'">
              <span id="account-followers-count" style="color: var(--x-text-primary); font-weight: 700; font-size: 14px;">0</span>
              <span style="color: var(--x-text-secondary); margin-left: 4px; font-size: 14px;" data-i18n="accountFollowersLabel">關注者</span>
            </div>
          </div>

          <!-- 關注提示 -->
          <div id="account-follows-you" style="display: none; color: var(--x-text-secondary); font-size: 13px; margin-bottom: 16px; padding-left: 8px;" data-i18n="accountFollowsYou">
            關注你
          </div>
        </div>

        <!-- 標籤欄 -->
        <div style="display: flex; border-bottom: 1px solid var(--x-border-color);">
          <div class="account-tab active" onclick="switchAccountTab('posts')" style="flex: 1; text-align: center; padding: 16px 0; font-size: 15px; font-weight: 700; color: var(--x-text-primary); cursor: pointer; position: relative; border-bottom: 4px solid var(--x-accent);">
            <span data-i18n="accountPostsTab">帖子</span>
          </div>
          <div class="account-tab" onclick="switchAccountTab('replies')" style="flex: 1; text-align: center; padding: 16px 0; font-size: 15px; font-weight: 500; color: var(--x-text-secondary); cursor: pointer; position: relative; border-bottom: 4px solid transparent;">
            <span data-i18n="accountRepliesTab">回復</span>
          </div>
          <div class="account-tab" onclick="switchAccountTab('likes')" style="flex: 1; text-align: center; padding: 16px 0; font-size: 15px; font-weight: 500; color: var(--x-text-secondary); cursor: pointer; position: relative; border-bottom: 4px solid transparent;">
            <span data-i18n="accountLikesTab">喜歡</span>
          </div>
        </div>

        <!-- 推文列表 -->
        <div id="account-tweets-container">
          <!-- 推文將動態插入這裡 -->
        </div>
      </div>
    </div>

    <!-- 帳戶提問箱頁面 -->
    <div id="account-askbox-page" class="x-page" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; display: none; flex-direction: column; overflow: hidden; z-index: 15;">
      <!-- 背景圖 -->
      <div id="account-askbox-background" style="
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-image: url('https://i.postimg.cc/tJvBC00j/mmexport1759642131681.jpg');
        background-size: cover;
        background-position: center;
        z-index: 0;
      "></div>

      <!-- 主內容區域 -->
      <div style="position: relative; z-index: 1; width: 100%; height: 100%; display: flex; flex-direction: column; overflow-y: auto; padding-top: 20px;">
        <!-- 頂部按鈕欄 -->
        <div style="display: flex; justify-content: space-between; align-items: center; padding: 20px 16px 12px 16px;">
          <!-- 返回按鈕 -->
          <div onclick="closeAccountAskbox()" style="cursor: pointer; padding: 8px; border-radius: 50%; background-color: rgba(255,255,255,0.2); backdrop-filter: blur(10px); transition: all 0.2s;"
            onmouseover="this.style.backgroundColor='rgba(255,255,255,0.3)'"
            onmouseout="this.style.backgroundColor='rgba(255,255,255,0.2)'">
            <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: #fff;">
              <path d="M7.414 13l5.043 5.04-1.414 1.42L3.586 12l7.457-7.46 1.414 1.42L7.414 11H21v2H7.414z"/>
            </svg>
          </div>

          <!-- 設置按鈕 -->
          <div onclick="openAccountAskboxSettings()" style="cursor: pointer; padding: 8px; border-radius: 50%; background-color: rgba(255,255,255,0.2); backdrop-filter: blur(10px); transition: all 0.2s;"
            onmouseover="this.style.backgroundColor='rgba(255,255,255,0.3)'"
            onmouseout="this.style.backgroundColor='rgba(255,255,255,0.2)'">
            <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: #fff;">
              <path d="M19.14 12.94c.04-.3.06-.61.06-.94 0-.32-.02-.64-.07-.94l2.03-1.58c.18-.14.23-.41.12-.61l-1.92-3.32c-.12-.22-.37-.29-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54c-.04-.24-.24-.41-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.05.3-.09.63-.09.94s.02.64.07.94l-2.03 1.58c-.18.14-.23.41-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z"/>
            </svg>
          </div>
        </div>

        <!-- 頭像和昵稱區域 -->
        <div style="display: flex; flex-direction: column; align-items: center; padding: 20px 16px;">
          <!-- 頭像 -->
          <div onclick="changeAccountAskboxAvatar()" style="cursor: pointer; margin-bottom: 12px; position: relative; transition: transform 0.2s;"
            onmouseover="this.style.transform='scale(1.05)'"
            onmouseout="this.style.transform='scale(1)'">
            <img id="account-askbox-avatar" src="https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg" 
              style="width: 80px; height: 80px; border-radius: 50%; border: 3px solid rgba(255,255,255,0.8); box-shadow: 0 4px 12px rgba(0,0,0,0.15);">
          </div>

          <!-- 昵稱/ID區域 -->
          <div style="display: flex; align-items: center; gap: 8px; background-color: rgba(255,255,255,0.15); backdrop-filter: blur(10px); padding: 6px 12px; border-radius: 20px;">
            <span id="account-askbox-nickname" 
              contenteditable="true"
              style="color: #fff; font-size: 14px; font-weight: 500; outline: none; cursor: text; min-width: 20px;"
              onblur="saveAccountAskboxNickname()"
              onkeydown="if(event.key==='Enter'){event.preventDefault();this.blur();}">⩌⌯⩌</span>
          </div>
        </div>

        <!-- 提問卡片 -->
        <div style="
          margin: 0 20px 24px 20px;
          background-color: rgba(255,255,255,0.9);
          backdrop-filter: blur(10px);
          border-radius: 16px;
          padding: 32px 24px;
          box-shadow: 0 4px 16px rgba(0,0,0,0.1);
          transition: all 0.2s;
          min-height: 120px;
          display: flex;
          align-items: center;
          justify-content: center;
        ">
          <div id="account-askbox-prompt" 
            contenteditable="true"
            style="
            color: #333;
            font-size: 16px;
            line-height: 1.6;
            text-align: center;
            word-break: break-word;
            outline: none;
            cursor: text;
            width: 100%;
          "
          onblur="saveAccountAskboxPrompt()"
          onkeydown="if(event.key==='Enter'&&!event.shiftKey){event.preventDefault();this.blur();}">在這裡輸入你的匿名提問，或點擊下方按鈕生成隨機提問...</div>
        </div>

        <!-- 獲取新提問/提交提問按鈕 -->
        <div onclick="getNewAccountQuestion()" style="
          margin: 0 20px 32px 20px;
          background-color: rgba(255,255,255,0.85);
          backdrop-filter: blur(10px);
          border-radius: 24px;
          padding: 14px 24px;
          text-align: center;
          cursor: pointer;
          transition: all 0.2s;
          box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        " onmouseover="this.style.backgroundColor='rgba(255,255,255,0.95)'; this.style.transform='translateY(-1px)'"
          onmouseout="this.style.backgroundColor='rgba(255,255,255,0.85)'; this.style.transform='translateY(0)'">
          <span style="color: #333; font-size: 15px; font-weight: 600;">獲取回答 / 生成隨機提問</span>
        </div>

        <!-- 已回答的提問列表 -->
        <div style="padding: 0 20px 20px 20px;">
          <div id="account-answered-questions-title" style="
            color: rgba(255,255,255,0.8);
            font-size: 15px;
            font-weight: 500;
            margin-bottom: 16px;
            text-align: center;
            display: none;
          ">最新提問如下</div>
          <div id="account-answered-questions-list">
            <!-- 已回答的提問將動態載入在這裡 -->
          </div>
        </div>
      </div>
    </div>
  </div>

    <!-- 底部巡覽列 -->
    <div class="x-bottom-nav"
      style="display: flex; justify-content: space-around; padding: 10px 0; border-top: 1px solid #333; background-color: #000;">
      <!-- 主頁圖示 -->
      <div class="x-nav-item active" onclick="switchXPage('home')"
        style="display: flex; justify-content: center; align-items: center; position: relative; padding: 5px 15px; cursor: pointer;">
        <svg viewBox="0 0 24 24" aria-hidden="true" style="width: 26px; height: 26px; fill: var(--x-accent);">
          <g>
            <path
              d="M12 1.696L.622 8.807l1.06 1.696L3 9.679V19.5C3 20.881 4.119 22 5.5 22h13c1.381 0 2.5-1.119 2.5-2.5V9.679l1.318.824 1.06-1.696L12 1.696zM12 16.5c-1.933 0-3.5-1.567-3.5-3.5s1.567-3.5 3.5-3.5 3.5 1.567 3.5 3.5-1.567 3.5-3.5 3.5z">
            </path>
          </g>
        </svg>
        <!-- 提醒點 -->
        <div id="home-notification-dot" style="
          position: absolute;
          top: 2px;
          right: 8px;
          width: 8px;
          height: 8px;
          background-color: var(--x-accent);
          border-radius: 50%;
          border: 2px solid var(--x-bg-primary);
          display: none;
        "></div>
        <!-- 高亮效果 -->
        <div class="nav-highlight"
          style="position: absolute; width: 5px; height: 5px; background-color: var(--x-accent); border-radius: 50%; bottom: -8px;">
        </div>
      </div>

      <!-- 搜索圖示 -->
      <div class="x-nav-item" onclick="switchXPage('search')"
        style="display: flex; justify-content: center; align-items: center; position: relative; padding: 5px 15px; cursor: pointer;">
        <svg viewBox="0 0 24 24" aria-hidden="true" style="width: 26px; height: 26px; fill: #fff;">
          <g>
            <path
              d="M10.25 3.75c-3.59 0-6.5 2.91-6.5 6.5s2.91 6.5 6.5 6.5c1.795 0 3.419-.726 4.596-1.904 1.178-1.177 1.904-2.801 1.904-4.596 0-3.59-2.91-6.5-6.5-6.5zm-8.5 6.5c0-4.694 3.806-8.5 8.5-8.5s8.5 3.806 8.5 8.5c0 1.986-.682 3.815-1.824 5.262l4.781 4.781-1.414 1.414-4.781-4.781c-1.447 1.142-3.276 1.824-5.262 1.824-4.694 0-8.5-3.806-8.5-8.5z">
            </path>
          </g>
        </svg>
        <div class="nav-highlight"
          style="position: absolute; width: 5px; height: 5px; background-color: var(--x-accent); border-radius: 50%; bottom: -8px; display: none;">
        </div>
      </div>

      <!-- 通知圖示 -->
      <div class="x-nav-item" onclick="switchXPage('notifications')"
        style="display: flex; justify-content: center; align-items: center; position: relative; padding: 5px 15px; cursor: pointer;">
        <svg viewBox="0 0 24 24" aria-hidden="true" style="width: 26px; height: 26px; fill: #fff;">
          <g>
            <path
              d="M19.993 9.042C19.48 5.017 16.054 2 11.996 2s-7.49 3.021-7.999 7.051L2.866 18H7.1c.463 2.282 2.481 4 4.9 4s4.437-1.718 4.9-4h4.236l-1.143-8.958zM12 20c-1.306 0-2.417-.835-2.829-2h5.658c-.412 1.165-1.523 2-2.829 2zm-6.866-4l.847-6.698C6.364 6.272 8.941 4 11.996 4s5.627 2.268 6.013 5.295L18.864 16H5.134z">
            </path>
          </g>
        </svg>
        <!-- 提醒點 -->
        <div id="notifications-notification-dot" style="
          position: absolute;
          top: 2px;
          right: 8px;
          width: 8px;
          height: 8px;
          background-color: var(--x-accent);
          border-radius: 50%;
          border: 2px solid var(--x-bg-primary);
          display: none;
        "></div>
        <div class="nav-highlight"
          style="position: absolute; width: 5px; height: 5px; background-color: var(--x-accent); border-radius: 50%; bottom: -8px; display: none;">
        </div>
      </div>

      <!-- 私信圖示 -->
      <div class="x-nav-item" onclick="switchXPage('messages')"
        style="display: flex; justify-content: center; align-items: center; position: relative; padding: 5px 15px; cursor: pointer;">
        <svg viewBox="0 0 24 24" aria-hidden="true" style="width: 26px; height: 26px; fill: #fff;">
          <g>
            <path
              d="M1.998 5.5c0-1.381 1.119-2.5 2.5-2.5h15c1.381 0 2.5 1.119 2.5 2.5v13c0 1.381-1.119 2.5-2.5 2.5h-15c-1.381 0-2.5-1.119-2.5-2.5v-13zm2.5-.5c-.276 0-.5.224-.5.5v2.764l8 3.638 8-3.636V5.5c0-.276-.224-.5-.5-.5h-15zm15.5 5.463l-8 3.636-8-3.638V18.5c0 .276.224.5.5.5h15c.276 0 .5-.224.5-.5v-8.037z">
            </path>
          </g>
        </svg>
        <!-- 提醒點 -->
        <div id="messages-notification-dot" style="
          position: absolute;
          top: 2px;
          right: 8px;
          width: 8px;
          height: 8px;
          background-color: var(--x-accent);
          border-radius: 50%;
          border: 2px solid var(--x-bg-primary);
          display: none;
        "></div>
        <div class="nav-highlight"
          style="position: absolute; width: 5px; height: 5px; background-color: var(--x-accent); border-radius: 50%; bottom: -8px; display: none;">
        </div>
      </div>
    </div>
  <!-- ▲▲▲ X社交頁面結束 ▲▲▲ -->
    `;

    // 將創建的HTML添加到body
    document.body.appendChild(container);
    console.log('✅ X Social App: HTML結構已創建');
  }

  // ============================================
  // 第三部分: 核心JavaScript功能
  // ============================================

  // === 工具函數集合 (從31766行開始) ===

  // X社交專用資料庫配置函數
  function getXDB() {
    const db = new Dexie('XSocialDB');
    // 版本1：初始表結構
    db.version(1).stores({
      xTweetsData: '&id',
      xSettings: '&id',
      xPresets: '++id, name, createdAt',
      xUserProfile: '&id',
      xUserTweets: '&id',
      xCharacterProfiles: '&characterId',
      xActiveAccount: '&id',
      xAccountList: '&accountId, name, createdAt',
      xNPCs: '&id',
      xAskbox: '&id',
    });
    // 版本2：添加帳戶主頁和帳戶提問箱表
    db.version(2).stores({
      xTweetsData: '&id',
      xSettings: '&id',
      xPresets: '++id, name, createdAt',
      xUserProfile: '&id',
      xUserTweets: '&id',
      xCharacterProfiles: '&characterId',
      xActiveAccount: '&id',
      xAccountList: '&accountId, name, createdAt',
      xNPCs: '&id',
      xAskbox: '&id',
      xAccountProfiles: '&handle, name, updatedAt',
      xAccountAskbox: '&id',
    });
    // 版本3：添加角色關係冊表
    db.version(3).stores({
      xTweetsData: '&id',
      xSettings: '&id',
      xPresets: '++id, name, createdAt',
      xUserProfile: '&id',
      xUserTweets: '&id',
      xCharacterProfiles: '&characterId',
      xActiveAccount: '&id',
      xAccountList: '&accountId, name, createdAt',
      xNPCs: '&id',
      xAskbox: '&id',
      xAccountProfiles: '&handle, name, updatedAt',
      xAccountAskbox: '&id',
      xCharacterRelationships: '&id, accountId, lastUpdated',
    });
    // 版本4：確保所有表都存在
    db.version(4).stores({
      xTweetsData: '&id',
      xSettings: '&id',
      xPresets: '++id, name, createdAt',
      xUserProfile: '&id',
      xUserTweets: '&id',
      xCharacterProfiles: '&characterId',
      xActiveAccount: '&id',
      xAccountList: '&accountId, name, createdAt',
      xNPCs: '&id',
      xAskbox: '&id',
      xAccountProfiles: '&handle, name, updatedAt',
      xAccountAskbox: '&id',
      xCharacterRelationships: '&id, accountId, lastUpdated',
    });
    // 版本5：添加書簽表（多帳戶隔離）
    db.version(5).stores({
      xTweetsData: '&id',
      xSettings: '&id',
      xPresets: '++id, name, createdAt',
      xUserProfile: '&id',
      xUserTweets: '&id',
      xCharacterProfiles: '&characterId',
      xActiveAccount: '&id',
      xAccountList: '&accountId, name, createdAt',
      xNPCs: '&id',
      xAskbox: '&id',
      xAccountProfiles: '&handle, name, updatedAt',
      xAccountAskbox: '&id',
      xCharacterRelationships: '&id, accountId, lastUpdated',
      xBookmarks: '&id, accountId, tweetId, bookmarkedAt',
    });
    // 版本6：添加喜歡表（多帳戶隔離）
    db.version(6).stores({
      xTweetsData: '&id',
      xSettings: '&id',
      xPresets: '++id, name, createdAt',
      xUserProfile: '&id',
      xUserTweets: '&id',
      xCharacterProfiles: '&characterId',
      xActiveAccount: '&id',
      xAccountList: '&accountId, name, createdAt',
      xNPCs: '&id',
      xAskbox: '&id',
      xAccountProfiles: '&handle, name, updatedAt',
      xAccountAskbox: '&id',
      xCharacterRelationships: '&id, accountId, lastUpdated',
      xBookmarks: '&id, accountId, tweetId, bookmarkedAt',
      xLikes: '&id, accountId, tweetId, likedAt',
    });
    return db;
  }

  // 原有全域資料庫配置函數 - 用於訪問API配置和角色資訊
  function getDB() {
    return window.db; // 通過window訪問
  }

  // 常用DOM操作工具函數
  const DOMUtils = {
    hide: selector => document.querySelectorAll(selector).forEach(el => (el.style.display = 'none')),
    show: (selector, display = 'block') =>
      document.querySelectorAll(selector).forEach(el => (el.style.display = display)),
    removeClass: (selector, className) =>
      document.querySelectorAll(selector).forEach(el => el.classList.remove(className)),
    addClass: (selector, className) => document.querySelectorAll(selector).forEach(el => el.classList.add(className)),
    setStyle: (selector, property, value) =>
      document.querySelectorAll(selector).forEach(el => (el.style[property] = value)),
  };

  // 字串構建工具函數 - 簡化重複的拼接邏輯
  const StringBuilders = {
    // 構建角色資訊字串
    buildCharacterInfo(char, xProfile, userXProfileInfo) {
      let info = `\n角色名：${char.name}`;
      info += `\n本名：${char.originalName}`;
      info += `\n人設：${char.settings.aiPersona || '無特定人設'}`;

      // 情侶認證關係
      if (userXProfileInfo.verificationType === 'couple' && userXProfileInfo.coupleCharacterId === char.id) {
        info += `\n【特殊關係】：該角色是使用者的情侶認證物件，所有X平臺觀眾都知道這層關係`;
      }

      // X平臺身份資訊
      info += `\n【X平臺身份（必須嚴格使用）】：`;
      info += `\n- X用戶名：${xProfile.xName}`;
      info += `\n- X控制碼：@${xProfile.xHandle}`;
      info += `\n- X頭像：${xProfile.xAvatar}`;
      info += `\n- 認證狀態：${xProfile.xVerified ? '是' : '否'}`;

      if (xProfile.xBio) info += `\n- X簡介：${xProfile.xBio}`;
      if (xProfile.publicIdentity) info += `\n- 公眾身份：${xProfile.publicIdentity}`;
      if (xProfile.showRealName && xProfile.realName) {
        info += `\n- 真實姓名：${xProfile.realName}（已公開）`;
      }

      return info;
    },

    // 構建使用者身份識別資訊
    buildUserIdentityInfo(char, xProfile, userXProfileInfo) {
      const knowsUserIdentity = userXProfileInfo.knownIdentityCharacters.includes(char.id);
      let info = `\n【用戶身份識別】：${knowsUserIdentity ? '知道用戶身份' : '不知道用戶身份'}`;

      if (knowsUserIdentity) {
        info += `\n- 該角色可以識別用戶帳號 ${userXProfileInfo.handle}（${userXProfileInfo.name}）`;
        info += `\n- 可以根據角色特定的使用者人設與用戶自然互動，回復時表現出認識`;

        const characterUserPersona = xProfile && xProfile.userPersona ? xProfile.userPersona : '';
        if (characterUserPersona.trim()) {
          info += `\n- 該角色瞭解的使用者資訊：${characterUserPersona.substring(0, 150)}${
            characterUserPersona.length > 150 ? '...' : ''
          }`;
        } else {
          info += `\n- 該角色尚未設置使用者人設資訊，按基礎認識模式互動`;
        }
      } else {
        info += `\n- 該角色完全不知道用戶的真實身份，按照陌生人模式回復`;
      }

      return info;
    },

    // 構建NPC關係資訊
    buildNPCRelationships(xProfile) {
      if (!xProfile.relationships || xProfile.relationships.length === 0) return '';

      let info = `\n【已綁定NPC關係】：`;
      xProfile.relationships.forEach(rel => {
        info += `\n- ${rel.npcName} (${rel.npcHandle}): ${rel.relationshipType}`;
        if (rel.description) info += ` | ${rel.description}`;
      });
      info += `\n注意：當該角色參與回復時，其綁定的NPC也可能出現在回復中，要體現相應的關係特點。`;
      return info;
    },

    // 構建記憶資訊
    buildMemoryInfo(char) {
      let info = '';
      if (char.history && char.history.length > 0) {
        const recentHistory = char.history.slice(-10);
        info += '\n最近聊天記憶：';
        recentHistory.forEach(msg => {
          if (msg.role === 'assistant' && msg.content) {
            info += `\n- ${char.name}: ${msg.content.substring(0, 100)}...`;
          }
        });
      }

      if (char.longTermMemory && char.longTermMemory.length > 0) {
        info += '\n長期記憶：';
        char.longTermMemory.forEach(mem => {
          info += `\n- ${mem.content}`;
        });
      }

      return info;
    },

    // 構建完整角色資訊（需要從資料庫獲取資料）
    // scenario: 'tweet' | 'reaction' | 'reply'
    // 🎯 優化版：使用統一資料獲取系統
    async buildCompleteCharacterInfo(boundCharacters, userXProfileInfo, scenario = 'reply') {
      if (!boundCharacters || boundCharacters.length === 0) return '';

      const mainDB = getDB();
      const xDB = getXDB();

      // 獲取所有角色的X資料（用於提取控制碼）
      const allXProfiles = await xDB.xCharacterProfiles.toArray();
      const characterHandles = [];

      for (const charId of boundCharacters) {
        const xProfile = allXProfiles.find(p => p.characterId === charId);
        if (xProfile && xProfile.xHandle) {
          characterHandles.push(xProfile.xHandle);
        }
      }

      if (characterHandles.length === 0) return '';

      // 🎯 使用統一資料獲取系統批量獲取角色資料（傳遞使用者資訊以正確讀取私信等資料）
      const profiles = await this.getBatchProfiles(characterHandles, { userProfileInfo: userXProfileInfo });

      if (profiles.length === 0) return '';

      // 根據場景選擇合適的描述
      let scenarioTitle = '';
      if (scenario === 'tweet') {
        scenarioTitle = '\n\n【綁定角色資訊】以下綁定角色可以作為推文發佈者，根據其設定和興趣發佈推文：\n';
      } else if (scenario === 'reaction') {
        scenarioTitle =
          '\n\n【綁定角色資訊】以下綁定角色可以對推文進行互動（評論、點贊等），根據角色設定和話題相關性決定是否互動：\n';
      } else {
        scenarioTitle = '\n\n【綁定角色資訊】以下綁定角色可以參與回復，根據角色設定和話題相關性決定是否回復：\n';
      }

      let charactersInfo = scenarioTitle;

      // 遍歷每個角色資料，格式化輸出
      for (const profile of profiles) {
        if (profile.type !== 'character') continue;

        charactersInfo += this.formatProfileForPrompt(profile, {
          includeType: false, // 不顯示類型標識（已經在scenarioTitle中說明）
          includeTweets: true,
          includeRelationships: true,
        });

        // 添加使用者身份識別資訊
        const knowsUserIdentity = userXProfileInfo.knownIdentityCharacters.includes(profile._characterId);
        charactersInfo += `\n【用戶身份識別】：${knowsUserIdentity ? '知道用戶身份' : '不知道用戶身份'}`;

        if (knowsUserIdentity) {
          charactersInfo += `\n- 該角色可以識別用戶帳號 ${userXProfileInfo.handle}（${userXProfileInfo.name}）`;
          charactersInfo += `\n- 可以根據角色特定的使用者人設與用戶自然互動，回復時表現出認識`;

          const characterUserPersona =
            profile.characterData && profile.characterData.userPersona ? profile.characterData.userPersona : '';
          if (characterUserPersona.trim()) {
            charactersInfo += `\n- 該角色瞭解的使用者資訊：${characterUserPersona.substring(0, 150)}${
              characterUserPersona.length > 150 ? '...' : ''
            }`;
          } else {
            charactersInfo += `\n- 該角色尚未設置使用者人設資訊，按基礎認識模式互動`;
          }
        } else {
          charactersInfo += `\n- 該角色完全不知道用戶的真實身份，按照陌生人模式回復`;
        }

        charactersInfo += '\n\n';
      }

      // 根據場景添加不同的要求說明
      if (scenario === 'tweet') {
        charactersInfo += `
【角色發推要求】：
- 角色發推內容要符合其人設、興趣和性格特點
- 知道用戶身份的角色：可以在推文中自然地@使用者或提及使用者相關話題
- 不知道用戶身份的角色：發佈獨立推文，不涉及用戶
- 推文內容應該多樣化：日常生活、興趣愛好、工作學習、情感分享等

【NPC關係互動】：
- 有綁定NPC關係的角色，其NPC可能在其推文下評論互動
- NPC用戶名、控制碼與關係設定保持一致，頭像統一使用預設頭像，認證狀態為"否"
- 同一NPC保持身份和性格一致性`;
      } else if (scenario === 'reaction') {
        charactersInfo += `
【角色互動要求】：
- 角色互動（評論/點贊）要符合其人設和興趣，與推文內容相關
- 知道用戶身份的角色：在使用者發佈的推文下可以表現出認識，自然互動
- 不知道用戶身份的角色：按照陌生人模式互動，不知道發佈者身份
- 互動應該自然真實，就像普通用戶一樣

【NPC關係互動】：
- 有綁定NPC關係的角色，其NPC可在評論中出現，體現關係特點
- NPC用戶名、控制碼與關係設定保持一致，頭像統一使用預設頭像，認證狀態為"否"
- 同一NPC保持身份和性格一致性`;
      } else {
        charactersInfo += `
【角色回復要求】：
- 角色回復要自然真實，就像普通用戶回復一樣
- 知道用戶身份的角色：回復時可表現出認識，體現對使用者的瞭解
- 不知道用戶身份的角色：按照陌生人模式回復，不知道使用者帳號資訊

【NPC關係互動】：
- 有綁定NPC關係的角色，其NPC可在回復中出現，體現關係特點
- NPC用戶名、控制碼與關係設定保持一致，頭像統一使用預設頭像，認證狀態為"否"
- 同一NPC保持身份和性格一致性，不認識的NPC間不互相@或提及`;
      }

      return charactersInfo;
    },

    // 構建基礎系統提示詞（通用版本）- 只包含提示詞+世界書
    buildBaseSystemPrompt({ userPrompt, worldSetting }) {
      let systemPrompt = '';

      // 1. 用戶自訂提示詞
      if (userPrompt.trim()) systemPrompt += userPrompt.trim() + '\n\n';

      // 2. 世界觀設定
      systemPrompt += '【世界觀設定約束】：';
      if (worldSetting.trim()) {
        systemPrompt += `
${worldSetting.trim()}

上述世界觀設定是最高優先順序的約束條件，必須嚴格遵守。`;
      } else {
        systemPrompt += `
無特殊世界觀限制，但內容需健康正面，符合社交平臺規範。`;
      }

      return systemPrompt;
    },

    // 構建使用者X個人資料資訊
    buildUserXProfileInfo(userProfileData) {
      return {
        name: userProfileData.name,
        handle: userProfileData.handle,
        avatar: userProfileData.avatar,
        bio: userProfileData.bio,
        verified: userProfileData.verified,
        verificationType: userProfileData.verificationType || 'none',
        coupleCharacterId: userProfileData.coupleCharacterId || '',
        coupleCharacterName: userProfileData.coupleCharacterName || '',
        publicIdentity: userProfileData.publicIdentity || '',
        showRealName: userProfileData.showRealName || false,
        realName: userProfileData.realName || '',
        knownIdentityCharacters: userProfileData.knownIdentityCharacters || [],
      };
    },

    // 構建通用約束條件
    buildUniversalConstraints(userXProfileInfo) {
      const verificationDesc = this.getUserVerificationTypeDescription(userXProfileInfo);

      return `

🚫🚫🚫 【核心禁令 - 最高優先順序】 🚫🚫🚫
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
**絕對禁止以使用者身份生成任何內容！**

使用者身份標識（禁止使用）：
- 用戶名：${userXProfileInfo.name}
- 用戶控制碼：${userXProfileInfo.handle}
- 🚨 警告：用戶是獨立的個體，不要與任何綁定角色混淆！
- 🚨 警告：不要將綁定角色誤認為用戶！
- 使用者資訊：僅供理解上下文，嚴禁在生成內容中使用

**你只能生成以下身份的內容**：
✅ 綁定角色（使用提供的xName、xHandle、xAvatar等）
✅ 虛構的普通X平臺用戶（自創用戶名和控制碼）
❌ 絕對不能生成用戶本人發表的任何推文/評論/回復
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【用戶X平臺公開身份】（所有觀眾都知道的公開信息）：
- 用戶名：${userXProfileInfo.name}（這是用戶，不是角色！）
- 用戶控制碼：${userXProfileInfo.handle}（這是使用者的唯一標識！）
- 認證狀態：${userXProfileInfo.verified ? '已認證' : '未認證'}
- 認證類型：${verificationDesc}
${
  userXProfileInfo.verificationType === 'couple' && userXProfileInfo.coupleCharacterName
    ? `- 情侶關係：與${userXProfileInfo.coupleCharacterName}為公開情侶（觀眾可知）`
    : ''
}
${userXProfileInfo.publicIdentity ? `- 公眾身份：${userXProfileInfo.publicIdentity}` : ''}
${userXProfileInfo.bio ? `- 個人簡介：${userXProfileInfo.bio}` : ''}

【身份識別關鍵點】：
🚨 用戶 vs 角色的區別：
- 用戶（${userXProfileInfo.name} / ${userXProfileInfo.handle}）：真實操作者，你絕對不能模擬其發言
- 綁定角色：已設定的虛擬角色，有各自的X平臺身份（xName、xHandle），你可以生成他們的內容
- 🚨 特別注意：即使某個角色與用戶有關係（如情侶），也不要將該角色當成用戶本人！

【許可權分級 - 路人評論者的認知範圍】：
🔓 路人可見（X平臺公開信息）：
  - 用戶/角色的X姓名、X控制碼、認證狀態
  - X簡介、公眾身份、公開的情侶關係
  - X平臺上發佈的推文內容

🔒 路人禁知（私密信息）：
  - 真實姓名、真實職業、真實身份
  - 角色人設描述、性格細節、AI人格設定
  - 聊天記憶、私人對話、使用者專屬人設
  - 只有親密關係才知道的資訊（除非是已綁定的關係NPC）
  
⚠️ 路人評論規則：
  - 路人只能基於🔓公開信息進行評論
  - 禁止在評論中提及🔒私密資訊
  - 禁止使用只有親密關係才知道的稱呼（如"老師"、"同學"等，除非是公開身份）`;
    },

    // 獲取認證類型描述
    getUserVerificationTypeDescription(userXProfileInfo) {
      switch (userXProfileInfo.verificationType) {
        case 'verified':
          return '藍色勾標認證';
        case 'couple':
          return '情侶認證';
        case 'married':
          return '已婚認證';
        case 'vip':
          return 'VIP認證';
        default:
          return '無認證';
      }
    },

    // 構建場景分支提示詞
    buildScenarioPrompt({ isOwnPost, commentType, pageType, parentComment, targetCommentEl }) {
      let scenarioPrompt = '\n\n【場景識別】：';

      if (isOwnPost && commentType === 'main_comment') {
        scenarioPrompt += `用戶在自己發佈的推文下方發表了評論。
【任務】：生成其他用戶對她評論的反應回復，或新的話題相關評論。`;
      } else if (isOwnPost && commentType === 'reply_comment') {
        scenarioPrompt += `用戶在自己發佈的推文的評論區樓中樓發表了回復。
【任務】：生成其他用戶對這條樓中樓回復的反應，或話題相關的新回復。`;
      } else if (!isOwnPost && commentType === 'main_comment') {
        scenarioPrompt += `用戶在別人發佈的推文下方發表了評論。
【任務】：生成其他用戶（包括原推作者）對此評論的互動回復。`;
      } else if (!isOwnPost && commentType === 'reply_comment') {
        scenarioPrompt += `用戶在別人發佈的推文的評論區樓中樓發表了回復。
【任務】：生成其他用戶對此樓中樓回復的反應，可能包括被回復者本人。`;
      }

      // 添加通用生成要求
      scenarioPrompt += `

【生成要求】：
1. 社交真實性：類比真實的X平臺使用者互動，語言自然流暢
2. 情緒共鳴：根據原推內容和使用者評論，生成有情感共鳴的回應
3. 多樣化互動：可以是贊同、反對、補充、提問、調侃等多種類型
4. 身份一致：每個角色回復都要符合其設定的身份和性格特點
5. 避免重複：多個回復之間保持內容和表達方式的差異性

【格式要求】：
- 每條回復獨立成段，以"【回復X】"開頭標記
- 嚴格按照角色的X平臺身份資訊生成，不得擅自修改用戶名、控制碼等
- 回復長度適中，符合社交媒體特點（一般20-200字）
- 可以適當使用emoji表情，但不要過度`;

      return scenarioPrompt;
    },

    // ========== 統一資料獲取工具 ==========
    // 通過控制碼獲取任何類型的完整資料（角色/帳戶/陌生人）
    // options: { userProfileInfo, messageId } - 傳入使用者資料以檢查身份識別，messageId用於讀取陌生人自訂設置
    async getUnifiedProfile(handle, options = {}) {
      try {
        const cleanHandle = handle.replace('@', '').trim();
        if (!cleanHandle) return null;

        console.log(`🔍 [統一資料] 查詢控制碼: ${cleanHandle}`);

        // 0. 🆕 檢查是否是用戶自己
        // 使用者控制碼可能存儲在多個欄位中，按優先順序嘗試
        let userXHandle =
          window.userProfileData?.xHandle || window.userProfileData?.handle || window.userProfileData?.username;

        if (userXHandle) {
          userXHandle = userXHandle.replace('@', '').trim();
        }

        console.log(
          `🔍 [統一資料] 使用者控制碼對比: 查詢="${cleanHandle}" vs 用戶="${userXHandle}" (來源: xHandle=${window.userProfileData?.xHandle}, handle=${window.userProfileData?.handle}, username=${window.userProfileData?.username})`,
        );

        // 不區分大小寫比較控制碼
        if (userXHandle && cleanHandle.toLowerCase() === userXHandle.toLowerCase()) {
          // 使用者資料欄位映射（相容不同的欄位名）
          const userName = window.userProfileData.name || window.userProfileData.xName || '用戶';
          const userHandle = window.userProfileData.handle || window.userProfileData.xHandle || `@${userXHandle}`;
          const userAvatar =
            window.userProfileData.avatar ||
            window.userProfileData.xAvatar ||
            'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg';
          const userVerified = window.userProfileData.verified || window.userProfileData.xVerified || false;
          const userBio = window.userProfileData.bio || window.userProfileData.xBio || '';
          const userCover = window.userProfileData.cover || window.userProfileData.xCover || '';

          console.log(`✅ [統一資料] 找到使用者自己: ${userName} (${userHandle})`);

          // 返回使用者的X資料
          const userProfile = {
            type: 'user',
            name: userName,
            handle: userHandle,
            avatar: userAvatar,
            verified: userVerified,
            publicIdentity: window.userProfileData.publicIdentity || '',
            bio: userBio,
            xProfile: {
              xName: userName,
              xHandle: userHandle,
              xAvatar: userAvatar,
              xVerified: userVerified,
              xBio: userBio,
              xCover: userCover,
            },
            // 使用者沒有"認識使用者"這個概念
            knowsUserIdentity: false,
            xMessageHistory: [],
            recentTweets: [],
          };
          return userProfile;
        }

        // 1. 嘗試作為角色查詢
        const characterProfile = await this._getCharacterProfileByHandle(cleanHandle, options.userProfileInfo);
        if (characterProfile) {
          console.log(`✅ [統一資料] 找到角色: ${characterProfile.name}`);
          return characterProfile;
        }

        // 2. 嘗試作為綁定NPC查詢
        const npcProfile = await this._getNPCProfileByHandle(cleanHandle);
        if (npcProfile) {
          console.log(`✅ [統一資料] 找到綁定NPC: ${npcProfile.name}`);
          return npcProfile;
        }

        // 3. 嘗試作為關係NPC查詢
        const relationshipNpcProfile = await this._getRelationshipNPCProfileByHandle(cleanHandle);
        if (relationshipNpcProfile) {
          console.log(`✅ [統一資料] 找到關係NPC: ${relationshipNpcProfile.name}`);
          return relationshipNpcProfile;
        }

        // 4. 嘗試作為帳戶查詢
        const accountProfile = await this._getAccountProfileByHandle(cleanHandle);
        if (accountProfile) {
          console.log(`✅ [統一資料] 找到帳戶: ${accountProfile.name}`);
          return accountProfile;
        }

        // 5. 作為陌生人返回（傳入messageId以讀取自訂設置）
        console.log(`ℹ️ [統一資料] 未找到匹配，創建陌生人範本`);
        return await this._createStrangerProfile(handle, options.messageId);
      } catch (error) {
        console.error('[統一資料] 查詢失敗:', error);
        return null;
      }
    },

    // 內部方法：通過控制碼獲取角色資料
    // userProfileInfo: 使用者資料資訊，用於檢查該角色是否識別用戶身份
    async _getCharacterProfileByHandle(cleanHandle, userProfileInfo = null) {
      try {
        const xDB = getXDB();
        const mainDB = getDB();

        // 從 xCharacterProfiles 查找
        const allXProfiles = await xDB.xCharacterProfiles.toArray();
        const xProfile = allXProfiles.find(
          p => p.xHandle && p.xHandle.replace('@', '').toLowerCase() === cleanHandle.toLowerCase(),
        );

        if (!xProfile) return null;

        // 獲取角色詳細資訊
        const allChats = await mainDB.chats.toArray();
        const character = allChats.find(c => c.id === xProfile.characterId);

        if (!character) return null;

        // 獲取角色的推文
        const accountProfile = await xDB.xAccountProfiles.get(cleanHandle);
        const tweets = accountProfile?.tweets || [];

        // 🔧 檢查該角色是否識別用戶身份
        let knowsUserIdentity = false;
        if (userProfileInfo && userProfileInfo.knownIdentityCharacters) {
          knowsUserIdentity = userProfileInfo.knownIdentityCharacters.includes(character.id);
        }
        console.log(
          `👤 [身份識別] 角色 ${xProfile.xName} ${knowsUserIdentity ? '✅ 知道' : '❌ 不知道'}用戶身份${
            knowsUserIdentity && xProfile.userPersona ? ' (有專屬人設)' : knowsUserIdentity ? ' (無專屬人設)' : ''
          }`,
        );

        // 🆕 讀取X平臺私信記憶
        let xMessageHistory = [];
        try {
          const currentAccount = window.currentAccountId || 'main';

          // 嘗試在多個帳戶下查找（當前帳戶優先，然後是main帳戶）
          const accountsToTry = [currentAccount];
          if (currentAccount !== 'main') {
            accountsToTry.push('main');
          }

          let messageConversation = null;

          // 嘗試查找角色的私信對話
          for (const accountId of accountsToTry) {
            const messageConversationId = `messageConversation_${accountId}_msg_${character.id}`;
            const data = await xDB.xAccountProfiles.get(messageConversationId);

            if (data && data.data && data.data.messages) {
              messageConversation = data;
              break;
            }
          }

          if (messageConversation && messageConversation.data && messageConversation.data.messages) {
            // 提取最近的私信對話（最多30條）
            const messages = messageConversation.data.messages.slice(-50);
            xMessageHistory = messages.map(msg => ({
              type: msg.type,
              content: msg.content || '',
              isOwn: msg.isOwn || false,
              time: msg.time || '',
              timestamp: msg.timestamp || '',
            }));
            console.log(`✅ [私信數據] 角色 ${xProfile.xName}: ${xMessageHistory.length} 條記憶`);
          }
        } catch (error) {
          console.error(`❌ [私信數據] 角色 ${xProfile.xName} 讀取失敗:`, error);
        }

        return {
          type: 'character',
          // 基礎資訊
          name: xProfile.xName,
          handle: xProfile.xHandle,
          avatar: xProfile.xAvatar,
          bio: xProfile.xBio || '',
          verified: xProfile.xVerified || false,
          publicIdentity: xProfile.publicIdentity || '',

          // 角色特有資料
          characterData: {
            id: character.id,
            originalName: character.originalName,
            aiPersona: character.settings?.aiPersona || '',
            history: character.history || [],
            longTermMemory: character.longTermMemory || [],
            userPersona: xProfile.userPersona || '',
            xMessageHistory: xMessageHistory, // 🆕 X平臺私信記憶
          },

          // 🔧 使用者身份識別資訊
          knowsUserIdentity: knowsUserIdentity,

          // 推文數據
          tweets: tweets,

          // 關係資料
          relationships: xProfile.relationships || [],

          // 原始物件（保留用於相容性）
          xProfile: xProfile,
          character: character,
          characterId: character.id,

          // 元信息
          _source: 'character',
          _characterId: character.id,
          _loadedAt: Date.now(),
        };
      } catch (error) {
        console.error('[統一資料] 角色查詢失敗:', error);
        return null;
      }
    },

    // 內部方法：通過控制碼獲取帳戶資料
    async _getAccountProfileByHandle(cleanHandle) {
      try {
        const xDB = getXDB();
        const accountProfile = await xDB.xAccountProfiles.get(cleanHandle);

        if (!accountProfile) return null;

        const accountInfo = accountProfile.accountInfo || accountProfile;

        // 🆕 讀取X平臺私信記憶
        const xMessageHistory = await this._loadXMessageHistory(accountInfo.handle);

        return {
          type: 'account',
          // 基礎資訊
          name: accountInfo.name,
          handle: accountInfo.handle,
          avatar: accountInfo.avatar,
          bio: accountInfo.bio || '',
          verified: accountInfo.verified || false,
          publicIdentity: accountInfo.publicIdentity || '',

          // 帳戶資訊（用於 queryAccountData）
          accountInfo: {
            name: accountInfo.name,
            handle: accountInfo.handle,
            avatar: accountInfo.avatar,
            bio: accountInfo.bio || '',
            verified: accountInfo.verified || false,
            verificationType: accountInfo.verificationType || 'none',
            cover:
              accountInfo.cover || accountProfile.cover || 'https://i.postimg.cc/tT8Rfsf1/mmexport1759603246385.jpg',
            publicIdentity: accountInfo.publicIdentity || '',
            customTag1: accountInfo.customTag1 || accountProfile.customTag1 || null,
            customTag2: accountInfo.customTag2 || accountProfile.customTag2 || null,
            followersCount: accountInfo.followersCount || '0',
            followingCount: accountInfo.followingCount || '0',
          },

          // 帳戶特有資料
          accountData: {
            accountType: accountProfile.accountType || 'unknown',
            personality: accountProfile.personality || '',
            postingHabits: accountProfile.postingHabits || '',
            sourceContext: accountProfile.sourceContext || null,
            followersCount: accountInfo.followersCount || '0',
            followingCount: accountInfo.followingCount || '0',
            xMessageHistory: xMessageHistory, // 🆕 X平臺私信記憶
          },

          // 推文數據
          tweets: accountProfile.tweets || [],

          // 關係資料（NPC帳戶可能有）
          relationships: accountProfile.relationships || [],

          // 元信息
          _source: 'account',
          _accountHandle: cleanHandle,
          _loadedAt: Date.now(),
        };
      } catch (error) {
        console.error('[統一資料] 帳戶查詢失敗:', error);
        return null;
      }
    },

    // 🆕 內部輔助方法：通過控制碼讀取X平臺私信記憶
    async _loadXMessageHistory(handle) {
      try {
        const xDB = getXDB();
        const currentAccount = window.currentAccountId || 'main';
        const cleanHandle = handle.replace('@', '');

        // 嘗試在多個帳戶下查找（當前帳戶優先，然後是main帳戶）
        const accountsToTry = [currentAccount];
        if (currentAccount !== 'main') {
          accountsToTry.push('main');
        }

        let messagesListData = null;
        let messagesListAccount = null;

        // 1. 首先嘗試從私信列表中查找
        for (const accountId of accountsToTry) {
          const messagesListId = `messagesList_${accountId}`;
          const data = await xDB.xAccountProfiles.get(messagesListId);

          if (data && data.data && data.data.length > 0) {
            messagesListData = data;
            messagesListAccount = accountId;
            break;
          }
        }

        if (!messagesListData) {
          return [];
        }

        // 2. 在私信清單中查找對應控制碼的對話
        const conversation = messagesListData.data.find(
          msg => msg.userHandle && msg.userHandle.replace('@', '').toLowerCase() === cleanHandle.toLowerCase(),
        );

        let conversationId, conversationData;

        if (!conversation) {
          // 3. 如果私信列表中沒有，嘗試備用查找（直接通過ID格式查找對話資料）
          const possibleIds = [
            `msg_account_${cleanHandle}`,
            `msg_npc_${cleanHandle}`,
            `msg_relationship_${cleanHandle}`,
            cleanHandle,
          ];

          for (const accountId of accountsToTry) {
            for (const possibleId of possibleIds) {
              const testConversationId = `messageConversation_${accountId}_${possibleId}`;
              const testData = await xDB.xAccountProfiles.get(testConversationId);

              if (testData && testData.data && testData.data.messages) {
                conversationId = testConversationId;
                conversationData = testData;
                break;
              }
            }
            if (conversationData) break;
          }

          if (!conversationData) {
            return [];
          }
        } else {
          // 4. 找到對話ID，讀取對話詳細消息
          conversationId = `messageConversation_${messagesListAccount}_${conversation.id}`;
          conversationData = await xDB.xAccountProfiles.get(conversationId);
        }

        if (!conversationData || !conversationData.data || !conversationData.data.messages) {
          return [];
        }

        // 5. 提取最近50條私信
        const messages = conversationData.data.messages.slice(-50);
        const history = messages.map(msg => ({
          type: msg.type,
          content: msg.content || '',
          isOwn: msg.isOwn || false,
          time: msg.time || '',
          timestamp: msg.timestamp || '',
          // 保留其他欄位供特殊消息類型使用
          amount: msg.amount,
          note: msg.note,
          imageDescription: msg.imageDescription,
          voiceText: msg.voiceText,
          title: msg.title,
          url: msg.url,
          tweet: msg.tweet,
          profile: msg.profile,
        }));
        console.log(`✅ [私信數據] ${handle}: ${history.length} 條記憶`);
        return history;
      } catch (error) {
        console.error(`❌ [私信數據] ${handle}: 讀取失敗`, error);
        return [];
      }
    },

    // 內部方法：通過控制碼獲取綁定NPC資料
    async _getNPCProfileByHandle(cleanHandle) {
      try {
        const xDB = getXDB();
        const npcDataId = 'xNPCs_global';
        const npcData = await xDB.xNPCs.get(npcDataId);
        const allNPCs = npcData?.npcs || [];

        for (const npc of allNPCs) {
          const npcCleanHandle = npc.handle.replace('@', '');

          if (npcCleanHandle.toLowerCase() === cleanHandle.toLowerCase()) {
            // 🆕 讀取X平臺私信記憶
            const xMessageHistory = await this._loadXMessageHistory(npc.handle);

            return {
              type: 'npc',
              // 基礎資訊
              name: npc.name,
              handle: npc.handle,
              avatar: npc.avatar,
              bio: '',
              verified: false,
              publicIdentity: '',

              // NPC特有資料
              npcData: {
                personality: npc.personality || '',
                postingHabits: npc.postingHabits || '',
                homepage: npc.homepage || '',
                xMessageHistory: xMessageHistory, // 🆕 X平臺私信記憶
              },

              // 原始物件（保留用於相容性）
              npc: npc,

              // 推文數據
              tweets: [],

              // 關係資料
              relationships: [],

              // 元信息
              _source: 'npc',
              _loadedAt: Date.now(),
            };
          }
        }

        return null;
      } catch (error) {
        console.error('[統一資料] 綁定NPC查詢失敗:', error);
        return null;
      }
    },

    // 內部方法：通過控制碼獲取關係NPC資料
    async _getRelationshipNPCProfileByHandle(cleanHandle) {
      try {
        const xDB = getXDB();
        const mainDB = getDB();

        // 獲取所有角色的X資料
        const allXProfiles = await xDB.xCharacterProfiles.toArray();
        const allChats = await mainDB.chats.toArray();

        // 遍歷所有角色的關係列表
        for (const xProfile of allXProfiles) {
          if (!xProfile.relationships || xProfile.relationships.length === 0) continue;

          for (const relationship of xProfile.relationships) {
            const relNpcCleanHandle = relationship.npcHandle.replace('@', '');

            if (relNpcCleanHandle.toLowerCase() === cleanHandle.toLowerCase()) {
              // 找到對應的角色資料
              const ownerCharacter = allChats.find(chat => chat.id === xProfile.characterId);

              if (ownerCharacter) {
                // 🆕 讀取X平臺私信記憶
                const xMessageHistory = await this._loadXMessageHistory(relationship.npcHandle);

                return {
                  type: 'relationshipNpc',
                  // 基礎資訊
                  name: relationship.npcName,
                  handle: relationship.npcHandle,
                  avatar: 'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg',
                  bio: '',
                  verified: false,
                  publicIdentity: '',

                  // 關係NPC特有資料
                  relationshipData: {
                    relationshipType: relationship.relationshipType,
                    description: relationship.description || '',
                    ownerCharacterId: ownerCharacter.id,
                    ownerCharacterName: ownerCharacter.name,
                    xMessageHistory: xMessageHistory, // 🆕 X平臺私信記憶
                  },

                  // 原始物件（保留用於相容性）
                  relationship: relationship,
                  ownerCharacter: ownerCharacter,
                  ownerXProfile: xProfile,

                  // 推文數據
                  tweets: [],

                  // 關係資料
                  relationships: [],

                  // 元信息
                  _source: 'relationshipNpc',
                  _ownerId: ownerCharacter.id,
                  _loadedAt: Date.now(),
                };
              }
            }
          }
        }

        return null;
      } catch (error) {
        console.error('[統一資料] 關係NPC查詢失敗:', error);
        return null;
      }
    },

    // 內部方法：創建陌生人範本（支援讀取自訂設置）
    async _createStrangerProfile(handle, messageId = null) {
      const cleanHandle = handle.replace('@', '').trim();

      // 默認頭像
      let customAvatar = 'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg';

      // 嘗試讀取陌生人的自訂設置
      if (messageId) {
        try {
          const xDB = getXDB();
          const currentAccount = window.currentAccountId || 'main';
          const strangerSettingsId = `strangerSettings_${currentAccount}_${messageId}`;
          const strangerSettings = await xDB.xAccountProfiles.get(strangerSettingsId);

          if (strangerSettings && strangerSettings.customAvatar) {
            customAvatar = strangerSettings.customAvatar;
            console.log(`✅ [陌生人資料] 讀取到自訂頭像: ${customAvatar}`);
          }
        } catch (error) {
          console.error('[陌生人資料] 讀取自訂設置失敗:', error);
        }
      }

      // 🆕 讀取X平臺私信記憶
      const xMessageHistory = await this._loadXMessageHistory(`@${cleanHandle}`);

      return {
        type: 'stranger',
        // 基礎資訊
        name: cleanHandle,
        handle: `@${cleanHandle}`,
        avatar: customAvatar,
        bio: '',
        verified: false,
        publicIdentity: '',

        // 空資料（但包含私信記憶）
        characterData: null,
        accountData: {
          xMessageHistory: xMessageHistory, // 🆕 X平臺私信記憶
        },
        tweets: [],
        relationships: [],

        // 元信息
        _source: 'stranger',
        _messageId: messageId,
        _loadedAt: Date.now(),
      };
    },

    // 格式化資料為提示詞文本
    formatProfileForPrompt(profile, options = {}) {
      if (!profile) return '';

      const { includeType = true, includeTweets = true, includeRelationships = true } = options;

      let promptText = '';

      // 類型標識
      if (includeType) {
        const typeLabels = {
          character: '【角色資料】',
          account: '【帳戶資料】',
          stranger: '【陌生人資料】',
        };
        promptText += `${typeLabels[profile.type] || '【資料】'}\n`;
      }

      // 🔧 空值保護：確保基本欄位存在
      if (!profile.name || !profile.handle) {
        console.warn('⚠️ [格式化資料] profile 缺少必需欄位 name 或 handle:', {
          type: profile.type,
          name: profile.name,
          handle: profile.handle,
        });
        return '';
      }

      // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      // 📱 X平臺公開信息（所有X用戶都能看到）
      // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      promptText += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📱 X平臺公開信息（路人可見）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
X姓名：${profile.name}
X控制碼：${profile.handle}
認證狀態：${profile.verified ? '已認證' : '未認證'}
${profile.bio ? `X簡介：${profile.bio}` : ''}
${profile.publicIdentity ? `公開身份：${profile.publicIdentity}` : ''}

🚨 重要：以上資訊是X平臺上的公開資料，所有X使用者（包括路人、陌生人）都能看到。
路人評論時只能基於這些公開信息，不能提及下方的私密資訊！
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;

      // 角色特有資訊
      if (profile.type === 'character' && profile.characterData) {
        const cd = profile.characterData;

        // 🔧 確保角色關鍵資料存在
        const originalName = cd.originalName || profile.name || '未知';
        const aiPersona = cd.aiPersona || '無特定人設';

        promptText += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🔒 角色私密資料（僅供AI理解角色，路人不知道）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
真實姓名：${originalName}
人設描述：${aiPersona}

⚠️ 隱私規則：
- 真實姓名"${originalName}"是私密資訊，路人評論中禁止提及！
- 路人只能稱呼X姓名"${profile.name}"或使用控制碼"${profile.handle}"
- 只有該角色本人或關係NPC（已綁定的私人關係）才知道真實姓名
- 人設描述僅供AI理解角色性格，路人不知道這些細節
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;

        // 🔧 使用者身份識別資訊
        if (profile.knowsUserIdentity !== undefined) {
          promptText += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
👤 用戶身份識別
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
該角色${profile.knowsUserIdentity ? '知道' : '不知道'}用戶的真實身份
`;
          if (profile.knowsUserIdentity) {
            promptText += `✅ 該角色可以識別用戶，回復時應該表現出認識
`;
            if (cd.userPersona && cd.userPersona.trim()) {
              promptText += `
【角色瞭解的使用者資訊】（專屬使用者人設）：
${cd.userPersona}

⚠️ 該角色應該根據這些資訊與使用者互動
`;
            } else {
              promptText += `⚠️ 該角色尚未設置專屬用戶人設，按基礎認識模式互動
`;
            }
          } else {
            promptText += `❌ 該角色完全不知道用戶的真實身份，必須按照陌生人模式回復
⚠️ 不要讓角色猜測、暗示或表現出任何對使用者的認識
`;
          }
          promptText += `━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
        }

        // 🆕 X平臺私信記憶（無論角色是否認識使用者身份，只要有私信記錄就顯示）
        if (cd.xMessageHistory && cd.xMessageHistory.length > 0) {
          const xMessageSectionStart = promptText.length;
          promptText += `
【X平臺私信記憶】（該角色與用戶在X平臺私信中的對話記錄）：
`;
          const recentXMessages = cd.xMessageHistory.slice(-50); // 顯示最近50條
          let xMemCount = 0;
          for (const msg of recentXMessages) {
            const sender = msg.isOwn ? '用戶' : profile.name;
            let content = '';

            if (msg.type === 'text') {
              content = msg.content || ''; // 🔧 空值保護
            } else if (msg.type === 'image') {
              content = msg.isOwn ? '[使用者發送了圖片]' : `[圖片: ${msg.imageDescription || '圖片'}]`;
            } else if (msg.type === 'voice') {
              content = `[語音: ${msg.voiceText || '語音訊息'}]`;
            } else if (msg.type === 'sticker') {
              content = '[表情包]';
            } else if (msg.type === 'transfer') {
              const amount = msg.amount ? `$${msg.amount}` : '';
              const note = msg.note ? ` (${msg.note})` : '';
              content = `[轉帳${amount}${note}]`;
            } else if (msg.type === 'link') {
              content = `[分享連結: ${msg.title || '連結'}]`;
            } else if (msg.type === 'quoteTweet') {
              content = `[轉發推文: ${msg.tweet?.content || ''}]`;
            } else if (msg.type === 'quoteProfile') {
              content = `[分享主頁: ${msg.profile?.name || ''}]`;
            } else {
              content = `[${msg.type}消息]`;
            }

            if (content) {
              const displayContent = content.length > 80 ? `${content.substring(0, 80)}...` : content;
              promptText += `${sender}: ${displayContent}\n`;
              xMemCount++;
            }

            if (xMemCount >= 50) break;
          }
          promptText += `
⚠️ 重要說明：
- 這些是在X平臺私信功能中的真實對話記錄
- 無論角色是否"認識使用者身份"（其他場景的身份），這些X平臺對話都是客觀存在的
- 根據當前場景（推文/評論/私信）自然使用，不要在公開推文中直接提及私信內容
`;
          // 統計私信記憶的 token 數量
          const xMessageSection = promptText.substring(xMessageSectionStart);
          const xMessageTokens = TokenUtils.estimateTokens(xMessageSection);
          console.log(`📊 [私信] 角色 ${profile.name}: ${xMemCount}條, ~${xMessageTokens} tokens`);
        }

        // 記憶資訊（只有知道使用者身份且有專屬人設時才顯示）
        if (
          profile.knowsUserIdentity &&
          cd.userPersona &&
          cd.userPersona.trim() &&
          cd.history &&
          cd.history.length > 0
        ) {
          promptText += `
【其他聊天記憶】（與使用者在其他場景的對話，僅供參考）：
`;
          const recentHistory = cd.history.slice(-10);
          let memCount = 0;
          for (const msg of recentHistory) {
            // 🔧 空值保護：確保 msg.content 存在
            if (msg.role === 'user' && msg.content) {
              const content = String(msg.content); // 確保是字串
              promptText += `用戶: ${content.substring(0, 100)}${content.length > 100 ? '...' : ''}\n`;
              memCount++;
            } else if (msg.role === 'assistant' && msg.content) {
              const content = String(msg.content); // 確保是字串
              promptText += `${profile.name}: ${content.substring(0, 100)}${content.length > 100 ? '...' : ''}\n`;
              memCount++;
            }
            if (memCount >= 10) break;
          }
          promptText += `⚠️ 以上記憶僅供理解角色與使用者關係，根據當前場景自然使用
`;
        }

        // 長期記憶
        if (cd.longTermMemory && cd.longTermMemory.length > 0) {
          promptText += `
【長期記憶】（僅供AI參考，路人不知道）：
`;
          cd.longTermMemory.forEach((mem, idx) => {
            promptText += `${idx + 1}. ${mem.content}\n`;
          });
        }
      }

      // 帳戶特有資訊
      if (profile.type === 'account' && profile.accountData) {
        const ad = profile.accountData;
        promptText += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🔒 帳戶資料（僅供AI理解，路人不知道）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
帳戶類型：${ad.accountType}
${ad.personality ? `人設描述：${ad.personality}` : ''}
${ad.postingHabits ? `發帖習慣：${ad.postingHabits}` : ''}
${ad.followersCount ? `關注者：${ad.followersCount}` : ''}
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;

        // 🆕 X平臺私信記憶（如果有）
        if (ad.xMessageHistory && ad.xMessageHistory.length > 0) {
          const xMessageSectionStart = promptText.length;
          promptText += `
【X平臺私信記憶】（該帳戶與用戶在X平臺私信中的對話記錄，僅供參考）：
`;
          const recentXMessages = ad.xMessageHistory.slice(-50);
          let xMemCount = 0;
          for (const msg of recentXMessages) {
            const sender = msg.isOwn ? '用戶' : profile.name;
            let content = '';

            if (msg.type === 'text') {
              content = msg.content || ''; // 🔧 空值保護
            } else if (msg.type === 'image') {
              content = msg.isOwn ? '[使用者發送了圖片]' : `[圖片: ${msg.imageDescription || '圖片'}]`;
            } else if (msg.type === 'voice') {
              content = `[語音: ${msg.voiceText || '語音訊息'}]`;
            } else if (msg.type === 'sticker') {
              content = '[表情包]';
            } else if (msg.type === 'transfer') {
              const amount = msg.amount ? `$${msg.amount}` : '';
              const note = msg.note ? ` (${msg.note})` : '';
              content = `[轉帳${amount}${note}]`;
            } else if (msg.type === 'link') {
              content = `[分享連結: ${msg.title || '連結'}]`;
            } else if (msg.type === 'quoteTweet') {
              content = `[轉發推文: ${msg.tweet?.content || ''}]`;
            } else if (msg.type === 'quoteProfile') {
              content = `[分享主頁: ${msg.profile?.name || ''}]`;
            } else {
              content = `[${msg.type}消息]`;
            }

            if (content) {
              const displayContent = content.length > 80 ? `${content.substring(0, 80)}...` : content;
              promptText += `${sender}: ${displayContent}\n`;
              xMemCount++;
            }

            if (xMemCount >= 50) break;
          }
          promptText += `⚠️ 以上是X平臺私信對話記錄，僅供理解該帳戶與用戶的關係和溝通風格
⚠️ 根據當前場景（推文/評論）自然使用，不要在公開推文中直接提及私信內容
`;
          // 統計私信記憶的 token 數量
          const xMessageSection = promptText.substring(xMessageSectionStart);
          const xMessageTokens = TokenUtils.estimateTokens(xMessageSection);
          console.log(`📊 [私信] 帳戶 ${profile.name}: ${xMemCount}條, ~${xMessageTokens} tokens`);
        }
      }

      // 綁定NPC特有資訊
      if (profile.type === 'npc' && profile.npcData) {
        const nd = profile.npcData;
        promptText += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🔒 NPC資料（僅供AI理解角色，路人不知道）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
${nd.personality ? `人設描述：${nd.personality}` : ''}
${nd.postingHabits ? `發帖習慣：${nd.postingHabits}` : ''}
${nd.homepage ? `主頁連結：${nd.homepage}` : ''}

⚠️ 該NPC是全域綁定的虛擬角色，按照人設描述進行互動
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;

        // 🆕 X平臺私信記憶（如果有）
        if (nd.xMessageHistory && nd.xMessageHistory.length > 0) {
          const xMessageSectionStart = promptText.length;
          promptText += `
【X平臺私信記憶】（該NPC與用戶在X平臺私信中的對話記錄，僅供參考）：
`;
          const recentXMessages = nd.xMessageHistory.slice(-50);
          let xMemCount = 0;
          for (const msg of recentXMessages) {
            const sender = msg.isOwn ? '用戶' : profile.name;
            let content = '';

            if (msg.type === 'text') {
              content = msg.content || ''; // 🔧 空值保護
            } else if (msg.type === 'image') {
              content = msg.isOwn ? '[使用者發送了圖片]' : `[圖片: ${msg.imageDescription || '圖片'}]`;
            } else if (msg.type === 'voice') {
              content = `[語音: ${msg.voiceText || '語音訊息'}]`;
            } else if (msg.type === 'sticker') {
              content = '[表情包]';
            } else if (msg.type === 'transfer') {
              const amount = msg.amount ? `$${msg.amount}` : '';
              const note = msg.note ? ` (${msg.note})` : '';
              content = `[轉帳${amount}${note}]`;
            } else if (msg.type === 'link') {
              content = `[分享連結: ${msg.title || '連結'}]`;
            } else if (msg.type === 'quoteTweet') {
              content = `[轉發推文: ${msg.tweet?.content || ''}]`;
            } else if (msg.type === 'quoteProfile') {
              content = `[分享主頁: ${msg.profile?.name || ''}]`;
            } else {
              content = `[${msg.type}消息]`;
            }

            if (content) {
              const displayContent = content.length > 80 ? `${content.substring(0, 80)}...` : content;
              promptText += `${sender}: ${displayContent}\n`;
              xMemCount++;
            }

            if (xMemCount >= 50) break;
          }
          promptText += `⚠️ 以上是X平臺私信對話記錄，僅供理解該NPC與用戶的關係和溝通風格
⚠️ 根據當前場景（推文/評論）自然使用，不要在公開推文中直接提及私信內容
`;
          // 統計私信記憶的 token 數量
          const xMessageSection = promptText.substring(xMessageSectionStart);
          const xMessageTokens = TokenUtils.estimateTokens(xMessageSection);
          console.log(`📊 [私信] NPC ${profile.name}: ${xMemCount}條, ~${xMessageTokens} tokens`);
        }
      }

      // 關係NPC特有資訊
      if (profile.type === 'relationshipNpc' && profile.relationshipData) {
        const rd = profile.relationshipData;
        promptText += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🔒 關係NPC資料（僅供AI理解角色，路人不知道）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
關係類型：${rd.relationshipType}
${rd.description ? `關係描述：${rd.description}` : ''}
所屬角色：${rd.ownerCharacterName}（該NPC是 ${rd.ownerCharacterName} 的專屬關係角色）

⚠️ 該NPC與角色 ${rd.ownerCharacterName} 有綁定關係，互動時應體現這種關係
⚠️ 該NPC只與其所屬角色有特殊關係，與其他角色/用戶按照普通關係互動
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;

        // 🆕 X平臺私信記憶（如果有）
        if (rd.xMessageHistory && rd.xMessageHistory.length > 0) {
          const xMessageSectionStart = promptText.length;
          promptText += `
【X平臺私信記憶】（該關係NPC與用戶在X平臺私信中的對話記錄，僅供參考）：
`;
          const recentXMessages = rd.xMessageHistory.slice(-50);
          let xMemCount = 0;
          for (const msg of recentXMessages) {
            const sender = msg.isOwn ? '用戶' : profile.name;
            let content = '';

            if (msg.type === 'text') {
              content = msg.content || ''; // 🔧 空值保護
            } else if (msg.type === 'image') {
              content = msg.isOwn ? '[使用者發送了圖片]' : `[圖片: ${msg.imageDescription || '圖片'}]`;
            } else if (msg.type === 'voice') {
              content = `[語音: ${msg.voiceText || '語音訊息'}]`;
            } else if (msg.type === 'sticker') {
              content = '[表情包]';
            } else if (msg.type === 'transfer') {
              const amount = msg.amount ? `$${msg.amount}` : '';
              const note = msg.note ? ` (${msg.note})` : '';
              content = `[轉帳${amount}${note}]`;
            } else if (msg.type === 'link') {
              content = `[分享連結: ${msg.title || '連結'}]`;
            } else if (msg.type === 'quoteTweet') {
              content = `[轉發推文: ${msg.tweet?.content || ''}]`;
            } else if (msg.type === 'quoteProfile') {
              content = `[分享主頁: ${msg.profile?.name || ''}]`;
            } else {
              content = `[${msg.type}消息]`;
            }

            if (content) {
              const displayContent = content.length > 80 ? `${content.substring(0, 80)}...` : content;
              promptText += `${sender}: ${displayContent}\n`;
              xMemCount++;
            }

            if (xMemCount >= 50) break;
          }
          promptText += `⚠️ 以上是X平臺私信對話記錄，僅供理解該NPC與用戶的關係和溝通風格
⚠️ 根據當前場景（推文/評論）自然使用，不要在公開推文中直接提及私信內容
`;
          // 統計私信記憶的 token 數量
          const xMessageSection = promptText.substring(xMessageSectionStart);
          const xMessageTokens = TokenUtils.estimateTokens(xMessageSection);
          console.log(`📊 [私信] 關係NPC ${profile.name}: ${xMemCount}條, ~${xMessageTokens} tokens`);
        }
      }

      // 陌生人特有提示
      if (profile.type === 'stranger') {
        promptText += `
⚠️ 該使用者是陌生人（未在系統中綁定），回復應該自然真實，符合普通X平臺用戶的特點
⚠️ 如果沒有特殊設定，按照一般性格進行回復
`;

        // 🆕 X平臺私信記憶（如果有）
        if (
          profile.accountData &&
          profile.accountData.xMessageHistory &&
          profile.accountData.xMessageHistory.length > 0
        ) {
          const xMessageSectionStart = promptText.length;
          promptText += `
【X平臺私信記憶】（該陌生人與用戶在X平臺私信中的對話記錄，僅供參考）：
`;
          const recentXMessages = profile.accountData.xMessageHistory.slice(-50);
          let xMemCount = 0;
          for (const msg of recentXMessages) {
            const sender = msg.isOwn ? '用戶' : profile.name;
            let content = '';

            if (msg.type === 'text') {
              content = msg.content || ''; // 🔧 空值保護
            } else if (msg.type === 'image') {
              content = msg.isOwn ? '[使用者發送了圖片]' : `[圖片: ${msg.imageDescription || '圖片'}]`;
            } else if (msg.type === 'voice') {
              content = `[語音: ${msg.voiceText || '語音訊息'}]`;
            } else if (msg.type === 'sticker') {
              content = '[表情包]';
            } else if (msg.type === 'transfer') {
              const amount = msg.amount ? `$${msg.amount}` : '';
              const note = msg.note ? ` (${msg.note})` : '';
              content = `[轉帳${amount}${note}]`;
            } else if (msg.type === 'link') {
              content = `[分享連結: ${msg.title || '連結'}]`;
            } else if (msg.type === 'quoteTweet') {
              content = `[轉發推文: ${msg.tweet?.content || ''}]`;
            } else if (msg.type === 'quoteProfile') {
              content = `[分享主頁: ${msg.profile?.name || ''}]`;
            } else {
              content = `[${msg.type}消息]`;
            }

            if (content) {
              const displayContent = content.length > 80 ? `${content.substring(0, 80)}...` : content;
              promptText += `${sender}: ${displayContent}\n`;
              xMemCount++;
            }

            if (xMemCount >= 50) break;
          }
          promptText += `⚠️ 以上是X平臺私信對話記錄，僅供理解該陌生人與用戶的關係和溝通風格
⚠️ 根據當前場景（推文/評論）自然使用，不要在公開推文中直接提及私信內容
`;
          // 統計私信記憶的 token 數量
          const xMessageSection = promptText.substring(xMessageSectionStart);
          const xMessageTokens = TokenUtils.estimateTokens(xMessageSection);
          console.log(`📊 [私信] 陌生人 ${profile.name}: ${xMemCount}條, ~${xMessageTokens} tokens`);
        }
      }

      // 推文信息
      if (includeTweets && profile.tweets && profile.tweets.length > 0) {
        promptText += `\n【最近推文】（參考發帖風格）：\n`;
        const recentTweets = profile.tweets.slice(0, 3);
        recentTweets.forEach((tweet, idx) => {
          promptText += `${idx + 1}. "${tweet.content}"\n`;
          promptText += `   互動：${tweet.stats?.likes || 0}喜歡，${tweet.stats?.comments || 0}評論\n`;
        });
      }

      // 關係資訊
      if (includeRelationships && profile.relationships && profile.relationships.length > 0) {
        promptText += `\n【已綁定關係】：\n`;
        profile.relationships.forEach(rel => {
          promptText += `- ${rel.npcName} (${rel.npcHandle}): ${rel.relationshipType}`;
          if (rel.description) promptText += ` | ${rel.description}`;
          promptText += '\n';
        });
      }

      return promptText;
    },

    // 批量獲取多個資料
    async getBatchProfiles(handles, options = {}) {
      if (!Array.isArray(handles) || handles.length === 0) return [];

      const profiles = await Promise.all(handles.map(handle => this.getUnifiedProfile(handle, options)));

      return profiles.filter(p => p !== null);
    },

    // ========== 用戶身份冒用篩選工具 ==========
    // 刪除所有冒充使用者身份的內容
    filterUserImpersonation(data, userHandle, userName) {
      console.log('🚫 [身份篩選] 開始檢查用戶身份冒用...');

      if (!userHandle || !userName) {
        console.warn('⚠️ [身份篩選] 缺少使用者資訊，跳過篩選');
        return data;
      }

      const cleanUserHandle = userHandle.replace('@', '').toLowerCase();
      const cleanUserName = userName.toLowerCase();
      let removedCount = 0;

      // 檢查使用者物件是否冒用了使用者身份
      const isUserImpersonation = user => {
        if (!user || !user.handle) return false;

        const cleanHandle = user.handle.replace('@', '').toLowerCase();
        const cleanName = (user.name || '').toLowerCase();

        // 控制碼完全匹配
        if (cleanHandle === cleanUserHandle) {
          console.warn(`🚫 [身份篩選] 檢測到控制碼冒用: ${user.handle}`);
          return true;
        }

        // 姓名完全匹配
        if (cleanName === cleanUserName) {
          console.warn(`🚫 [身份篩選] 檢測到姓名冒用: ${user.name}`);
          return true;
        }

        return false;
      };

      // 篩選推文陣列
      const filterTweets = tweets => {
        if (!Array.isArray(tweets)) return tweets;

        return tweets.filter(tweet => {
          // 檢查推文作者是否冒用（這是真正的冒用：假扮用戶發推文）
          if (isUserImpersonation(tweet.user)) {
            console.warn(`🗑️ [身份篩選] 刪除冒用推文: "${tweet.content?.substring(0, 50)}..."`);
            removedCount++;
            return false;
          }

          // 篩選評論（刪除假扮用戶的評論）
          if (tweet.comments && Array.isArray(tweet.comments)) {
            tweet.comments = filterComments(tweet.comments);
          }

          // ⚠️ 不刪除引用推文中的使用者內容
          // 引用用戶的推文是合法的，只有假扮用戶才是冒用
          // 如果 quotedTweet.user 是用戶，這是正常的轉發引用，不是冒用

          return true;
        });
      };

      // 篩選評論陣列（遞迴）
      const filterComments = comments => {
        if (!Array.isArray(comments)) return comments;

        return comments.filter(comment => {
          // 檢查評論作者
          if (isUserImpersonation(comment.user)) {
            console.warn(`🗑️ [身份篩選] 刪除冒用評論: "${comment.content?.substring(0, 50)}..."`);
            removedCount++;
            return false;
          }

          // 遞迴篩選回復
          if (comment.replies && Array.isArray(comment.replies)) {
            comment.replies = filterComments(comment.replies);
          }

          return true;
        });
      };

      // 處理不同的資料結構
      if (data.forYouTweets) {
        data.forYouTweets = filterTweets(data.forYouTweets);
      }

      if (data.followingTweets) {
        data.followingTweets = filterTweets(data.followingTweets);
      }

      if (data.tweets && Array.isArray(data.tweets)) {
        data.tweets = filterTweets(data.tweets);
      }

      if (data.comments && Array.isArray(data.comments)) {
        data.comments = filterComments(data.comments);
      }

      if (data.replies && Array.isArray(data.replies)) {
        data.replies = filterComments(data.replies);
      }

      // 處理 Mentions 資料
      if (data.likes && Array.isArray(data.likes)) {
        data.likes = data.likes.filter(like => {
          const allUsers = like.users || [];
          like.users = allUsers.filter(user => !isUserImpersonation(user));
          if (like.users.length === 0) {
            console.warn(`🗑️ [身份篩選] 刪除全冒用點贊通知`);
            removedCount++;
            return false;
          }
          return true;
        });
      }

      if (data.retweets && Array.isArray(data.retweets)) {
        data.retweets = data.retweets.filter(retweet => {
          // 檢查轉推者
          if (isUserImpersonation(retweet.user)) {
            console.warn(`🗑️ [身份篩選] 刪除冒用轉推通知`);
            removedCount++;
            return false;
          }

          // 篩選轉推的評論
          if (retweet.comments) {
            retweet.comments = filterComments(retweet.comments);
          }

          return true;
        });
      }

      if (removedCount > 0) {
        console.log(`✅ [身份篩選] 共刪除 ${removedCount} 個冒用使用者身份的內容`);
      } else {
        console.log(`✅ [身份篩選] 未檢測到身份冒用`);
      }

      return data;
    },

    // ========== 頭像強制修正工具 ==========
    // 強制修正所有使用者頭像，確保遵守頭像規則
    async enforceAvatarRules(data, userHandle = null) {
      console.log('🔧 [頭像修正] 開始修正頭像...');

      const xDB = getXDB();
      const mainDB = getDB();

      // 1. 構建角色/NPC/用戶控制碼映射表
      const avatarMap = new Map();

      // 載入使用者的X資料（最高優先順序）
      if (window.userProfileData && window.userProfileData.handle && window.userProfileData.avatar) {
        const cleanUserHandle = window.userProfileData.handle.replace('@', '').toLowerCase();
        avatarMap.set(cleanUserHandle, {
          avatar: window.userProfileData.avatar,
          type: 'user',
          name: window.userProfileData.name,
        });
        console.log(`👤 [頭像修正] 已載入用戶頭像: ${window.userProfileData.name} (${window.userProfileData.handle})`);
      }

      // 載入所有角色的X資料
      const allXProfiles = await xDB.xCharacterProfiles.toArray();
      for (const xProfile of allXProfiles) {
        if (xProfile.xHandle && xProfile.xAvatar) {
          const cleanHandle = xProfile.xHandle.replace('@', '').toLowerCase();
          avatarMap.set(cleanHandle, {
            avatar: xProfile.xAvatar,
            type: 'character',
            name: xProfile.xName,
          });
        }
      }

      // 載入所有綁定NPC
      const npcDataId = 'xNPCs_global';
      const npcData = await xDB.xNPCs.get(npcDataId);
      const allNPCs = npcData?.npcs || [];
      for (const npc of allNPCs) {
        if (npc.handle && npc.avatar) {
          const cleanHandle = npc.handle.replace('@', '').toLowerCase();
          avatarMap.set(cleanHandle, {
            avatar: npc.avatar,
            type: 'npc',
            name: npc.name,
          });
        }
      }

      // 載入所有關係NPC（它們使用默認頭像）
      for (const xProfile of allXProfiles) {
        if (xProfile.relationships && xProfile.relationships.length > 0) {
          for (const rel of xProfile.relationships) {
            if (rel.npcHandle) {
              const cleanHandle = rel.npcHandle.replace('@', '').toLowerCase();
              avatarMap.set(cleanHandle, {
                avatar: 'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg',
                type: 'relationshipNpc',
                name: rel.npcName,
              });
            }
          }
        }
      }

      // 🔧 載入所有陌生人的自訂頭像（從 strangerSettings 中）
      const allProfiles = await xDB.xAccountProfiles.toArray();
      const strangerSettings = allProfiles.filter(
        item => item.handle && item.handle.startsWith('strangerSettings_') && item.customAvatar,
      );
      for (const setting of strangerSettings) {
        // 從私信清單中找到對應的陌生人資訊
        const messageId = setting.messageId;
        if (messageId) {
          // 嘗試從私信清單獲取控制碼資訊
          const messagesLists = allProfiles.filter(item => item.name === 'messagesList');
          for (const msgList of messagesLists) {
            if (msgList.data && Array.isArray(msgList.data)) {
              const stranger = msgList.data.find(msg => msg.id === messageId);
              if (stranger && stranger.userHandle) {
                const cleanHandle = stranger.userHandle.replace('@', '').toLowerCase();
                avatarMap.set(cleanHandle, {
                  avatar: setting.customAvatar,
                  type: 'stranger',
                  name: stranger.userName || '陌生人',
                });
                console.log(
                  `🆕 [頭像修正] 已載入陌生人自訂頭像: ${stranger.userName} (${stranger.userHandle}) -> ${setting.customAvatar}`,
                );
              }
            }
          }
        }
      }

      console.log(`📋 [頭像修正] 已載入 ${avatarMap.size} 個用戶/角色/NPC/陌生人的頭像資訊`);

      // 2. 定義修正函數
      const defaultAvatar = 'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg';
      let fixedCount = 0;

      const fixUser = user => {
        if (!user || !user.handle) return;

        const cleanHandle = user.handle.replace('@', '').toLowerCase();

        // 檢查是否是已知用戶/角色/NPC/陌生人
        if (avatarMap.has(cleanHandle)) {
          const correctInfo = avatarMap.get(cleanHandle);
          if (user.avatar !== correctInfo.avatar) {
            const typeLabel =
              {
                user: '用戶',
                character: '角色',
                npc: 'NPC',
                relationshipNpc: '關係NPC',
                stranger: '陌生人（自訂）',
              }[correctInfo.type] || correctInfo.type;
            console.log(
              `🔧 [頭像修正] ${user.name} (${user.handle}): ${typeLabel}頭像 ${user.avatar} -> ${correctInfo.avatar}`,
            );
            user.avatar = correctInfo.avatar;
            fixedCount++;
          }
        } else {
          // 未知用戶（路人），強制使用默認頭像
          if (user.avatar !== defaultAvatar) {
            console.log(`🔧 [頭像修正] ${user.name} (${user.handle}): 路人頭像 ${user.avatar} -> ${defaultAvatar}`);
            user.avatar = defaultAvatar;
            fixedCount++;
          }
        }
      };

      // 3. 遞迴修正所有使用者物件
      const fixDataRecursively = obj => {
        if (!obj || typeof obj !== 'object') return;

        // 如果是陣列，遞迴處理每個元素
        if (Array.isArray(obj)) {
          obj.forEach(item => fixDataRecursively(item));
          return;
        }

        // 如果有user欄位，修正它
        if (obj.user && obj.user.handle) {
          fixUser(obj.user);
        }

        // 遞迴處理所有屬性
        for (const key in obj) {
          if (obj.hasOwnProperty(key) && typeof obj[key] === 'object') {
            fixDataRecursively(obj[key]);
          }
        }
      };

      // 4. 開始修正
      fixDataRecursively(data);

      if (fixedCount > 0) {
        console.log(`✅ [頭像修正] 共修正了 ${fixedCount} 個頭像`);
      } else {
        console.log(`✅ [頭像修正] 所有頭像都正確，無需修正`);
      }

      return data;
    },

    // 獲取適用的世界書內容
    async getApplicableWorldBooks(scene, options = {}) {
      try {
        const xDB = getXDB();

        // 🔧 從全域設置讀取世界書（所有帳戶共用）
        const globalSettings = await xDB.xSettings.get('globalWorldBooks');
        if (!globalSettings || !globalSettings.worldBooks || globalSettings.worldBooks.length === 0) {
          console.log(`🔍 [世界書] 未找到全域世界書資料`);
          return '';
        }

        console.log(`🔍 [世界書] 當前場景: ${scene}, 總世界書數: ${globalSettings.worldBooks.length}`);
        const { boundCharacters = [] } = options;

        // 篩選適用的世界書
        const applicableBooks = globalSettings.worldBooks.filter(book => {
          const hasSceneBinding = book.scenes && book.scenes.length > 0; // 是否綁定了場景
          const hasTargetBinding = book.targetType && book.targetType !== 'none'; // 是否綁定了目標

          // 真正的閒置狀態：既沒有場景綁定，也沒有目標綁定
          const isTrulyIdle = !hasSceneBinding && !hasTargetBinding;

          if (isTrulyIdle) {
            console.log(`⏸️ [世界書] "${book.name}" - 閒置狀態，跳過應用`);
            return false;
          }

          const isMessagesScene = scene === 'messages'; // 私信詳情頁

          // 【指定角色】：該角色出現的任何地方都使用，無視場景
          if (book.targetType === 'specific' && book.selectedCharacters) {
            const applicable =
              boundCharacters && boundCharacters.some(charId => book.selectedCharacters.includes(charId));
            console.log(
              `${applicable ? '✅' : '❌'} [世界書] "${book.name}" - 指定角色 (當前: [${boundCharacters.join(
                ', ',
              )}], 需要: [${book.selectedCharacters.join(', ')}])`,
            );
            return applicable;
          }

          // 【私信詳情頁場景】：通過綁定目標（全域對話/僅角色對話）判斷
          if (isMessagesScene) {
            // 如果綁定了場景（且不包含全域），則不適用於私信場景
            if (hasSceneBinding && !book.scenes.includes('global')) {
              console.log(`❌ [世界書] "${book.name}" - 私信場景但綁定了其他場景 (${book.scenes.join(', ')})`);
              return false;
            }

            // 如果包含全域場景，直接適用
            if (book.scenes && book.scenes.includes('global')) {
              console.log(`✅ [世界書] "${book.name}" - 全域場景，適用於所有場景`);
              return true;
            }

            // 全域對話：所有私信詳情頁
            if (book.targetType === 'all') {
              console.log(`✅ [世界書] "${book.name}" - 全域對話，適用於所有私信`);
              return true;
            }

            // 僅角色對話：所有角色私信詳情頁
            if (book.targetType === 'characterOnly') {
              const applicable = boundCharacters && boundCharacters.length > 0;
              console.log(
                `${applicable ? '✅' : '❌'} [世界書] "${book.name}" - 僅角色對話 (當前角色數: ${
                  boundCharacters.length
                })`,
              );
              return applicable;
            }

            console.log(`❌ [世界書] "${book.name}" - 私信場景但目標類型不適用`);
            return false;
          }

          // 【其他場景】：必須檢查場景綁定
          if (!hasSceneBinding) {
            console.log(`❌ [世界書] "${book.name}" - 非私信場景且未綁定場景`);
            return false;
          }

          // 檢查場景是否匹配
          const sceneMatches = book.scenes.includes('global') || book.scenes.includes(scene);
          if (!sceneMatches) {
            console.log(`❌ [世界書] "${book.name}" - 場景不匹配 (需要: ${book.scenes.join(', ')}, 當前: ${scene})`);
            return false;
          }

          console.log(`✅ [世界書] "${book.name}" - 場景匹配 (${book.scenes.join(', ')})`);

          // 場景匹配後，如果是全域場景，直接適用
          if (book.scenes.includes('global')) {
            console.log(`✅ [世界書] "${book.name}" - 全域場景，無需檢查目標類型`);
            return true;
          }

          // 其他場景需要檢查目標類型
          if (book.targetType === 'all') {
            console.log(`✅ [世界書] "${book.name}" - 目標: 全域對話，適用`);
            return true;
          } else if (book.targetType === 'characterOnly') {
            const applicable = boundCharacters && boundCharacters.length > 0;
            console.log(
              `${applicable ? '✅' : '❌'} [世界書] "${book.name}" - 目標: 僅角色 (角色數: ${boundCharacters.length})`,
            );
            return applicable;
          } else if (book.targetType === 'none') {
            // targetType為none但有場景綁定，也應該適用（只要場景匹配）
            console.log(`✅ [世界書] "${book.name}" - 場景綁定，無特定目標限制`);
            return true;
          }

          console.log(`❌ [世界書] "${book.name}" - 未知目標類型: ${book.targetType}`);
          return false;
        });

        // 合併世界書內容
        if (applicableBooks.length === 0) {
          console.log(`🔍 [世界書] 沒有適用的世界書`);
          return '';
        }

        console.log(
          `✅ [世界書] 找到 ${applicableBooks.length} 個適用的世界書: ${applicableBooks.map(b => b.name).join(', ')}`,
        );

        let worldBooksContent =
          '\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n📚 世界書（額外知識庫）📚\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n';
        applicableBooks.forEach(book => {
          worldBooksContent += `\n【${book.name}】\n${book.content}\n`;
        });

        return worldBooksContent;
      } catch (error) {
        console.error('獲取世界書內容失敗:', error);
        return '';
      }
    },

    // 構建角色關係資訊
    async buildCharacterRelationships(boundCharacters, currentAccountId) {
      if (!boundCharacters || boundCharacters.length === 0) return '';

      try {
        const xDB = getXDB();
        const currentAccount = currentAccountId || 'main';
        const dataId = `xCharacterRelationships_${currentAccount}`;

        // 載入角色關係資料
        const relationshipRecord = await xDB.xCharacterRelationships.get(dataId);

        if (!relationshipRecord || !relationshipRecord.data) {
          return '';
        }

        const relationshipData = relationshipRecord.data;
        const links = relationshipData.links || [];

        if (links.length === 0) {
          return '';
        }

        // 獲取角色名稱和X資料映射
        const mainDB = getDB();
        const allChats = await mainDB.chats.toArray();
        const allXProfiles = await xDB.xCharacterProfiles.toArray();

        const charMap = new Map();
        const xProfileMap = new Map();

        allChats.forEach(chat => {
          if (!chat.isGroup) {
            charMap.set(chat.id, chat.name);
          }
        });

        allXProfiles.forEach(profile => {
          xProfileMap.set(profile.characterId, profile);
        });

        // 構建關係資訊
        let relationshipsInfo = `

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
💞 角色關係網絡（角色之間的關係）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🚨 重要提示：以下是已綁定角色彼此之間的關係，這些關係與用戶無關！
- 用戶是獨立的個體，不要將任何角色誤認為用戶
- 這些關係描述的是角色A與角色B之間的互動，而非用戶參與的關係

`;

        links.forEach((link, index) => {
          const charAName = charMap.get(link.charA) || '未知角色A';
          const charBName = charMap.get(link.charB) || '未知角色B';
          const xProfileA = xProfileMap.get(link.charA);
          const xProfileB = xProfileMap.get(link.charB);

          relationshipsInfo += `【角色關係 ${index + 1}】（角色之間的關係，與用戶無關）\n`;

          // 角色A的基本身份資訊
          relationshipsInfo += `- 角色A：${charAName}\n`;
          if (xProfileA) {
            relationshipsInfo += `  X平臺身份：${xProfileA.xName} (${xProfileA.xHandle})\n`;
          }

          // 角色B的基本身份資訊
          relationshipsInfo += `- 角色B：${charBName}\n`;
          if (xProfileB) {
            relationshipsInfo += `  X平臺身份：${xProfileB.xName} (${xProfileB.xHandle})\n`;
          }

          relationshipsInfo += `- ${charAName}對${charBName}的關係：${link.relationshipAtoB || '未設置'}\n`;
          relationshipsInfo += `- ${charBName}對${charAName}的關係：${link.relationshipBtoA || '未設置'}\n`;

          if (link.story && link.story.trim()) {
            relationshipsInfo += `- 關係情節：${link.story}\n`;
          }

          relationshipsInfo += `\n`;
        });

        relationshipsInfo += `
【角色關係互動規則】：
🚨 核心原則：這些是角色之間的關係，不要與用戶關係混淆！

1. 角色互動物件識別：
   - 當角色A與角色B互動時，使用上述列出的X平臺身份（xName和xHandle）
   - 絕對不要將角色B誤認為用戶
   - 用戶有獨立的用戶名和控制碼，不要與角色身份混淆

2. 互動頻率和類型根據關係親密度決定：
   - 親密關係（情侶、摯友、家人等）：互動頻率較高（30-50%），可以親昵稱呼、開玩笑
   - 普通關係（朋友、同事、熟人等）：互動頻率中等（15-30%），保持禮貌友好
   - 緊張關係（競爭、冷戰、敵對等）：互動頻率較低（5-15%），可能帶有暗諷、針鋒相對

3. 互動內容要符合關係設定和情節背景

4. 避免強行製造互動，保持自然真實

5. 如果關係情節中有具體故事，可以在互動中體現相關細節

6. 🚨 再次強調：所有上述關係都是"角色↔角色"的關係，不是"角色↔用戶"的關係！
`;

        return relationshipsInfo;
      } catch (error) {
        console.error('構建角色關係資訊失敗:', error);
        return '';
      }
    },
  };

  // HTML範本生成工具 - 簡化重複的DOM創建
  const TemplateBuilders = {
    // 構建角色選擇項範本
    buildCharacterItem(character, isChecked = false) {
      const itemId = `character-item-${character.id}`;
      const avatarId = `character-avatar-${character.id}`;

      setTimeout(() => {
        // 添加事件處理器
        const item = document.getElementById(itemId);
        const avatar = document.getElementById(avatarId);

        if (item) {
          EventUtils.addHoverEffect(
            item,
            { backgroundColor: 'rgba(255,255,255,0.05)' },
            { backgroundColor: 'transparent' },
          );
          EventUtils.safeAddEventListener(item, 'click', () => toggleCharacterSelection(character.id));
        }

        if (avatar) {
          EventUtils.safeAddEventListener(avatar, 'contextmenu', e => {
            e.preventDefault();
            openCharacterXProfile(character.id);
            return false;
          });

          // 長按事件
          let longPressTimer;
          EventUtils.safeAddEventListener(avatar, 'mousedown', () => {
            longPressTimer = setTimeout(() => openCharacterXProfile(character.id), 500);
          });
          EventUtils.safeAddEventListener(avatar, 'mouseup', () => clearTimeout(longPressTimer));
          EventUtils.safeAddEventListener(avatar, 'mouseleave', () => clearTimeout(longPressTimer));
          EventUtils.safeAddEventListener(avatar, 'touchstart', () => {
            longPressTimer = setTimeout(() => openCharacterXProfile(character.id), 500);
          });
          EventUtils.safeAddEventListener(avatar, 'touchend', () => clearTimeout(longPressTimer));
        }
      }, 0);

      return `
            <div id="${itemId}" class="character-item" style="display: flex; align-items: center; gap: 12px; padding: 12px; border: 1px solid #333; border-radius: 8px; margin-bottom: 8px; cursor: pointer; transition: all 0.2s;">
              <img id="${avatarId}" src="${character.settings.aiAvatar}" alt="${character.name}" 
                   style="width: 40px; height: 40px; border-radius: 50%; flex-shrink: 0; cursor: pointer;"
                   title="長按設置X資料">
              <div style="flex: 1; min-width: 0;">
                <div style="color: #fff; font-weight: 600; font-size: 15px; margin-bottom: 2px;">${character.name}</div>
                <div style="color: #71767b; font-size: 13px; text-overflow: ellipsis; overflow: hidden; white-space: nowrap;">
                  ${character.originalName}
                </div>
                <div style="color: var(--x-accent); font-size: 11px; margin-top: 2px;">
                  長按頭像設置X資料
                </div>
              </div>
              ${this.buildCheckbox(character.id, isChecked)}
            </div>
          `;
    },

    // 構建核取方塊
    buildCheckbox(characterId, isChecked) {
      return `
            <div class="character-checkbox" data-character-id="${characterId}" style="
              width: 20px; 
              height: 20px; 
              border: 2px solid ${isChecked ? 'var(--x-accent)' : '#71767b'}; 
              border-radius: 4px; 
              display: flex; 
              align-items: center; 
              justify-content: center;
              background-color: ${isChecked ? 'var(--x-accent)' : '#71767b'};
              transition: all 0.2s;
            ">
              ${
                isChecked
                  ? '<svg viewBox="0 0 24 24" style="width: 12px; height: 12px; fill: #fff;"><path d="M9 16.17L5.53 12.7l-1.06 1.06L9 18.3l9.54-9.54-1.06-1.06L9 16.17z"/></svg>'
                  : ''
              }
            </div>
          `;
    },

    // 構建角色資訊顯示
    buildCharacterInfoDisplay(character) {
      return `
            <div style="display: flex; align-items: center; gap: 16px;">
              <img src="${character.settings.aiAvatar}" alt="${character.name}" style="width: 60px; height: 60px; border-radius: 50%;">
              <div>
                <div style="color: #fff; font-size: 18px; font-weight: 600; margin-bottom: 4px;">${character.name}</div>
                <div style="color: #71767b; font-size: 14px;">本名：${character.originalName}</div>
                <div style="color: #71767b; font-size: 14px;">設置該角色在X平臺的專屬身份資料</div>
              </div>
            </div>
          `;
    },

    // 構建空狀態提示
    buildEmptyState(message) {
      return `<p style="color: #71767b; text-align: center; padding: 20px;">${message}</p>`;
    },

    // 構建錯誤狀態提示
    buildErrorState(message) {
      return `<p style="color: #f4212e; text-align: center; padding: 20px;">${message}</p>`;
    },
  };

  // 驗證和錯誤處理工具 - 簡化重複驗證邏輯
  const ValidationUtils = {
    // 驗證必需欄位
    validateRequired(fields) {
      const missing = [];
      for (const [key, value] of Object.entries(fields)) {
        if (!value || value.trim() === '') {
          missing.push(key);
        }
      }
      return {
        isValid: missing.length === 0,
        missing: missing,
      };
    },

    // 驗證控制碼格式
    validateHandle(handle) {
      if (!handle) return { isValid: false, error: '控制碼不能為空' };
      if (handle.length > 15) return { isValid: false, error: '控制碼長度不能超過15個字元' };
      if (!/^[a-zA-Z0-9_]+$/.test(handle)) return { isValid: false, error: '控制碼只能包含字母、數位和底線' };
      return { isValid: true };
    },

    // 驗證名稱長度
    validateName(name, maxLength = 30) {
      if (!name) return { isValid: false, error: '名稱不能為空' };
      if (name.length > maxLength) return { isValid: false, error: `名稱長度不能超過${maxLength}個字元` };
      return { isValid: true };
    },

    // 安全的資料解析
    safeParseJSON(jsonString, defaultValue = null) {
      try {
        return JSON.parse(jsonString);
      } catch (error) {
        console.error('JSON解析失敗:', error);
        return defaultValue;
      }
    },

    // 安全的DOM操作
    safeGetElement(id) {
      const element = document.getElementById(id);
      if (!element) {
        console.warn(`未找到元素: ${id}`);
      }
      return element;
    },

    // 統一錯誤處理
    handleError(error, context = '') {
      console.error(`${context} 錯誤:`, error);
      showXToast(`${context}失敗: ${error.message}`, 'error');
    },
  };

  // Token計數工具 - 用於監控AI調用的token使用量
  const TokenUtils = {
    // 估算文本的token數量（粗略估計：1個token ≈ 4個字元）
    estimateTokens(text) {
      if (!text) return 0;
      // 對於中文，大約2個漢字=1個token；對於英文，大約4個字元=1個token
      const chineseChars = (text.match(/[\u4e00-\u9fa5]/g) || []).length;
      const otherChars = text.length - chineseChars;
      return Math.ceil(chineseChars / 2 + otherChars / 4);
    },

    // 記錄token使用情況
    logTokenUsage(sceneName, step, content, cumulativeTokens = 0) {
      const tokens = this.estimateTokens(content);
      const newTotal = cumulativeTokens + tokens;
      console.log(
        `📊 [${sceneName}] ${step}: ${tokens.toLocaleString()} tokens | 累計: ${newTotal.toLocaleString()} tokens`,
      );
      return newTotal;
    },

    // 記錄完整prompt的token使用情況
    logFinalPrompt(sceneName, systemPrompt, userMessage = '', contextInfo = '') {
      const systemTokens = this.estimateTokens(systemPrompt);
      const userTokens = this.estimateTokens(userMessage);
      const contextTokens = this.estimateTokens(contextInfo);
      const totalTokens = systemTokens + userTokens + contextTokens;

      console.log(`
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📊 [${sceneName}] Token使用統計
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
系統提示詞: ${systemTokens.toLocaleString()} tokens
使用者消息: ${userTokens.toLocaleString()} tokens
上下文信息: ${contextTokens.toLocaleString()} tokens
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
總計: ${totalTokens.toLocaleString()} tokens
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      `);

      return {
        systemTokens,
        userTokens,
        contextTokens,
        totalTokens,
      };
    },
  };

  // 事件處理工具 - 簡化重複的事件處理邏輯
  const EventUtils = {
    // 添加懸停效果
    addHoverEffect(element, hoverStyle = {}, defaultStyle = {}) {
      if (!element) return;

      element.addEventListener('mouseover', () => {
        Object.assign(element.style, hoverStyle);
      });

      element.addEventListener('mouseout', () => {
        Object.assign(element.style, defaultStyle);
      });
    },

    // 批量添加懸停效果
    addHoverEffectBatch(selector, hoverStyle = {}, defaultStyle = {}) {
      document.querySelectorAll(selector).forEach(element => {
        this.addHoverEffect(element, hoverStyle, defaultStyle);
      });
    },

    // 添加按鈕懸停效果（通用樣式）
    addButtonHover(element) {
      this.addHoverEffect(
        element,
        {
          backgroundColor: 'rgba(255,255,255,0.1)',
        },
        {
          backgroundColor: 'transparent',
        },
      );
    },

    // 添加連結底線懸停效果
    addLinkUnderlineHover(element, targetSelector = 'span') {
      if (!element) return;

      element.addEventListener('mouseover', () => {
        const target = targetSelector ? element.querySelector(targetSelector) : element;
        if (target) target.style.textDecoration = 'underline';
      });

      element.addEventListener('mouseout', () => {
        const target = targetSelector ? element.querySelector(targetSelector) : element;
        if (target) target.style.textDecoration = 'none';
      });
    },

    // 安全的事件監聽器添加
    safeAddEventListener(element, event, handler) {
      if (element && typeof handler === 'function') {
        element.addEventListener(event, handler);
      }
    },

    // 防抖函數
    debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    },

    // 節流函數
    throttle(func, limit) {
      let inThrottle;
      return function executedFunction(...args) {
        if (!inThrottle) {
          func.apply(this, args);
          inThrottle = true;
          setTimeout(() => (inThrottle = false), limit);
        }
      };
    },
  };

  // 資料處理工具 - 簡化重複的資料處理邏輯
  const DataUtils = {
    // 格式化數字顯示
    formatNumber(num) {
      if (num === undefined || num === null) return '0';
      if (num < 1000) return num.toString();
      if (num < 1000000) return (num / 1000).toFixed(1).replace(/\.0$/, '') + 'K';
      if (num < 1000000000) return (num / 1000000).toFixed(1).replace(/\.0$/, '') + 'M';
      return (num / 1000000000).toFixed(1).replace(/\.0$/, '') + 'B';
    },

    // 格式化時間顯示
    formatTime(dateString) {
      const date = new Date(dateString);
      const now = new Date();
      const diffInSeconds = Math.floor((now - date) / 1000);

      if (diffInSeconds < 60) return '剛剛';
      if (diffInSeconds < 3600) return Math.floor(diffInSeconds / 60) + '分鐘前';
      if (diffInSeconds < 86400) return Math.floor(diffInSeconds / 3600) + '小時前';
      if (diffInSeconds < 2592000) return Math.floor(diffInSeconds / 86400) + '天前';

      return date.toLocaleDateString('zh-TW', {
        year: 'numeric',
        month: 'short',
        day: 'numeric',
      });
    },

    // 生成唯一ID
    generateId(prefix = 'id') {
      return `${prefix}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    },

    // 深拷貝物件
    deepClone(obj) {
      if (obj === null || typeof obj !== 'object') return obj;
      if (obj instanceof Date) return new Date(obj.getTime());
      if (obj instanceof Array) return obj.map(item => this.deepClone(item));
      if (typeof obj === 'object') {
        const clonedObj = {};
        for (const key in obj) {
          if (obj.hasOwnProperty(key)) {
            clonedObj[key] = this.deepClone(obj[key]);
          }
        }
        return clonedObj;
      }
    },

    // 陣列去重
    uniqueArray(arr, key = null) {
      if (key) {
        const seen = new Set();
        return arr.filter(item => {
          const keyValue = item[key];
          if (seen.has(keyValue)) {
            return false;
          }
          seen.add(keyValue);
          return true;
        });
      }
      return [...new Set(arr)];
    },

    // 安全獲取嵌套物件屬性
    safeGet(obj, path, defaultValue = null) {
      const keys = path.split('.');
      let result = obj;
      for (const key of keys) {
        if (result === null || result === undefined || !result.hasOwnProperty(key)) {
          return defaultValue;
        }
        result = result[key];
      }
      return result;
    },

    // 數據排序
    sortBy(arr, key, ascending = true) {
      return arr.sort((a, b) => {
        const aVal = this.safeGet(a, key);
        const bVal = this.safeGet(b, key);

        if (aVal < bVal) return ascending ? -1 : 1;
        if (aVal > bVal) return ascending ? 1 : -1;
        return 0;
      });
    },

    // 分頁資料
    paginate(arr, page = 1, limit = 10) {
      const offset = (page - 1) * limit;
      return {
        data: arr.slice(offset, offset + limit),
        pagination: {
          page,
          limit,
          total: arr.length,
          totalPages: Math.ceil(arr.length / limit),
          hasNext: offset + limit < arr.length,
          hasPrev: page > 1,
        },
      };
    },
  };

  // 性能優化工具 - 提升代碼執行效率
  const PerformanceUtils = {
    // 緩存機制
    cache: new Map(),

    // 設置緩存
    setCache(key, value, ttl = 300000) {
      // 默認5分鐘過期
      this.cache.set(key, {
        value,
        expiry: Date.now() + ttl,
      });
    },

    // 獲取緩存
    getCache(key) {
      const item = this.cache.get(key);
      if (!item) return null;

      if (Date.now() > item.expiry) {
        this.cache.delete(key);
        return null;
      }

      return item.value;
    },

    // 清理過期緩存
    cleanExpiredCache() {
      const now = Date.now();
      for (const [key, item] of this.cache.entries()) {
        if (now > item.expiry) {
          this.cache.delete(key);
        }
      }
    },

    // 批量DOM操作
    batchDOMUpdate(updates) {
      const fragment = document.createDocumentFragment();
      updates.forEach(update => {
        if (typeof update === 'function') {
          update(fragment);
        }
      });
      return fragment;
    },

    // 延遲執行
    defer(callback, delay = 0) {
      return setTimeout(callback, delay);
    },

    // 請求閒置時間執行
    idle(callback) {
      if (window.requestIdleCallback) {
        return window.requestIdleCallback(callback);
      } else {
        return setTimeout(callback, 1);
      }
    },

    // 監控性能
    measurePerformance(name, fn) {
      return async (...args) => {
        const start = performance.now();
        try {
          const result = await fn(...args);
          const end = performance.now();
          console.log(`Performance [${name}]: ${(end - start).toFixed(2)}ms`);
          return result;
        } catch (error) {
          const end = performance.now();
          console.error(`Performance [${name}] Error: ${(end - start).toFixed(2)}ms`, error);
          throw error;
        }
      };
    },
  };

  // 定期清理緩存
  setInterval(() => PerformanceUtils.cleanExpiredCache(), 60000); // 每分鐘清理一次

  // === 核心業務邏輯函數 ===

  // 頁面切換函數

  // 切換X社交頁面的函數 - 優化後
  function switchXPage(pageType) {
    // 如果切換到主頁、消息、通知、設置等主要頁面，清除搜索結果標記
    const mainPages = ['home', 'notifications', 'messages', 'settings', 'profile'];
    if (mainPages.includes(pageType) && isInSearchResults) {
      console.log('📖 [導航] 切換到其他頁面，清除搜索結果標記');
      isInSearchResults = false;
      currentSearchQuery = '';
    }

    // 清除對應頁面的提醒點
    if (pageType === 'home') {
      hideNavNotificationDot('home');
    } else if (pageType === 'notifications') {
      hideNavNotificationDot('notifications');
    } else if (pageType === 'messages') {
      hideNavNotificationDot('messages');
    }

    // 隱藏所有頁面，顯示選中頁面
    DOMUtils.hide('.x-page');
    const targetPage = document.getElementById('x-' + pageType + '-page');
    if (targetPage) targetPage.style.display = 'flex';

    // 獲取頂部欄和底部巡覽列
    const topBar = document.querySelector('.x-top-bar');
    const bottomNav = document.querySelector('.x-bottom-nav');
    const refreshBtn = document.querySelector('.refresh-trends-btn');

    // 如果是提問箱頁面，隱藏頂部欄和底部巡覽列
    if (pageType === 'askbox') {
      if (topBar) topBar.style.display = 'none';
      if (bottomNav) bottomNav.style.display = 'none';
      if (refreshBtn) refreshBtn.style.display = 'none';
    } else {
      // 其他頁面顯示頂部欄和底部巡覽列
      if (topBar) topBar.style.display = 'flex';
      if (bottomNav) bottomNav.style.display = 'flex';

      // 只在搜尋網頁面顯示刷新按鈕
      if (refreshBtn) {
        refreshBtn.style.display = pageType === 'search' ? 'flex' : 'none';
      }
    }

    // 重置導航樣式
    DOMUtils.removeClass('.x-nav-item', 'active');
    DOMUtils.setStyle('.x-nav-item svg', 'fill', '#fff');
    DOMUtils.hide('.nav-highlight');

    // 頁面索引映射
    const pageIndexMap = { home: 0, search: 1, notifications: 2, messages: 3, settings: -1, profile: -1, askbox: -1 };
    const targetIndex = pageIndexMap[pageType];

    if (pageType === 'profile') {
      setTimeout(() => {
        loadUserProfileToUI(); // 刷新使用者資料顯示
        loadUserProfileTweets(); // 載入用戶推文
      }, 100);
    } else if (pageType === 'askbox') {
      // 載入提問箱數據
      setTimeout(() => {
        loadAskboxData();
      }, 100);
    } else if (pageType === 'search') {
      // 載入搜尋網頁面數據
      setTimeout(() => {
        initSearchPage();
      }, 100);
    } else if (pageType === 'notifications') {
      // 載入通知資料
      setTimeout(async () => {
        await loadNotifications();
      }, 100);
    } else if (pageType === 'messages') {
      // 載入私信列表
      setTimeout(async () => {
        await loadMessagesList();
      }, 100);
    }

    // 切換到設置頁面時，重新載入X設置（按帳號載入）
    if (pageType === 'settings') {
      setTimeout(async () => {
        await initializeXSettings();
        await loadLanguagePreference(); // 載入語言偏好
        await loadAccentColorPreference(); // 載入主題色偏好
        console.log('✅ 已載入當前帳號的X設置');
      }, 100);
    }

    // 高亮當前導航項
    const navItems = document.querySelectorAll('.x-nav-item');
    if (navItems[targetIndex] && targetIndex >= 0) {
      navItems[targetIndex].classList.add('active');
      navItems[targetIndex].querySelector('svg').style.fill = 'var(--x-accent)';
      navItems[targetIndex].querySelector('.nav-highlight').style.display = 'block';
    }
  }

  // 添加主頁標籤切換功能
  function switchHomeTab(tabName) {
    // 重置所有標籤和內容
    DOMUtils.removeClass('.x-tab', 'active');
    DOMUtils.setStyle('.x-tab', 'color', '#71767b');
    DOMUtils.hide('.tab-indicator');
    DOMUtils.hide('.tab-content');

    // 啟動選中的標籤
    const tabs = document.querySelectorAll('.x-tab');
    const tabIndex = tabName === 'for-you' ? 0 : 1;
    const contentId = tabName === 'for-you' ? 'for-you-content' : 'following-content';

    if (tabs[tabIndex]) {
      tabs[tabIndex].classList.add('active');
      tabs[tabIndex].style.color = '#fff';
      tabs[tabIndex].querySelector('.tab-indicator').style.display = 'block';
    }

    const content = document.getElementById(contentId);
    if (content) content.style.display = 'flex';
  }

  // ============================================
  // 搜尋網頁面功能
  // ============================================

  // 熱搜數據
  let currentSearchTab = 'recommended';
  let trendingData = {
    recommended: [
      {
        id: 't1',
        category: '娛樂 · 熱門話題',
        title: '流行電影討論',
        count: 125600,
      },
      {
        id: 't2',
        category: '體育 · 即時',
        title: '籃球比賽精彩瞬間',
        count: 89200,
      },
      {
        id: 't3',
        category: '科技 · 趨勢',
        title: 'AI技術新突破',
        count: 256700,
      },
      {
        id: 't4',
        category: '音樂 · 流行',
        title: '新專輯發佈',
        count: 67800,
      },
      {
        id: 't5',
        category: '遊戲 · 熱門',
        title: '年度遊戲評選',
        count: 145300,
      },
    ],
    trending: [
      {
        id: 't6',
        category: '全球 · 趨勢',
        title: '國際新聞熱點',
        count: 892300,
      },
      {
        id: 't7',
        category: '商業 · 財經',
        title: '股市最新動態',
        count: 234500,
      },
      {
        id: 't8',
        category: '社會 · 討論',
        title: '社會話題關注',
        count: 456700,
      },
      {
        id: 't9',
        category: '文化 · 熱議',
        title: '傳統文化傳承',
        count: 178900,
      },
      {
        id: 't10',
        category: '健康 · 生活',
        title: '養生健康小貼士',
        count: 123400,
      },
    ],
  };

  // 自訂分類資料
  let customCategories = [];

  // 搜索相關資料
  let currentSearchQuery = '';
  let currentSearchResultTab = 'top';
  let isInSearchResults = false; // 標記是否在搜索結果視圖
  let searchResultsData = {
    top: [],
    latest: [],
    users: [],
  };

  // 切換搜索標籤
  function switchSearchTab(tabName) {
    currentSearchTab = tabName;

    // 更新標籤樣式
    const tabs = document.querySelectorAll('.search-tab');
    tabs.forEach(tab => {
      tab.classList.remove('active');
    });

    const activeTab = Array.from(tabs).find(tab => tab.onclick && tab.onclick.toString().includes(tabName));
    if (activeTab) {
      activeTab.classList.add('active');
    }

    // 渲染對應的熱搜列表
    renderTrendingList();
  }

  // 渲染熱搜列表
  function renderTrendingList() {
    const container = document.getElementById('trending-list');
    if (!container) return;

    const trends = trendingData[currentSearchTab] || [];

    if (trends.length === 0) {
      container.innerHTML = `
        <div style="display: flex; justify-content: center; align-items: center; padding: 40px 20px; color: #71767b;">
          暫無熱搜內容
        </div>
      `;
      return;
    }

    container.innerHTML = trends
      .map(
        trend => `
      <div class="trending-item" onclick="handleTrendingClick('${trend.id}')">
        <div class="trending-header">
          <div class="trending-category">${trend.category}</div>
          <div class="trending-more" onclick="event.stopPropagation(); handleTrendingMore('${trend.id}')">
            <svg viewBox="0 0 24 24" aria-hidden="true">
              <g><path d="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"></path></g>
            </svg>
          </div>
        </div>
        <div class="trending-title">${trend.title}</div>
        <div class="trending-count">${formatNumber(trend.count)} 條帖子</div>
      </div>
    `,
      )
      .join('');
  }

  // 刷新熱搜（第五個情景：熱搜生成器）
  async function refreshTrends() {
    const refreshBtn = document.querySelector('.refresh-trends-btn');
    if (!refreshBtn) return;

    // 添加旋轉動畫
    refreshBtn.classList.add('spinning');

    try {
      // 1. 讀取API配置和X設置
      const db = getDB(); // 用於訪問API配置
      const xDb = getXDB(); // 用於訪問X專用設置

      const apiConfig = await db.apiConfig.get('main');
      if (!apiConfig || !apiConfig.proxyUrl || !apiConfig.apiKey || !apiConfig.model) {
        showXToast('請先配置API設置', 'error');
        return;
      }

      const { proxyUrl, apiKey, model } = apiConfig;

      // 2. 從X設置中讀取配置（按帳號讀取）
      const settingsId = `xSettings_${currentAccountId || 'main'}`;
      const xSettings = await xDb.xSettings.get(settingsId);
      const userPrompt = xSettings?.systemPrompt || '';
      const worldSetting = xSettings?.worldSetting || '';
      const boundCharacters = xSettings?.boundCharacters || [];

      // 3. 構建使用者X個人資料資訊
      const userXProfileInfo = StringBuilders.buildUserXProfileInfo(window.userProfileData);

      // 4. 判斷用戶是否為大曝光身份（明星/網紅等公眾人物）
      const publicIdentity = userXProfileInfo.publicIdentity || '';
      const bio = userXProfileInfo.bio || '';
      const isPublicFigure =
        /明星|網紅|博主|演員|歌手|藝人|主播|up主|偶像|導演|製片|編劇|作家|influencer|celebrity|singer|actor|artist|streamer|idol/i.test(
          publicIdentity + ' ' + bio,
        );

      console.log('🎭 用戶公眾身份檢測:', {
        isPublicFigure,
        publicIdentity,
        bio,
      });

      // Token計數器
      let tokenCount = 0;

      // 5. 構建基礎系統提示詞（提示詞 + 世界觀）
      let systemPrompt = StringBuilders.buildBaseSystemPrompt({
        userPrompt,
        worldSetting,
      });
      tokenCount = TokenUtils.logTokenUsage('熱搜生成器', '基礎系統提示詞', systemPrompt, tokenCount);

      // 5.5. 獲取適用的世界書內容
      const worldBooksContent = await StringBuilders.getApplicableWorldBooks('trending', {
        boundCharacters,
      });
      if (worldBooksContent) {
        systemPrompt += worldBooksContent;
        tokenCount = TokenUtils.logTokenUsage('熱搜生成器', '世界書內容', worldBooksContent, tokenCount);
      }

      // 6. 獲取啟用的自訂分類
      const enabledCustomCategories = customCategories.filter(cat => cat.enabled && cat.name);

      // 7. 添加熱搜生成任務說明
      systemPrompt += `

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 核心任務說明 🎯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
你是X社交平臺的熱搜生成器。請生成當前的熱門話題清單。

【生成要求】：
- 為"為你推薦"和"當前趨勢"各生成5條熱搜
${
  enabledCustomCategories.length > 0
    ? `- 同時為以下自訂分類各生成5條熱搜：${enabledCustomCategories.map(c => `"${c.name}"`).join('、')}`
    : ''
}
- 熱搜話題要多樣化，涵蓋不同領域和分類
- 熱搜數量（帖子數）要符合真實社交平臺規模（1萬到100萬之間）
- 話題標題要簡潔有力，符合社交媒體特點
${
  isPublicFigure
    ? '- 用戶或綁定角色是公眾人物，可以適當生成1-2條相關熱搜（占比約20%）'
    : '- 用戶和角色不是公眾人物，生成通用熱門話題即可，不要涉及使用者或角色'
}

【熱搜分類示例】：
- 娛樂 · 熱門話題：電影、音樂、綜藝、明星動態
- 體育 · 即時：比賽、運動員、體育賽事
- 科技 · 趨勢：新技術、產品發佈、科技新聞
- 社會 · 討論：時事、民生、社會話題
- 遊戲 · 熱門：遊戲更新、電競、遊戲新聞
- 文化 · 熱議：藝術、文學、傳統文化
- 音樂 · 流行：新歌、演唱會、音樂人動態
- 美食 · 推薦：美食探店、烹飪技巧
- 旅遊 · 探索：旅行目的地、旅遊攻略
- 時尚 · 潮流：穿搭、時裝周、潮流單品
- 健康 · 生活：養生、健身、生活方式
- 全球 · 趨勢：國際新聞、全球熱點
- 商業 · 財經：經濟動態、商業新聞
- 教育 · 學習：學習方法、教育資訊
${
  enabledCustomCategories.length > 0
    ? `
【自訂分類詳細說明】：${enabledCustomCategories
        .map(
          cat => `
- ${cat.name}：${cat.description || '生成該分類下的熱門話題'}`,
        )
        .join('')}
`
    : ''
}
`;

      // 8. 如果是公眾人物，添加使用者和角色資訊
      if (isPublicFigure) {
        systemPrompt += `

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📋 公眾人物資訊（可用于生成相關熱搜）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【用戶公開信息】：
- 用戶名：${userXProfileInfo.name}
- 用戶控制碼：${userXProfileInfo.handle}
- 公眾身份：${userXProfileInfo.publicIdentity}
${userXProfileInfo.bio ? `- 個人簡介：${userXProfileInfo.bio}` : ''}
${
  userXProfileInfo.verificationType !== 'none'
    ? `- 認證狀態：${StringBuilders.getUserVerificationTypeDescription(userXProfileInfo)}`
    : ''
}
${
  userXProfileInfo.verificationType === 'couple' && userXProfileInfo.coupleCharacterName
    ? `- 情侶關係：與${userXProfileInfo.coupleCharacterName}為公開情侶`
    : ''
}
`;

        // 9. 讀取綁定的公眾人物（角色 + NPC）
        // 🎯 優化：添加NPC支持
        const publicFigureProfiles = [];

        // 9.1. 檢查綁定角色
        if (boundCharacters.length > 0) {
          const allXProfiles = await xDb.xCharacterProfiles.toArray();

          for (const charId of boundCharacters) {
            const xProfile = allXProfiles.find(p => p.characterId === charId);
            if (xProfile && xProfile.publicIdentity) {
              // 只添加有公眾身份的角色
              const isCharPublicFigure =
                /明星|網紅|博主|演員|歌手|藝人|主播|up主|偶像|導演|製片|編劇|作家|influencer|celebrity|singer|actor|artist|streamer|idol/i.test(
                  xProfile.publicIdentity,
                );

              if (isCharPublicFigure) {
                publicFigureProfiles.push({
                  type: 'character',
                  name: xProfile.xName,
                  handle: xProfile.xHandle,
                  publicIdentity: xProfile.publicIdentity,
                  bio: xProfile.xBio || '',
                });
              }
            }
          }
        }

        // 9.2. 檢查綁定的NPC
        const npcDataId = 'xNPCs_global';
        const npcData = await xDb.xNPCs.get(npcDataId);
        const allNPCs = npcData?.npcs || [];
        const currentAccount = currentAccountId || 'main';
        const boundNPCs = allNPCs.filter(npc => npc.boundUsers && npc.boundUsers.includes(currentAccount));

        for (const npc of boundNPCs) {
          // 檢查NPC是否有公眾屬性（人設或主頁內容中提到明星、網紅等）
          const npcTexts = [npc.personality || '', npc.homepage || ''].join(' ');
          const isNpcPublicFigure =
            /明星|網紅|博主|演員|歌手|藝人|主播|up主|偶像|導演|製片|編劇|作家|influencer|celebrity|singer|actor|artist|streamer|idol/i.test(
              npcTexts,
            );

          if (isNpcPublicFigure) {
            publicFigureProfiles.push({
              type: 'npc',
              name: npc.name,
              handle: npc.handle,
              publicIdentity: '公眾人物',
              bio: npc.personality || '',
            });
          }
        }

        if (publicFigureProfiles.length > 0) {
          systemPrompt += `
【綁定公眾人物資訊】：
`;
          for (const profile of publicFigureProfiles) {
            systemPrompt += `
【${profile.name}】（${profile.type === 'character' ? '角色' : 'NPC'}）
- X姓名：${profile.name}
- X控制碼：${profile.handle}
- 公眾身份：${profile.publicIdentity}
${profile.bio ? `- 簡介/人設：${profile.bio}` : ''}
`;

            // 讀取近期推文
            try {
              const cleanHandle = profile.handle.replace('@', '');
              const accountProfile = await xDb.xAccountProfiles.get(cleanHandle);
              const recentTweets = accountProfile?.tweets?.slice(0, 5) || [];

              if (recentTweets.length > 0) {
                systemPrompt += `
${profile.name} 的近期推文（${recentTweets.length}條）：
`;
                recentTweets.forEach((tweet, index) => {
                  systemPrompt += `
${index + 1}. "${tweet.content}"
   - 時間：${tweet.time || '最近'}
   - 互動：${tweet.stats?.likes || 0}喜歡，${tweet.stats?.retweets || 0}轉發
${tweet.media && tweet.media.length > 0 ? `   - 媒體：${tweet.media[0].description.substring(0, 50) + '...'}\n` : ''}`;
                });
              }
            } catch (error) {
              console.warn(`熱搜生成器：讀取 ${profile.name} 的推文失敗:`, error);
            }

            systemPrompt += `\n`;
          }
        }

        // 10. 添加用戶近期推文（如果用戶是公眾人物）
        // 讀取用戶的最近5條推文
        try {
          const userTweetsId = `userTweets_${currentAccountId || 'main'}`;
          const userTweetsData = await xDb.xUserTweets.get(userTweetsId);
          const recentUserTweets = userTweetsData?.tweets?.slice(0, 5) || [];

          if (recentUserTweets.length > 0) {
            systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📰 用戶近期推文（公眾人物）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
${userXProfileInfo.name} 的近期推文（${recentUserTweets.length}條）：
`;
            recentUserTweets.forEach((tweet, index) => {
              systemPrompt += `
${index + 1}. "${tweet.content}"
   - 時間：${tweet.time || '最近'}
   - 互動：${tweet.stats?.likes || 0}喜歡，${tweet.stats?.retweets || 0}轉發，${tweet.stats?.comments || 0}評論
${
  tweet.image
    ? `   - 媒體：${tweet.image.type === 'description' ? tweet.image.content.substring(0, 50) + '...' : '包含圖片'}\n`
    : ''
}`;
            });

            systemPrompt += `
【使用說明】：
- 可以基於使用者和角色的近期推文內容生成相關的熱搜話題
- 熱搜可以反映他們最近的活動、作品、或引起的討論
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
          }
        } catch (error) {
          console.warn('熱搜生成器：讀取用戶推文失敗:', error);
        }

        systemPrompt += `
【公眾人物熱搜規則】：
- 可以生成與用戶或角色相關的熱搜話題（1-2條，占比約20%）
- 話題應該基於公眾身份資訊和近期推文內容，符合其領域和形象
- 可以圍繞他們的近期動態、作品、或引起的熱議生成熱搜
- 不要洩露私密人設、聊天記憶等非公開信息
- 熱搜內容要真實可信，像真正的社交平臺熱搜
- 其餘80%的熱搜應該是與用戶/角色無關的通用熱門話題
`;

        // 統計公眾人物資訊和推文的 token 使用
        const publicFigureSection = systemPrompt.substring(systemPrompt.indexOf('📋 公眾人物資訊'));
        tokenCount = TokenUtils.logTokenUsage('熱搜生成器', '公眾人物資訊與近期推文', publicFigureSection, tokenCount);
      }

      // 11. 添加格式要求
      let jsonFormat = `{
  "recommended": [
    {
      "category": "分類 · 標籤",
      "title": "熱搜話題標題",
      "count": 數字（帖子數量，1萬-100萬之間）
    }
  ],
  "trending": [
    {
      "category": "分類 · 標籤",
      "title": "熱搜話題標題",
      "count": 數字（帖子數量，1萬-100萬之間）
    }
  ]`;

      // 如果有自訂分類，添加到JSON格式中
      if (enabledCustomCategories.length > 0) {
        enabledCustomCategories.forEach(cat => {
          jsonFormat += `,
  "${cat.id}": [
    {
      "category": "分類 · 標籤",
      "title": "熱搜話題標題",
      "count": 數字（帖子數量，1萬-100萬之間）
    }
  ]`;
        });
      }

      jsonFormat += `
}`;

      systemPrompt += `

【返回格式】：嚴格JSON格式，不要添加任何其他文字說明

${jsonFormat}

**注意事項**：
1. category格式：分類 · 標籤（例如："娛樂 · 熱門話題"）
2. title要簡潔有力，不超過20個字
3. count必須是純數字，不帶引號，範圍在10000-1000000之間
4. 每個陣列包含5個熱搜項
5. 話題要多樣化，不要集中在某一領域
6. 確保返回純JSON，不要有markdown代碼塊標記
${enabledCustomCategories.length > 0 ? `7. 自訂分類的熱搜要緊密圍繞分類主題和描述，確保內容相關性` : ''}

【最終檢查】：確認話題真實可信，分類準確，數量合理，${worldSetting.trim() ? '嚴格遵守世界觀設定，' : ''}格式正確。
`;

      const requirementsSection = systemPrompt.substring(systemPrompt.indexOf('🎯 核心任務說明 🎯'));
      tokenCount = TokenUtils.logTokenUsage('熱搜生成器', '任務說明與格式要求', requirementsSection, tokenCount);

      const messages = [{ role: 'user', content: '請生成最新的X平臺熱搜話題清單' }];

      // 最終統計
      TokenUtils.logFinalPrompt('熱搜生成器', systemPrompt, messages[0].content);

      // 12. 發送API請求
      let isGemini = proxyUrl.includes('generativelanguage');
      let response;

      if (isGemini) {
        const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models';
        const apiKeyValue = typeof getRandomValue === 'function' ? getRandomValue(apiKey) : apiKey;
        const geminiConfig = {
          url: `${GEMINI_API_URL}/${model}:generateContent?key=${apiKeyValue}`,
          data: {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              contents: [
                {
                  parts: [
                    {
                      text: systemPrompt + '\n\n' + messages.map(m => m.content).join('\n'),
                    },
                  ],
                },
              ],
              generationConfig: {
                temperature: 0.9,
              },
            }),
          },
        };
        response = await fetch(geminiConfig.url, geminiConfig.data);
      } else {
        const openAiPayload = {
          model: model,
          messages: [{ role: 'system', content: systemPrompt }, ...messages],
          temperature: 0.9,
          stream: false,
        };
        response = await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${apiKey}`,
          },
          body: JSON.stringify(openAiPayload),
        });
      }

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(`API錯誤: ${response.status} - ${errorData.error?.message || response.statusText}`);
      }

      const data = await response.json();
      let aiResponseContent;

      if (isGemini) {
        // Gemini格式
        if (data.candidates && data.candidates[0] && data.candidates[0].content && data.candidates[0].content.parts) {
          aiResponseContent = data.candidates[0].content.parts[0].text || '';
        }
      } else {
        // OpenAI格式
        aiResponseContent = data.choices?.[0]?.message?.content || '';
      }

      console.log('🔥 AI熱搜回應:', aiResponseContent);

      // 13. 解析JSON回應
      const cleanedResponse = aiResponseContent
        .replace(/```json\s*/i, '')
        .replace(/```\s*$/, '')
        .trim();

      if (!cleanedResponse) {
        throw new Error('AI返回了空的回應內容');
      }

      let newTrendsData;
      try {
        newTrendsData = JSON.parse(cleanedResponse);
      } catch (parseError) {
        console.error('JSON解析失敗:', parseError);
        console.error('嘗試解析的內容:', cleanedResponse.substring(0, 500) + '...');
        throw new Error(`AI返回的資料不是有效的JSON格式: ${parseError.message}`);
      }

      // 14. 驗證資料格式
      if (!newTrendsData.recommended || !newTrendsData.trending) {
        throw new Error('AI返回的資料格式不正確，缺少必要欄位');
      }

      if (!Array.isArray(newTrendsData.recommended) || !Array.isArray(newTrendsData.trending)) {
        throw new Error('熱搜資料格式錯誤：recommended和trending必須是陣列');
      }

      // 驗證自訂分類資料
      if (enabledCustomCategories.length > 0) {
        for (const category of enabledCustomCategories) {
          if (!newTrendsData[category.id]) {
            console.warn(`⚠️ AI未返回自訂分類"${category.name}"的數據`);
          } else if (!Array.isArray(newTrendsData[category.id])) {
            console.warn(`⚠️ 自訂分類"${category.name}"的資料格式錯誤`);
          }
        }
      }

      // 15. 為熱搜添加唯一ID
      const timestamp = Date.now();
      newTrendsData.recommended = newTrendsData.recommended.map((trend, index) => ({
        ...trend,
        id: `rec_${timestamp}_${index}`,
      }));

      newTrendsData.trending = newTrendsData.trending.map((trend, index) => ({
        ...trend,
        id: `trend_${timestamp}_${index}`,
      }));

      // 為自訂分類添加唯一ID
      enabledCustomCategories.forEach(category => {
        if (newTrendsData[category.id] && Array.isArray(newTrendsData[category.id])) {
          newTrendsData[category.id] = newTrendsData[category.id].map((trend, index) => ({
            ...trend,
            id: `${category.id}_${timestamp}_${index}`,
          }));
        }
      });

      // 16. 更新全域熱搜資料
      trendingData.recommended = newTrendsData.recommended;
      trendingData.trending = newTrendsData.trending;

      // 更新自訂分類資料
      enabledCustomCategories.forEach(category => {
        if (newTrendsData[category.id]) {
          trendingData[category.id] = newTrendsData[category.id];
        }
      });

      // 17. 保存到資料庫
      try {
        const saveData = {
          id: 'trends',
          recommended: newTrendsData.recommended,
          trending: newTrendsData.trending,
          lastUpdated: new Date().toISOString(),
        };

        // 添加自訂分類資料
        enabledCustomCategories.forEach(category => {
          if (newTrendsData[category.id]) {
            saveData[category.id] = newTrendsData[category.id];
          }
        });

        await xDb.xTweetsData.put(saveData);
        console.log('✅ 熱搜資料已保存到資料庫', {
          默認分類: 2,
          自訂分類: enabledCustomCategories.length,
        });
      } catch (saveError) {
        console.error('⚠️ 保存熱搜資料失敗:', saveError);
        // 不影響主流程，繼續執行
      }

      // 18. 重新渲染熱搜列表
      renderTrendingList();

      showXToast('熱搜已刷新', 'success');
    } catch (error) {
      console.error('❌ 刷新熱搜失敗:', error);
      showXToast(`刷新失敗: ${error.message}`, 'error');
    } finally {
      // 移除旋轉動畫
      if (refreshBtn) {
        refreshBtn.classList.remove('spinning');
      }
    }
  }

  // 處理熱搜點擊
  function handleTrendingClick(trendId) {
    console.log('點擊熱搜:', trendId);

    // 查找熱搜數據
    let trendItem = null;
    for (const category in trendingData) {
      const found = trendingData[category].find(t => t.id === trendId);
      if (found) {
        trendItem = found;
        break;
      }
    }

    if (!trendItem) {
      console.error('未找到熱搜數據:', trendId);
      return;
    }

    // 將熱搜標題填入搜索框
    const searchInput = document.getElementById('search-input');
    if (searchInput) {
      searchInput.value = trendItem.title;
      toggleSearchButton(); // 顯示搜索按鈕
    }

    // 自動執行搜索
    performSearch();
  }

  // 處理熱搜更多選項
  function handleTrendingMore(trendId) {
    console.log('熱搜更多選項:', trendId);
    showXToast('更多選項功能待開發', 'info');
  }

  // 顯示/隱藏搜索按鈕
  function toggleSearchButton() {
    const input = document.getElementById('search-input');
    const button = document.getElementById('search-submit-btn');

    if (input && button) {
      if (input.value.trim()) {
        button.style.display = 'flex';
      } else {
        button.style.display = 'none';
      }
    }
  }

  // 切換搜索結果標籤
  function switchSearchResultTab(tabName) {
    currentSearchResultTab = tabName;

    // 更新標籤樣式
    const tabs = document.querySelectorAll('#search-results-view .search-tab');
    tabs.forEach((tab, index) => {
      const tabNames = ['top', 'latest', 'users'];
      if (tabNames[index] === tabName) {
        tab.classList.add('active');
      } else {
        tab.classList.remove('active');
      }
    });

    // 渲染對應的搜索結果
    renderSearchResults();
  }

  // 渲染搜索結果
  function renderSearchResults() {
    const container = document.getElementById('search-results-content');
    if (!container) return;

    const results = searchResultsData[currentSearchResultTab] || [];

    if (results.length === 0) {
      container.innerHTML = `
        <div style="
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          padding: 60px 20px;
          color: #71767b;
        ">
          <svg viewBox="0 0 24 24" style="width: 80px; height: 80px; fill: #71767b; margin-bottom: 20px;">
            <g><path d="M10.25 3.75c-3.59 0-6.5 2.91-6.5 6.5s2.91 6.5 6.5 6.5c1.795 0 3.419-.726 4.596-1.904 1.178-1.177 1.904-2.801 1.904-4.596 0-3.59-2.91-6.5-6.5-6.5zm-8.5 6.5c0-4.694 3.806-8.5 8.5-8.5s8.5 3.806 8.5 8.5c0 1.986-.682 3.815-1.824 5.262l4.781 4.781-1.414 1.414-4.781-4.781c-1.447 1.142-3.276 1.824-5.262 1.824-4.694 0-8.5-3.806-8.5-8.5z"></path></g>
          </svg>
          <div style="font-size: 20px; font-weight: 600; margin-bottom: 8px;">沒有找到結果</div>
          <div style="font-size: 14px;">嘗試搜索其他內容</div>
        </div>
      `;
      return;
    }

    // 如果是使用者標籤，顯示使用者卡片
    if (currentSearchResultTab === 'users') {
      container.innerHTML = results
        .map(
          user => `
        <div style="
          padding: 16px;
          border-bottom: 1px solid #2f3336;
          display: flex;
          align-items: center;
          gap: 12px;
          cursor: pointer;
          transition: background-color 0.2s;
        " onmouseover="this.style.backgroundColor='rgba(255,255,255,0.03)'"
          onmouseout="this.style.backgroundColor='transparent'">
          <img 
            src="${user.avatar}" 
            alt="${user.name}" 
            onclick="event.stopPropagation(); openAccountProfile('${user.name.replace(/'/g, "\\'")}', '${
            user.handle.startsWith('@') ? user.handle : '@' + user.handle
          }', '${user.avatar}', {
              source: 'search',
              searchQuery: '${currentSearchQuery.replace(/'/g, "\\'")}',
              userBio: '${(user.bio || '').replace(/'/g, "\\'")}',
              verified: ${user.verified || false}
            })"
            style="
            width: 48px;
            height: 48px;
            border-radius: 50%;
            flex-shrink: 0;
              cursor: pointer;
              transition: opacity 0.2s;
            "
            onmouseover="this.style.opacity='0.8'"
            onmouseout="this.style.opacity='1'">
          <div style="flex: 1; min-width: 0;">
            <div style="display: flex; align-items: center; gap: 4px; margin-bottom: 2px;">
              <span style="color: #fff; font-weight: 700; font-size: 15px;">${user.name}</span>
              ${
                user.verified
                  ? `<svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-accent);">
                       <g><path d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.26 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.45 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z"></path></g>
                     </svg>`
                  : ''
              }
            </div>
            <div style="color: #71767b; font-size: 15px; margin-bottom: 4px;">@${user.handle}</div>
            ${user.bio ? `<div style="color: #e7e9ea; font-size: 14px;">${user.bio}</div>` : ''}
          </div>
        </div>
      `,
        )
        .join('');
    } else {
      // 渲染推文列表（熱門/最新）
      container.innerHTML = '';
      results.forEach(tweet => {
        const tweetElement = createTweetElement(tweet);
        container.appendChild(tweetElement);

        // 修改評論按鈕的點擊行為，使其顯示詳情頁而不是評論列表
        const commentAction = tweetElement.querySelector('.tweet-action.comment');
        if (commentAction) {
          // 移除原有的 onclick 屬性
          commentAction.removeAttribute('onclick');
          // 添加新的點擊事件
          commentAction.addEventListener('click', async e => {
            e.stopPropagation();
            console.log('📖 [搜索結果] 點擊評論按鈕，顯示詳情:', tweet.id);
            await showSearchTweetDetail(tweet.id);
          });
        }
      });
    }
  }

  // 顯示搜索結果推文詳情
  window.showSearchTweetDetail = async function (tweetId) {
    console.log('📖 [搜索結果] 顯示推文詳情:', tweetId);

    // 從搜索結果中查找推文
    const allSearchTweets = [...(searchResultsData.top || []), ...(searchResultsData.latest || [])];
    const tweet = allSearchTweets.find(t => t.id === tweetId);

    if (!tweet) {
      showXToast('未找到該推文', 'error');
      return;
    }

    // 確保推文已標記為搜索結果
    if (!tweet._source) {
      tweet._source = 'search';
    }

    // 使用現有的showTweetDetail函數顯示詳情
    await showTweetDetail(tweet);
  };

  // 執行搜索（第六個情景：搜索生成器）
  async function performSearch() {
    const input = document.getElementById('search-input');
    const query = input?.value?.trim();

    if (!query) {
      showXToast('請輸入搜索內容', 'info');
      return;
    }

    currentSearchQuery = query;
    isInSearchResults = true; // 標記進入搜索結果視圖

    // 顯示搜索結果視圖，隱藏熱搜視圖
    document.getElementById('trending-view').style.display = 'none';
    document.getElementById('search-results-view').style.display = 'flex';

    // 顯示返回按鈕，隱藏刷新按鈕
    const backBtn = document.getElementById('search-back-btn');
    if (backBtn) backBtn.style.display = 'flex';

    const refreshBtn = document.querySelector('.refresh-trends-btn');
    if (refreshBtn) refreshBtn.style.display = 'none';

    // 顯示載入狀態
    const container = document.getElementById('search-results-content');
    container.innerHTML = `
      <div style="
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 60px 20px;
        color: #71767b;
      ">
        <div style="
          width: 40px;
          height: 40px;
          border: 3px solid var(--x-accent);
          border-top-color: transparent;
          border-radius: 50%;
          animation: spin 1s linear infinite;
        "></div>
        <div style="margin-top: 20px; font-size: 15px;">正在搜索"${query}"...</div>
      </div>
    `;

    try {
      // 1. 讀取API配置和X設置
      const db = getDB();
      const xDb = getXDB();

      const apiConfig = await db.apiConfig.get('main');
      if (!apiConfig || !apiConfig.proxyUrl || !apiConfig.apiKey || !apiConfig.model) {
        showXToast('請先配置API設置', 'error');
        return;
      }

      const { proxyUrl, apiKey, model } = apiConfig;

      // 2. 從X設置中讀取配置
      const settingsId = `xSettings_${currentAccountId || 'main'}`;
      const xSettings = await xDb.xSettings.get(settingsId);
      const userPrompt = xSettings?.systemPrompt || '';
      const worldSetting = xSettings?.worldSetting || '';
      const boundCharacters = xSettings?.boundCharacters || [];

      // 3. 構建使用者X個人資料資訊
      const userXProfileInfo = StringBuilders.buildUserXProfileInfo(window.userProfileData);

      // 4. 讀取綁定角色的X資料
      const allXProfiles = await xDb.xCharacterProfiles.toArray();
      const characterXProfiles = [];

      for (const charId of boundCharacters) {
        const xProfile = allXProfiles.find(p => p.characterId === charId);
        if (xProfile) {
          characterXProfiles.push(xProfile);
        }
      }

      // 5. 檢查用戶是否為公眾人物（高曝光率身份）
      const userPublicIdentity = userXProfileInfo.publicIdentity || '';
      const userBio = userXProfileInfo.bio || '';
      const isUserPublicFigure =
        /明星|網紅|博主|演員|歌手|藝人|主播|up主|偶像|導演|製片|編劇|作家|influencer|celebrity|singer|actor|artist|streamer|idol/i.test(
          userPublicIdentity + ' ' + userBio,
        );

      // Token計數器
      let tokenCount = 0;

      // 7. 構建基礎系統提示詞
      let systemPrompt = StringBuilders.buildBaseSystemPrompt({
        userPrompt,
        worldSetting,
      });
      tokenCount = TokenUtils.logTokenUsage('搜索生成器', '基礎系統提示詞', systemPrompt, tokenCount);

      // 7.5. 獲取適用的世界書內容
      const worldBooksContent = await StringBuilders.getApplicableWorldBooks('search', {
        boundCharacters,
      });
      if (worldBooksContent) {
        systemPrompt += worldBooksContent;
        tokenCount = TokenUtils.logTokenUsage('搜索生成器', '世界書內容', worldBooksContent, tokenCount);
      }

      // 7.6. 從世界書中提取可能提到的角色ID，並將其添加到允許列表
      const worldBookCharacterIds = new Set();
      if (worldBooksContent) {
        // 遍歷所有綁定的角色，檢查世界書中是否提到他們
        for (const charId of boundCharacters) {
          const xProfile = allXProfiles.find(p => p.characterId === charId);
          if (xProfile) {
            const charName = xProfile.xName || '';
            const charHandle = xProfile.xHandle || '';
            // 如果世界書內容中提到了角色名或控制碼，將其加入列表
            if (
              (charName && worldBooksContent.includes(charName)) ||
              (charHandle && worldBooksContent.includes(charHandle))
            ) {
              worldBookCharacterIds.add(charId);
              console.log(`🔍 世界書中提到角色: ${charName} (${charHandle})`);
            }
          }
        }
      }

      // 6. 檢查所有可能出現在搜索中的身份（角色/NPC/關係NPC）
      // 🎯 優化：使用統一資料獲取系統
      const allowedProfiles = [];
      const queryLower = query.toLowerCase();

      // 6.1. 檢查綁定角色
      for (const xProfile of characterXProfiles) {
        let allowInSearch = false;

        // 檢查角色是否為公眾人物
        const charPublicIdentity = xProfile.publicIdentity || '';
        const isCharPublicFigure =
          /明星|網紅|博主|演員|歌手|藝人|主播|up主|偶像|導演|製片|編劇|作家|influencer|celebrity|singer|actor|artist|streamer|idol/i.test(
            charPublicIdentity,
          );

        // 判斷是否允許在搜索結果中出現
        if (isCharPublicFigure) {
          // 公眾人物：檢查搜索關鍵字是否與角色相關
          const charName = xProfile.xName || '';
          const charHandle = xProfile.xHandle || '';
          const charBio = xProfile.xBio || '';

          if (
            charName.toLowerCase().includes(queryLower) ||
            queryLower.includes(charName.toLowerCase()) ||
            charHandle.toLowerCase().includes(queryLower) ||
            queryLower.includes(charHandle.toLowerCase()) ||
            charPublicIdentity.toLowerCase().includes(queryLower) ||
            queryLower.includes(charPublicIdentity.toLowerCase()) ||
            (charBio && (charBio.toLowerCase().includes(queryLower) || queryLower.includes(charBio.toLowerCase())))
          ) {
            allowInSearch = true;
          }
        }

        // 檢查真名搜索：只有公開真名的角色才能通過真名搜索到
        if (xProfile.showRealName && xProfile.realName) {
          const realNameLower = xProfile.realName.toLowerCase();
          if (realNameLower.includes(queryLower) || queryLower.includes(realNameLower)) {
            allowInSearch = true;
          }
        }

        if (allowInSearch) {
          allowedProfiles.push({
            type: 'character',
            characterId: xProfile.characterId,
            xProfile: xProfile,
            name: xProfile.xName,
            handle: xProfile.xHandle,
            avatar: xProfile.xAvatar,
            verified: xProfile.xVerified || false,
            publicIdentity: charPublicIdentity,
            bio: xProfile.xBio || '',
            reason: '公眾人物或真名搜索',
          });
        }
      }

      // 6.2. 檢查綁定的NPC
      const npcDataId = 'xNPCs_global';
      const npcData = await xDb.xNPCs.get(npcDataId);
      const allNPCs = npcData?.npcs || [];
      const currentAccount = currentAccountId || 'main';
      const boundNPCs = allNPCs.filter(npc => npc.boundUsers && npc.boundUsers.includes(currentAccount));

      for (const npc of boundNPCs) {
        // NPC默認可以被搜索到（因為它們通常是公開帳戶）
        const npcName = npc.name || '';
        const npcHandle = npc.handle || '';
        const npcPersonality = npc.personality || '';
        const npcHomepage = npc.homepage || '';

        // 檢查搜索關鍵字是否與NPC相關
        if (
          npcName.toLowerCase().includes(queryLower) ||
          queryLower.includes(npcName.toLowerCase()) ||
          npcHandle.toLowerCase().includes(queryLower) ||
          queryLower.includes(npcHandle.toLowerCase()) ||
          npcPersonality.toLowerCase().includes(queryLower) ||
          npcHomepage.toLowerCase().includes(queryLower)
        ) {
          allowedProfiles.push({
            type: 'npc',
            npc: npc,
            name: npcName,
            handle: npcHandle,
            avatar: npc.avatar,
            verified: false,
            publicIdentity: '',
            bio: '',
            reason: 'NPC帳戶匹配',
          });
        }
      }

      // 6.3. 檢查關係NPC
      for (const xProfile of allXProfiles) {
        if (xProfile.relationships && xProfile.relationships.length > 0) {
          for (const relationship of xProfile.relationships) {
            const relNpcName = relationship.npcName || '';
            const relNpcHandle = relationship.npcHandle || '';
            const relType = relationship.relationshipType || '';
            const relDesc = relationship.description || '';

            // 檢查搜索關鍵字是否與關係NPC相關
            if (
              relNpcName.toLowerCase().includes(queryLower) ||
              queryLower.includes(relNpcName.toLowerCase()) ||
              relNpcHandle.toLowerCase().includes(queryLower) ||
              queryLower.includes(relNpcHandle.toLowerCase()) ||
              relType.toLowerCase().includes(queryLower) ||
              relDesc.toLowerCase().includes(queryLower)
            ) {
              allowedProfiles.push({
                type: 'relationshipNpc',
                relationship: relationship,
                ownerXProfile: xProfile,
                name: relNpcName,
                handle: relNpcHandle,
                avatar: 'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg',
                verified: false,
                publicIdentity: '',
                bio: '',
                reason: '關係NPC匹配',
              });
            }
          }
        }
      }

      console.log('🔍 搜索匹配檢查:', {
        query,
        角色: allowedProfiles.filter(p => p.type === 'character').length,
        NPC: allowedProfiles.filter(p => p.type === 'npc').length,
        關係NPC: allowedProfiles.filter(p => p.type === 'relationshipNpc').length,
        總計: allowedProfiles.length,
      });

      // 7.7. 將世界書中提到的角色也加入允許列表（如果尚未加入）
      for (const charId of worldBookCharacterIds) {
        // 檢查是否已在允許列表中
        if (!allowedProfiles.find(p => p.type === 'character' && p.characterId === charId)) {
          const xProfile = allXProfiles.find(p => p.characterId === charId);
          if (xProfile) {
            allowedProfiles.push({
              type: 'character',
              characterId: xProfile.characterId,
              xProfile: xProfile,
              name: xProfile.xName,
              handle: xProfile.xHandle,
              avatar: xProfile.xAvatar,
              verified: xProfile.xVerified || false,
              publicIdentity: xProfile.publicIdentity || '',
              bio: xProfile.xBio || '',
              reason: '世界書提及',
            });
          }
        }
      }

      console.log('🔍 搜索隱私檢查（優化後）:', {
        query,
        isUserPublicFigure,
        totalCharacters: boundCharacters.length,
        totalNPCs: boundNPCs.length,
        worldBookMentioned: worldBookCharacterIds.size,
        allowedTotal: allowedProfiles.length,
        allowedList: allowedProfiles.map(p => `${p.name} (${p.reason})`),
      });

      // 8. 添加搜索任務說明
      systemPrompt += `

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 核心任務說明 🎯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
你是X社交平臺的搜索結果生成器。使用者搜索了關鍵字："${query}"

這是全域搜索，需要生成符合搜索關鍵字的X平臺內容。

請生成與搜索關鍵字相關的結果：
- 熱門：3-8條與關鍵字高度相關的熱門推文
- 最新：3-5條與關鍵字相關的最新推文  
- 用戶：2-6個與關鍵字相關的X使用者帳號

【重要隱私規則】：
${
  allowedProfiles.length === 0 && !isUserPublicFigure
    ? `- **禁止出現綁定身份**：用戶和所有綁定身份都不符合搜索條件
- 生成的所有內容必須是虛構的陌生用戶，不能使用任何綁定角色/NPC的資訊
- 這是全域搜索，應該展示與關鍵字相關的公眾內容，而非私人關係`
    : ''
}
${
  isUserPublicFigure && queryLower.includes(userXProfileInfo.name.toLowerCase())
    ? `- **使用者是公眾人物且搜索了使用者相關關鍵字**：可以生成少量與使用者相關的內容（1-2條）`
    : ''
}
${
  allowedProfiles.length > 0
    ? `- **允許出現以下身份**（僅限這些）：${allowedProfiles.map(p => `${p.name}[${p.reason}]`).join('、')}
- 原因說明：
  * "公眾人物或真名搜索"：該角色是公眾人物且搜索關鍵字與他們相關，或搜索了他們公開的真名
  * "世界書提及"：該角色在世界書中被提及，可以根據世界書的上下文在搜索結果中出現
  * "NPC帳戶匹配"：該NPC的名稱、控制碼或人設與搜索關鍵字匹配
  * "關係NPC匹配"：該關係NPC的名稱、控制碼或關係描述與搜索關鍵字匹配
- 其他未列出的身份嚴禁出現`
    : `- **禁止出現任何綁定身份**：沒有身份符合出現條件（非公眾人物、搜索關鍵字不相關、且未在世界書中提及）`
}

【生成要求】：
- 所有內容必須與搜索關鍵字"${query}"高度相關
- 熱門推文應該有較高的互動資料（點贊、轉發、評論）
- 最新推文時間較近（幾分鐘到幾小時前）
- 推文內容要多樣化，從不同角度體現搜索關鍵字
- 每條推文2-5條評論即可
- 用戶帳號要有相關性（用戶名、簡介、或身份與關鍵字相關）
- 除已綁定角色外，其他用戶頭像統一：https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg
- 這是全域搜索，應展示多樣化的陌生使用者內容，而非私人社交圈
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;

      const taskSection = systemPrompt.substring(systemPrompt.indexOf('🎯 核心任務說明 🎯'));
      tokenCount = TokenUtils.logTokenUsage('搜索生成器', '搜索任務說明', taskSection, tokenCount);

      // 9. 如果有允許出現的身份，添加資料 + 近期推文
      // 🎯 優化：支持角色/NPC/關係NPC
      if (allowedProfiles.length > 0) {
        const profileSectionStart = systemPrompt.length;
        systemPrompt += `

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📋 允許出現的身份資訊
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
以下是符合搜索條件、可以在結果中出現的身份：

`;
        for (const profile of allowedProfiles) {
          systemPrompt += `
【${profile.name}】（${profile.type === 'character' ? '角色' : profile.type === 'npc' ? 'NPC' : '關係NPC'}）
- X姓名：${profile.name}
- X控制碼：${profile.handle}
- X頭像：${profile.avatar}
- 認證狀態：${profile.verified ? '已認證' : '未認證'}
${profile.publicIdentity ? `- 公眾身份：${profile.publicIdentity}` : ''}
${profile.bio ? `- X簡介：${profile.bio}` : ''}
- 出現原因：${profile.reason}
`;

          // 根據類型添加特定資訊
          if (profile.type === 'character' && profile.xProfile) {
            if (profile.xProfile.showRealName && profile.xProfile.realName) {
              systemPrompt += `- 真實姓名：${profile.xProfile.realName}（已公開）\n`;
            }
          } else if (profile.type === 'npc' && profile.npc) {
            if (profile.npc.personality) {
              systemPrompt += `- 人設：${profile.npc.personality}\n`;
            }
            if (profile.npc.postingHabits) {
              systemPrompt += `- 發帖習慣：${profile.npc.postingHabits}\n`;
            }
          } else if (profile.type === 'relationshipNpc' && profile.relationship) {
            systemPrompt += `- 關係類型：與 ${profile.ownerXProfile.xName} (${profile.ownerXProfile.xHandle}) 的 ${profile.relationship.relationshipType}\n`;
            if (profile.relationship.description) {
              systemPrompt += `- 關係描述：${profile.relationship.description}\n`;
            }
          }

          // 讀取近期推文（所有類型都嘗試讀取）
          try {
            const cleanHandle = profile.handle.replace('@', '');
            const accountProfile = await xDb.xAccountProfiles.get(cleanHandle);
            const recentTweets = accountProfile?.tweets?.slice(0, 5) || [];

            if (recentTweets.length > 0) {
              systemPrompt += `
${profile.name} 的近期推文（${recentTweets.length}條）：
`;
              recentTweets.forEach((tweet, index) => {
                systemPrompt += `
${index + 1}. "${tweet.content}"
   - 時間：${tweet.time || '最近'}
   - 互動：${tweet.stats?.likes || 0}喜歡，${tweet.stats?.retweets || 0}轉發
${tweet.media && tweet.media.length > 0 ? `   - 媒體：${tweet.media[0].description.substring(0, 50) + '...'}\n` : ''}`;
              });
            }
          } catch (error) {
            console.warn(`搜索生成器：讀取 ${profile.name} 的推文失敗:`, error);
          }

          systemPrompt += `\n`;
        }

        systemPrompt += `
【使用規則】：
- 只能使用上述列出的身份資訊
- 必須嚴格使用其X姓名、控制碼、頭像、認證狀態
- 如果他們與搜索關鍵字相關，可以作為推文發佈者或出現在用戶列表中
- 可以基於他們的近期推文內容生成相關的搜索結果
- 標注為"世界書提及"的角色，說明他們在世界書中被提及
- 標注為"公眾人物或真名搜索"的角色，說明他們是公眾人物且與搜索關鍵字相關
- 標注為"NPC帳戶匹配"的NPC，說明其資訊與搜索關鍵字匹配
- 標注為"關係NPC匹配"的關係NPC，說明其關係資訊與搜索關鍵字匹配
- 其他未列出的身份嚴禁出現
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
        const profileSection = systemPrompt.substring(profileSectionStart);
        tokenCount = TokenUtils.logTokenUsage('搜索生成器', '允許身份資訊與推文', profileSection, tokenCount);
      }

      // 10. 使用者資料 + 近期推文（如果用戶是公眾人物且被搜索）
      const userConstraintsStart = systemPrompt.length;
      systemPrompt += StringBuilders.buildUniversalConstraints(userXProfileInfo);

      // 如果使用者是公眾人物且搜索關鍵字與使用者相關，添加用戶近期推文
      if (isUserPublicFigure && queryLower.includes(userXProfileInfo.name.toLowerCase())) {
        systemPrompt += `

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📰 用戶近期推文（公眾人物）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;

        // 讀取用戶的最近5條推文
        try {
          const userTweetsId = `userTweets_${currentAccountId || 'main'}`;
          const userTweetsData = await xDb.xUserTweets.get(userTweetsId);
          const recentUserTweets = userTweetsData?.tweets?.slice(0, 5) || [];

          if (recentUserTweets.length > 0) {
            systemPrompt += `${userXProfileInfo.name} 的近期推文（${recentUserTweets.length}條）：
`;
            recentUserTweets.forEach((tweet, index) => {
              systemPrompt += `
${index + 1}. "${tweet.content}"
   - 時間：${tweet.time || '最近'}
   - 互動：${tweet.stats?.likes || 0}喜歡，${tweet.stats?.retweets || 0}轉發，${tweet.stats?.comments || 0}評論
${
  tweet.image
    ? `   - 媒體：${tweet.image.type === 'description' ? tweet.image.content.substring(0, 50) + '...' : '包含圖片'}\n`
    : ''
}`;
            });

            systemPrompt += `
【使用說明】：
- 可以基於用戶的近期推文生成相關的搜索結果
- 用戶是公眾人物，可以在搜索結果中適度出現（1-2條推文）
- 但仍然禁止在評論區假扮用戶身份
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
          } else {
            systemPrompt += `暫無近期推文資料
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
          }
        } catch (error) {
          console.warn('搜索生成器：讀取用戶推文失敗:', error);
          systemPrompt += `暫無近期推文資料
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
        }
      }

      const userConstraints = systemPrompt.substring(userConstraintsStart);
      tokenCount = TokenUtils.logTokenUsage('搜索生成器', '使用者資料約束與推文', userConstraints, tokenCount);

      // 11. 添加格式要求
      systemPrompt += `

【JSON返回格式】：
\`\`\`json
{
  "top": [熱門推文陣列(3-5條)],
  "latest": [最新推文陣列(3-5條)],
  "users": [使用者陣列(2-4個)]
}
\`\`\`

推文物件結構：
- user: {name, handle, avatar, verified}
- content: 推文文本（必須與"${query}"相關）
- time: 時間描述
- stats: {comments, retweets, likes, views} (純數字)
- media: [{type:"description", description:"描述，至少20字", sensitive:false}] (可選，30-50%推文包含)
- comments: [評論陣列(2-5條，必須生成)]

評論物件結構：
- id: 評論唯一ID（可留空，系統自動生成）
- user: {name, handle, avatar, verified}
- content: 評論文本
- time: 時間描述
- image: {type: "description", content: "圖片文字描述"} (可選，10-20%的評論帶圖)
- replies: [樓中樓回復陣列] (可選，0-2條)

樓中樓回復物件結構：
- id: 回復唯一ID（可留空，系統自動生成）
- user: {name, handle, avatar, verified}
- content: 回復文本
- time: 時間描述
- image: {type: "description", content: "圖片文字描述"} (可選)
- replyTo: "@被回復者控制碼" (必填)

使用者物件結構：
- name: 用戶姓名
- handle: 用戶控制碼（不帶@）
- avatar: 頭像URL
- verified: 布林值
- bio: 個人簡介（體現與"${query}"的關聯）

關鍵規則：
1. 所有內容必須圍繞搜索關鍵字"${query}"展開
2. 熱門推文stats高（1萬-50萬），最新推文stats低（100-5千）
3. 最新推文時間近（剛剛、幾分鐘前、1小時前等）
4. verified欄位必須是布林值(true/false)
5. stats中所有數位必須是純數位
6. 每條推文必須包含2-5條評論，10-20%的評論可帶圖
7. 評論可以包含樓中樓回復（replies陣列），形成對話鏈${worldSetting.trim() ? '\n8. 嚴格遵守世界觀設定' : ''}

【🔒 隱私保護規則】：
🚨 搜索結果中的評論者（非綁定角色/關係NPC的路人）只能基於X平臺公開信息：
  ✅ 可以使用：X姓名、X控制碼、X簡介、公開身份
  ❌ 禁止提及：真實姓名、真實職業、私人關係、未公開的身份資訊
  ❌ 禁止使用：只有親密關係才知道的稱呼（如"老師"、"同學"等，除非是公開身份）
  
⚠️ 只有已綁定的關係NPC才能在評論中提及私密資訊（因為他們是角色的私人關係）
`;

      const formatSection = systemPrompt.substring(systemPrompt.lastIndexOf('【JSON返回格式】'));
      tokenCount = TokenUtils.logTokenUsage('搜索生成器', 'JSON格式要求', formatSection, tokenCount);

      const messages = [{ role: 'user', content: `請生成關鍵字"${query}"的搜索結果` }];

      // 最終統計
      TokenUtils.logFinalPrompt('搜索生成器', systemPrompt, messages[0].content);

      // 12. 發送API請求
      let isGemini = proxyUrl.includes('generativelanguage');
      let response;

      if (isGemini) {
        const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models';
        const apiKeyValue = typeof getRandomValue === 'function' ? getRandomValue(apiKey) : apiKey;
        const geminiConfig = {
          url: `${GEMINI_API_URL}/${model}:generateContent?key=${apiKeyValue}`,
          data: {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              contents: [
                {
                  parts: [
                    {
                      text: systemPrompt + '\n\n' + messages.map(m => m.content).join('\n'),
                    },
                  ],
                },
              ],
              generationConfig: {
                temperature: 0.8,
              },
            }),
          },
        };
        response = await fetch(geminiConfig.url, geminiConfig.data);
      } else {
        const openAiPayload = {
          model: model,
          messages: [{ role: 'system', content: systemPrompt }, ...messages],
          temperature: 0.8,
          stream: false,
        };
        response = await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${apiKey}`,
          },
          body: JSON.stringify(openAiPayload),
        });
      }

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(`API錯誤: ${response.status} - ${errorData.error?.message || response.statusText}`);
      }

      const data = await response.json();
      let aiResponseContent;

      if (isGemini) {
        if (data.candidates && data.candidates[0] && data.candidates[0].content && data.candidates[0].content.parts) {
          aiResponseContent = data.candidates[0].content.parts[0].text || '';
        }
      } else {
        aiResponseContent = data.choices?.[0]?.message?.content || '';
      }

      console.log('🔍 AI搜索回應:', aiResponseContent);

      // 13. 解析JSON回應
      const cleanedResponse = aiResponseContent
        .replace(/```json\s*/i, '')
        .replace(/```\s*$/, '')
        .trim();

      if (!cleanedResponse) {
        throw new Error('AI返回了空的回應內容');
      }

      let searchResults;
      try {
        searchResults = JSON.parse(cleanedResponse);
      } catch (parseError) {
        console.error('JSON解析失敗:', parseError);
        console.error('嘗試解析的內容:', cleanedResponse.substring(0, 500) + '...');
        throw new Error(`AI返回的資料不是有效的JSON格式: ${parseError.message}`);
      }

      // 🚫 篩選用戶身份冒用（最優先）
      searchResults = StringBuilders.filterUserImpersonation(
        searchResults,
        userXProfileInfo.handle,
        userXProfileInfo.name,
      );

      // 🔧 強制修正所有頭像
      await StringBuilders.enforceAvatarRules(searchResults, userXProfileInfo.handle);

      // 14. 驗證資料格式
      if (!searchResults.top || !searchResults.latest || !searchResults.users) {
        throw new Error('AI返回的資料格式不正確，缺少必要欄位');
      }

      // 15. 為推文添加唯一ID和來源標記
      const timestamp = Date.now();

      searchResults.top = searchResults.top.map((tweet, index) => ({
        ...tweet,
        id: `search_top_${timestamp}_${index}`,
        _source: 'search', // 標記為搜索結果
        comments:
          tweet.comments?.map((comment, cIndex) => {
            const commentWithId = {
              ...comment,
              id: `search_top_${timestamp}_${index}_c${cIndex}`,
            };
            // 為樓中樓回復添加ID
            if (comment.replies && comment.replies.length > 0) {
              commentWithId.replies = comment.replies.map((reply, rIndex) => ({
                ...reply,
                id: `search_top_${timestamp}_${index}_c${cIndex}_r${rIndex}`,
              }));
            }
            return commentWithId;
          }) || [],
      }));

      searchResults.latest = searchResults.latest.map((tweet, index) => ({
        ...tweet,
        id: `search_latest_${timestamp}_${index}`,
        _source: 'search', // 標記為搜索結果
        comments:
          tweet.comments?.map((comment, cIndex) => {
            const commentWithId = {
              ...comment,
              id: `search_latest_${timestamp}_${index}_c${cIndex}`,
            };
            // 為樓中樓回復添加ID
            if (comment.replies && comment.replies.length > 0) {
              commentWithId.replies = comment.replies.map((reply, rIndex) => ({
                ...reply,
                id: `search_latest_${timestamp}_${index}_c${rIndex}`,
              }));
            }
            return commentWithId;
          }) || [],
      }));

      // 16. 更新搜索結果資料
      searchResultsData.top = searchResults.top;
      searchResultsData.latest = searchResults.latest;
      searchResultsData.users = searchResults.users;

      // 17. 保存到資料庫
      try {
        await xDb.xTweetsData.put({
          id: `search_${query}`,
          query: query,
          results: searchResults,
          timestamp: new Date().toISOString(),
        });
        console.log('✅ 搜索結果已保存到資料庫');
      } catch (saveError) {
        console.error('⚠️ 保存搜索結果失敗:', saveError);
      }

      // 18. 渲染搜索結果
      renderSearchResults();

      showXToast(`找到 ${searchResults.top.length + searchResults.latest.length} 條相關推文`, 'success');
    } catch (error) {
      console.error('❌ 搜索失敗:', error);
      showXToast(`搜索失敗: ${error.message}`, 'error');

      // 顯示錯誤狀態
      const container = document.getElementById('search-results-content');
      container.innerHTML = `
        <div style="
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          padding: 60px 20px;
          color: #f4212e;
        ">
          <svg viewBox="0 0 24 24" style="width: 80px; height: 80px; fill: #f4212e; margin-bottom: 20px;">
            <g><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"></path></g>
          </svg>
          <div style="font-size: 18px; font-weight: 600; margin-bottom: 8px;">搜索出錯</div>
          <div style="font-size: 14px; color: #71767b;">${error.message}</div>
        </div>
      `;
    }
  }

  // 返回熱搜視圖
  function backToTrending() {
    isInSearchResults = false; // 清除搜索結果標記
    document.getElementById('search-results-view').style.display = 'none';
    document.getElementById('trending-view').style.display = 'flex';

    // 隱藏返回按鈕，顯示刷新按鈕
    const backBtn = document.getElementById('search-back-btn');
    if (backBtn) backBtn.style.display = 'none';

    const refreshBtn = document.querySelector('.refresh-trends-btn');
    if (refreshBtn) refreshBtn.style.display = 'flex';

    // 清空搜索框
    const input = document.getElementById('search-input');
    if (input) {
      input.value = '';
      toggleSearchButton();
    }

    currentSearchQuery = '';
  }

  // 打開自訂分類管理模態框
  async function openAddCategoryModal() {
    const modal = document.getElementById('category-manager-modal');
    if (modal) {
      modal.style.display = 'flex';

      // 載入自訂分類資料
      await loadCustomCategories();

      // 渲染分類列表
      renderCustomCategoriesList();
    }
  }

  // 關閉分類管理模態框
  function closeCategoryModal(event) {
    if (event && event.target !== event.currentTarget) return;

    const modal = document.getElementById('category-manager-modal');
    if (modal) {
      modal.style.display = 'none';
    }
  }

  // 載入自訂分類
  async function loadCustomCategories() {
    try {
      const xDb = getXDB();
      const accountId = currentAccountId || 'main';
      const settingsId = `customCategories_${accountId}`;

      const savedData = await xDb.xTweetsData.get(settingsId);
      if (savedData && savedData.categories) {
        customCategories = savedData.categories;
        console.log('✅ 已載入自訂分類:', customCategories.length, '個');
      } else {
        customCategories = [];
      }
    } catch (error) {
      console.error('⚠️ 載入自訂分類失敗:', error);
      customCategories = [];
    }
  }

  // 保存自訂分類
  async function saveCustomCategories() {
    try {
      const xDb = getXDB();
      const accountId = currentAccountId || 'main';
      const settingsId = `customCategories_${accountId}`;

      await xDb.xTweetsData.put({
        id: settingsId,
        categories: customCategories,
        lastUpdated: new Date().toISOString(),
      });

      console.log('✅ 自訂分類已保存');
      showXToast('分類設置已保存', 'success');

      // 更新標籤欄顯示
      updateSearchTabs();

      // 關閉模態框
      closeCategoryModal();
    } catch (error) {
      console.error('❌ 保存自訂分類失敗:', error);
      showXToast('保存失敗: ' + error.message, 'error');
    }
  }

  // 渲染自訂分類列表
  function renderCustomCategoriesList() {
    const container = document.getElementById('custom-categories-list');
    if (!container) return;

    if (customCategories.length === 0) {
      container.innerHTML = `
        <div style="
          text-align: center;
          padding: 40px 20px;
          color: #71767b;
          font-size: 14px;
        ">
          還沒有自訂分類，點擊"添加分類"按鈕創建
        </div>
      `;
      return;
    }

    container.innerHTML = customCategories
      .map(
        (category, index) => `
      <div style="
        background-color: #1a1a1a;
        border: 1px solid #333;
        border-radius: 8px;
        padding: 16px;
      ">
        <div style="display: flex; align-items: flex-start; gap: 12px;">
          <!-- 啟用開關 -->
          <label style="
            display: flex;
            align-items: center;
            cursor: pointer;
            margin-top: 4px;
          ">
            <input 
              type="checkbox" 
              ${category.enabled ? 'checked' : ''} 
              onchange="toggleCategory(${index})"
              style="
                width: 18px;
                height: 18px;
                accent-color: var(--x-accent);
                cursor: pointer;
              ">
          </label>

          <!-- 分類內容 -->
          <div style="flex: 1; min-width: 0;">
            <!-- 分類名稱 -->
            <div style="margin-bottom: 12px;">
              <label style="
                display: block;
                color: #8b98a5;
                font-size: 13px;
                margin-bottom: 4px;
              ">分類名稱 *</label>
              <input 
                type="text" 
                value="${category.name || ''}" 
                placeholder="例如：動漫"
                onchange="updateCategoryName(${index}, this.value)"
                style="
                  width: 100%;
                  background-color: #000;
                  border: 1px solid #333;
                  border-radius: 4px;
                  color: #fff;
                  padding: 8px 12px;
                  font-size: 15px;
                  outline: none;
                " 
                onfocus="this.style.borderColor='var(--x-accent)'" 
                onblur="this.style.borderColor='#333'">
            </div>

            <!-- 分類描述 -->
            <div style="margin-bottom: 12px;">
              <label style="
                display: block;
                color: #8b98a5;
                font-size: 13px;
                margin-bottom: 4px;
              ">分類內容/類型（可選）</label>
              <textarea 
                placeholder="例如：動畫、漫畫、聲優、番劇相關內容"
                onchange="updateCategoryDescription(${index}, this.value)"
                style="
                  width: 100%;
                  min-height: 60px;
                  background-color: #000;
                  border: 1px solid #333;
                  border-radius: 4px;
                  color: #fff;
                  padding: 8px 12px;
                  font-size: 14px;
                  resize: vertical;
                  outline: none;
                  font-family: inherit;
                " 
                onfocus="this.style.borderColor='var(--x-accent)'" 
                onblur="this.style.borderColor='#333'">${category.description || ''}</textarea>
            </div>

            <!-- 狀態提示 -->
            <div style="
              display: flex;
              align-items: center;
              justify-content: space-between;
              color:${category.enabled ? 'var(--x-accent)' : '#71767b'};
              font-size: 12px;
            ">
              <span>${category.enabled ? '✅ 已啟用' : '❌ 已禁用'}</span>
              <button 
                onclick="deleteCategory(${index})"
                style="
                  background: transparent;
                  color: #f4212e;
                  border: 1px solid #f4212e;
                  border-radius: 16px;
                  padding: 4px 12px;
                  font-size: 12px;
                  cursor: pointer;
                  transition: all 0.2s;
                "
                onmouseover="this.style.backgroundColor='rgba(244,33,46,0.1)'"
                onmouseout="this.style.backgroundColor='transparent'">
                刪除
              </button>
            </div>
          </div>
        </div>
      </div>
    `,
      )
      .join('');
  }

  // 添加新分類
  function addNewCategory() {
    customCategories.push({
      id: `custom_${Date.now()}`,
      name: '',
      description: '',
      enabled: true,
    });

    renderCustomCategoriesList();
  }

  // 刪除分類
  function deleteCategory(index) {
    if (confirm('確定要刪除這個分類嗎？')) {
      customCategories.splice(index, 1);
      renderCustomCategoriesList();
    }
  }

  // 切換分類啟用狀態
  function toggleCategory(index) {
    if (customCategories[index]) {
      customCategories[index].enabled = !customCategories[index].enabled;
      renderCustomCategoriesList();
    }
  }

  // 更新分類名稱
  function updateCategoryName(index, name) {
    if (customCategories[index]) {
      customCategories[index].name = name.trim();
    }
  }

  // 更新分類描述
  function updateCategoryDescription(index, description) {
    if (customCategories[index]) {
      customCategories[index].description = description.trim();
    }
  }

  // 更新搜索標籤欄
  function updateSearchTabs() {
    const tabsContainer = document.querySelector('.search-tabs');
    if (!tabsContainer) return;

    // 清空現有標籤（保留+號按鈕）
    const addBtn = tabsContainer.querySelector('.add-category-btn');
    tabsContainer.innerHTML = '';

    // 添加默認標籤
    const recommendedTab = document.createElement('div');
    recommendedTab.className = 'search-tab' + (currentSearchTab === 'recommended' ? ' active' : '');
    recommendedTab.textContent = '為你推薦';
    recommendedTab.onclick = () => switchSearchTab('recommended');
    tabsContainer.appendChild(recommendedTab);

    const trendingTab = document.createElement('div');
    trendingTab.className = 'search-tab' + (currentSearchTab === 'trending' ? ' active' : '');
    trendingTab.textContent = '當前趨勢';
    trendingTab.onclick = () => switchSearchTab('trending');
    tabsContainer.appendChild(trendingTab);

    // 添加啟用的自訂分類標籤
    customCategories
      .filter(cat => cat.enabled && cat.name)
      .forEach(category => {
        const customTab = document.createElement('div');
        customTab.className = 'search-tab' + (currentSearchTab === category.id ? ' active' : '');
        customTab.textContent = category.name;
        customTab.onclick = () => switchSearchTab(category.id);
        tabsContainer.appendChild(customTab);
      });

    // 重新添加+號按鈕
    if (addBtn) {
      tabsContainer.appendChild(addBtn);
    }
  }

  // 初始化搜尋網頁面
  async function initSearchPage() {
    // 載入自訂分類
    await loadCustomCategories();

    // 更新標籤欄
    updateSearchTabs();

    // 檢查是否需要恢復搜索結果視圖
    if (isInSearchResults && currentSearchQuery) {
      // 保持搜索結果視圖
      document.getElementById('trending-view').style.display = 'none';
      document.getElementById('search-results-view').style.display = 'flex';

      // 顯示返回按鈕，隱藏刷新按鈕
      const backBtn = document.getElementById('search-back-btn');
      if (backBtn) backBtn.style.display = 'flex';
      const refreshBtn = document.querySelector('.refresh-trends-btn');
      if (refreshBtn) refreshBtn.style.display = 'none';
    } else {
      // 預設顯示熱搜視圖，隱藏搜索結果視圖
      document.getElementById('trending-view').style.display = 'flex';
      document.getElementById('search-results-view').style.display = 'none';

      // 顯示刷新按鈕，隱藏返回按鈕
      const refreshBtn = document.querySelector('.refresh-trends-btn');
      if (refreshBtn) refreshBtn.style.display = 'flex';

      const backBtn = document.getElementById('search-back-btn');
      if (backBtn) backBtn.style.display = 'none';
    }

    // 嘗試從資料庫載入熱搜資料
    try {
      const xDb = getXDB();
      const savedTrends = await xDb.xTweetsData.get('trends');

      if (savedTrends) {
        // 載入預設分類資料
        if (savedTrends.recommended && savedTrends.trending) {
          trendingData.recommended = savedTrends.recommended;
          trendingData.trending = savedTrends.trending;
        }

        // 載入自訂分類資料
        customCategories.forEach(category => {
          if (savedTrends[category.id]) {
            trendingData[category.id] = savedTrends[category.id];
          }
        });

        console.log('✅ 已從資料庫載入熱搜資料');
      }
    } catch (error) {
      console.log('⚠️ 載入熱搜資料失敗，使用預設資料:', error);
    }

    // 渲染熱搜列表
    renderTrendingList();
  }

  // ▼▼▼ ！！！三個情景綜合如下！！！▼▼▼
  // "為你推薦"頁面的測試推文資料（示範用）
  const forYouTweets = [
    {
      id: '1',
      user: {
        name: '熱門推薦用戶',
        handle: '@trending_user',
        avatar: 'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg',
        verified: true,
      },
      content: '🔥 今日熱門話題！大家都在討論的新技術趨勢 #AI #科技 #未來',
      time: '3小時',
      media: [],
      stats: {
        comments: 567,
        retweets: 1200,
        likes: 5600,
        views: 89000,
      },
      comments: [
        {
          id: 'c1-1',
          user: {
            name: '科技達人',
            handle: '@tech_expert',
            avatar: 'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg',
            verified: true,
          },
          content: '確實，AI技術發展太快了，每天都有新突破',
          time: '2小時',
          replies: [
            {
              id: 'c1-1-1',
              user: {
                name: '學生小王',
                handle: '@student_wang',
                avatar: 'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg',
                verified: false,
              },
              content: '請問有什麼推薦的學習資源嗎？',
              time: '1小時',
              replyTo: '@tech_expert',
            },
          ],
        },
      ],
    },
  ];

  // "正在關注"頁面的測試推文資料（示範用）
  const followingTweets = [
    {
      id: '2',
      user: {
        name: '我的朋友',
        handle: '@my_friend',
        avatar: 'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg',
        verified: false,
      },
      content: '今天天氣真不錯，和朋友們一起出去玩了！😊 #美好時光',
      time: '30分鐘',
      media: [
        {
          type: 'image',
          description: '陽光明媚的公園裡，幾個朋友在草地上野餐的溫馨場景',
          sensitive: false,
        },
      ],
      stats: {
        comments: 8,
        retweets: 2,
        likes: 24,
        views: 156,
      },
      comments: [
        {
          id: 'c2-1',
          user: {
            name: '好友A',
            handle: '@friend_a',
            avatar: 'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg',
            verified: false,
          },
          content: '看起來很棒！下次叫上我 😊',
          time: '25分鐘',
          replies: [],
        },
      ],
    },
    {
      id: '3',
      user: {
        name: '數碼達人',
        handle: '@digital_expert',
        avatar: 'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg',
        verified: true,
      },
      content: '完全同意這個觀點！AI確實正在改變我們的生活方式，每個人都應該學會擁抱這種變化 🤖✨',
      time: '45分鐘',
      media: [],
      quotedTweet: {
        type: 'tweet',
        user: {
          name: '科技前沿',
          handle: '@tech_frontier',
          avatar: 'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg',
          verified: true,
        },
        content: 'AI技術的快速發展正在重塑各行各業，從自動駕駛到智慧助手，我們正生活在一個科技革命的時代 #AI #未來科技',
        time: '2小時',
      },
      stats: {
        comments: 15,
        retweets: 32,
        likes: 89,
        views: 1250,
      },
      comments: [
        {
          id: 'c3-1',
          user: {
            name: '科技愛好者',
            handle: '@tech_lover',
            avatar: 'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg',
            verified: false,
          },
          content: '是的，特別是在工作效率提升方面，AI工具幫助很大',
          time: '40分鐘',
          replies: [],
        },
      ],
    },
  ];

  // 格式化數字顯示
  function formatNumber(num) {
    if (num >= 1000000) {
      return (num / 1000000).toFixed(1) + '萬';
    } else if (num >= 10000) {
      return (num / 10000).toFixed(1) + '萬';
    } else if (num >= 1000) {
      return (num / 1000).toFixed(1) + 'K';
    }
    return num.toString();
  }

  // 處理推文內容，為話題標籤和提及添加高亮
  function processContent(content) {
    if (!content) return '';

    // 處理話題標籤 (#hashtag)
    content = content.replace(/#([^\s#@]+)/g, '<span class="hashtag">#$1</span>');

    // 處理提及 (@mention)
    content = content.replace(/@([^\s#@]+)/g, '<span class="mention">@$1</span>');

    return content;
  }

  // 清理評論內容中的重複回復文本
  function cleanReplyContent(content, replyTo) {
    if (!content) return '';

    // 如果有replyTo，移除評論內容開頭的"回復@xxx:"格式
    if (replyTo) {
      // 移除開頭的"回復@用戶名:"或"回復 @用戶名:"
      content = content.replace(/^回復\s*@[^\s:：]+[：:]\s*/, '');
      // 移除開頭直接的"@用戶名"格式（如果跟replyTo重複）
      const replyHandle = replyTo.replace('@', '');
      content = content.replace(new RegExp(`^@${replyHandle}\\s*[：:]?\\s*`, 'i'), '');
      // 移除內容中任何與replyTo重複的@提及
      content = content.replace(new RegExp(`@${replyHandle}(?=\\s|$|[^\\w])`, 'gi'), '');
    }

    return content;
  }

  // 創建推文元素
  function createTweetElement(tweet) {
    const tweetEl = document.createElement('div');
    tweetEl.className = 'tweet-item';
    tweetEl.dataset.tweetId = tweet.id;

    tweetEl.innerHTML = `
              <img class="tweet-avatar" src="${tweet.user.avatar}" alt="${tweet.user.name}">
              <div class="tweet-main">
                <div class="tweet-user-info">
                  <span class="tweet-user-name">${tweet.user.name}</span>
                  ${
                    tweet.user.verified
                      ? '<svg class="tweet-verified" viewBox="0 0 24 24"><g><path d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.27 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.46 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z"></path></g></svg>'
                      : ''
                  }
                  <span class="tweet-user-handle">${tweet.user.handle}</span>
                  <span class="tweet-time">·${tweet.time}</span>
                  <div class="tweet-more">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                      <g><path d="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"></path></g>
                    </svg>
                  </div>
                </div>
                ${tweet.content ? `<div class="tweet-content">${processContent(tweet.content)}</div>` : ''}
                ${
                  tweet.quotedTweet
                    ? `
                  <div class="quoted-tweet" onclick="handleQuotedTweetClick('${tweet.quotedTweet.user.handle}')">
                    <div class="quote-indicator">
                      <svg viewBox="0 0 24 24">
                        <g><path d="M4.5 3.88l4.432 4.14-1.364 1.46L5.5 7.55V16c0 1.1.896 2 2 2H13v2H7.5c-2.209 0-4-1.791-4-4V7.55L1.432 9.48.068 8.02 4.5 3.88zM16.5 6H11V4h5.5c2.209 0 4 1.791 4 4v8.45l2.068-1.93 1.364 1.46-4.432 4.14-4.432-4.14 1.364-1.46 2.068 1.93V8c0-1.1-.896-2-2-2z"></path></g>
                      </svg>
                      ${tweet.quotedTweet.type === 'comment' ? '引用評論' : '引用推文'}
                    </div>
                    <div class="quoted-user-info">
                      <img class="quoted-user-avatar" src="${tweet.quotedTweet.user.avatar}" alt="${
                        tweet.quotedTweet.user.name
                      }">
                      <span class="quoted-user-name">${tweet.quotedTweet.user.name}</span>
                      ${
                        tweet.quotedTweet.user.verified
                          ? '<svg class="tweet-verified" style="width: 14px; height: 14px;" viewBox="0 0 24 24"><g><path d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.27 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.46 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z"></path></g></svg>'
                          : ''
                      }
                      <span class="quoted-user-handle">${tweet.quotedTweet.user.handle}</span>
                      <span class="quoted-user-time">·${tweet.quotedTweet.time}</span>
                    </div>
                    <div class="quoted-content">${processContent(tweet.quotedTweet.content)}</div>
                    ${
                      tweet.quotedTweet.image
                        ? `
                      <div class="quoted-media" style="margin-top: 8px;">
                        ${
                          tweet.quotedTweet.image.type === 'description'
                            ? `
                          <div style="background-color: rgba(255,255,255,0.05); border: 1px solid #333; border-radius: 8px; padding: 8px;">
                            <div style="color: #fff; font-size: 12px; line-height: 1.4;">${tweet.quotedTweet.image.content}</div>
                          </div>
                        `
                            : ''
                        }
                        ${
                          tweet.quotedTweet.image.type === 'upload'
                            ? `
                          <div style="border-radius: 8px; overflow: hidden;">
                            <img src="${tweet.quotedTweet.image.content}" style="width: 100%; max-height: 100px; object-fit: cover; display: block;" alt="引用圖片">
                          </div>
                        `
                            : ''
                        }
                      </div>
                    `
                        : ''
                    }
                  </div>
                `
                    : ''
                }
                ${
                  tweet.media && tweet.media.length > 0
                    ? `
                  <div class="tweet-media">
                    <div style="width: 100%; max-height: 200px; background-color: var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 16px; color: var(--x-text-primary); position: relative; overflow: hidden;" id="media-${
                      tweet.id
                    }">
                      ${
                        tweet.media[0].sensitive
                          ? `
                        <div class="sensitive-overlay" onclick="showSensitiveContent('${tweet.id}')">
                          <div class="sensitive-text">敏感內容</div>
                          <div class="sensitive-description">此推文可能包含敏感內容</div>
                        </div>
                      `
                          : ''
                      }
                      <div class="tweet-media-scrollable" style="width: 100%; max-height: 200px; padding: 16px; overflow-y: auto; box-sizing: border-box; ${
                        tweet.media[0].sensitive ? 'filter: blur(20px);' : ''
                      }" id="content-${tweet.id}">
                        <div style="font-size: 14px; line-height: 1.5; white-space: pre-wrap; word-wrap: break-word; overflow-wrap: break-word; width: 100%; box-sizing: border-box;">${
                          tweet.media[0].description
                        }</div>
                      </div>
                    </div>
                  </div>
                `
                    : ''
                }
                <div class="tweet-actions">
                  <div class="tweet-action comment" onclick="showTweetComments('${tweet.id}')">
                    <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor">
                      <g><path d="M1.751 10c0-4.42 3.584-8.005 8.005-8.005h4.366c4.49 0 8.129 3.64 8.129 8.13 0 2.96-1.607 5.68-4.196 7.11l-8.054 4.46v-3.69h-.067c-4.49.1-8.183-3.51-8.183-8.005zm8.005-6.005c-3.317 0-6.005 2.69-6.005 6.005 0 3.37 2.77 6.08 6.138 6.01l.351-.01h1.761v2.3l5.087-2.81c1.951-1.08 3.163-3.13 3.163-5.36 0-3.39-2.744-6.13-6.129-6.13H9.756z"></path></g>
                    </svg>
                    <span>${formatNumber(tweet.stats.comments)}</span>
                  </div>
                  <div class="tweet-action retweet" onclick="handleQuoteRetweetFromData('tweet', '${tweet.id}')">
                    <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor">
                      <g><path d="M4.5 3.88l4.432 4.14-1.364 1.46L5.5 7.55V16c0 1.1.896 2 2 2H13v2H7.5c-2.209 0-4-1.791-4-4V7.55L1.432 9.48.068 8.02 4.5 3.88zM16.5 6H11V4h5.5c2.209 0 4 1.791 4 4v8.45l2.068-1.93 1.364 1.46-4.432 4.14-4.432-4.14 1.364-1.46 2.068 1.93V8c0-1.1-.896-2-2-2z"></path></g>
                    </svg>
                    <span>${DataUtils.formatNumber(tweet.stats.retweets)}</span>
                  </div>
                  <div class="tweet-action like" onclick="toggleLike('${
                    tweet.id
                  }', this)" data-liked="false" data-likes="${tweet.stats.likes}">
                    <svg class="action-icon like-icon" viewBox="0 0 24 24" fill="currentColor">
                      <g><path d="M16.697 5.5c-1.222-.06-2.679.51-3.89 2.16l-.805 1.09-.806-1.09C9.984 6.01 8.526 5.44 7.304 5.5c-1.243.07-2.349.78-2.91 1.91-.552 1.12-.633 2.78.479 4.82 1.074 1.97 3.257 4.27 7.129 6.61 3.87-2.34 6.052-4.64 7.126-6.61 1.111-2.04 1.03-3.7.477-4.82-.561-1.13-1.666-1.84-2.908-1.91zm4.187 7.69c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g>
                    </svg>
                    <span class="like-count">${DataUtils.formatNumber(tweet.stats.likes)}</span>
                  </div>
                  <div class="tweet-action view">
                    <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor">
                      <g><path d="M8.75 21V3h2v18h-2zM18 21V8.5h2V21h-2zM4 21l.004-10H6v10H4zm9.248 0v-7h2v7h-2z"></path></g>
                    </svg>
                    <span>${DataUtils.formatNumber(tweet.stats.views)}</span>
                  </div>
                  <div class="tweet-action bookmark" onclick="toggleBookmark('${
                    tweet.id
                  }', this)" data-bookmarked="false">
                    <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor">
                      <g><path d="M4 4.5C4 3.12 5.119 2 6.5 2h11C18.881 2 20 3.12 20 4.5v18.44l-8-5.71-8 5.71V4.5zM6.5 4c-.276 0-.5.22-.5.5v14.56l6-4.29 6 4.29V4.5c0-.28-.224-.5-.5-.5h-11z"></path></g>
                    </svg>
                  </div>
                  <div class="tweet-action share">
                    <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor">
                      <g><path d="M12 2.59l5.7 5.7-1.41 1.42L13 6.41V16h-2V6.41l-3.29 3.3-1.42-1.42L12 2.59zM21 15l-.02 3.51c0 1.38-1.12 2.49-2.5 2.49H5.5C4.11 21 3 19.88 3 18.5V15h2v3.5c0 .28.22.5.5.5h12.98c.28 0 .5-.22.5-.5L19 15h2z"></path></g>
                    </svg>
                  </div>
                </div>
              </div>
            `;

    // 非同步檢查書簽狀態並更新UI
    (async () => {
      const bookmarked = await isBookmarked(tweet.id);
      const bookmarkBtn = tweetEl.querySelector('.bookmark');
      if (bookmarkBtn) {
        bookmarkBtn.setAttribute('data-bookmarked', bookmarked ? 'true' : 'false');
        if (bookmarked) {
          const svg = bookmarkBtn.querySelector('svg');
          if (svg) {
            // 填充的書簽圖示
            svg.innerHTML =
              '<g><path d="M4 4.5C4 3.12 5.119 2 6.5 2h11C18.881 2 20 3.12 20 4.5v18.44l-8-5.71-8 5.71V4.5z"></path></g>';
          }
        }
      }
    })();

    // 非同步檢查喜歡狀態並更新UI
    (async () => {
      const liked = await isLiked(tweet.id);
      const likeBtn = tweetEl.querySelector('.tweet-action.like');
      if (likeBtn) {
        likeBtn.setAttribute('data-liked', liked ? 'true' : 'false');
        if (liked) {
          const svg = likeBtn.querySelector('svg');
          if (svg) {
            // 填充的愛心圖示
            svg.innerHTML =
              '<g><path d="M20.884 13.19c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g>';
          }
        }
      }
    })();

    return tweetEl;
  }

  // 處理引用推文點擊
  function handleQuotedTweetClick(userHandle) {
    showXToast(`點擊了引用的 ${userHandle} 的內容`, 'info');
  }

  // ============================================
  // 書簽/亮點功能
  // ============================================

  // 切換書簽狀態
  window.toggleBookmark = async function (tweetId, buttonElement) {
    try {
      const isBookmarked = buttonElement.getAttribute('data-bookmarked') === 'true';

      if (isBookmarked) {
        // 取消收藏
        await removeBookmark(tweetId);
        buttonElement.setAttribute('data-bookmarked', 'false');

        // 更新圖示為未收藏狀態
        const svg = buttonElement.querySelector('svg');
        if (svg) {
          svg.innerHTML =
            '<g><path d="M4 4.5C4 3.12 5.119 2 6.5 2h11C18.881 2 20 3.12 20 4.5v18.44l-8-5.71-8 5.71V4.5zM6.5 4c-.276 0-.5.22-.5.5v14.56l6-4.29 6 4.29V4.5c0-.28-.224-.5-.5-.5h-11z"></path></g>';
        }

        showXToast('已取消收藏', 'info');
        console.log(`📌 [書簽] 已取消收藏推文: ${tweetId}`);
      } else {
        // 添加收藏
        await saveBookmark(tweetId);
        buttonElement.setAttribute('data-bookmarked', 'true');

        // 更新圖示為已收藏狀態（實心）
        const svg = buttonElement.querySelector('svg');
        if (svg) {
          svg.innerHTML =
            '<g><path d="M4 4.5C4 3.12 5.119 2 6.5 2h11C18.881 2 20 3.12 20 4.5v18.44l-8-5.71-8 5.71V4.5z"></path></g>';
        }

        showXToast('已添加到書簽', 'success');
        console.log(`📌 [書簽] 已收藏推文: ${tweetId}`);
      }

      // 如果當前在用戶主頁的亮點標籤，刷新內容
      const highlightsContent = document.getElementById('profile-highlights-content');
      if (highlightsContent && highlightsContent.style.display === 'block') {
        await loadHighlights();
      }
    } catch (error) {
      console.error('❌ [書簽] 切換書簽狀態失敗:', error);
      showXToast('操作失敗', 'error');
    }
  };

  // 保存書簽到資料庫（按帳戶隔離）
  async function saveBookmark(tweetId) {
    try {
      const accountId = currentAccountId || 'main';
      const xDb = getXDB();

      // 查找推文資料 - 多種來源
      let tweetData = null;

      // 1. 從記憶體中的首頁推文查找
      const allTweets = [...(window.xTweetsData?.forYouTweets || []), ...(window.xTweetsData?.followingTweets || [])];
      tweetData = allTweets.find(t => t.id === tweetId);

      // 2. 如果沒找到，從資料庫中的首頁推文查找
      if (!tweetData) {
        const tweetsData = await xDb.xTweetsData.get('tweets');
        if (tweetsData) {
          tweetData =
            tweetsData.forYouTweets?.find(t => t.id === tweetId) ||
            tweetsData.followingTweets?.find(t => t.id === tweetId);
        }
      }

      // 3. 如果是用戶發的推文，從使用者推文資料查找
      if (!tweetData && tweetId.startsWith('user_')) {
        const userTweetsId = `userTweets_${accountId}`;
        const userTweetsData = await xDb.xUserTweets.get(userTweetsId);
        if (userTweetsData && userTweetsData.tweets) {
          tweetData = userTweetsData.tweets.find(t => t.id === tweetId);
        }
      }

      // 4. 從帳戶主頁推文中查找
      if (!tweetData && currentViewingAccount && currentViewingAccount.tweets) {
        tweetData = currentViewingAccount.tweets.find(t => t.id === tweetId);
      }

      // 5. 從DOM中提取推文資料作為最後的備選方案
      if (!tweetData) {
        const tweetElement = document.querySelector(`[data-tweet-id="${tweetId}"]`);
        if (tweetElement) {
          console.log('📝 [書簽] 從DOM中提取推文資料');
          // 從DOM元素中提取基本資訊
          tweetData = extractTweetDataFromDOM(tweetElement);
        }
      }

      if (!tweetData) {
        console.warn('⚠️ [書簽] 未找到推文數據:', tweetId);
        showXToast('無法收藏該推文', 'error');
        return;
      }

      const bookmarkId = `bookmark_${accountId}_${tweetId}`;

      // 保存書簽資料（多帳戶隔離）
      await xDb.xBookmarks.put({
        id: bookmarkId,
        accountId: accountId,
        tweetId: tweetId,
        tweetData: tweetData,
        bookmarkedAt: Date.now(),
      });

      console.log(`✅ [書簽] 帳戶 ${accountId} 已保存書簽: ${tweetId}`);
    } catch (error) {
      console.error('❌ [書簽] 保存書簽失敗:', error);
      throw error;
    }
  }

  // 從DOM元素中提取推文資料（備用方案）
  function extractTweetDataFromDOM(tweetElement) {
    try {
      // 提取使用者資訊
      const avatar = tweetElement.querySelector('.tweet-avatar')?.src || '';
      const userName = tweetElement.querySelector('.tweet-user-name')?.textContent || '';
      const userHandle = tweetElement.querySelector('.tweet-user-handle')?.textContent || '';
      const verified = !!tweetElement.querySelector('.tweet-verified');

      // 提取推文內容
      const content = tweetElement.querySelector('.tweet-content')?.textContent || '';
      const time = tweetElement.querySelector('.tweet-time')?.textContent?.replace('·', '').trim() || '';

      // 提取統計資料
      const commentCount = tweetElement.querySelector('.tweet-action.comment span')?.textContent || '0';
      const retweetCount = tweetElement.querySelector('.tweet-action.retweet span')?.textContent || '0';
      const likeCount = tweetElement.querySelector('.like-count')?.textContent || '0';
      const viewCount = tweetElement.querySelector('.tweet-action.view span')?.textContent || '0';

      return {
        id: tweetElement.dataset.tweetId,
        user: {
          name: userName,
          handle: userHandle,
          avatar: avatar,
          verified: verified,
        },
        content: content,
        time: time,
        stats: {
          comments: parseStatNumber(commentCount),
          retweets: parseStatNumber(retweetCount),
          likes: parseStatNumber(likeCount),
          views: parseStatNumber(viewCount),
        },
        comments: [], // DOM中無法獲取完整評論資料
      };
    } catch (error) {
      console.error('❌ [書簽] 從DOM提取推文資料失敗:', error);
      return null;
    }
  }

  // 解析統計數字（支援K、M等單位）
  function parseStatNumber(str) {
    if (!str) return 0;
    str = str.trim().toUpperCase();
    if (str.endsWith('K')) {
      return Math.round(parseFloat(str) * 1000);
    } else if (str.endsWith('M')) {
      return Math.round(parseFloat(str) * 1000000);
    }
    return parseInt(str) || 0;
  }

  // 從資料庫移除書簽（按帳戶隔離）
  async function removeBookmark(tweetId) {
    try {
      const accountId = currentAccountId || 'main';
      const xDb = getXDB();
      const bookmarkId = `bookmark_${accountId}_${tweetId}`;

      await xDb.xBookmarks.delete(bookmarkId);
      console.log(`✅ [書簽] 帳戶 ${accountId} 已刪除書簽: ${tweetId}`);
    } catch (error) {
      console.error('❌ [書簽] 刪除書簽失敗:', error);
      throw error;
    }
  }

  // 載入當前帳戶的所有書簽（多帳戶隔離）
  async function loadBookmarks() {
    try {
      const accountId = currentAccountId || 'main';
      const xDb = getXDB();

      // 只載入當前帳戶的書簽
      const bookmarks = await xDb.xBookmarks.where('accountId').equals(accountId).sortBy('bookmarkedAt');

      // 倒序排列（最新的在前）
      bookmarks.reverse();

      console.log(`📚 [書簽] 帳戶 ${accountId} 已載入 ${bookmarks.length} 個書簽`);
      return bookmarks;
    } catch (error) {
      console.error('❌ [書簽] 載入書簽失敗:', error);
      return [];
    }
  }

  // 檢查推文是否已被當前帳戶收藏
  async function isBookmarked(tweetId) {
    try {
      const accountId = currentAccountId || 'main';
      const xDb = getXDB();
      const bookmarkId = `bookmark_${accountId}_${tweetId}`;

      const bookmark = await xDb.xBookmarks.get(bookmarkId);
      return !!bookmark;
    } catch (error) {
      console.error('❌ [書簽] 檢查收藏狀態失敗:', error);
      return false;
    }
  }

  // 載入並顯示亮點內容
  window.loadHighlights = async function () {
    try {
      console.log('🌟 [亮點] 開始載入亮點內容');

      const highlightsContent = document.getElementById('profile-highlights-content');
      if (!highlightsContent) {
        console.warn('⚠️ [亮點] 未找到亮點容器');
        return;
      }

      // 載入當前帳戶的所有書簽
      const bookmarks = await loadBookmarks();

      if (bookmarks.length === 0) {
        // 顯示空狀態（使用國際化文本）
        const config = languageConfig[currentLanguage] || languageConfig.zh;
        highlightsContent.innerHTML = `
          <div style="padding: 60px 32px; text-align: center;">
            <div style="color: var(--x-text-secondary); font-size: 31px; font-weight: 800; margin-bottom: 8px;">${config.profileNoHighlights}</div>
            <div style="color: var(--x-text-secondary); font-size: 15px;">${config.profileNoHighlightsDesc}</div>
          </div>
        `;
        return;
      }

      // 清空容器
      highlightsContent.innerHTML = '';

      // 渲染每個收藏的推文
      bookmarks.forEach(bookmark => {
        if (bookmark.tweetData) {
          const tweetElement = createTweetElement(bookmark.tweetData);
          highlightsContent.appendChild(tweetElement);

          // 更新書簽按鈕狀態為已收藏
          const bookmarkBtn = tweetElement.querySelector('.bookmark');
          if (bookmarkBtn) {
            bookmarkBtn.setAttribute('data-bookmarked', 'true');
            const svg = bookmarkBtn.querySelector('svg');
            if (svg) {
              svg.innerHTML =
                '<g><path d="M4 4.5C4 3.12 5.119 2 6.5 2h11C18.881 2 20 3.12 20 4.5v18.44l-8-5.71-8 5.71V4.5z"></path></g>';
            }
          }
        }
      });

      console.log(`✅ [亮點] 已顯示 ${bookmarks.length} 個收藏的推文`);
    } catch (error) {
      console.error('❌ [亮點] 載入亮點內容失敗:', error);
      showXToast('載入失敗', 'error');
    }
  };

  // ============================================
  // 💖 喜歡功能
  // ============================================

  // 切換喜歡狀態
  window.toggleLike = async function (tweetId, buttonElement) {
    try {
      const isLiked = buttonElement.getAttribute('data-liked') === 'true';
      const likeCountSpan = buttonElement.querySelector('.like-count');
      let currentLikes = parseInt(buttonElement.getAttribute('data-likes')) || 0;

      if (isLiked) {
        // 取消喜歡
        await removeLike(tweetId);
        buttonElement.setAttribute('data-liked', 'false');
        currentLikes = Math.max(0, currentLikes - 1);
        buttonElement.setAttribute('data-likes', currentLikes);

        // 更新UI
        if (likeCountSpan) {
          likeCountSpan.textContent = DataUtils.formatNumber(currentLikes);
        }

        // 更新圖示為未喜歡狀態（空心）
        const svg = buttonElement.querySelector('svg');
        if (svg) {
          svg.innerHTML =
            '<g><path d="M16.697 5.5c-1.222-.06-2.679.51-3.89 2.16l-.805 1.09-.806-1.09C9.984 6.01 8.526 5.44 7.304 5.5c-1.243.07-2.349.78-2.91 1.91-.552 1.12-.633 2.78.479 4.82 1.074 1.97 3.257 4.27 7.129 6.61 3.87-2.34 6.052-4.64 7.126-6.61 1.111-2.04 1.03-3.7.477-4.82-.561-1.13-1.666-1.84-2.908-1.91zm4.187 7.69c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g>';
        }

        console.log(`💔 [喜歡] 已取消喜歡推文: ${tweetId}`);
      } else {
        // 添加喜歡
        await saveLike(tweetId);
        buttonElement.setAttribute('data-liked', 'true');
        currentLikes += 1;
        buttonElement.setAttribute('data-likes', currentLikes);

        // 更新UI
        if (likeCountSpan) {
          likeCountSpan.textContent = DataUtils.formatNumber(currentLikes);
        }

        // 更新圖示為已喜歡狀態（實心）
        const svg = buttonElement.querySelector('svg');
        if (svg) {
          svg.innerHTML =
            '<g><path d="M20.884 13.19c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g>';
        }

        console.log(`💖 [喜歡] 已喜歡推文: ${tweetId}`);

        // 🎯 檢查是否需要觸發AI主動發消息
        await checkAutoMessageTrigger();
      }

      // 如果當前在用戶主頁的喜歡標籤，刷新內容
      const likesContent = document.getElementById('profile-likes-content');
      if (likesContent && likesContent.style.display === 'block') {
        await loadLikes();
      }
    } catch (error) {
      console.error('❌ [喜歡] 切換喜歡狀態失敗:', error);
      showXToast('操作失敗', 'error');
    }
  };

  // 保存喜歡到資料庫（按帳戶隔離）
  async function saveLike(tweetId) {
    try {
      const accountId = currentAccountId || 'main';
      const xDb = getXDB();

      // 查找推文資料 - 多種來源
      let tweetData = null;

      // 1. 從記憶體中的首頁推文查找
      const allTweets = [...forYouTweets, ...followingTweets];
      tweetData = allTweets.find(t => t.id === tweetId);

      // 2. 如果沒找到，從資料庫中的首頁推文查找
      if (!tweetData) {
        const tweetsData = await xDb.xTweetsData.get('tweets');
        if (tweetsData) {
          tweetData =
            tweetsData.forYouTweets?.find(t => t.id === tweetId) ||
            tweetsData.followingTweets?.find(t => t.id === tweetId);
        }
      }

      // 3. 如果是用戶發的推文，從使用者推文資料查找
      if (!tweetData && tweetId.startsWith('user_')) {
        const userTweetsId = `userTweets_${accountId}`;
        const userTweetsData = await xDb.xUserTweets.get(userTweetsId);
        if (userTweetsData && userTweetsData.tweets) {
          tweetData = userTweetsData.tweets.find(t => t.id === tweetId);
        }
      }

      // 4. 從帳戶主頁推文中查找
      if (!tweetData && currentViewingAccount && currentViewingAccount.tweets) {
        tweetData = currentViewingAccount.tweets.find(t => t.id === tweetId);
      }

      // 5. 從DOM中提取推文資料作為最後的備選方案
      if (!tweetData) {
        const tweetElement = document.querySelector(`[data-tweet-id="${tweetId}"]`);
        if (tweetElement) {
          console.log('📝 [喜歡] 從DOM中提取推文資料');
          tweetData = extractTweetDataFromDOM(tweetElement);
        }
      }

      if (!tweetData) {
        console.warn('⚠️ [喜歡] 未找到推文資料:', tweetId);
        showXToast('無法喜歡該推文', 'error');
        return;
      }

      const likeId = `like_${accountId}_${tweetId}`;

      // 保存喜歡資料（多帳戶隔離）
      await xDb.xLikes.put({
        id: likeId,
        accountId: accountId,
        tweetId: tweetId,
        tweetData: tweetData,
        likedAt: Date.now(),
      });

      console.log(`✅ [喜歡] 帳戶 ${accountId} 已保存喜歡: ${tweetId}`);
    } catch (error) {
      console.error('❌ [喜歡] 保存喜歡失敗:', error);
      throw error;
    }
  }

  // 從資料庫移除喜歡（按帳戶隔離）
  async function removeLike(tweetId) {
    try {
      const accountId = currentAccountId || 'main';
      const xDb = getXDB();
      const likeId = `like_${accountId}_${tweetId}`;

      await xDb.xLikes.delete(likeId);
      console.log(`✅ [喜歡] 帳戶 ${accountId} 已刪除喜歡: ${tweetId}`);
    } catch (error) {
      console.error('❌ [喜歡] 刪除喜歡失敗:', error);
      throw error;
    }
  }

  // 載入當前帳戶的所有喜歡（多帳戶隔離）
  async function loadLikesData() {
    try {
      const accountId = currentAccountId || 'main';
      const xDb = getXDB();

      // 只載入當前帳戶的喜歡
      const likes = await xDb.xLikes.where('accountId').equals(accountId).sortBy('likedAt');

      // 倒序排列（最新的在前）
      likes.reverse();

      console.log(`💖 [喜歡] 帳戶 ${accountId} 已載入 ${likes.length} 個喜歡`);
      return likes;
    } catch (error) {
      console.error('❌ [喜歡] 載入喜歡失敗:', error);
      return [];
    }
  }

  // 檢查推文是否已被當前帳戶喜歡
  async function isLiked(tweetId) {
    try {
      const accountId = currentAccountId || 'main';
      const xDb = getXDB();
      const likeId = `like_${accountId}_${tweetId}`;

      const like = await xDb.xLikes.get(likeId);
      return !!like;
    } catch (error) {
      console.error('❌ [喜歡] 檢查喜歡狀態失敗:', error);
      return false;
    }
  }

  // 載入並顯示喜歡內容
  window.loadLikes = async function () {
    try {
      console.log('💖 [喜歡] 開始載入喜歡內容');

      const likesContent = document.getElementById('profile-likes-content');
      if (!likesContent) {
        console.warn('⚠️ [喜歡] 未找到喜歡容器');
        return;
      }

      // 載入當前帳戶的所有喜歡
      const likes = await loadLikesData();

      if (likes.length === 0) {
        // 顯示空狀態（使用國際化文本）
        const config = languageConfig[currentLanguage] || languageConfig.zh;
        likesContent.innerHTML = `
          <div style="padding: 60px 32px; text-align: center;">
            <div style="color: var(--x-text-secondary); font-size: 31px; font-weight: 800; margin-bottom: 8px;">${config.profileNoLikes}</div>
            <div style="color: var(--x-text-secondary); font-size: 15px;">${config.profileNoLikesDesc}</div>
          </div>
        `;
        return;
      }

      // 清空容器
      likesContent.innerHTML = '';

      // 渲染每個喜歡的推文
      likes.forEach(like => {
        if (like.tweetData) {
          const tweetElement = createTweetElement(like.tweetData);
          likesContent.appendChild(tweetElement);

          // 更新喜歡按鈕狀態為已喜歡
          const likeBtn = tweetElement.querySelector('.tweet-action.like');
          if (likeBtn) {
            likeBtn.setAttribute('data-liked', 'true');
            const svg = likeBtn.querySelector('svg');
            if (svg) {
              svg.innerHTML =
                '<g><path d="M20.884 13.19c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g>';
            }
          }
        }
      });

      console.log(`✅ [喜歡] 已顯示 ${likes.length} 個喜歡的推文`);
    } catch (error) {
      console.error('❌ [喜歡] 載入喜歡內容失敗:', error);
      showXToast('載入失敗', 'error');
    }
  };

  // 🎯 檢查是否需要觸發AI主動發消息（每點贊5條觸發一次）
  let lastLikeTriggerTime = 0; // 上次觸發時間戳記
  const LIKE_TRIGGER_COOLDOWN = 5 * 60 * 1000; // 5分鐘冷卻時間

  async function checkAutoMessageTrigger() {
    try {
      const accountId = currentAccountId || 'main';
      const xDb = getXDB();

      // 獲取當前帳戶的喜歡總數
      const likesCount = await xDb.xLikes.where('accountId').equals(accountId).count();

      console.log(`📊 [喜歡觸發] 當前喜歡總數: ${likesCount}`);

      // 每5條喜歡觸發一次
      if (likesCount > 0 && likesCount % 5 === 0) {
        // 檢查冷卻時間
        const now = Date.now();
        const timeSinceLastTrigger = now - lastLikeTriggerTime;

        if (timeSinceLastTrigger < LIKE_TRIGGER_COOLDOWN) {
          const remainingSeconds = Math.ceil((LIKE_TRIGGER_COOLDOWN - timeSinceLastTrigger) / 1000);
          console.log(`⏳ [喜歡觸發] 冷卻中，還需等待 ${remainingSeconds} 秒`);
          return;
        }

        console.log('🎯 [喜歡觸發] 達到觸發條件，準備隨機選擇一條喜歡的推文');
        lastLikeTriggerTime = now; // 更新觸發時間

        // 獲取最近5條喜歡的推文
        const recentLikes = await xDb.xLikes.where('accountId').equals(accountId).sortBy('likedAt');
        const last5Likes = recentLikes.slice(-5);

        if (last5Likes.length > 0) {
          // 隨機選擇其中一條
          const randomLike = last5Likes[Math.floor(Math.random() * last5Likes.length)];
          const tweetData = randomLike.tweetData;

          console.log(`🎲 [喜歡觸發] 隨機選中推文:`, tweetData);

          // 查找對應的角色或帳戶私信
          const tweetAuthorHandle = tweetData.user.handle.replace('@', '');

          // 觸發AI主動發消息
          await triggerAutoMessageFromLikedTweet(tweetAuthorHandle, tweetData);
        }
      }
    } catch (error) {
      console.error('❌ [喜歡觸發] 檢查觸發條件失敗:', error);
    }
  }

  // 🤖 從喜歡的推文觸發AI主動發消息
  async function triggerAutoMessageFromLikedTweet(authorHandle, tweetData) {
    try {
      console.log(`🤖 [喜歡觸發AI] 開始處理推文作者: ${authorHandle}`);

      const xDb = getXDB();
      const accountId = currentAccountId || 'main';

      // 1. 檢查是否是角色
      const allXProfiles = await xDb.xCharacterProfiles.toArray();
      const characterProfile = allXProfiles.find(
        p => p.xHandle && p.xHandle.replace('@', '').toLowerCase() === authorHandle.toLowerCase(),
      );

      if (characterProfile) {
        console.log(`✅ [喜歡觸發AI] 找到角色: ${characterProfile.xName}`);

        // 構造消息資料（類比私信結構）
        const messageData = {
          id: characterProfile.characterId ? `msg_${characterProfile.characterId}` : 'msg_001',
          user: {
            name: characterProfile.xName,
            handle: characterProfile.xHandle,
            avatar: characterProfile.xAvatar,
            verified: characterProfile.xVerified || false,
          },
          preview: `看到你喜歡了我的推文`,
          time: '剛剛',
        };

        // 觸發私信詳情生成（續寫模式 + 自動發消息模式）
        const result = await generateMessageConversation(messageData, true, {
          isAutoMessage: true,
          timeSinceLastMessage: 0,
          likedTweetContext: tweetData, // 傳遞喜歡的推文資訊
        });

        if (result && result.length > 0) {
          // 保存AI生成的消息到對話記錄
          const conversationId = `messageConversation_${currentAccountId || 'main'}_${messageData.id}`;
          let savedConversation = await xDb.xAccountProfiles.get(conversationId);

          if (!savedConversation) {
            savedConversation = {
              handle: conversationId,
              name: 'messageConversation',
              data: { messages: [] },
              messageId: messageData.id,
              accountId: currentAccountId || 'main',
              updatedAt: new Date().toISOString(),
            };
          }

          // 添加新消息
          savedConversation.data.messages.push(...result);
          savedConversation.updatedAt = new Date().toISOString();
          await xDb.xAccountProfiles.put(savedConversation);

          // 顯示手機樣式通知
          const isEnglish = currentLanguage === 'en';
          showPhoneNotification({
            title: 'X',
            message: isEnglish
              ? `${characterProfile.xName} noticed you liked their tweet and sent you a message!`
              : `${characterProfile.xName} 看到你喜歡了TA的推文，發來了私信！`,
            avatar: characterProfile.xAvatar,
            leftIcon: 'x',
          });

          console.log(`✅ [喜歡觸發AI] 已觸發${characterProfile.xName}的主動私信`);
        }
      } else {
        console.log(`ℹ️ [喜歡觸發AI] ${authorHandle} 不是綁定角色，跳過觸發`);
      }
    } catch (error) {
      console.error('❌ [喜歡觸發AI] 觸發失敗:', error);
    }
  }

  // 渲染推文到容器
  function renderTweets(tweets, containerId) {
    const container = document.querySelector(`#${containerId} .tweets-container`);
    container.innerHTML = '';

    tweets.forEach((tweet, index) => {
      const tweetElement = createTweetElement(tweet);

      // 🎬 新推文添加滑入動畫
      if (tweet.isNew) {
        tweetElement.style.opacity = '0';
        tweetElement.style.transform = 'translateY(-20px)';
        tweetElement.style.transition = 'opacity 0.4s ease, transform 0.4s ease';

        // 延遲添加動畫，創造層疊效果
        setTimeout(() => {
          tweetElement.style.opacity = '1';
          tweetElement.style.transform = 'translateY(0)';
          // 動畫完成後移除isNew標記
          tweet.isNew = false;
        }, index * 50); // 每個推文延遲50ms
      }

      container.appendChild(tweetElement);

      // 為推文作者頭像添加點擊事件
      const avatar = tweetElement.querySelector('.tweet-avatar');
      if (avatar) {
        avatar.style.cursor = 'pointer';
        avatar.addEventListener('click', e => {
          e.stopPropagation();
          openAccountProfile(tweet.user.name, tweet.user.handle, tweet.user.avatar, {
            source: 'feed',
            tweetContent: tweet.content,
            tweetMedia: tweet.media,
            tweetStats: tweet.stats,
            tweetTime: tweet.time,
          });
        });
      }

      // 為引用推文中的頭像添加點擊事件
      const quotedAvatar = tweetElement.querySelector('.quoted-user-avatar');
      if (quotedAvatar && tweet.quotedTweet) {
        quotedAvatar.style.cursor = 'pointer';
        quotedAvatar.addEventListener('click', e => {
          e.stopPropagation();
          openAccountProfile(
            tweet.quotedTweet.user.name,
            tweet.quotedTweet.user.handle,
            tweet.quotedTweet.user.avatar,
            {
              source: 'feed',
              tweetContent: tweet.quotedTweet.content,
              tweetTime: tweet.quotedTweet.time,
            },
          );
        });
      }

      // 📱 長按多選刪除功能
      let longPressTimer = null;
      let touchStarted = false;

      // 移動端長按
      tweetElement.addEventListener('touchstart', e => {
        if (isFeedMultiSelectMode) {
          // 已經在多選模式，直接點擊選擇
          return;
        }
        touchStarted = true;
        longPressTimer = setTimeout(() => {
          if (touchStarted) {
            e.preventDefault();
            enterFeedMultiSelectMode(containerId);
            selectFeedTweet(tweet.id, tweetElement);
          }
        }, 500);
      });

      tweetElement.addEventListener('touchmove', () => {
        touchStarted = false;
        if (longPressTimer) clearTimeout(longPressTimer);
      });

      tweetElement.addEventListener('touchend', () => {
        touchStarted = false;
        if (longPressTimer) clearTimeout(longPressTimer);
      });

      // 桌面端長按
      tweetElement.addEventListener('mousedown', e => {
        if (isFeedMultiSelectMode) {
          // 已經在多選模式，直接點擊選擇
          return;
        }
        if (e.button !== 0) return;

        longPressTimer = setTimeout(() => {
          enterFeedMultiSelectMode(containerId);
          selectFeedTweet(tweet.id, tweetElement);
        }, 500);
      });

      tweetElement.addEventListener('mouseup', () => {
        if (longPressTimer) clearTimeout(longPressTimer);
      });

      tweetElement.addEventListener('mouseleave', () => {
        if (longPressTimer) clearTimeout(longPressTimer);
      });

      // 多選模式下點擊選擇
      tweetElement.addEventListener('click', e => {
        if (isFeedMultiSelectMode) {
          e.preventDefault();
          e.stopPropagation();
          selectFeedTweet(tweet.id, tweetElement);
        }
      });
    });
  }

  // ============================================
  // 📱 首頁推文多選刪除功能
  // ============================================
  let isFeedMultiSelectMode = false;
  let selectedFeedTweetIds = new Set();
  let currentFeedContainer = null;

  // 進入多選模式
  function enterFeedMultiSelectMode(containerId) {
    if (isFeedMultiSelectMode) return;

    isFeedMultiSelectMode = true;
    currentFeedContainer = containerId;
    selectedFeedTweetIds.clear();

    // 顯示多選工具列
    showFeedMultiSelectToolbar();

    // 給所有推文添加視覺提示
    const container = document.querySelector(`#${containerId} .tweets-container`);
    if (container) {
      const tweetElements = container.querySelectorAll('.tweet-item');
      tweetElements.forEach(el => {
        el.style.transition = 'transform 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease';
        el.style.cursor = 'pointer';
      });
    }

    console.log('📱 [首頁多選] 已進入多選模式');
  }

  // 選擇推文
  function selectFeedTweet(tweetId, tweetElement) {
    if (!isFeedMultiSelectMode) return;

    if (selectedFeedTweetIds.has(tweetId)) {
      // 取消選擇
      selectedFeedTweetIds.delete(tweetId);
      tweetElement.style.transform = '';
      tweetElement.style.boxShadow = '';
      tweetElement.style.backgroundColor = '';
    } else {
      // 選中
      selectedFeedTweetIds.add(tweetId);
      tweetElement.style.transform = 'scale(0.98)';
      tweetElement.style.boxShadow = '0 0 0 3px var(--x-accent)';
      tweetElement.style.backgroundColor = 'color-mix(in srgb, var(--x-accent) 10%, transparent)';
    }

    updateFeedMultiSelectToolbar();
  }

  // 顯示多選工具列
  function showFeedMultiSelectToolbar() {
    const oldToolbar = document.getElementById('feed-multi-select-toolbar');
    if (oldToolbar) oldToolbar.remove();

    const toolbar = document.createElement('div');
    toolbar.id = 'feed-multi-select-toolbar';
    toolbar.style.cssText = `
      position: fixed;
      bottom: 70px;
      left: 50%;
      transform: translateX(-50%);
      background-color: var(--x-bg-secondary);
      border: 1px solid var(--x-border-color);
      border-radius: 24px;
      padding: 12px 20px;
      display: flex;
      align-items: center;
      gap: 16px;
      z-index: 1000;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      animation: feedSlideUp 0.3s ease;
    `;

    toolbar.innerHTML = `
      <span id="feed-selected-count" style="color: var(--x-text-primary); font-size: 14px; font-weight: 600;">已選擇 0 條</span>
      <button onclick="selectAllFeedTweets()" style="
        background-color: var(--x-accent);
        color: #fff;
        border: none;
        border-radius: 16px;
        padding: 8px 16px;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
      " onmouseover="this.style.opacity='0.8'" onmouseout="this.style.opacity='1'">
        全選
      </button>
      <button onclick="deleteFeedSelectedTweets()" style="
        background-color: #f4212e;
        color: #fff;
        border: none;
        border-radius: 16px;
        padding: 8px 16px;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
      " onmouseover="this.style.backgroundColor='#d91b2a'" onmouseout="this.style.backgroundColor='#f4212e'">
        刪除
      </button>
      <button onclick="exitFeedMultiSelectMode()" style="
        background-color: transparent;
        color: var(--x-text-primary);
        border: 1px solid var(--x-border-color);
        border-radius: 16px;
        padding: 8px 16px;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
      " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='transparent'">
        取消
      </button>
    `;

    document.body.appendChild(toolbar);

    // 添加動畫CSS
    if (!document.getElementById('feed-multiselect-animation-style')) {
      const style = document.createElement('style');
      style.id = 'feed-multiselect-animation-style';
      style.textContent = `
        @keyframes feedSlideUp {
          from {
            transform: translateX(-50%) translateY(20px);
            opacity: 0;
          }
          to {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
          }
        }
        @keyframes feedSlideDown {
          from {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
          }
          to {
            transform: translateX(-50%) translateY(20px);
            opacity: 0;
          }
        }
      `;
      document.head.appendChild(style);
    }
  }

  // 更新工具列
  function updateFeedMultiSelectToolbar() {
    const countElement = document.getElementById('feed-selected-count');
    if (countElement) {
      countElement.textContent = `已選擇 ${selectedFeedTweetIds.size} 條`;
    }
  }

  // 全選
  window.selectAllFeedTweets = function () {
    if (!isFeedMultiSelectMode || !currentFeedContainer) return;

    const container = document.querySelector(`#${currentFeedContainer} .tweets-container`);
    if (!container) return;

    const isForYou = currentFeedContainer === 'for-you-content';
    const tweets = isForYou ? forYouTweets : followingTweets;

    // 全選所有推文
    const tweetElements = container.querySelectorAll('.tweet-item');
    tweets.forEach((tweet, index) => {
      selectedFeedTweetIds.add(tweet.id);
      const tweetElement = tweetElements[index];
      if (tweetElement) {
        tweetElement.style.transform = 'scale(0.98)';
        tweetElement.style.boxShadow = '0 0 0 3px var(--x-accent)';
        tweetElement.style.backgroundColor = 'color-mix(in srgb, var(--x-accent) 10%, transparent)';
      }
    });

    updateFeedMultiSelectToolbar();
  };

  // 退出多選模式
  window.exitFeedMultiSelectMode = function () {
    if (!isFeedMultiSelectMode) return;

    isFeedMultiSelectMode = false;
    selectedFeedTweetIds.clear();
    currentFeedContainer = null;

    // 隱藏工具列
    const toolbar = document.getElementById('feed-multi-select-toolbar');
    if (toolbar) {
      toolbar.style.animation = 'feedSlideDown 0.3s ease';
      setTimeout(() => toolbar.remove(), 300);
    }

    // 移除所有選擇樣式
    document.querySelectorAll('.tweet-item').forEach(el => {
      el.style.transform = '';
      el.style.boxShadow = '';
      el.style.backgroundColor = '';
      el.style.cursor = '';
    });

    console.log('📱 [首頁多選] 已退出多選模式');
  };

  // 刪除選中的推文
  window.deleteFeedSelectedTweets = async function () {
    if (selectedFeedTweetIds.size === 0) {
      showXToast('請先選擇要刪除的推文', 'info');
      return;
    }

    if (!confirm(`確定要刪除 ${selectedFeedTweetIds.size} 條推文嗎？`)) {
      return;
    }

    try {
      const isForYou = currentFeedContainer === 'for-you-content';
      const tweetsArray = isForYou ? forYouTweets : followingTweets;

      // 過濾掉選中的推文
      const remainingTweets = tweetsArray.filter(tweet => !selectedFeedTweetIds.has(tweet.id));

      if (isForYou) {
        forYouTweets.length = 0;
        forYouTweets.push(...remainingTweets);
      } else {
        followingTweets.length = 0;
        followingTweets.push(...remainingTweets);
      }

      // 更新資料庫
      const xDb = getXDB();
      await xDb.xTweetsData.put({
        id: 'tweets',
        forYouTweets: forYouTweets,
        followingTweets: followingTweets,
        lastUpdated: new Date().toISOString(),
      });

      // 重新渲染
      renderTweets(isForYou ? forYouTweets : followingTweets, currentFeedContainer);

      showXToast(`已刪除 ${selectedFeedTweetIds.size} 條推文`, 'success');

      // 退出多選模式
      exitFeedMultiSelectMode();
    } catch (error) {
      console.error('刪除推文失敗:', error);
      showXToast('刪除失敗', 'error');
    }
  };

  // 初始化推文數據
  async function initializeTweets() {
    try {
      // 嘗試從資料庫載入保存的推文資料
      const db = getXDB();

      const savedData = await db.xTweetsData.get('tweets');

      if (savedData && savedData.forYouTweets && savedData.followingTweets) {
        // 使用保存的資料
        forYouTweets.length = 0;
        followingTweets.length = 0;
        forYouTweets.push(...savedData.forYouTweets);
        followingTweets.push(...savedData.followingTweets);

        console.log('已載入保存的推文資料，最後更新時間:', savedData.lastUpdated);
      }
    } catch (error) {
      console.error('載入推文資料失敗，使用預設資料:', error);
    }

    // 渲染推文
    renderTweets(forYouTweets, 'for-you-content');
    renderTweets(followingTweets, 'following-content');
  }

  // ============================================
  // ⏰ 動態時間更新功能
  // ============================================

  // 計算相對時間
  function getRelativeTime(createdAt) {
    const now = Date.now();
    const diff = now - createdAt;

    const seconds = Math.floor(diff / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);

    if (seconds < 60) return '剛剛';
    if (minutes < 60) return `${minutes}分鐘前`;
    if (hours < 24) return `${hours}小時前`;
    if (days < 7) return `${days}天前`;

    // 超過7天顯示具體日期
    const date = new Date(createdAt);
    const month = date.getMonth() + 1;
    const day = date.getDate();
    return `${month}月${day}日`;
  }

  // 更新所有推文的時間顯示
  function updateAllTweetTimes() {
    // 更新為你推薦頁面
    forYouTweets.forEach(tweet => {
      if (tweet.createdAt) {
        tweet.time = getRelativeTime(tweet.createdAt);
      }
    });

    // 更新正在關注頁面
    followingTweets.forEach(tweet => {
      if (tweet.createdAt) {
        tweet.time = getRelativeTime(tweet.createdAt);
      }
    });

    // 🔧 更新DOM中所有帶有data-timestamp的時間顯示（適用於所有頁面）
    document.querySelectorAll('.tweet-time[data-timestamp]').forEach(timeEl => {
      const timestamp = parseInt(timeEl.dataset.timestamp);
      if (timestamp && !isNaN(timestamp)) {
        timeEl.textContent = getRelativeTime(timestamp);
      }
    });

    // 🔧 相容舊的推文時間更新邏輯
    document.querySelectorAll('.tweet-time').forEach(timeEl => {
      const tweetEl = timeEl.closest('.tweet-item');
      if (tweetEl && tweetEl.dataset.tweetId && !timeEl.dataset.timestamp) {
        const tweetId = tweetEl.dataset.tweetId;
        const tweet = [...forYouTweets, ...followingTweets].find(t => t.id === tweetId);
        if (tweet && tweet.createdAt) {
          timeEl.textContent = getRelativeTime(tweet.createdAt);
        }
      }
    });
  }

  // 啟動動態時間更新計時器（每30秒更新一次）
  setInterval(updateAllTweetTimes, 30000);

  // 顯示敏感內容
  function showSensitiveContent(tweetId) {
    const overlay = document.querySelector(`#media-${tweetId} .sensitive-overlay`);
    const content = document.getElementById(`content-${tweetId}`);

    if (overlay) {
      overlay.style.display = 'none';
    }
    if (content) {
      content.style.filter = 'none';
    }
  }

  // 點贊功能已移至書簽功能下方的window.toggleLike（完整版本，包含資料庫保存和AI觸發）

  // 生成隨機點贊數
  function generateRandomLikes() {
    return Math.floor(Math.random() * 50) + 1;
  }

  // 動態計算評論時間顯示
  function formatCommentTime(commentTimestamp) {
    // 驗證時間戳記有效性
    if (!commentTimestamp || isNaN(commentTimestamp) || commentTimestamp <= 0) {
      console.warn('⚠️ [時間顯示] 無效的時間戳記:', commentTimestamp);
      return '剛剛';
    }

    const now = Date.now();
    const diff = now - commentTimestamp;

    const minutes = Math.floor(diff / (1000 * 60));
    const hours = Math.floor(diff / (1000 * 60 * 60));
    const days = Math.floor(diff / (1000 * 60 * 60 * 24));

    if (minutes < 1) return '剛剛';
    if (minutes < 60) return `${minutes}分鐘前`;
    if (hours < 24) return `${hours}小時前`;
    if (days < 7) return `${days}天前`;

    // 超過7天顯示具體日期
    const date = new Date(commentTimestamp);

    // 二次驗證日期對象有效性
    if (isNaN(date.getTime())) {
      console.warn('⚠️ [時間顯示] 無效的日期對象，時間戳記:', commentTimestamp);
      return '剛剛';
    }

    const month = date.getMonth() + 1;
    const day = date.getDate();
    return `${month}月${day}日`;
  }

  // 創建評論元素
  function createCommentElement(comment, isReply = false) {
    const commentEl = document.createElement('div');
    commentEl.className = isReply ? 'comment-item reply-item' : 'comment-item';
    commentEl.dataset.commentId = comment.id;

    const randomLikes = generateRandomLikes();
    const randomComments = Math.floor(Math.random() * 10) + 1;
    const randomRetweets = Math.floor(Math.random() * 5) + 1;
    const randomViews = Math.floor(Math.random() * 1000) + 50;

    commentEl.innerHTML = `
              <img class="tweet-avatar" src="${comment.user.avatar}" alt="${comment.user.name}" 
                onclick="openAccountProfile('${comment.user.name.replace(/'/g, "\\'")}', '${comment.user.handle}', '${
      comment.user.avatar
    }', {source: 'tweetDetail', commentContent: '${comment.content
      .replace(/'/g, "\\'")
      .substring(0, 100)}'});event.stopPropagation();" 
                style="cursor: pointer; transition: opacity 0.2s;" 
                onmouseover="this.style.opacity='0.8'" 
                onmouseout="this.style.opacity='1'">
              <div class="comment-main">
                <div class="comment-user-info">
                  <span class="tweet-user-name" onclick="openAccountProfile('${comment.user.name.replace(
                    /'/g,
                    "\\'",
                  )}', '${comment.user.handle}', '${
      comment.user.avatar
    }', {source: 'tweetDetail', commentContent: '${comment.content
      .replace(/'/g, "\\'")
      .substring(0, 100)}'});event.stopPropagation();" style="cursor: pointer;">${comment.user.name}</span>
                  ${
                    comment.user.verified
                      ? '<svg class="tweet-verified" viewBox="0 0 24 24"><g><path d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.27 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.46 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z"></path></g></svg>'
                      : ''
                  }
                  <span class="tweet-user-handle">${
                    comment.user.handle.startsWith('@') ? comment.user.handle : '@' + comment.user.handle
                  }</span>
                  <span class="tweet-time">·${
                    comment.timestamp ? formatCommentTime(comment.timestamp) : comment.time || '剛剛'
                  }</span>
                  <div style="margin-left: auto; cursor: pointer; padding: 4px; border-radius: 50%; transition: background-color: 0.2s; display: flex; align-items: center;" onmouseover="this.style.backgroundColor='color-mix(in srgb, var(--x-accent) , 0.1)'" onmouseout="this.style.backgroundColor='transparent'" onclick="${
                    comment.user.handle === userProfileData.handle
                      ? `deleteUserComment('${comment.id}')`
                      : `event.stopPropagation(); showXToast('更多選項開發中', 'info')`
                  }">
                    <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: #71767b;">
                      <g><circle cx="12" cy="5" r="2"></circle><circle cx="12" cy="12" r="2"></circle><circle cx="12" cy="19" r="2"></circle></g>
                    </svg>
                  </div>
                </div>
                <div class="comment-content">
                  ${comment.replyTo ? `<span class="reply-to">${comment.replyTo}</span>` : ''}
                  ${processContent(cleanReplyContent(comment.content, comment.replyTo))}
                  ${
                    comment.image
                      ? comment.image.type === 'description'
                        ? `<div style="margin-top: 8px; background-color: var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 8px; padding: 8px; box-sizing: border-box;">
                            <div style="color: var(--x-text-primary); font-size: 13px; line-height: 1.4; white-space: pre-wrap; word-wrap: break-word; overflow-wrap: break-word; width: 100%; box-sizing: border-box;">${comment.image.content}</div>
                          </div>`
                        : `<div style="margin-top: 8px; border-radius: 12px; overflow: hidden; max-width: 300px;">
                            <img src="${comment.image.content}" style="width: 100%; max-height: 280px; object-fit: cover; display: block;" alt="評論圖片">
                          </div>`
                      : ''
                  }
                </div>
                <div class="comment-actions" style="display: flex; justify-content: space-between; align-items: center; margin-top: 8px; gap: 2px; max-width: 100%; overflow-x: hidden;">
                  <div class="comment-action reply-action" onclick="showReplyInput('${comment.id}', '${
      comment.user.handle
    }')" style="display: flex; align-items: center; gap: 2px; cursor: pointer; color: #71767b; transition: color 0.2s; flex: 0 1 auto; min-width: 0;">
                    <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor" style="width: 16px; height: 16px; flex-shrink: 0;">
                      <g><path d="M1.751 10c0-4.42 3.584-8.005 8.005-8.005h4.366c4.49 0 8.129 3.64 8.129 8.13 0 2.96-1.607 5.68-4.196 7.11l-8.054 4.46v-3.69h-.067c-4.49.1-8.183-3.51-8.183-8.005zm8.005-6.005c-3.317 0-6.005 2.69-6.005 6.005 0 3.37 2.77 6.08 6.138 6.01l.351-.01h1.761v2.3l5.087-2.81c1.951-1.08 3.163-3.13 3.163-5.36 0-3.39-2.744-6.13-6.129-6.13H9.756z"></path></g>
                    </svg>
                    <span style="font-size: 12px; white-space: nowrap;">${randomComments}</span>
                  </div>
                  <div class="comment-action" onclick="handleQuoteRetweetFromData('comment', '${
                    comment.id
                  }')" style="display: flex; align-items: center; gap: 2px; cursor: pointer; color: #71767b; transition: color 0.2s; flex: 0 1 auto; min-width: 0;">
                    <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor" style="width: 16px; height: 16px; flex-shrink: 0;">
                      <g><path d="M4.5 3.88l4.432 4.14-1.364 1.46L5.5 7.55V16c0 1.1.896 2 2 2H13v2H7.5c-2.209 0-4-1.791-4-4V7.55L1.432 9.48.068 8.02 4.5 3.88zM16.5 6H11V4h5.5c2.209 0 4 1.791 4 4v8.45l2.068-1.93 1.364 1.46-4.432 4.14-4.432-4.14 1.364-1.46 2.068 1.93V8c0-1.1-.896-2-2-2z"></path></g>
                    </svg>
                    <span style="font-size: 12px; white-space: nowrap;">${randomRetweets}</span>
                  </div>
                  <div class="comment-action like" onclick="toggleCommentLike('${
                    comment.id
                  }', this)" data-liked="false" data-likes="${randomLikes}" style="display: flex; align-items: center; gap: 2px; cursor: pointer; color: #71767b; transition: color 0.2s; flex: 0 1 auto; min-width: 0;">
                    <svg class="action-icon like-icon" viewBox="0 0 24 24" fill="currentColor" style="width: 16px; height: 16px; flex-shrink: 0;">
                      <g><path d="M16.697 5.5c-1.222-.06-2.679.51-3.89 2.16l-.805 1.09-.806-1.09C9.984 6.01 8.526 5.44 7.304 5.5c-1.243.07-2.349.78-2.91 1.91-.552 1.12-.633 2.78.479 4.82 1.074 1.97 3.257 4.27 7.129 6.61 3.87-2.34 6.052-4.64 7.126-6.61 1.111-2.04 1.03-3.7.477-4.82-.561-1.13-1.666-1.84-2.908-1.91zm4.187 7.69c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g>
                    </svg>
                    <span class="like-count" style="font-size: 12px; white-space: nowrap;">${randomLikes}</span>
                  </div>
                  <div class="comment-action" style="display: flex; align-items: center; gap: 2px; cursor: pointer; color: #71767b; transition: color 0.2s; flex: 0 1 auto; min-width: 0;">
                    <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor" style="width: 16px; height: 16px; flex-shrink: 0;">
                      <g><path d="M8.75 21V3h2v18h-2zM18 21V8.5h2V21h-2zM4 21l.004-10H6v10H4zm9.248 0v-7h2v7h-2z"></path></g>
                    </svg>
                    <span style="font-size: 12px; white-space: nowrap;">${formatNumber(randomViews)}</span>
                  </div>
                  <div class="comment-action bookmark" style="display: flex; align-items: center; cursor: pointer; color: #71767b; transition: color 0.2s; flex: 0 0 auto; min-width: 16px;">
                    <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor" style="width: 16px; height: 16px; flex-shrink: 0;">
                      <g><path d="M4 4.5C4 3.12 5.119 2 6.5 2h11C18.881 2 20 3.12 20 4.5v18.44l-8-5.71-8 5.71V4.5zM6.5 4c-.276 0-.5.22-.5.5v14.56l6-4.29 6 4.29V4.5c0-.28-.224-.5-.5-.5h-11z"></path></g>
                    </svg>
                  </div>
                  <div class="comment-action share comment-share-btn" data-comment-id="${
                    comment.id
                  }" style="display: flex; align-items: center; cursor: pointer; color: #71767b; transition: color 0.2s; flex: 0 0 auto; min-width: 16px;">
                    <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor" style="width: 16px; height: 16px; flex-shrink: 0;">
                      <g><path d="M12 2.59l5.7 5.7-1.41 1.42L13 6.41V16h-2V6.41l-3.29 3.3-1.42-1.42L12 2.59zM21 15l-.02 3.51c0 1.38-1.12 2.49-2.5 2.49H5.5C4.11 21 3 19.88 3 18.5V15h2v3.5c0 .28.22.5.5.5h12.98c.28 0 .5-.22.5-.5L19 15h2z"></path></g>
                    </svg>
                  </div>
                </div>
                <!-- 回復輸入框容器 -->
                <div id="reply-input-${
                  comment.id
                }" class="reply-input-container" style="display: none; margin-top: 12px; padding-left: 48px;">
                  <div style="display: flex; align-items: flex-start; gap: 12px;">
                    <img src="https://i.postimg.cc/pXxk1JXk/IMG-6442.jpg" alt="Your avatar" style="width: 32px; height: 32px; border-radius: 50%; flex-shrink: 0;" class="reply-user-avatar">
                    <div style="flex: 1;">
                      <textarea placeholder="發佈你的回復" style="width: 100%; min-height: 20px; max-height: 80px; background: transparent; border: none; color: #fff; font-size: 15px; resize: none; outline: none; font-family: inherit; line-height: 1.3; border-bottom: 1px solid #333; padding-bottom: 8px;" oninput="autoResizeReply(this, '${
                        comment.id
                      }')" onkeydown="handleReplyInput(event, '${comment.id}', '${comment.user.handle}')"></textarea>
                      <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 8px;">
                        <div style="display: flex; gap: 12px;">
                          <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: var(--x-accent); cursor: pointer;">
                            <g><path d="M3 5.5C3 4.119 4.119 3 5.5 3h13C19.881 3 21 4.119 21 5.5v13c0 1.381-1.119 2.5-2.5 2.5h-13C4.119 21 3 19.881 3 18.5v-13zM5.5 5c-.276 0-.5.224-.5.5v9.086l3-3 3 3 5-5 3 3V5.5c0-.276-.224-.5-.5-.5h-13zM19 15.414l-3-3-5 5-3-3-3 3V18.5c0 .276.224.5.5.5h13c.276 0 .5-.224.5-.5v-3.086zM9.75 7C8.784 7 8 7.784 8 8.75s.784 1.75 1.75 1.75 1.75-.784 1.75-1.75S10.716 7 9.75 7z"></path></g>
                          </svg>
                          <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: var(--x-accent); cursor: pointer;">
                            <g><path d="M8 9.5C8 8.119 8.672 7 9.5 7S11 8.119 11 9.5 10.328 12 9.5 12 8 10.881 8 9.5zm6.5 2.5c.828 0 1.5-1.119 1.5-2.5S15.328 7 14.5 7 13 8.119 13 9.5s.672 2.5 1.5 2.5zM12 16c-2.224 0-3.021-2.227-3.051-2.316l-1.897.633c.05.15 1.271 3.684 4.949 3.684s4.898-3.533 4.949-3.684l-1.896-.638c-.033.095-.83 2.322-3.053 2.322zm10.25-4.001c0 5.652-4.598 10.25-10.25 10.25S1.75 17.652 1.75 12 6.348 1.75 12 1.75 22.25 6.348 22.25 12zm-2 0c0-4.549-3.701-8.25-8.25-8.25S3.75 7.451 3.75 12s3.701 8.25 8.25 8.25 8.25-3.701 8.25-8.25z"></path></g>
                          </svg>
                        </div>
                        <div style="display: flex; gap: 8px;">
                          <button onclick="cancelReply('${
                            comment.id
                          }')" style="background: transparent; color: #71767b; border: 1px solid #333; border-radius: 16px; padding: 4px 12px; font-size: 13px; cursor: pointer;">取消</button>
                          <button id="reply-btn-${comment.id}" onclick="submitReply('${comment.id}', '${
      comment.user.handle
    }')" style="background-color: var(--x-accent); color: #fff; border: none; border-radius: 16px; padding: 4px 12px; font-size: 13px; cursor: pointer; opacity: 0.5;" disabled>回復</button>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            `;

    // 添加分享按鈕點擊事件
    const shareBtn = commentEl.querySelector('.comment-share-btn');
    if (shareBtn) {
      shareBtn.onclick = () => {
        // 嘗試從 sessionStorage 獲取當前推文資料
        let parentTweet = null;
        const currentTweetDataStr = sessionStorage.getItem('currentTweetData');
        if (currentTweetDataStr) {
          try {
            parentTweet = JSON.parse(currentTweetDataStr);
          } catch (e) {
            console.error('解析推文數據失敗:', e);
          }
        }

        showShareContentModal(
          {
            user: comment.user,
            content: comment.content,
            time: comment.time || (comment.timestamp ? formatCommentTime(comment.timestamp) : '剛剛'),
            image: comment.image,
            // 包含所屬推文的數據
            parentTweet: parentTweet,
          },
          'comment',
        );
      };
    }

    return commentEl;
  }

  // 刪除用戶評論功能
  async function deleteUserComment(commentId) {
    if (!confirm('確定要刪除這條評論嗎？')) {
      return;
    }

    const commentElement = document.querySelector(`[data-comment-id="${commentId}"]`);
    if (commentElement) {
      // 添加淡出動畫
      commentElement.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
      commentElement.style.opacity = '0';
      commentElement.style.transform = 'translateX(-20px)';

      // 動畫完成後移除元素
      setTimeout(() => {
        commentElement.remove();
        showXToast('評論已刪除', 'success');
      }, 300);

      // 遞迴刪除評論的輔助函數
      const removeCommentById = (comments, targetId) => {
        return comments.filter(comment => {
          if (comment.id === targetId) {
            return false; // 刪除匹配的評論
          }
          if (comment.replies && comment.replies.length > 0) {
            comment.replies = removeCommentById(comment.replies, targetId);
          }
          return true;
        });
      };

      // 同時從推文資料中移除這條評論
      try {
        // 更新sessionStorage中的資料
        const currentTweetData = sessionStorage.getItem('currentTweetData');
        if (currentTweetData) {
          const tweetData = JSON.parse(currentTweetData);
          if (tweetData.comments) {
            tweetData.comments = removeCommentById(tweetData.comments, commentId);
            sessionStorage.setItem('currentTweetData', JSON.stringify(tweetData));

            // 更新統計資料
            const commentsCount = document.querySelector('.tweet-stats .comment-count');
            if (commentsCount) {
              const currentCount = parseInt(commentsCount.textContent) || 0;
              if (currentCount > 0) {
                commentsCount.textContent = currentCount - 1;
              }
            }

            // 同時更新資料庫中的資料
            const db = getXDB();
            const tweetsData = await db.xTweetsData.get('tweets');

            if (tweetsData) {
              // 在forYouTweets中查找並更新
              if (tweetsData.forYouTweets) {
                const tweetIndex = tweetsData.forYouTweets.findIndex(t => t.id === tweetData.id);
                if (tweetIndex !== -1) {
                  tweetsData.forYouTweets[tweetIndex].comments = removeCommentById(
                    tweetsData.forYouTweets[tweetIndex].comments || [],
                    commentId,
                  );
                  // 更新全域變數
                  forYouTweets[tweetIndex] = tweetsData.forYouTweets[tweetIndex];
                }
              }

              // 在followingTweets中查找並更新
              if (tweetsData.followingTweets) {
                const tweetIndex = tweetsData.followingTweets.findIndex(t => t.id === tweetData.id);
                if (tweetIndex !== -1) {
                  tweetsData.followingTweets[tweetIndex].comments = removeCommentById(
                    tweetsData.followingTweets[tweetIndex].comments || [],
                    commentId,
                  );
                  // 更新全域變數
                  followingTweets[tweetIndex] = tweetsData.followingTweets[tweetIndex];
                }
              }

              // 保存更新後的資料
              await db.xTweetsData.put(tweetsData);
            }

            // 如果是用戶自己的推文，也更新使用者推文資料
            if (tweetData.id.startsWith('user_')) {
              // 🔧 多帳戶隔離：使用帳戶ID
              const userTweetsId = `userTweets_${currentAccountId || 'main'}`;
              const userTweets = await db.xUserTweets.get(userTweetsId);
              if (userTweets && userTweets.tweets) {
                const userTweetIndex = userTweets.tweets.findIndex(t => t.id === tweetData.id);
                if (userTweetIndex !== -1) {
                  userTweets.tweets[userTweetIndex].comments = removeCommentById(
                    userTweets.tweets[userTweetIndex].comments || [],
                    commentId,
                  );
                  await db.xUserTweets.put(userTweets);
                }
              }
            }

            console.log('評論已從資料庫中刪除:', commentId);
          }
        } else if (currentTweetId) {
          // 如果是主頁評論頁面，更新主頁數據
          const allTweets = [...forYouTweets, ...followingTweets];
          const tweet = allTweets.find(t => t.id === currentTweetId);

          if (tweet && tweet.comments) {
            tweet.comments = removeCommentById(tweet.comments, commentId);
            tweet.stats.comments = Math.max(0, (tweet.stats.comments || 0) - 1);

            // 更新全域陣列引用
            const tweetIndex = forYouTweets.findIndex(t => t.id === tweet.id);
            if (tweetIndex !== -1) {
              forYouTweets[tweetIndex] = tweet;
            } else {
              const followingIndex = followingTweets.findIndex(t => t.id === tweet.id);
              if (followingIndex !== -1) {
                followingTweets[followingIndex] = tweet;
              }
            }

            // 保存到資料庫
            const db = getXDB();
            await db.xTweetsData.put({
              id: 'tweets',
              forYouTweets: forYouTweets,
              followingTweets: followingTweets,
              lastUpdated: new Date().toISOString(),
            });

            console.log('主頁評論已從資料庫中刪除:', commentId);
          }
        }
      } catch (error) {
        console.error('刪除評論資料失敗:', error);
        showXToast('刪除評論失敗，請重試', 'error');
      }
    }
  }

  // 評論點贊功能
  function toggleCommentLike(commentId, element) {
    const isLiked = element.dataset.liked === 'true';
    const currentLikes = parseInt(element.dataset.likes);
    const likeIcon = element.querySelector('.like-icon');
    const likeCount = element.querySelector('.like-count');

    if (isLiked) {
      element.dataset.liked = 'false';
      element.dataset.likes = (currentLikes - 1).toString();
      element.classList.remove('liked');
      likeCount.textContent = (currentLikes - 1).toString();
    } else {
      element.dataset.liked = 'true';
      element.dataset.likes = (currentLikes + 1).toString();
      element.classList.add('liked');
      likeCount.textContent = (currentLikes + 1).toString();

      likeIcon.classList.add('like-animation');
      setTimeout(() => {
        likeIcon.classList.remove('like-animation');
      }, 600);
    }
  }

  // 渲染評論
  function renderComments(tweetId) {
    const container = document.querySelector('.comments-container');
    container.innerHTML = '';

    // 找到對應的推文（包括主頁推文、搜索結果推文、帳戶推文）
    let allTweets = [...forYouTweets, ...followingTweets];

    // 添加搜索結果推文
    if (searchResultsData.top || searchResultsData.latest) {
      allTweets = [...allTweets, ...(searchResultsData.top || []), ...(searchResultsData.latest || [])];
    }

    // 添加帳戶推文
    if (currentViewingAccount && currentViewingAccount.tweets) {
      allTweets = [...allTweets, ...currentViewingAccount.tweets];
    }

    const tweet = allTweets.find(t => t.id === tweetId);

    if (!tweet || !tweet.comments) return;

    tweet.comments.forEach(comment => {
      // 創建評論組容器
      const commentGroup = document.createElement('div');
      commentGroup.style.cssText = 'position: relative;';

      // 添加主評論
      const commentElement = createCommentElement(comment);

      // 如果有回復，給主評論添加特殊類
      if (comment.replies && comment.replies.length > 0) {
        commentElement.classList.add('has-replies');
      }

      commentGroup.appendChild(commentElement);

      // 為主評論頭像添加點擊事件
      const commentAvatar = commentElement.querySelector('.tweet-avatar');
      if (commentAvatar) {
        commentAvatar.style.cursor = 'pointer';
        commentAvatar.addEventListener('click', e => {
          e.stopPropagation();
          openAccountProfile(comment.user.name, comment.user.handle, comment.user.avatar, {
            source: 'comment',
            commentContent: comment.content,
            commentImage: comment.image,
            commentTime: comment.time,
          });
        });
      }

      // 渲染回復
      if (comment.replies && comment.replies.length > 0) {
        comment.replies.forEach(reply => {
          const replyElement = createCommentElement(reply, true);
          commentGroup.appendChild(replyElement);

          // 為回復頭像添加點擊事件
          const replyAvatar = replyElement.querySelector('.tweet-avatar');
          if (replyAvatar) {
            replyAvatar.style.cursor = 'pointer';
            replyAvatar.addEventListener('click', e => {
              e.stopPropagation();
              openAccountProfile(reply.user.name, reply.user.handle, reply.user.avatar, {
                source: 'comment',
                commentContent: reply.content,
                commentImage: reply.image,
                commentTime: reply.time,
                replyTo: reply.replyTo,
              });
            });
          }
        });
      }

      container.appendChild(commentGroup);
    });

    // 更新所有回復輸入框頭像
    const replyUserAvatars = document.querySelectorAll('.reply-user-avatar');
    replyUserAvatars.forEach(avatar => {
      avatar.src = userProfileData.avatar;
    });
  }

  // 評論圖片資料存儲
  let commentImageData = null;
  let detailCommentImageData = null;

  // 觸發主頁評論圖片上傳
  function triggerCommentImageUpload() {
    document.getElementById('comment-image-input').click();
  }

  // 處理主頁評論圖片上傳
  function handleCommentImageUpload(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = function (e) {
      commentImageData = e.target.result;
      const preview = document.getElementById('comment-image-preview');
      const img = document.getElementById('comment-image-preview-img');
      img.src = commentImageData;
      preview.style.display = 'block';

      showXToast('圖片已添加', 'success');
    };
    reader.readAsDataURL(file);
  }

  // 移除主頁評論圖片
  function removeCommentImage() {
    commentImageData = null;
    const preview = document.getElementById('comment-image-preview');
    const img = document.getElementById('comment-image-preview-img');
    img.src = '';
    preview.style.display = 'none';
    document.getElementById('comment-image-input').value = '';
  }

  // 觸發詳情頁評論圖片上傳
  function triggerDetailCommentImageUpload() {
    document.getElementById('detail-comment-image-input').click();
  }

  // 處理詳情頁評論圖片上傳
  function handleDetailCommentImageUpload(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = function (e) {
      detailCommentImageData = e.target.result;
      const preview = document.getElementById('detail-comment-image-preview');
      const img = document.getElementById('detail-comment-image-preview-img');
      img.src = detailCommentImageData;
      preview.style.display = 'block';

      showXToast('圖片已添加', 'success');
    };
    reader.readAsDataURL(file);
  }

  // 移除詳情頁評論圖片
  function removeDetailCommentImage() {
    detailCommentImageData = null;
    const preview = document.getElementById('detail-comment-image-preview');
    const img = document.getElementById('detail-comment-image-preview-img');
    img.src = '';
    preview.style.display = 'none';
    document.getElementById('detail-comment-image-input').value = '';
  }

  // 處理評論輸入
  function handleCommentInput(event) {
    const textarea = event.target;
    const replyBtn = document.getElementById('reply-btn');

    // 更新按鈕狀態
    if (textarea.value.trim().length > 0) {
      replyBtn.style.opacity = '1';
      replyBtn.disabled = false;
    } else {
      replyBtn.style.opacity = '0.5';
      replyBtn.disabled = true;
    }

    // 回車發送評論（Shift+回車換行）
    if (event.key === 'Enter' && !event.shiftKey) {
      event.preventDefault();
      if (textarea.value.trim().length > 0) {
        submitComment();
      }
    }
  }

  // 自動調整textarea高度
  function autoResize(textarea) {
    textarea.style.height = '20px';
    textarea.style.height = Math.min(textarea.scrollHeight, 120) + 'px';

    // 更新按鈕狀態
    const replyBtn = document.getElementById('reply-btn');
    if (textarea.value.trim().length > 0) {
      replyBtn.style.opacity = '1';
      replyBtn.disabled = false;
    } else {
      replyBtn.style.opacity = '0.5';
      replyBtn.disabled = true;
    }
  }

  // 當前正在查看的推文ID
  let currentTweetId = null;

  // 提交評論
  async function submitComment() {
    const textarea = document.getElementById('comment-input');
    const content = textarea.value.trim();

    if (content.length === 0 || !currentTweetId) return;

    // 獲取當前推文資料 - 需要同時檢查帳戶推文
    let tweet = null;
    let isAccountTweet = false;

    // 先從主頁推文中查找
    const allTweets = [...forYouTweets, ...followingTweets];
    tweet = allTweets.find(t => t.id === currentTweetId);

    // 如果沒找到，檢查是否為帳戶推文
    if (!tweet && currentViewingAccount && currentViewingAccount.tweets) {
      tweet = currentViewingAccount.tweets.find(t => t.id === currentTweetId);
      isAccountTweet = !!tweet;
    }

    if (!tweet) {
      showXToast('無法找到對應的推文', 'error');
      return;
    }

    // 檢查是否為僅自己可見的帖子（主頁推文一般不會有private標記，但為了統一）
    if (tweet.privacy === 'private') {
      showXToast('私有帖子不支援回復功能', 'error');
      return;
    }

    // 創建新評論物件（使用window.userProfileData確保獲取最新帳號資料）
    const newComment = {
      id: 'new-' + Date.now(),
      user: {
        name: window.userProfileData.name,
        handle: window.userProfileData.handle,
        avatar: window.userProfileData.avatar,
        verified: window.userProfileData.verified,
      },
      content: content,
      timestamp: Date.now(), // 使用時間戳記而不是固定文本
      replies: [],
    };

    // 如果有圖片，添加圖片資料
    if (commentImageData) {
      newComment.image = {
        type: 'upload',
        content: commentImageData,
      };
    }

    // 添加到對應推文的評論列表
    if (tweet) {
      // 確保評論列表存在
      if (!tweet.comments) {
        tweet.comments = [];
      }
      tweet.comments.push(newComment);
      tweet.stats.comments += 1;

      // 強制更新全域陣列引用，確保資料同步
      const tweetIndex = forYouTweets.findIndex(t => t.id === tweet.id);
      if (tweetIndex !== -1) {
        forYouTweets[tweetIndex] = tweet;
      } else {
        const followingIndex = followingTweets.findIndex(t => t.id === tweet.id);
        if (followingIndex !== -1) {
          followingTweets[followingIndex] = tweet;
        }
      }

      // 保存更新後的推文資料
      try {
        const db = getXDB();

        if (isAccountTweet) {
          // 保存到帳戶主頁數據
          const accountHandle =
            tweet._accountHandle || (currentViewingAccount.accountInfo || currentViewingAccount).handle;
          const cleanHandle = accountHandle.replace('@', '');

          // 更新currentViewingAccount中的推文
          const tweetIndex = currentViewingAccount.tweets.findIndex(t => t.id === tweet.id);
          if (tweetIndex !== -1) {
            currentViewingAccount.tweets[tweetIndex] = tweet;
          }

          // 保存到資料庫
          await db.xAccountProfiles.put({
            handle: cleanHandle,
            name: (currentViewingAccount.accountInfo || currentViewingAccount).name,
            accountInfo: currentViewingAccount.accountInfo || currentViewingAccount,
            tweets: currentViewingAccount.tweets,
            accountReplies: currentViewingAccount.accountReplies || [],
            updatedAt: new Date().toISOString(),
          });

          console.log('✅ 用戶評論已保存到帳戶推文，評論ID:', newComment.id, '帳戶:', cleanHandle);
        } else {
          // 保存到主頁推文資料
          await db.xTweetsData.put({
            id: 'tweets',
            forYouTweets: forYouTweets,
            followingTweets: followingTweets,
            lastUpdated: new Date().toISOString(),
          });

          console.log('使用者評論已保存到資料庫，評論ID:', newComment.id);
        }
      } catch (saveError) {
        console.error('保存評論資料失敗:', saveError);
      }
    }

    // 重新渲染評論
    renderComments(currentTweetId);

    // 清空輸入框並重置高度
    textarea.value = '';
    textarea.style.height = '20px';

    // 清除圖片
    if (commentImageData) {
      removeCommentImage();
    }

    // 重新開機按鈕狀態
    const replyBtn = document.getElementById('reply-btn');
    replyBtn.style.opacity = '0.5';
    replyBtn.disabled = true;

    // 滾動到底部顯示新評論
    const commentsContainer = document.querySelector('.comments-container');
    setTimeout(() => {
      commentsContainer.scrollTop = commentsContainer.scrollHeight;
    }, 100);

    showXToast('你的評論等待回復中', 'info');

    // 觸發AI回復 - 判斷是否為用戶自己的帖子（主頁推文中使用者自己的帖子需要特別處理）
    const isOwnPost = tweet.user && (tweet.user.handle === userProfileData.handle || tweet.id.startsWith('user_'));

    // 延遲觸發AI回復，確保用戶評論已經完全渲染和保存
    setTimeout(async () => {
      await generateUnifiedAIResponse(tweet, newComment, {
        isOwnPost,
        commentType: 'main_comment',
        pageType: 'main',
        parentComment: null,
      });
    }, 100);
  }

  // 顯示回復輸入框
  function showReplyInput(commentId, userHandle) {
    // 隱藏所有其他回復輸入框
    document.querySelectorAll('.reply-input-container').forEach(container => {
      container.style.display = 'none';
    });

    // 顯示當前評論的回復輸入框
    const replyContainer = document.getElementById(`reply-input-${commentId}`);
    if (replyContainer) {
      replyContainer.style.display = 'block';
      const textarea = replyContainer.querySelector('textarea');
      textarea.focus();
    }
  }

  // 取消回復
  function cancelReply(commentId) {
    const replyContainer = document.getElementById(`reply-input-${commentId}`);
    if (replyContainer) {
      replyContainer.style.display = 'none';
      const textarea = replyContainer.querySelector('textarea');
      textarea.value = '';
      textarea.style.height = '20px';

      // 重新開機按鈕狀態
      const replyBtn = document.getElementById(`reply-btn-${commentId}`);
      replyBtn.style.opacity = '0.5';
      replyBtn.disabled = true;
    }
  }

  // 處理回復輸入
  function handleReplyInput(event, commentId, userHandle) {
    const textarea = event.target;
    const replyBtn = document.getElementById(`reply-btn-${commentId}`);

    // 更新按鈕狀態
    if (textarea.value.trim().length > 0) {
      replyBtn.style.opacity = '1';
      replyBtn.disabled = false;
    } else {
      replyBtn.style.opacity = '0.5';
      replyBtn.disabled = true;
    }

    // 回車發送回復
    if (event.key === 'Enter' && !event.shiftKey) {
      event.preventDefault();
      if (textarea.value.trim().length > 0) {
        submitReply(commentId, userHandle);
      }
    }
  }

  // 自動調整回復textarea高度
  function autoResizeReply(textarea, commentId) {
    textarea.style.height = '20px';
    textarea.style.height = Math.min(textarea.scrollHeight, 80) + 'px';

    // 更新按鈕狀態
    const replyBtn = document.getElementById(`reply-btn-${commentId}`);
    if (textarea.value.trim().length > 0) {
      replyBtn.style.opacity = '1';
      replyBtn.disabled = false;
    } else {
      replyBtn.style.opacity = '0.5';
      replyBtn.disabled = true;
    }
  }

  // 提交回復
  async function submitReply(commentId, replyToHandle) {
    const replyContainer = document.getElementById(`reply-input-${commentId}`);
    const textarea = replyContainer.querySelector('textarea');
    const content = textarea.value.trim();

    if (content.length === 0) return;

    // 獲取當前推文資料 - 先嘗試從sessionStorage（詳情頁），再從主頁數據
    let tweetData = null;
    const currentTweetDataFromSession = sessionStorage.getItem('currentTweetData');

    if (currentTweetDataFromSession) {
      // 詳情頁面的情況
      try {
        tweetData = JSON.parse(currentTweetDataFromSession);
      } catch (e) {
        console.error('解析sessionStorage推文數據失敗:', e);
      }
    }

    if (!tweetData && currentTweetId) {
      // 主頁推文的情況
      const allTweets = [...forYouTweets, ...followingTweets];
      tweetData = allTweets.find(t => t.id === currentTweetId);
    }

    if (!tweetData) {
      showXToast('無法獲取推文資訊', 'error');
      return;
    }

    // 檢查是否為僅自己可見的帖子
    if (tweetData.privacy === 'private') {
      showXToast('私有帖子不支援回復功能', 'error');
      return;
    }

    // 找到被回復的評論 - 支援樓中樓回復並處理為平級顯示
    let parentComment = null;
    let mainCommentId = commentId; // 用於查找主評論ID（對於樓中樓回復）
    const isDetailPage = !!currentTweetDataFromSession;
    const commentsContainer = isDetailPage
      ? document.getElementById('detail-comments-container')
      : document.querySelector('.comments-container');
    const allComments = commentsContainer.querySelectorAll('.comment-item');

    // 首先找到被回復的評論
    let targetCommentEl = null;
    allComments.forEach(commentEl => {
      if (commentEl.dataset.commentId === commentId) {
        targetCommentEl = commentEl;
      }
    });

    if (targetCommentEl) {
      // 從DOM中提取評論資訊構建parentComment
      const userName = targetCommentEl.querySelector('.tweet-user-name').textContent;
      const userHandle = targetCommentEl.querySelector('.tweet-user-handle').textContent;
      const commentContent = targetCommentEl.querySelector('.comment-content').textContent.trim();

      parentComment = {
        id: commentId,
        user: { name: userName, handle: userHandle },
        content: commentContent,
      };

      // 如果被回復的是樓中樓，需要找到對應的主評論ID（用於資料存儲）
      if (targetCommentEl.classList.contains('reply-item')) {
        // 向上查找同一個評論組中的主評論
        let currentEl = targetCommentEl.previousElementSibling;
        while (currentEl && currentEl.classList.contains('reply-item')) {
          currentEl = currentEl.previousElementSibling;
        }
        if (currentEl && currentEl.classList.contains('comment-item') && !currentEl.classList.contains('reply-item')) {
          mainCommentId = currentEl.dataset.commentId;
        } else {
          // 如果向上沒找到，可能是第一個回復，向上查找父容器中的主評論
          let parentContainer = targetCommentEl.parentNode;
          let firstComment = parentContainer.querySelector('.comment-item:not(.reply-item)');
          if (firstComment) {
            mainCommentId = firstComment.dataset.commentId;
          }
        }
      }
    }

    // 創建新回復物件（使用window.userProfileData確保獲取最新帳號資料）
    const newReply = {
      id: 'reply-' + Date.now(),
      user: {
        name: window.userProfileData.name,
        handle: window.userProfileData.handle,
        avatar: window.userProfileData.avatar,
        verified: window.userProfileData.verified,
      },
      content: content,
      timestamp: Date.now(), // 使用時間戳記而不是固定文本
      replyTo: replyToHandle,
      replies: [],
    };

    console.log('💬 [樓中樓回復] 創建新回復:', {
      id: newReply.id,
      content: newReply.content.substring(0, 50) + '...',
      replyTo: replyToHandle,
      mainCommentId,
      isDetailPage,
    });

    if (isDetailPage) {
      // 詳情頁面：渲染到頁面並同時保存到資料庫 - 修復樓中樓插入位置
      const commentElement = createCommentElement(newReply, true);

      if (targetCommentEl) {
        let insertAfter = null;

        if (targetCommentEl.classList.contains('reply-item')) {
          // 如果回復的是樓中樓，找到這個評論組的最後一個評論
          let nextSibling = targetCommentEl.nextElementSibling;
          insertAfter = targetCommentEl;

          // 找到當前評論組的最後一條評論
          while (nextSibling && nextSibling.classList.contains('reply-item')) {
            insertAfter = nextSibling;
            nextSibling = nextSibling.nextElementSibling;
          }
        } else {
          // 如果回復的是主評論，找到這個評論組的最後一條評論（包括所有樓中樓）
          let nextSibling = targetCommentEl.nextElementSibling;
          insertAfter = targetCommentEl;

          while (nextSibling && nextSibling.classList.contains('reply-item')) {
            insertAfter = nextSibling;
            nextSibling = nextSibling.nextElementSibling;
          }
        }

        // 插入到正確位置
        if (insertAfter.nextSibling) {
          insertAfter.parentNode.insertBefore(commentElement, insertAfter.nextSibling);
        } else {
          insertAfter.parentNode.appendChild(commentElement);
        }
      }

      // 同時保存到sessionStorage中的推文資料
      try {
        console.log('💬 [樓中樓回復] 開始保存到資料庫');
        let updatedTweetData = JSON.parse(sessionStorage.getItem('currentTweetData'));

        if (updatedTweetData) {
          console.log('💬 [樓中樓回復] 推文ID:', updatedTweetData.id);
          console.log('💬 [樓中樓回復] 主評論ID:', mainCommentId);
          console.log('💬 [樓中樓回復] 當前評論總數:', updatedTweetData.comments?.length || 0);

          const mainComment = updatedTweetData.comments.find(c => c.id === mainCommentId);
          if (mainComment) {
            console.log('💬 [樓中樓回復] 找到主評論，當前回復數:', mainComment.replies?.length || 0);

            if (!mainComment.replies) mainComment.replies = [];
            mainComment.replies.push(newReply);

            console.log('💬 [樓中樓回復] 新回復已添加，新回復總數:', mainComment.replies.length);

            // 更新sessionStorage
            sessionStorage.setItem('currentTweetData', JSON.stringify(updatedTweetData));
            console.log('✅ [樓中樓回復] sessionStorage 已更新');

            // 同時保存到資料庫
            const db = getXDB();
            const isUserTweet = updatedTweetData.id.startsWith('user_');
            const isAccountTweet = updatedTweetData._source === 'account';

            console.log('💬 [樓中樓回復] 是否為用戶推文:', isUserTweet);
            console.log('💬 [樓中樓回復] 是否為帳戶推文:', isAccountTweet);

            if (isAccountTweet) {
              // 帳戶推文，保存到 xAccountProfiles
              console.log('💬 [樓中樓回復] 保存到帳戶推文資料庫');
              const accountHandle =
                updatedTweetData._accountHandle || (currentViewingAccount.accountInfo || currentViewingAccount).handle;
              const cleanHandle = accountHandle.replace('@', '');

              if (currentViewingAccount && currentViewingAccount.tweets) {
                const tweetIndex = currentViewingAccount.tweets.findIndex(t => t.id === updatedTweetData.id);
                if (tweetIndex !== -1) {
                  currentViewingAccount.tweets[tweetIndex] = updatedTweetData;

                  await db.xAccountProfiles.put({
                    handle: cleanHandle,
                    name: (currentViewingAccount.accountInfo || currentViewingAccount).name,
                    accountInfo: currentViewingAccount.accountInfo || currentViewingAccount,
                    tweets: currentViewingAccount.tweets,
                    accountReplies: currentViewingAccount.accountReplies || [],
                    updatedAt: new Date().toISOString(),
                  });

                  console.log('✅ [樓中樓回復] 帳戶推文已更新，帳戶:', cleanHandle);
                } else {
                  console.warn('⚠️ [樓中樓回復] 未找到目標帳戶推文');
                }
              }
            } else if (isUserTweet) {
              // 用戶自己的推文，保存到 xUserTweets
              console.log('💬 [樓中樓回復] 保存到使用者推文資料庫');
              const accountTweetsId = `userTweets_${currentAccountId || 'main'}`;
              const userTweets = await db.xUserTweets.get(accountTweetsId);

              if (userTweets && userTweets.tweets) {
                console.log('💬 [樓中樓回復] 找到使用者推文資料，推文總數:', userTweets.tweets.length);

                const userTweetIndex = userTweets.tweets.findIndex(t => t.id === updatedTweetData.id);
                if (userTweetIndex !== -1) {
                  console.log('💬 [樓中樓回復] 找到目標推文，索引:', userTweetIndex);
                  userTweets.tweets[userTweetIndex] = updatedTweetData;
                  await db.xUserTweets.put(userTweets);
                  console.log('✅ [樓中樓回復] 用戶推文已更新到帳戶:', accountTweetsId);
                } else {
                  console.warn('⚠️ [樓中樓回復] 未找到目標使用者推文');
                }
              } else {
                console.warn('⚠️ [樓中樓回復] 未找到使用者推文資料');
              }
            } else {
              // 主頁推文，保存到 xTweetsData
              console.log('💬 [樓中樓回復] 保存到主頁推文資料庫');
              const tweetsData = await db.xTweetsData.get('tweets');

              if (tweetsData) {
                let updated = false;

                if (tweetsData.forYouTweets) {
                  const tweetIndex = tweetsData.forYouTweets.findIndex(t => t.id === updatedTweetData.id);
                  if (tweetIndex !== -1) {
                    tweetsData.forYouTweets[tweetIndex] = updatedTweetData;
                    updated = true;
                    console.log('💬 [樓中樓回復] 已更新 forYouTweets');
                  }
                }

                if (!updated && tweetsData.followingTweets) {
                  const tweetIndex = tweetsData.followingTweets.findIndex(t => t.id === updatedTweetData.id);
                  if (tweetIndex !== -1) {
                    tweetsData.followingTweets[tweetIndex] = updatedTweetData;
                    updated = true;
                    console.log('💬 [樓中樓回復] 已更新 followingTweets');
                  }
                }

                if (updated) {
                  await db.xTweetsData.put(tweetsData);
                  console.log('✅ [樓中樓回復] 主頁推文已保存到資料庫');
                } else {
                  console.warn('⚠️ [樓中樓回復] 未在主頁數據中找到目標推文');
                }
              }
            }
          } else {
            console.warn('⚠️ [樓中樓回復] 未找到主評論，mainCommentId:', mainCommentId);
          }
        } else {
          console.warn('⚠️ [樓中樓回復] sessionStorage 中無推文數據');
        }
      } catch (saveError) {
        console.error('❌ [樓中樓回復] 保存失敗:', saveError);
      }
    } else {
      // 主頁推文：添加到資料並重新渲染 - 支援樓中樓平級回復
      const mainComment = tweetData.comments.find(c => c.id === mainCommentId);
      if (mainComment) {
        if (!mainComment.replies) mainComment.replies = [];
        mainComment.replies.push(newReply);

        // 強制更新全域陣列引用，確保資料同步
        const tweetIndex = forYouTweets.findIndex(t => t.id === tweetData.id);
        if (tweetIndex !== -1) {
          forYouTweets[tweetIndex] = tweetData;
        } else {
          const followingIndex = followingTweets.findIndex(t => t.id === tweetData.id);
          if (followingIndex !== -1) {
            followingTweets[followingIndex] = tweetData;
          }
        }

        // 保存更新後的推文資料
        try {
          const db = getXDB();

          await db.xTweetsData.put({
            id: 'tweets',
            forYouTweets: forYouTweets,
            followingTweets: followingTweets,
            lastUpdated: new Date().toISOString(),
          });

          console.log('使用者回復已保存到資料庫，回復ID:', newReply.id);
        } catch (saveError) {
          console.error('保存回復資料失敗:', saveError);
        }

        // 重新渲染評論
        renderComments(currentTweetId);
      }
    }

    // 隱藏回復輸入框
    cancelReply(commentId);

    showXToast('你的評論等待回復中', 'info');

    // 觸發AI回復 - 判斷是否為用戶自己的帖子
    const isOwnPost =
      tweetData.user && (tweetData.user.handle === userProfileData.handle || tweetData.id.startsWith('user_'));

    // 延遲觸發AI回復，確保用戶回復已經完全渲染和保存
    setTimeout(async () => {
      await generateUnifiedAIResponse(tweetData, newReply, {
        isOwnPost,
        commentType: 'reply_comment',
        pageType: isDetailPage ? 'detail' : 'main',
        parentComment,
        mainCommentId, // 傳遞主評論ID用於樓中樓回復處理
      });
    }, 100);
  }

  // 修改顯示推文評論頁面函數，保存當前推文ID
  async function showTweetComments(tweetId) {
    console.log('📖 [首頁推文] 點擊評論按鈕，推文ID:', tweetId);

    // 從forYouTweets或followingTweets中找到對應的推文
    let tweet = forYouTweets.find(t => t.id === tweetId);
    if (!tweet) {
      tweet = followingTweets.find(t => t.id === tweetId);
    }

    if (!tweet) {
      console.error('❌ [首頁推文] 未找到推文:', tweetId);
      showXToast('未找到該推文', 'error');
      return;
    }

    // 使用統一的推文詳情頁面顯示
    await showTweetDetail(tweet);
  }

  // X風格提示框
  function showXToast(message, type = 'success') {
    // 移除現有的提示框
    const existingToast = document.querySelector('.x-toast');
    if (existingToast) {
      existingToast.remove();
    }

    const toast = document.createElement('div');
    toast.className = 'x-toast';
    toast.style.cssText = `
              position: fixed;
              top: 80px;
              left: 50%;
              transform: translateX(-50%);
              background-color: ${type === 'success' ? '#1d9bf0' : '#f4212e'};
              color: #fff;
              padding: 12px 20px;
              border-radius: 20px;
              font-size: 15px;
              font-weight: 600;
              z-index: 1000;
              box-shadow: 0 4px 12px rgba(0,0,0,0.3);
              animation: fadeInOut 3s ease-in-out forwards;
            `;
    toast.textContent = message;

    // 添加淡入淡出動畫
    const style = document.createElement('style');
    style.textContent = `
              @keyframes fadeInOut {
              0 % { opacity: 0; transform: translateX(-50 %) translateY(- 20px); }
            15% {opacity: 1; transform: translateX(-50%) translateY(0); }
            85% {opacity: 1; transform: translateX(-50%) translateY(0); }
            100% {opacity: 0; transform: translateX(-50%) translateY(-20px); }
              }
            `;
    document.head.appendChild(style);
    document.body.appendChild(toast);

    // 3秒後自動移除
    setTimeout(() => {
      if (toast.parentNode) {
        toast.remove();
      }
      if (style.parentNode) {
        style.remove();
      }
    }, 3000);
  }
  // ▼▼▼ 【主要！！！】第一個情景：推文生成器▼▼▼
  async function refreshXTweets() {
    const refreshBtn = document.querySelector('.x-refresh-btn');

    // 添加旋轉動畫
    refreshBtn.style.animation = 'spin 1s linear infinite';
    const spinStyle = document.createElement('style');
    spinStyle.textContent = `
              @keyframes spin {
              from {transform: rotate(0deg); }
            to {transform: rotate(360deg); }
              }
            `;
    document.head.appendChild(spinStyle);

    try {
      // CSV解析函數
      function parseCSVToTweets(csvText) {
        const lines = csvText
          .split('\n')
          .map(line => line.trim())
          .filter(line => line);

        const tweetsData = {
          forYouTweets: [],
          followingTweets: [],
        };

        let currentSection = '';
        let tweetIndex = 0;

        for (const line of lines) {
          if (line.includes('=== 為你推薦 ===')) {
            currentSection = 'forYou';
            tweetIndex = 0;
            continue;
          } else if (line.includes('=== 正在關注 ===')) {
            currentSection = 'following';
            tweetIndex = 0;
            continue;
          }

          // 跳過表頭
          if (line.includes('用戶名,用戶控制碼,用戶頭像,是否認證') || line.includes('評論1用戶名,評論1控制碼')) {
            continue;
          }

          // 解析推文數據行
          if (currentSection && line.includes(',')) {
            const values = line.split(',').map(v => v.trim());

            if (values.length >= 12) {
              // 至少包含基本推文資訊（包括頭像欄位）
              const tweet = {
                id: `${currentSection}_${tweetIndex}`,
                user: {
                  name: values[0] || '匿名使用者',
                  handle: values[1] || '@anonymous',
                  avatar: values[2] || 'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg',
                  verified: values[3] === '是',
                },
                content: values[4] || '',
                time: values[5] || '剛剛',
                media: values[6]
                  ? [
                      {
                        type: 'image',
                        description: values[6],
                        sensitive: values[7] === '是',
                      },
                    ]
                  : [],
                stats: {
                  comments: parseInt(values[8]) || 0,
                  retweets: parseInt(values[9]) || 0,
                  likes: parseInt(values[10]) || 0,
                  views: parseInt(values[11]) || 0,
                },
                comments: [],
              };

              // 解析引用推文資料（如果存在）
              // 檢查引用欄位：索引12-18是引用相關欄位（參考類型、引用用戶名、引用控制碼、引用頭像、引用認證、引用內容、引用時間）
              if (values.length >= 19 && values[12] && values[13] && values[17]) {
                tweet.quotedTweet = {
                  type: values[12] || 'tweet', // 'tweet' 或 'comment'
                  user: {
                    name: values[13] || '引用用戶',
                    handle: values[14] || '@quoted',
                    avatar: values[15] || 'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg',
                    verified: values[16] === '是',
                  },
                  content: values[17] || '',
                  time: values[18] || '剛剛',
                };
              }

              // 統一處理評論解析：所有推文的評論都從索引19開始
              // 無論是否有引用推文，評論欄位的位置都是固定的
              const comments = [];
              const commentStartIndex = 19; // 12個基本欄位 + 7個引用欄位 = 19

              // 從索引19開始，每7個欄位為一個評論：用戶名、控制碼、頭像、認證、內容、時間、回復物件
              let commentIndex = 1;
              let startIndex = commentStartIndex;

              while (startIndex + 6 < values.length) {
                const commentName = values[startIndex];
                const commentHandle = values[startIndex + 1];
                const commentAvatar = values[startIndex + 2];
                const commentVerified = values[startIndex + 3];
                const commentContent = values[startIndex + 4];
                const commentTime = values[startIndex + 5];
                const commentReplyTo = values[startIndex + 6];

                // 檢查評論是否有效（至少需要用戶名、控制碼、內容）
                if (commentName && commentHandle && commentContent) {
                  const newComment = {
                    id: `${tweet.id}_c${commentIndex}`,
                    user: {
                      name: commentName,
                      handle: commentHandle,
                      avatar: commentAvatar || 'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg',
                      verified: commentVerified === '是',
                    },
                    content: commentContent,
                    time: commentTime || '剛剛',
                    replyTo: commentReplyTo || '',
                    replies: [],
                  };

                  // 如果這個評論是回復其他評論，找到被回復的評論並添加為回復
                  if (commentReplyTo) {
                    const targetComment = comments.find(c => c.user.handle === commentReplyTo);
                    if (targetComment) {
                      targetComment.replies.push(newComment);
                    } else {
                      // 如果找不到被回復的評論，作為獨立評論添加
                      comments.push(newComment);
                    }
                  } else {
                    // 獨立評論
                    comments.push(newComment);
                  }

                  commentIndex++;
                } else {
                  // 如果遇到空的評論欄位，停止解析
                  break;
                }

                // 移動到下一個評論的起始位置
                startIndex += 7;
              }

              tweet.comments = comments;

              if (currentSection === 'forYou') {
                tweetsData.forYouTweets.push(tweet);
              } else if (currentSection === 'following') {
                tweetsData.followingTweets.push(tweet);
              }

              tweetIndex++;
            }
          }
        }

        return tweetsData;
      }
      // 從資料庫讀取API配置和X設置
      const db = getDB(); // 用於訪問API配置
      const xDb = getXDB(); // 用於訪問X專用設置

      // 定義X社交頁面需要的API輔助函數
      function toGeminiRequestData(model, apiKey, systemPrompt, messages) {
        const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models';
        return {
          url: `${GEMINI_API_URL}/${model}:generateContent?key=${apiKey}`,
          data: {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              contents: [
                {
                  parts: [
                    {
                      text: systemPrompt + '\n\n' + messages.map(m => m.content).join('\n'),
                    },
                  ],
                },
              ],
            }),
          },
        };
      }

      function getGeminiResponseText(data) {
        if (data.candidates && data.candidates[0] && data.candidates[0].content && data.candidates[0].content.parts) {
          return data.candidates[0].content.parts[0].text || '';
        }
        return '';
      }

      const apiConfig = await db.apiConfig.get('main');
      if (!apiConfig || !apiConfig.proxyUrl || !apiConfig.apiKey || !apiConfig.model) {
        showXToast('請先配置API設置', 'error');
        refreshBtn.style.animation = '';
        return;
      }

      const { proxyUrl, apiKey, model } = apiConfig;

      // 從X設置中讀取配置（按帳號讀取）
      const settingsId = `xSettings_${currentAccountId || 'main'}`;
      const xSettings = await xDb.xSettings.get(settingsId);
      const userPrompt = xSettings?.systemPrompt || '';
      const worldSetting = xSettings?.worldSetting || '';
      const boundCharacters = xSettings?.boundCharacters || [];

      // 讀取綁定的NPC資料（從全域讀取）
      const npcDataId = 'xNPCs_global'; // 全域存儲，所有帳號共用
      const npcData = await xDb.xNPCs.get(npcDataId);
      const allNPCs = npcData?.npcs || [];
      // 過濾出綁定了當前用戶的NPC
      const currentAccount = currentAccountId || 'main';
      const boundNPCs = allNPCs.filter(npc => npc.boundUsers && npc.boundUsers.includes(currentAccount));

      if (boundNPCs.length > 0) {
        console.log(
          `📋 已載入 ${boundNPCs.length} 個綁定NPC:`,
          boundNPCs.map(n => `${n.name}(${n.handle})`).join(', '),
        );
      }

      // 使用工具函數構建使用者X個人資料資訊（使用window.userProfileData確保獲取最新資料）
      const userXProfileInfo = StringBuilders.buildUserXProfileInfo(window.userProfileData);

      // 調試：輸出用戶身份識別設置
      console.log('🎭 綁定角色數量:', boundCharacters.length);
      if (boundCharacters.length > 0) {
        console.log('🎭 綁定角色列表:', boundCharacters);
      }
      console.log('👤 已知身份角色數:', window.userProfileData.knownIdentityCharacters?.length || 0);
      if (window.userProfileData.knownIdentityCharacters?.length > 0) {
        console.log('👤 已知身份角色列表:', window.userProfileData.knownIdentityCharacters);
      }

      // 檢測用戶是否為高曝光身份（明星/網紅等公眾人物）
      const userPublicIdentity = userXProfileInfo.publicIdentity || '';
      const userBio = userXProfileInfo.bio || '';
      const isUserHighExposure =
        /明星|網紅|博主|演員|歌手|藝人|主播|up主|偶像|導演|製片|編劇|作家|influencer|celebrity|singer|actor|artist|streamer|idol/i.test(
          userPublicIdentity + ' ' + userBio,
        );

      // 檢測角色是否為高曝光身份
      const highExposureCharacters = [];
      if (boundCharacters.length > 0) {
        const allXProfiles = await xDb.xCharacterProfiles.toArray();
        for (const charId of boundCharacters) {
          const xProfile = allXProfiles.find(p => p.characterId === charId);
          if (xProfile && xProfile.publicIdentity) {
            const isCharHighExposure =
              /明星|網紅|博主|演員|歌手|藝人|主播|up主|偶像|導演|製片|編劇|作家|influencer|celebrity|singer|actor|artist|streamer|idol/i.test(
                xProfile.publicIdentity,
              );
            if (isCharHighExposure) {
              highExposureCharacters.push({
                characterId: charId,
                xProfile: xProfile,
              });
            }
          }
        }
      }

      console.log('🌟 高曝光身份檢測:', {
        isUserHighExposure,
        highExposureCharactersCount: highExposureCharacters.length,
        highExposureCharactersList: highExposureCharacters.map(c => c.xProfile.xName),
      });

      // 如果有高曝光身份，讀取近期推文
      let recentTweetsContext = '';
      if (isUserHighExposure || highExposureCharacters.length > 0) {
        const userTweetsId = `userTweets_${currentAccountId || 'main'}`;
        const userTweetsData = await xDb.xUserTweets.get(userTweetsId);
        const recentUserTweets = userTweetsData?.tweets?.slice(0, 3) || [];

        if (recentUserTweets.length > 0 || highExposureCharacters.length > 0) {
          recentTweetsContext = `

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🌟 高曝光身份 - 近期推文上下文
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
以下是高曝光身份的公眾人物近期發佈的推文，其他使用者可能會討論這些內容：
`;

          // 添加用戶近期推文
          if (isUserHighExposure && recentUserTweets.length > 0) {
            recentTweetsContext += `
【${userXProfileInfo.name} 的近期推文】（${userXProfileInfo.publicIdentity}）
`;
            recentUserTweets.forEach((tweet, index) => {
              recentTweetsContext += `
${index + 1}. "${tweet.content}"
   - 發佈時間：${tweet.time || '最近'}
   - 互動數據：${tweet.stats?.likes || 0}喜歡，${tweet.stats?.retweets || 0}轉發，${tweet.stats?.comments || 0}評論
`;
            });
          }

          // 添加高曝光角色的近期推文（如果有）
          for (const { xProfile } of highExposureCharacters) {
            recentTweetsContext += `
【${xProfile.xName} 的信息】（${xProfile.publicIdentity}）
- 可能會發佈與其身份相關的推文
- 可能會被其他用戶討論或提及
`;
          }

          recentTweetsContext += `
【高曝光身份推文生成規則】：
- 約20-30%的新推文可以包含對上述推文的討論、轉發、或評論
- 討論應該是其他普通使用者或粉絲的視角，而非本人
- 可以是支援、批評、分析、或單純的轉發評論
- 不要在每條推文中都提及，保持自然和多樣性
- 其餘70-80%的推文應該是與高曝光身份無關的通用熱門內容
- 如果生成討論推文，要體現公眾人物的影響力（較高的互動資料）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;

          console.log('📰 已載入高曝光身份近期推文上下文，用戶推文數:', recentUserTweets.length);
        }
      }

      // Token計數器
      let tokenCount = 0;

      // 0. 時間感知（北京時間）
      const now = new Date();
      const beijingTime = new Date(now.getTime() + 8 * 60 * 60 * 1000); // UTC+8
      const timeInfo = `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
⏰ 時間感知
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
當前北京時間：${beijingTime.toLocaleString('zh-CN', {
        timeZone: 'Asia/Shanghai',
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        weekday: 'long',
      })}

【時間相關提示】：
- 生成的推文時間應該合理（例如：剛剛、1分鐘前、5分鐘前、1小時前、今天 xx:xx等）
- 不要生成未來時間
- 根據當前時間判斷是早晨、中午、下午、晚上、深夜，內容應該符合時段特徵
- 週末/工作日的內容風格可以有所不同
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;

      // 1. 提示詞 + 世界書
      let systemPrompt =
        timeInfo +
        StringBuilders.buildBaseSystemPrompt({
          userPrompt,
          worldSetting,
        });
      tokenCount = TokenUtils.logTokenUsage('推文生成器', '時間感知+基礎系統提示詞', systemPrompt, tokenCount);

      // 1.5. 獲取適用的世界書內容
      const worldBooksContent = await StringBuilders.getApplicableWorldBooks('feed', {
        boundCharacters,
      });
      if (worldBooksContent) {
        systemPrompt += worldBooksContent;
        tokenCount = TokenUtils.logTokenUsage('推文生成器', '世界書內容', worldBooksContent, tokenCount);
      }

      // 2. 角色定義（推文生成專用）
      systemPrompt += `

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 核心任務說明 🎯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
你是X社交平臺的內容生成器。請生成兩組推文資料：
- "為你推薦"頁面（熱門有趣內容）
- "正在關注"頁面（個人生活日常）

**你只負責生成其他用戶的推文，絕不生成用戶本人的推文！**
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【生成要求】：
- 每組生成5-10條推文，內容多樣化
- 熱門推文5-12條評論，普通推文1-5條，支持多層級樓中樓回復
- **綁定角色可以作為推文發佈者**：根據角色設定和興趣發佈獨立推文
- **綁定NPC可以作為推文發佈者**：根據NPC人設和發帖習慣發佈推文
- NPC關係互動：有綁定關係的NPC在角色推文下自然留言，體現關係特點
- 除了綁定角色外，其他用戶頭像統一：https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg
- 引用推文功能：約20-30%的推文可以使用引用功能，適合表達觀點、評論熱點、轉發有趣內容

【情侶關係與粉絲群體規則】：
${
  userXProfileInfo.verificationType === 'couple' && userXProfileInfo.coupleCharacterName
    ? `- **情侶關係自然化**：用戶與${userXProfileInfo.coupleCharacterName}是公開情侶，但這是私人關係
  - 情侶角色可以偶爾出現在推文/評論中，但頻率要低（建議10-20%概率），保持自然
  - 情侶互動應該圍繞推文主題，不要每次都強調情侶身份
  - 粉絲群體判斷：
    * 如果用戶或情侶角色有明星/網紅/公眾人物等身份 → 可以生成少量CP粉絲評論（最多1-2條）
    * 如果都是普通人身份 → 禁止生成"磕CP""嗑糖"等粉絲向評論，普通情侶不會有粉絲群體`
    : '- **普通情侶關係**：如果生成情侶內容，確保只在適合的場景下出現，且不應有粉絲群體'
}`;

      const coreTaskSection = systemPrompt.substring(
        tokenCount > 0 ? systemPrompt.lastIndexOf('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━') : 0,
      );
      tokenCount = TokenUtils.logTokenUsage('推文生成器', '核心任務說明', coreTaskSection, tokenCount);

      // 3. 角色資料（推文發佈場景）
      const charactersInfo = await StringBuilders.buildCompleteCharacterInfo(
        boundCharacters,
        userXProfileInfo,
        'tweet',
      );
      if (charactersInfo) {
        systemPrompt += charactersInfo;
        tokenCount = TokenUtils.logTokenUsage('推文生成器', '角色資料資訊', charactersInfo, tokenCount);
      }

      // 3.3. 角色關係網絡（新增）
      const relationshipsInfo = await StringBuilders.buildCharacterRelationships(
        boundCharacters,
        currentAccountId || 'main',
      );
      if (relationshipsInfo) {
        systemPrompt += relationshipsInfo;
        tokenCount = TokenUtils.logTokenUsage('推文生成器', '角色關係網絡', relationshipsInfo, tokenCount);
        console.log('💞 已載入角色關係網絡信息');
      }

      // 3.5. NPC資料（綁定NPC資訊）
      if (boundNPCs.length > 0) {
        const npcSectionStart = systemPrompt.length;
        systemPrompt += `

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📋 綁定NPC資料
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
以下是與當前用戶綁定的NPC，他們可以在推文生成中作為獨立用戶出現：

`;
        for (const npc of boundNPCs) {
          systemPrompt += `
【NPC基本資訊】
- X姓名：${npc.name}
- X控制碼：${npc.handle}
- X頭像：${npc.avatar}
- 認證狀態：false（NPC默認無認證）

【NPC人設】
${npc.personality || '暫無人設描述'}

【發帖習慣】
${npc.postingHabits || '暫無發帖習慣描述'}

【主頁內容】
${npc.homepage || '暫無主頁內容設置'}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
        }

        systemPrompt += `
【NPC使用規則】：
1. NPC可以作為推文發佈者，生成符合其人設和發帖習慣的推文
2. NPC可以在評論區出現，根據其人設進行互動
3. NPC的內容應該圍繞其人設和主頁內容展開
4. NPC與角色/用戶的互動應該自然，不要過於頻繁
5. 嚴格使用NPC的X姓名(${boundNPCs.map(n => n.name).join('、')})、控制碼(${boundNPCs.map(n => n.handle).join('、')})和頭像
6. NPC認證狀態固定為 false
`;
        const npcSection = systemPrompt.substring(npcSectionStart);
        tokenCount = TokenUtils.logTokenUsage('推文生成器', 'NPC資料資訊', npcSection, tokenCount);
      }

      // 3.7. 高曝光身份近期推文上下文（如果有）
      if (recentTweetsContext) {
        systemPrompt += recentTweetsContext;
        tokenCount = TokenUtils.logTokenUsage('推文生成器', '高曝光身份推文上下文', recentTweetsContext, tokenCount);
      }

      // 4. 使用者資料
      const userConstraintsStart = systemPrompt.length;
      systemPrompt += StringBuilders.buildUniversalConstraints(userXProfileInfo);
      const userConstraints = systemPrompt.substring(userConstraintsStart);
      tokenCount = TokenUtils.logTokenUsage('推文生成器', '使用者資料約束', userConstraints, tokenCount);

      systemPrompt += `

【JSON返回格式】：
\`\`\`json
{"forYouTweets": [推文陣列], "followingTweets": [推文陣列]}
\`\`\`

推文物件結構：
- user: {name, handle, avatar, verified}
- content: 推文文本
- time: 時間描述
- stats: {comments, retweets, likes, views} (純數字)
- media: [{type:"description", description:"文字描述，至少30字"}] (可選)
- quotedTweet: {type, user, content, time} (可選，約20-30%推文使用)
- comments: [評論陣列] (3-8條熱門推文，1-4條普通推文)

評論物件結構：
- user: {name, handle, avatar, verified}
- content: 評論文本
- time: 時間描述  
- replies: [回復陣列] (可選，支持多層級但不超過3層)
- replyTo: "@被回復者控制碼" (樓中樓回復時必填)

關鍵規則：
1. verified欄位必須是布林值(true/false)
2. stats中所有數位必須是純數位，不帶引號
3. 可選欄位不使用時完全省略，不要設為null
4. content直接寫內容，不用引號包裹`;

      const formatSection = systemPrompt.substring(systemPrompt.lastIndexOf('【JSON返回格式】'));
      tokenCount = TokenUtils.logTokenUsage('推文生成器', 'JSON格式要求', formatSection, tokenCount);

      const messages = [{ role: 'user', content: '請生成新的X社交平臺推文資料' }];

      // 最終統計
      TokenUtils.logFinalPrompt('推文生成器', systemPrompt, messages[0].content);

      // 判斷API類型並發送請求
      let isGemini = proxyUrl.includes('generativelanguage');
      let response;

      if (isGemini) {
        // 為X社交頁面創建正確的Gemini請求配置
        const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models';
        const geminiConfig = {
          url: `${GEMINI_API_URL}/${model}:generateContent?key=${getRandomValue(apiKey)}`,
          data: {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              contents: [
                {
                  parts: [
                    {
                      text: systemPrompt + '\n\n' + messages.map(m => m.content).join('\n'),
                    },
                  ],
                },
              ],
              generationConfig: {
                temperature: 0.8,
              },
            }),
          },
        };
        response = await fetch(geminiConfig.url, geminiConfig.data);
      } else {
        const openAiPayload = {
          model: model,
          messages: [{ role: 'system', content: systemPrompt }, ...messages],
          temperature: 0.8,
          stream: false,
        };
        response = await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${apiKey}`,
          },
          body: JSON.stringify(openAiPayload),
        });
      }

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(`API錯誤: ${response.status} - ${errorData.error?.message || response.statusText}`);
      }

      const data = await response.json();
      let aiResponseContent;

      if (isGemini) {
        aiResponseContent = getGeminiResponseText(data);
      } else {
        // OpenAI格式
        aiResponseContent = data.choices?.[0]?.message?.content || '';
      }

      console.log('AI原始回應:', aiResponseContent);

      // 解析AI返回的JSON資料
      const cleanedResponse = aiResponseContent
        .replace(/```json\s*/i, '')
        .replace(/```\s*$/, '')
        .trim();

      if (!cleanedResponse) {
        throw new Error('AI返回了空的回應內容');
      }

      let newTweetsData;
      try {
        newTweetsData = JSON.parse(cleanedResponse);
      } catch (parseError) {
        console.error('JSON解析失敗:', parseError);
        console.error('嘗試解析的內容:', cleanedResponse.substring(0, 500) + '...');
        throw new Error(`AI返回的資料不是有效的JSON格式: ${parseError.message}`);
      }

      // 🚫 篩選用戶身份冒用（最優先）
      newTweetsData = StringBuilders.filterUserImpersonation(
        newTweetsData,
        userXProfileInfo.handle,
        userXProfileInfo.name,
      );

      // 🔧 強制修正所有頭像
      await StringBuilders.enforceAvatarRules(newTweetsData, userXProfileInfo.handle);

      // 驗證資料格式
      if (!newTweetsData.forYouTweets || !newTweetsData.followingTweets) {
        throw new Error('AI返回的資料格式不正確，缺少必要欄位');
      }

      // 為推文添加必要的ID和格式化
      const processTweets = tweets => {
        return tweets.map(tweet => {
          // 確保stats欄位存在
          if (!tweet.stats) {
            tweet.stats = {
              comments: tweet.comments?.length || 0,
              retweets: 0,
              likes: 0,
              views: 0,
            };
          }

          // 處理評論資料，添加ID
          if (tweet.comments) {
            tweet.comments = tweet.comments.map(comment => {
              const processedComment = {
                ...comment,
                id: `c_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
              };

              // 處理回復資料
              if (comment.replies) {
                processedComment.replies = comment.replies.map(reply => ({
                  ...reply,
                  id: `r_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                }));
              }

              return processedComment;
            });
          }

          return tweet;
        });
      };

      newTweetsData.forYouTweets = processTweets(newTweetsData.forYouTweets);
      newTweetsData.followingTweets = processTweets(newTweetsData.followingTweets);

      // 為推文分配ID和時間戳記
      const timestamp = Date.now();
      newTweetsData.forYouTweets.forEach((tweet, index) => {
        tweet.id = `fy_${timestamp}_${index}`;
        tweet.createdAt = timestamp; // 添加創建時間戳記用於動態時間計算
      });

      newTweetsData.followingTweets.forEach((tweet, index) => {
        tweet.id = `fl_${timestamp}_${index}`;
        tweet.createdAt = timestamp; // 添加創建時間戳記用於動態時間計算
      });

      // 🔧 推進模式：在現有推文前面添加新推文，而不是覆蓋
      forYouTweets.unshift(...newTweetsData.forYouTweets);
      followingTweets.unshift(...newTweetsData.followingTweets);

      // 限制推文總數，避免資料過多（保留最新的50條）
      if (forYouTweets.length > 50) {
        forYouTweets.splice(50);
      }
      if (followingTweets.length > 50) {
        followingTweets.splice(50);
      }

      // 保存推文資料到資料庫
      try {
        await xDb.xTweetsData.put({
          id: 'tweets',
          forYouTweets: newTweetsData.forYouTweets,
          followingTweets: newTweetsData.followingTweets,
          lastUpdated: new Date().toISOString(),
        });
      } catch (saveError) {
        console.error('保存推文資料失敗:', saveError);
      }

      // 檢查是否有人@用戶
      const userHandle = userXProfileInfo.handle;
      let mentionFound = false;

      // 檢查"為你推薦"中的推文和評論
      for (const tweet of newTweetsData.forYouTweets) {
        if (tweet.content && tweet.content.includes(userHandle)) {
          mentionFound = true;
          break;
        }
        if (tweet.comments) {
          for (const comment of tweet.comments) {
            if (comment.content && comment.content.includes(userHandle)) {
              mentionFound = true;
              break;
            }

            // 檢查回復中的內容
            if (comment.replies) {
              for (const reply of comment.replies) {
                if (reply.content && reply.content.includes(userHandle)) {
                  mentionFound = true;
                  break;
                }
              }
            }
            if (mentionFound) break;
          }
        }
        if (mentionFound) break;
      }

      // 檢查"正在關注"中的推文和評論
      if (!mentionFound) {
        for (const tweet of newTweetsData.followingTweets) {
          if (tweet.content && tweet.content.includes(userHandle)) {
            mentionFound = true;
            break;
          }
          if (tweet.comments) {
            for (const comment of tweet.comments) {
              if (comment.content && comment.content.includes(userHandle)) {
                mentionFound = true;
                break;
              }
              // 檢查回復中的內容
              if (comment.replies) {
                for (const reply of comment.replies) {
                  if (reply.content && reply.content.includes(userHandle)) {
                    mentionFound = true;
                    break;
                  }
                }
              }
              if (mentionFound) break;
            }
          }
          if (mentionFound) break;
        }
      }

      // 標記新推文（用於動畫效果）
      newTweetsData.forYouTweets.forEach(tweet => {
        tweet.isNew = true;
      });
      newTweetsData.followingTweets.forEach(tweet => {
        tweet.isNew = true;
      });

      // 重新渲染頁面
      renderTweets(forYouTweets, 'for-you-content');
      renderTweets(followingTweets, 'following-content');

      // 顯示相應的提醒消息
      const isEnglish = currentLanguage === 'en';
      const userAvatar = window.userProfileData?.avatar || 'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg';

      if (mentionFound) {
        showPhoneNotification({
          title: 'X',
          message: isEnglish
            ? 'Your feed has been refreshed! Someone mentioned you 🔔'
            : '你的首頁已刷新！有人提到你了哦 🔔',
          avatar: userAvatar,
          leftIcon: 'x',
        });
      } else {
        showPhoneNotification({
          title: 'X',
          message: isEnglish ? 'Your feed has been refreshed!' : '你的首頁已刷新！',
          avatar: userAvatar,
          leftIcon: 'x',
        });
      }
    } catch (error) {
      console.error('刷新推文失敗:', error);
      showXToast(`刷新失敗: ${error.message}`, 'error');
    } finally {
      // 停止旋轉動畫
      refreshBtn.style.animation = '';
      if (spinStyle.parentNode) {
        spinStyle.remove();
      }
    }
  }
  // ▲▲▲ 【主要！！！】第一個情景：推文生成器 ▲▲▲

  // ============================================
  // 底部巡覽列提醒點管理
  // ============================================

  // 顯示提醒點
  function showNavNotificationDot(page) {
    const dotId = `${page}-notification-dot`;
    const dot = document.getElementById(dotId);
    if (dot) {
      dot.style.display = 'block';
      console.log(`✨ 顯示${page}提醒點`);
    }
  }

  // 隱藏提醒點
  function hideNavNotificationDot(page) {
    const dotId = `${page}-notification-dot`;
    const dot = document.getElementById(dotId);
    if (dot) {
      dot.style.display = 'none';
      console.log(`✅ 清除${page}提醒點`);
    }
  }

  // 將函數暴露到全域
  window.showNavNotificationDot = showNavNotificationDot;
  window.hideNavNotificationDot = hideNavNotificationDot;

  // ============================================
  // 智慧刷新主頁服務管理
  // ============================================
  let autoRefreshFeedTimer = null;
  let autoRefreshFeedEnabled = false;
  const REFRESH_INTERVAL = 10 * 60 * 1000; // 10分鐘

  // 開關智慧刷新主頁服務
  window.toggleAutoRefreshFeed = async function () {
    autoRefreshFeedEnabled = !autoRefreshFeedEnabled;

    const toggle = document.getElementById('auto-refresh-feed-toggle');
    const circle = toggle.querySelector('.toggle-circle');
    const statusDiv = document.getElementById('auto-refresh-feed-status');

    if (autoRefreshFeedEnabled) {
      // 開啟刷新
      toggle.style.backgroundColor = 'var(--x-accent)';
      circle.style.left = '22px';
      statusDiv.style.display = 'block';

      // 啟動計時器
      startAutoRefreshFeedTimer();

      // 保存狀態
      await saveAutoRefreshFeedState(true);

      const isEnglish = currentLanguage === 'en';
      showXToast(isEnglish ? 'Auto refresh enabled' : '智能刷新已開啟', 'success');
    } else {
      // 關閉刷新
      toggle.style.backgroundColor = '#333';
      circle.style.left = '2px';
      statusDiv.style.display = 'none';

      // 停止計時器
      if (autoRefreshFeedTimer) {
        clearInterval(autoRefreshFeedTimer);
        autoRefreshFeedTimer = null;
      }

      // 保存狀態
      await saveAutoRefreshFeedState(false);

      const isEnglish = currentLanguage === 'en';
      showXToast(isEnglish ? 'Auto refresh disabled' : '智能刷新已關閉', 'info');
    }
  };

  // 啟動計時器
  function startAutoRefreshFeedTimer() {
    if (autoRefreshFeedTimer) {
      clearInterval(autoRefreshFeedTimer);
    }

    autoRefreshFeedTimer = setInterval(async () => {
      await runAutoRefresh();
    }, REFRESH_INTERVAL);

    updateNextRefreshTime();
  }

  // 執行自動刷新
  async function runAutoRefresh() {
    try {
      console.log('⏰ [智慧刷新] 開始自動刷新主頁推文...');
      await refreshXTweets();
      updateNextRefreshTime();

      // 顯示主頁提醒點（如果用戶不在主頁）
      const currentPage = document.querySelector('.x-page[style*="display: flex"]');
      const isOnHomePage = currentPage && currentPage.id === 'x-home-page';
      if (!isOnHomePage) {
        showNavNotificationDot('home');
      }

      console.log('✅ [智慧刷新] 刷新完成');
    } catch (error) {
      console.error('❌ [智慧刷新] 自動刷新失敗:', error);
    }
  }

  // 更新下次刷新時間顯示
  function updateNextRefreshTime() {
    const nextTime = new Date(Date.now() + REFRESH_INTERVAL);
    const timeStr = `${nextTime.getHours().toString().padStart(2, '0')}:${nextTime
      .getMinutes()
      .toString()
      .padStart(2, '0')}`;
    const timeSpan = document.getElementById('next-refresh-time');
    if (timeSpan) {
      timeSpan.textContent = timeStr;
    }
  }

  // 保存刷新狀態
  async function saveAutoRefreshFeedState(enabled) {
    try {
      const xDb = getXDB();
      const settingsId = `xSettings_${currentAccountId || 'main'}`;
      let settings = await xDb.xSettings.get(settingsId);

      if (!settings) {
        settings = {
          id: settingsId,
          autoRefreshFeedEnabled: enabled,
          updatedAt: new Date().toISOString(),
        };
      } else {
        settings.autoRefreshFeedEnabled = enabled;
        settings.updatedAt = new Date().toISOString();
      }

      await xDb.xSettings.put(settings);
      console.log(`💾 [智慧刷新] 狀態已保存: ${enabled ? '開啟' : '關閉'}`);
    } catch (error) {
      console.error('保存刷新狀態失敗:', error);
    }
  }

  // 恢復刷新狀態（在初始化時調用）
  async function restoreAutoRefreshFeedState() {
    try {
      const xDb = getXDB();
      const settingsId = `xSettings_${currentAccountId || 'main'}`;
      const settings = await xDb.xSettings.get(settingsId);

      if (settings && settings.autoRefreshFeedEnabled) {
        console.log('🔄 [智慧刷新] 檢測到已保存的開啟狀態，正在恢復...');
        // 延遲1秒後啟動，確保UI已載入
        setTimeout(() => {
          const toggle = document.getElementById('auto-refresh-feed-toggle');
          if (toggle) {
            autoRefreshFeedEnabled = false; // 先設為false，讓toggle函數切換
            window.toggleAutoRefreshFeed();
          }
        }, 1000);
      } else {
        console.log('ℹ️ [智慧刷新] 未檢測到開啟狀態，保持關閉');
      }
    } catch (error) {
      console.error('恢復刷新狀態失敗:', error);
    }
  }

  // ▼▼▼ 【主要！！！】第七個情景：帳戶主頁生成器 ▼▼▼
  // 當前查看的帳戶資料
  let currentViewingAccount = null;

  // 推進模式狀態
  let isProgressMode = false;
  let progressLongPressTimer = null;

  // 計算兩個字串的相似度（0-1之間，1表示完全相同）- 帳戶主頁生成器專用
  function calculateSimilarity(str1, str2) {
    if (str1 === str2) return 1;
    if (str1.length === 0 || str2.length === 0) return 0;

    // 使用最長公共子序列（LCS）演算法的簡化版本
    const longer = str1.length > str2.length ? str1 : str2;
    const shorter = str1.length > str2.length ? str2 : str1;

    // 計算字元匹配度
    let matches = 0;
    const shorterChars = shorter.split('');
    const longerChars = longer.split('');

    shorterChars.forEach(char => {
      const index = longerChars.indexOf(char);
      if (index !== -1) {
        matches++;
        longerChars.splice(index, 1); // 移除已匹配的字元，避免重複計數
      }
    });

    // 相似度 = 匹配字元數 / 較長字串長度
    const similarity = matches / longer.length;

    // 額外檢測：如果較短字串完全包含在較長字串中，提高相似度
    if (longer.includes(shorter)) {
      return Math.max(similarity, shorter.length / longer.length);
    }

    return similarity;
  }

  // 打開帳戶主頁
  window.openAccountProfile = async function (accountName, accountHandle, accountAvatar, sourceContext = {}) {
    try {
      console.log(`🔍 正在打開帳戶主頁: ${accountName} (${accountHandle})`);
      console.log('📍 來源資訊:', sourceContext);

      // 先檢查資料庫中是否有已保存的帳戶主頁數據
      const xDB = getXDB();
      const cleanHandle = accountHandle.replace('@', '');
      const savedProfile = await xDB.xAccountProfiles.get(cleanHandle);

      if (savedProfile) {
        console.log('✅ 找到已保存的帳戶主頁數據');

        // 🔄 檢查是否是角色帳戶，如果是則同步最新的X資料資訊
        const characterProfile = await xDB.xCharacterProfiles.toArray();
        const matchedCharacter = characterProfile.find(
          cp => cp.xHandle === accountHandle || cp.xHandle === `@${cleanHandle}`,
        );

        if (matchedCharacter) {
          console.log('🔄 [帳戶主頁] 檢測到角色帳戶，同步最新X資料');

          // 判斷認證類型
          let verificationType = 'verified';
          if (
            window.userProfileData.verificationType === 'couple' &&
            window.userProfileData.coupleCharacterId === matchedCharacter.characterId
          ) {
            verificationType = 'couple';
          }

          // 更新帳戶基本資訊為最新的X資料
          savedProfile.accountInfo = {
            ...savedProfile.accountInfo,
            name: matchedCharacter.xName,
            handle: matchedCharacter.xHandle,
            avatar: matchedCharacter.xAvatar,
            verified: matchedCharacter.xVerified,
            verificationType: matchedCharacter.xVerified ? verificationType : 'none',
            cover:
              matchedCharacter.xCover ||
              savedProfile.accountInfo.cover ||
              'https://i.postimg.cc/tT8Rfsf1/mmexport1759603246385.jpg',
            bio: matchedCharacter.xBio || '',
            publicIdentity: matchedCharacter.publicIdentity || '',
            customTag1: matchedCharacter.customTag1 || null,
            customTag2: matchedCharacter.customTag2 || null,
            followingCount: matchedCharacter.followingCount || savedProfile.accountInfo.followingCount || '',
            followersCount: matchedCharacter.followersCount || savedProfile.accountInfo.followersCount || '',
          };

          // 同步更新所有推文、評論、回復中的使用者資訊
          const updateUserInfo = user => {
            if (user && user.handle === matchedCharacter.xHandle) {
              user.name = matchedCharacter.xName;
              user.avatar = matchedCharacter.xAvatar;
              user.verified = matchedCharacter.xVerified;
              user.verificationType = matchedCharacter.xVerified ? verificationType : 'none';
            }
          };

          // 更新推文中的使用者資訊
          if (savedProfile.tweets) {
            savedProfile.tweets.forEach(tweet => {
              updateUserInfo(tweet.user);
              // 更新推文評論中的使用者資訊
              if (tweet.comments) {
                tweet.comments.forEach(comment => {
                  updateUserInfo(comment.user);
                  // 更新樓中樓回復
                  if (comment.replies) {
                    comment.replies.forEach(reply => updateUserInfo(reply.user));
                  }
                });
              }
            });
          }

          // 更新回復記錄中的使用者資訊
          if (savedProfile.accountReplies) {
            savedProfile.accountReplies.forEach(reply => {
              if (reply.accountReply) {
                updateUserInfo(reply.accountReply.user);
              }
            });
          }

          // 保存更新後的資料
          savedProfile.updatedAt = new Date().toISOString();
          await xDB.xAccountProfiles.put(savedProfile);
          console.log('✅ [帳戶主頁] 已同步最新X資料資訊');
        }

        // 🆕 重新讀取X平臺私信記憶（即使是已保存的資料，私信記憶也要即時讀取）
        console.log('🔄 [帳戶主頁] 重新讀取X平臺私信記憶');
        savedProfile.xMessageHistory = await StringBuilders._loadXMessageHistory(accountHandle);
        if (savedProfile.xMessageHistory && savedProfile.xMessageHistory.length > 0) {
          console.log(`✅ [帳戶主頁] 重新讀取到 ${savedProfile.xMessageHistory.length} 條私信記憶`);
        } else {
          console.log('ℹ️ [帳戶主頁] 該帳戶暫無私信記憶');
        }

        console.log('📊 [帳戶主頁] 載入資料統計:', {
          推文數: savedProfile.tweets?.length || 0,
          回復數: savedProfile.accountReplies?.length || 0,
          喜歡數: savedProfile.accountLikes?.length || 0,
          私信數: savedProfile.xMessageHistory?.length || 0,
        });
        currentViewingAccount = savedProfile;
        renderAccountProfile(savedProfile);
        return;
      }

      // 如果沒有保存的資料，查詢帳戶資料（傳遞現有資料）
      const accountData = await queryAccountData(accountName, accountHandle, accountAvatar, sourceContext.existingInfo);

      if (!accountData) {
        showXToast('無法載入帳戶資訊', 'error');
        return;
      }

      // 保存當前查看的帳戶（附加來源上下文）
      currentViewingAccount = { ...accountData, sourceContext };

      // 如果有完整的主頁數據，直接顯示
      if (accountData.tweets && accountData.tweets.length > 0) {
        renderAccountProfile(accountData);
        return;
      }

      // 否則，調用AI生成帳戶主頁內容
      showXToast('正在生成帳戶主頁...', 'info');
      const profileData = await generateAccountProfileContent(accountData, { sourceContext });

      if (profileData) {
        // 更新帳戶資料
        currentViewingAccount = { ...accountData, ...profileData };
        console.log('📊 [帳戶主頁] 新生成資料統計:', {
          推文數: profileData.tweets?.length || 0,
          回復數: profileData.accountReplies?.length || 0,
          喜歡數: profileData.accountLikes?.length || 0,
        });
        renderAccountProfile(currentViewingAccount);

        // 保存到資料庫
        await saveAccountProfile(currentViewingAccount);
        showXToast('帳戶主頁已生成並保存', 'success');
      }
    } catch (error) {
      console.error('打開帳戶主頁失敗:', error);
      showXToast(`載入失敗: ${error.message}`, 'error');
    }
  };

  // 查詢帳戶資料（判斷是角色/NPC/未知帳戶）
  // 🎯 已優化：使用統一資料獲取系統
  async function queryAccountData(accountName, accountHandle, accountAvatar, existingInfo = {}) {
    console.log(`🔍 [帳戶查詢] 查詢帳戶: ${accountName} (${accountHandle})`);

    // 使用統一資料獲取系統
    const profile = await StringBuilders.getUnifiedProfile(accountHandle, {
      userProfileInfo: window.userProfileData, // 傳遞使用者資料以檢查身份識別
      includeRecentTweets: false, // 不需要推文，主頁生成器會單獨獲取
      includeRelationships: true,
    });

    if (!profile) {
      // 未找到帳戶，返回未知帳戶
      console.log('⚠️ 未知帳戶，將根據基本資訊生成:', accountName);

      const unknownAccountData = {
        accountType: 'unknown',
        name: accountName,
        handle: accountHandle,
        avatar: accountAvatar,
        verified: existingInfo.verified !== undefined ? existingInfo.verified : false,
        cover: 'https://i.postimg.cc/tT8Rfsf1/mmexport1759603246385.jpg',
        bio: existingInfo.bio || '',
        publicIdentity: '',
        customTag1: null,
        customTag2: null,
        followingCount: '',
        followersCount: existingInfo.followersCount || '',
      };

      if (existingInfo.bio || existingInfo.followersCount) {
        console.log('✅ 使用來自私信的現有資料:', {
          bio: existingInfo.bio,
          followersCount: existingInfo.followersCount,
          verified: existingInfo.verified,
        });
      }

      return unknownAccountData;
    }

    // 根據帳戶類型返回對應的資料結構
    console.log(`✅ 識別為 ${profile.type} 帳戶:`, profile.name, `(${profile.handle})`);

    // 🆕 統一提取X平臺私信記憶（所有帳戶類型通用）
    let xMessageHistory = [];
    if (profile.type === 'character' && profile.characterData?.xMessageHistory) {
      xMessageHistory = profile.characterData.xMessageHistory;
    } else if (profile.type === 'account' && profile.accountData?.xMessageHistory) {
      xMessageHistory = profile.accountData.xMessageHistory;
    } else if (profile.type === 'npc' && profile.npcData?.xMessageHistory) {
      xMessageHistory = profile.npcData.xMessageHistory;
    } else if (profile.type === 'relationshipNpc' && profile.relationshipData?.xMessageHistory) {
      xMessageHistory = profile.relationshipData.xMessageHistory;
    } else if (profile.type === 'stranger' && profile.accountData?.xMessageHistory) {
      xMessageHistory = profile.accountData.xMessageHistory;
    }

    if (xMessageHistory.length > 0) {
      console.log(`✅ [帳戶查詢] 提取到 ${xMessageHistory.length} 條X平臺私信記憶`);
    }

    if (profile.type === 'character') {
      // 角色帳戶
      // 判斷認證類型：檢查該角色是否是使用者的情侶認證物件
      let verificationType = 'verified'; // 默認為普通認證
      if (
        window.userProfileData.verificationType === 'couple' &&
        window.userProfileData.coupleCharacterId === profile.characterId
      ) {
        verificationType = 'couple'; // 情侶認證
      }

      return {
        accountType: 'character',
        name: profile.name,
        handle: profile.handle,
        avatar: profile.avatar,
        verified: profile.verified,
        verificationType: profile.verified ? verificationType : 'none',
        cover: profile.xProfile.xCover || 'https://i.postimg.cc/tT8Rfsf1/mmexport1759603246385.jpg',
        bio: profile.bio,
        publicIdentity: profile.publicIdentity,
        customTag1: profile.xProfile.customTag1 || null,
        customTag2: profile.xProfile.customTag2 || null,
        followingCount: profile.xProfile.followingCount || '',
        followersCount: profile.xProfile.followersCount || '',
        personality: profile.characterData.aiPersona || '',
        characterData: profile.character,
        xProfileData: profile.xProfile,
        characterId: profile.characterId,
        xMessageHistory: xMessageHistory, // 🆕 統一欄位
      };
    } else if (profile.type === 'npc') {
      // NPC帳戶
      return {
        accountType: 'npc',
        name: profile.npc.name,
        handle: profile.npc.handle,
        avatar: profile.npc.avatar,
        verified: false,
        cover: 'https://i.postimg.cc/tT8Rfsf1/mmexport1759603246385.jpg',
        bio: '',
        publicIdentity: '',
        customTag1: null,
        customTag2: null,
        followingCount: '',
        followersCount: '',
        personality: profile.npc.personality || '',
        postingHabits: profile.npc.postingHabits || '',
        homepage: profile.npc.homepage || '',
        npcData: profile.npc,
        xMessageHistory: xMessageHistory, // 🆕 統一欄位
      };
    } else if (profile.type === 'relationshipNpc') {
      // 關係NPC帳戶
      return {
        accountType: 'relationshipNpc',
        name: profile.relationship.npcName,
        handle: profile.relationship.npcHandle,
        avatar: accountAvatar || 'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg',
        verified: false,
        cover: 'https://i.postimg.cc/tT8Rfsf1/mmexport1759603246385.jpg',
        bio: '',
        publicIdentity: '',
        customTag1: null,
        customTag2: null,
        followingCount: '',
        followersCount: '',
        relationshipType: profile.relationship.relationshipType,
        relationshipDescription: profile.relationship.description || '',
        ownerCharacterId: profile.ownerCharacter.id,
        ownerCharacterName: profile.ownerCharacter.name,
        ownerXProfile: profile.ownerXProfile,
        relationshipData: profile.relationship,
        xMessageHistory: xMessageHistory, // 🆕 統一欄位
      };
    } else if (profile.type === 'account') {
      // X帳戶（來自xAccountProfiles）
      return {
        accountType: 'account',
        name: profile.accountInfo.name,
        handle: profile.accountInfo.handle,
        avatar: profile.accountInfo.avatar,
        verified: profile.accountInfo.verified || false,
        verificationType: profile.accountInfo.verificationType || 'none',
        cover: profile.accountInfo.cover || 'https://i.postimg.cc/tT8Rfsf1/mmexport1759603246385.jpg',
        bio: profile.accountInfo.bio || '',
        publicIdentity: profile.accountInfo.publicIdentity || '',
        customTag1: profile.accountInfo.customTag1 || null,
        customTag2: profile.accountInfo.customTag2 || null,
        followingCount: profile.accountInfo.followingCount || '',
        followersCount: profile.accountInfo.followersCount || '',
        accountInfo: profile.accountInfo,
        xMessageHistory: xMessageHistory, // 🆕 統一欄位
      };
    }

    // 兜底：返回未知帳戶
    return {
      accountType: 'unknown',
      name: accountName,
      handle: accountHandle,
      avatar: accountAvatar,
      verified: false,
      cover: 'https://i.postimg.cc/tT8Rfsf1/mmexport1759603246385.jpg',
      bio: '',
      publicIdentity: '',
      customTag1: null,
      customTag2: null,
      followingCount: '',
      followersCount: '',
    };
  }

  // 調用AI生成帳戶主頁內容
  async function generateAccountProfileContent(accountData, options = {}) {
    try {
      const { isProgressMode = false, existingTweets = [], existingReplies = [], sourceContext = {} } = options;

      const db = getDB();
      const xDb = getXDB();

      // 獲取API配置
      const apiConfig = await db.apiConfig.get('main');
      if (!apiConfig || !apiConfig.proxyUrl || !apiConfig.apiKey || !apiConfig.model) {
        showXToast('請先配置API設置', 'error');
        return null;
      }

      const { proxyUrl, apiKey, model } = apiConfig;

      // 獲取X設置
      const settingsId = `xSettings_${currentAccountId || 'main'}`;
      const xSettings = await xDb.xSettings.get(settingsId);
      const userPrompt = xSettings?.systemPrompt || '';
      const worldSetting = xSettings?.worldSetting || '';

      // 構建使用者X資料資訊
      const userXProfileInfo = StringBuilders.buildUserXProfileInfo(window.userProfileData);

      // Token計數器
      let tokenCount = 0;

      // ▼▼▼ 構建SystemPrompt ▼▼▼
      // 1. 提示詞 + 世界書
      let systemPrompt = StringBuilders.buildBaseSystemPrompt({ userPrompt, worldSetting });
      tokenCount = TokenUtils.logTokenUsage('帳戶主頁生成器', '基礎系統提示詞', systemPrompt, tokenCount);

      // 1.5. 獲取適用的世界書內容（如果是角色帳戶，傳入角色ID）
      const worldBooksOptions = { boundCharacters: [] };
      if (accountData.accountType === 'character' && accountData.characterId) {
        worldBooksOptions.boundCharacters = [accountData.characterId];
      }
      const worldBooksContent = await StringBuilders.getApplicableWorldBooks('profile', worldBooksOptions);
      if (worldBooksContent) {
        systemPrompt += worldBooksContent;
        tokenCount = TokenUtils.logTokenUsage('帳戶主頁生成器', '世界書內容', worldBooksContent, tokenCount);
      }

      // 2. 核心任務說明
      if (isProgressMode) {
        systemPrompt += `

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 核心任務：推進帳戶主頁內容 🎯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
你需要為X平臺帳戶生成**新的**主頁展示內容，包括：
- **新的**推文（3-4條，必須與已有內容完全不同）
- **新的**回復互動（2-3條，必須與已有回復完全不同）

⚠️⚠️⚠️ 【絕對禁止重複】⚠️⚠️⚠️
- 已有的推文和回復會在下方完整展示
- 新推文的內容、話題、觀點必須與已有推文**完全不同**
- 新回復必須是全新的互動物件和內容
- 絕對不允許出現相同或高度相似的表達

**推進模式生成策略**：
- 帳戶基本資訊已固定，不需要生成
- 新推文應展現不同的話題維度或新的生活動態
- 可以是時間流逝後的新話題、新想法、新事件
- 新推文的時間應該比已有推文更新
- 嚴格遵循帳戶已有的風格和人設，但內容必須全新
- **禁止生成置頂推文**：所有新推文的 pinned 欄位必須設置為 false 或不設置
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
      } else {
        systemPrompt += `

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 核心任務：生成帳戶主頁內容 🎯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
你需要為X平臺帳戶生成主頁展示內容，包括：
- 帳戶基本資訊（若已提供則嚴格使用，不可修改）
- 最近發佈的推文（3-5條）
- 推文下的評論互動

**生成原則**：
- 如果是已知角色帳戶，必須嚴格遵循其X資料設定
- 如果是NPC帳戶，必須嚴格遵循其人設和發帖習慣
- 如果是角色關係NPC帳戶，必須體現與所屬角色的關係特點，遵循關係設定
- 如果是未知帳戶，根據昵稱、控制碼、簡介進行合理推斷
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
      }

      // 3. 目標帳戶資訊
      systemPrompt += `

【目標帳戶資訊】：
- X姓名：${accountData.name}
- X控制碼：${accountData.handle}
- X頭像：${accountData.avatar}
- 認證狀態：${accountData.verified ? '是' : '否'}
${
  accountData.verified
    ? `- 認證類型：${
        accountData.verificationType === 'couple'
          ? '情侶認證（心形圖示）'
          : accountData.verificationType === 'verified'
          ? '普通認證（藍色勾標）'
          : '普通認證（藍色勾標）'
      }`
    : ''
}
${accountData.bio ? `- X簡介：${accountData.bio}` : ''}
${accountData.publicIdentity ? `- 公眾身份：${accountData.publicIdentity}` : ''}
${accountData.personality ? `- 人設描述：${accountData.personality}` : ''}
${accountData.postingHabits ? `- 發帖習慣：${accountData.postingHabits}` : ''}
${accountData.cover ? `- 背景圖：${accountData.cover}` : ''}
${
  accountData.customTag1
    ? `- 自訂標籤1：${accountData.customTag1.icon} ${accountData.customTag1.text} (${accountData.customTag1.color})`
    : ''
}
${
  accountData.customTag2
    ? `- 自訂標籤2：${accountData.customTag2.icon} ${accountData.customTag2.text} (${accountData.customTag2.color})`
    : ''
}
${accountData.followingCount ? `- 正在關注：${accountData.followingCount}` : ''}
${accountData.followersCount ? `- 關注者：${accountData.followersCount}` : ''}
`;

      // 3.5. 添加帳戶來源上下文（如果有）
      if (sourceContext && sourceContext.source) {
        systemPrompt += `

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
【帳戶來源上下文】
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
        if (sourceContext.source === 'feed') {
          systemPrompt += `來源：首頁推文
該帳戶發佈的內容：
"${sourceContext.tweetContent}"
${
  sourceContext.tweetMedia && sourceContext.tweetMedia.length > 0
    ? `媒體內容：${sourceContext.tweetMedia[0].description}\n`
    : ''
}- 發佈時間：${sourceContext.tweetTime}
- 互動數據：${sourceContext.tweetStats?.comments || 0}評論，${sourceContext.tweetStats?.likes || 0}喜歡，${
            sourceContext.tweetStats?.retweets || 0
          }轉發

**生成要求**：
- 基於該帳戶發佈的內容，推斷其興趣、話題偏好和發帖風格
- 生成的主頁推文應該與這條推文風格一致
- 可以生成主題相關但不重複的推文內容`;
        } else if (sourceContext.source === 'comment') {
          systemPrompt += `來源：評論區
該帳戶發表的評論：
"${sourceContext.commentContent}"
${
  sourceContext.commentImage
    ? `評論圖片：${
        sourceContext.commentImage.type === 'description' ? sourceContext.commentImage.content : '包含圖片'
      }\n`
    : ''
}- 發佈時間：${sourceContext.commentTime}
${sourceContext.replyTo ? `- 回復對象：${sourceContext.replyTo}\n` : ''}
**生成要求**：
- 基於該帳戶發表的評論，推斷其互動風格和表達習慣
- 生成的主頁推文應該體現類似的表達方式和興趣點
- 主頁推文可以與評論主題相關，但要展現更完整的個人特色`;
        } else if (sourceContext.source === 'search') {
          systemPrompt += `來源：搜索結果
搜索關鍵字："${sourceContext.searchQuery}"
該帳戶在搜索結果中的資訊：
- 昵稱：${accountData.name}
- 控制碼：${accountData.handle}
${sourceContext.userBio ? `- 簡介：${sourceContext.userBio}\n` : ''}- 認證狀態：${
            sourceContext.verified ? '已認證' : '未認證'
          }

**生成要求**：
- 基於搜索關鍵字和帳戶基本資訊，推斷帳戶特點和內容方向
- 生成的推文應該與搜索關鍵字"${sourceContext.searchQuery}"有一定相關性
- 確保帳戶特點與簡介、昵稱、控制碼相符`;
        } else if (sourceContext.source === 'dm' || sourceContext.source === 'dm_quote_profile') {
          const sourceName = sourceContext.source === 'dm' ? '私信詳情頁' : '私信中的帳戶名片';
          systemPrompt += `來源：${sourceName}
該帳戶的已知資訊：
- 昵稱：${accountData.name}
- 控制碼：${accountData.handle}
${accountData.bio ? `- 簡介：${accountData.bio}\n` : ''}${
            accountData.followersCount ? `- 關注者：${accountData.followersCount}\n` : ''
          }- 認證狀態：${accountData.verified ? '已認證' : '未認證'}
${sourceContext.messagePreview ? `- 私信預覽："${sourceContext.messagePreview}"\n` : ''}
**生成要求**：
- ${accountData.bio ? '已有簡介，必須嚴格使用，不可修改' : '需要生成符合該帳戶特點的簡介'}
- ${
            accountData.followersCount
              ? `已有關注者數量(${accountData.followersCount})，必須使用，不可修改`
              : '需要生成合理的關注者數量（100-5000之間）'
          }
- 生成的推文內容要與已有資訊（簡介、私信內容等）保持一致
- 確保帳戶形象真實可信，符合其在私信中展現的特點`;
        }
        systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
        const contextSection = systemPrompt.substring(systemPrompt.lastIndexOf('【帳戶來源上下文】'));
        tokenCount = TokenUtils.logTokenUsage('帳戶主頁生成器', '帳戶來源上下文', contextSection, tokenCount);
      }

      // 4. 帳戶類型特定要求
      if (accountData.accountType === 'character') {
        systemPrompt += `

【角色帳戶特殊要求】：
- **嚴格遵守**：所有已提供的X資料資訊必須完全一致，不得修改
- 推文內容要符合角色人設和性格特點
- 評論互動要體現角色的社交風格
- 如有NPC關係，可在推文/評論中自然體現`;
      } else if (accountData.accountType === 'npc') {
        systemPrompt += `

【NPC帳戶特殊要求】：
- **嚴格遵守**：使用NPC的姓名、控制碼、頭像、人設
- 推文內容符合NPC的發帖習慣和主頁內容設置
- 評論互動符合NPC的性格特點`;
      } else if (accountData.accountType === 'relationshipNpc') {
        systemPrompt += `

【角色關係NPC帳戶特殊要求】：
- **嚴格遵守**：使用NPC的姓名（${accountData.name}）和控制碼（${accountData.handle}）
- 該NPC與角色 ${accountData.ownerCharacterName} (${accountData.ownerXProfile.xName} - ${
          accountData.ownerXProfile.xHandle
        }) 的關係：${accountData.relationshipType}
${accountData.relationshipDescription ? `- 關係描述：${accountData.relationshipDescription}` : ''}
- 推文內容應體現這種關係特點，可能會提及或艾特 ${accountData.ownerXProfile.xHandle}
- 生成的推文和互動要符合該NPC與角色的關係設定
- 評論區可能出現 ${accountData.ownerXProfile.xName} 的互動，要體現兩者的關係
- 如未提供bio、關注者數等資訊，由AI根據NPC特點和關係合理補充`;
      } else {
        systemPrompt += `

【未知帳戶生成要求】：
- 根據提供的昵稱、控制碼、簡介推斷帳戶特點
- 生成合理的推文內容和互動風格
- 保持帳戶身份的一致性`;
      }

      const accountInfoSection = systemPrompt.substring(systemPrompt.indexOf('【目標帳戶資訊】'));
      tokenCount = TokenUtils.logTokenUsage('帳戶主頁生成器', '帳戶資訊與要求', accountInfoSection, tokenCount);

      // 4.3. 如果是關係NPC帳戶，添加所屬角色的詳細資料
      if (accountData.accountType === 'relationshipNpc' && accountData.ownerCharacterId) {
        const mainDB = getDB();
        const allChats = await mainDB.chats.toArray();
        const ownerCharacter = allChats.find(c => c.id === accountData.ownerCharacterId);
        const ownerXProfile = accountData.ownerXProfile;

        if (ownerCharacter && ownerXProfile) {
          let ownerInfo = `

【所屬角色詳細資料】（該NPC的關係物件）：
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
- 角色本名：${ownerCharacter.name}
- 角色人設：${ownerCharacter.settings.aiPersona || '無特定人設'}
- X平臺身份（必須嚴格使用）：
  * X用戶名：${ownerXProfile.xName}
  * X控制碼：${ownerXProfile.xHandle}
  * X頭像：${ownerXProfile.xAvatar}
  * 認證狀態：${ownerXProfile.xVerified ? '是' : '否'}`;
          if (ownerXProfile.xBio) ownerInfo += `\n  * X簡介：${ownerXProfile.xBio}`;
          if (ownerXProfile.publicIdentity) ownerInfo += `\n  * 公眾身份：${ownerXProfile.publicIdentity}`;

          ownerInfo += `

- 該NPC（${accountData.name}）與角色（${ownerXProfile.xName}）的關係：${accountData.relationshipType}
${accountData.relationshipDescription ? `- 關係詳情：${accountData.relationshipDescription}` : ''}

【關係互動要求】：
- 推文內容應自然體現與 ${ownerXProfile.xName} (${ownerXProfile.xHandle}) 的關係
- ${ownerXProfile.xName} 可能在評論區出現，互動要符合雙方關係設定
- 必須嚴格使用 ${ownerXProfile.xName} 的X平臺身份資訊
- 可以提及或艾特 ${ownerXProfile.xHandle}，但不要過度頻繁
- 保持該NPC獨立的個性，不要完全依附於角色
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;

          systemPrompt += ownerInfo;
          tokenCount = TokenUtils.logTokenUsage('帳戶主頁生成器', '關係NPC-所屬角色資料', ownerInfo, tokenCount);

          // 如果所屬角色有NPC關係列表，也要載入
          if (ownerXProfile.relationships && ownerXProfile.relationships.length > 0) {
            let otherNpcsInfo = `

【所屬角色的其他NPC關係】（可能在互動中出現）：
`;
            ownerXProfile.relationships.forEach(rel => {
              // 跳過當前NPC自己
              if (rel.npcHandle !== accountData.handle) {
                otherNpcsInfo += `
- ${rel.npcName} (${rel.npcHandle}): ${rel.relationshipType}`;
                if (rel.description) otherNpcsInfo += ` - ${rel.description}`;
              }
            });

            otherNpcsInfo += `

注意：這些NPC也可能出現在評論區，要體現各自與 ${ownerXProfile.xName} 的關係特點。
`;
            systemPrompt += otherNpcsInfo;
            tokenCount = TokenUtils.logTokenUsage('帳戶主頁生成器', '關係NPC-其他NPC關係', otherNpcsInfo, tokenCount);
          }

          // 如果所屬角色有角色關係網絡，也要載入
          const ownerRelationshipsInfo = await StringBuilders.buildCharacterRelationships(
            [accountData.ownerCharacterId],
            currentAccountId || 'main',
          );

          if (ownerRelationshipsInfo) {
            systemPrompt += `

【所屬角色的角色關係網絡】（可能在互動中出現）：
${ownerRelationshipsInfo}
`;
            tokenCount = TokenUtils.logTokenUsage(
              '帳戶主頁生成器',
              '關係NPC-角色關係網絡',
              ownerRelationshipsInfo,
              tokenCount,
            );
          }
        }
      }

      // 4.4. 如果是角色帳戶，添加角色關係網絡和關係角色的詳細資料
      if (accountData.accountType === 'character' && accountData.characterId) {
        const relationshipsInfo = await StringBuilders.buildCharacterRelationships(
          [accountData.characterId],
          currentAccountId || 'main',
        );

        if (relationshipsInfo) {
          systemPrompt += relationshipsInfo;
          tokenCount = TokenUtils.logTokenUsage('帳戶主頁生成器', '角色關係網絡', relationshipsInfo, tokenCount);

          // 獲取關係網絡中涉及的其他角色的完整資料
          try {
            const mainDB = getDB();
            const currentAccount = currentAccountId || 'main';
            const dataId = `xCharacterRelationships_${currentAccount}`;

            const relationshipRecord = await xDb.xCharacterRelationships.get(dataId);
            if (relationshipRecord && relationshipRecord.data) {
              const links = relationshipRecord.data.links || [];
              const relatedCharacterIds = new Set();

              // 收集所有關係中的其他角色ID
              links.forEach(link => {
                if (link.charA === accountData.characterId) {
                  relatedCharacterIds.add(link.charB);
                } else if (link.charB === accountData.characterId) {
                  relatedCharacterIds.add(link.charA);
                }
              });

              if (relatedCharacterIds.size > 0) {
                const allChats = await mainDB.chats.toArray();
                const allXProfiles = await xDb.xCharacterProfiles.toArray();

                let relatedCharsInfo = `

【關係角色詳細資料】（可能出現在評論或互動中的角色）：
`;

                for (const charId of relatedCharacterIds) {
                  const charData = allChats.find(c => c.id === charId);
                  const xProfile = allXProfiles.find(p => p.characterId === charId);

                  if (charData && xProfile) {
                    relatedCharsInfo += `
- 角色名：${charData.name}
  人設：${charData.settings.aiPersona || '無特定人設'}
  X平臺身份（必須嚴格使用）：
    - X用戶名：${xProfile.xName}
    - X控制碼：${xProfile.xHandle}
    - X頭像：${xProfile.xAvatar}
    - 認證狀態：${xProfile.xVerified ? '是' : '否'}`;
                    if (xProfile.xBio) relatedCharsInfo += `\n    - X簡介：${xProfile.xBio}`;
                    if (xProfile.publicIdentity) relatedCharsInfo += `\n    - 公眾身份：${xProfile.publicIdentity}`;
                    relatedCharsInfo += `\n`;
                  }
                }

                relatedCharsInfo += `
【關係角色互動要求】：
- 關係角色可能在推文評論或回復中出現，體現彼此的關係
- 必須嚴格使用上述X平臺身份資訊（xName、xHandle、xAvatar等）
- 互動內容要符合角色人設和關係設定
- 保持各角色身份的一致性和準確性
`;

                systemPrompt += relatedCharsInfo;
                tokenCount = TokenUtils.logTokenUsage(
                  '帳戶主頁生成器',
                  '關係角色詳細資料',
                  relatedCharsInfo,
                  tokenCount,
                );
              }
            }
          } catch (error) {
            console.error('獲取關係角色詳細資料失敗:', error);
          }
        }
      }

      // 4.6. 如果是推進模式，添加現有內容作為上下文
      if (isProgressMode && (existingTweets.length > 0 || existingReplies.length > 0)) {
        systemPrompt += `

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
【已有內容上下文】- 絕對禁止重複以下內容
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

⚠️ 以下是該帳戶的所有已有推文和回復，生成新內容時必須**完全避開**這些話題和表達：

**已有推文（共${existingTweets.length}條）**：
`;
        // 顯示所有已有推文，不再限制數量
        existingTweets.forEach((tweet, index) => {
          systemPrompt += `
${index + 1}. "${tweet.content}" 
   - 時間：${tweet.time}
   - 互動：${tweet.stats.comments || 0}評論，${tweet.stats.likes || 0}喜歡
${tweet.media && tweet.media.length > 0 ? `   - 媒體：${tweet.media[0].description}\n` : ''}`;
        });

        if (existingReplies.length > 0) {
          systemPrompt += `

**已有回復（共${existingReplies.length}條）**：
`;
          // 顯示所有已有回復
          existingReplies.forEach((reply, index) => {
            systemPrompt += `
${index + 1}. 回復了${reply.type === 'tweet' ? '推文' : '評論'}: "${reply.accountReply.content}"
   - 時間：${reply.accountReply.time}`;
          });
        }

        systemPrompt += `

🚫🚫🚫 【重複檢測清單】🚫🚫🚫
- 上述${existingTweets.length}條推文的內容、話題、觀點都已被使用
- 新推文必須是**全新的話題**或**不同角度的觀點**
- 不要生成任何與上述內容相似度超過30%的推文
- 時間設置必須比最新推文（${existingTweets[0]?.time || '未知'}）更新
- 保持風格一致，但內容必須創新

**新內容生成方向建議**：
- 探索完全不同的生活話題或興趣領域
- 展現不同時間段的新想法或新發現
- 基於人設生成全新角度的內容
- 避免重複已有推文的關鍵字和主題
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;

        const existingContentSection = systemPrompt.substring(systemPrompt.indexOf('【已有內容上下文】'));
        tokenCount = TokenUtils.logTokenUsage('帳戶主頁生成器', '已有內容上下文', existingContentSection, tokenCount);
      }

      // 5. 身份約束與禁令（統一結構，分情況處理）
      const userConstraintsStart = systemPrompt.length;

      // 5.1 首先明確當前正在生成的帳戶身份
      systemPrompt += `

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 當前生成帳戶
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
正在生成：${accountData.name} (${accountData.handle}) 的帳戶主頁
帳戶類型：${
        accountData.accountType === 'character'
          ? '角色帳戶'
          : accountData.accountType === 'npc'
          ? 'NPC帳戶'
          : accountData.accountType === 'relationshipNpc'
          ? `角色關係NPC帳戶（與 ${accountData.ownerCharacterName} 的關係NPC）`
          : '未知帳戶'
      }
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;

      // 5.2 根據帳戶類型和身份識別情況，提供相關身份資訊
      if (accountData.accountType === 'character' && accountData.characterId) {
        // 角色帳戶：檢查是否知道用戶身份
        const knowsUserIdentity = userXProfileInfo.knownIdentityCharacters.includes(accountData.characterId);

        if (knowsUserIdentity) {
          // 情況A：角色知道使用者 → 提供使用者X資料 + 角色專屬使用者人設 + 用戶近期推文
          const knowsUserStart = systemPrompt.length;
          const verificationDesc =
            {
              verified: '藍色勾標認證',
              couple: '情侶認證',
              married: '已婚認證',
              vip: 'VIP認證',
            }[userXProfileInfo.verificationType] || '無認證';

          const hasUserPersona = accountData.xProfileData?.userPersona && accountData.xProfileData.userPersona.trim();

          systemPrompt += `

【使用者身份資訊】該角色認識使用者
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
使用者X平臺資料（僅供參考，嚴禁假扮）：
- 用戶名：${userXProfileInfo.name}
- 用戶控制碼：${userXProfileInfo.handle}
- 認證狀態：${verificationDesc}
${userXProfileInfo.publicIdentity ? `- 公眾身份：${userXProfileInfo.publicIdentity}` : ''}
${userXProfileInfo.bio ? `- 個人簡介：${userXProfileInfo.bio}` : ''}
`;

          // 讀取用戶的最近5條推文
          try {
            const userTweetsId = `userTweets_${currentAccountId || 'main'}`;
            const userTweetsData = await xDb.xUserTweets.get(userTweetsId);
            const recentUserTweets = userTweetsData?.tweets?.slice(0, 5) || [];

            if (recentUserTweets.length > 0) {
              systemPrompt += `
用戶近期推文（${recentUserTweets.length}條）：
`;
              recentUserTweets.forEach((tweet, index) => {
                systemPrompt += `
${index + 1}. "${tweet.content}"
   - 時間：${tweet.time || '最近'}
   - 互動：${tweet.stats?.likes || 0}喜歡，${tweet.stats?.retweets || 0}轉發，${tweet.stats?.comments || 0}評論
${
  tweet.image
    ? `   - 媒體：${tweet.image.type === 'description' ? tweet.image.content.substring(0, 50) + '...' : '包含圖片'}\n`
    : ''
}`;
              });
            }
          } catch (error) {
            console.warn('讀取用戶推文失敗:', error);
          }

          systemPrompt += `

該角色瞭解的使用者資訊：
${
  hasUserPersona
    ? accountData.xProfileData.userPersona
    : '⚠️ 未設置用戶人設 - 該角色只知道使用者的基本X平臺資訊（上述資料），不瞭解使用者的私人資訊、性格特點或兩者之間的具體關係。'
}

🚫 【關鍵約束】
${
  hasUserPersona
    ? `- 該角色可以在推文中提及或艾特用戶 ${userXProfileInfo.handle}，也可以討論用戶的推文
- 但評論區不能出現用戶 ${userXProfileInfo.name} (${userXProfileInfo.handle}) 的發言
- 所有評論必須是虛構的普通用戶，不得使用用戶的名稱或控制碼`
    : `- 該角色可以在推文中提及用戶 ${userXProfileInfo.handle}（基於基本認識），也可以討論使用者的推文
- 但不要捏造或推斷兩者的具體關係（如情侶、伴侶、家人等）
- 評論區絕對禁止出現用戶 ${userXProfileInfo.name} (${userXProfileInfo.handle}) 的發言
- 所有評論必須是虛構的普通用戶，不得使用用戶的名稱或控制碼
- ⚠️ 重要：未設置用戶人設意味著不能假設兩者有特殊關係`
}
- ${accountData.name} 和 ${userXProfileInfo.name} 是兩個完全獨立的不同個體
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;

          const knowsUserInfo = systemPrompt.substring(knowsUserStart);
          tokenCount = TokenUtils.logTokenUsage('帳戶主頁生成器', '角色認識使用者-資料與推文', knowsUserInfo, tokenCount);
        } else {
          // 情況B：角色不知道使用者 → 只提供使用者X平臺公開資料
          systemPrompt += `

【使用者身份資訊】該角色不認識使用者
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
使用者X平臺公開資料（僅供參考，禁止假扮）：
- 用戶名：${userXProfileInfo.name}
- 用戶控制碼：${userXProfileInfo.handle}
${userXProfileInfo.publicIdentity ? `- 公眾身份：${userXProfileInfo.publicIdentity}` : ''}

身份關係：
- ${accountData.name} 不知道用戶的真實身份
- ${accountData.name} 和 ${userXProfileInfo.name} 是完全獨立的不同個體
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
        }
      } else {
        // 非角色帳戶（NPC/未知）：檢測是否提及用戶或角色的X昵稱和控制碼
        const accountTexts = [
          accountData.name || '', // 帳戶昵稱
          accountData.handle || '', // 帳戶控制碼
          accountData.bio || '', // 帳戶簡介
          accountData.publicIdentity || '',
          accountData.personality || '',
          accountData.postingHabits || '',
          accountData.homepage || '',
        ].join(' ');

        // 檢測是否提及用戶的X昵稱或控制碼
        const mentionsUser =
          accountTexts.includes(userXProfileInfo.name) || // 用戶X昵稱
          accountTexts.includes(userXProfileInfo.handle) || // 用戶控制碼（含@）
          accountTexts.includes(userXProfileInfo.handle.replace('@', '')); // 用戶控制碼（不含@）

        // 檢測是否提及角色的X昵稱或控制碼
        const mainDB = getDB();
        const allChats = await mainDB.chats.toArray();
        const allXProfiles = await xDb.xCharacterProfiles.toArray();
        const mentionedCharacters = [];

        for (const xProfile of allXProfiles) {
          // 只基於X平臺的昵稱和控制碼進行匹配
          if (
            accountTexts.includes(xProfile.xName) || // 角色X昵稱
            accountTexts.includes(xProfile.xHandle) || // 角色控制碼（含@）
            accountTexts.includes(xProfile.xHandle.replace('@', '')) // 角色控制碼（不含@）
          ) {
            const character = allChats.find(c => c.id === xProfile.characterId);
            if (character) {
              mentionedCharacters.push({ character, xProfile });
            }
          }
        }

        if (mentionsUser || mentionedCharacters.length > 0) {
          // 情況C：帳戶資料提及使用者/角色 → 提供X平臺公開資料 + 近期推文
          const mentionedInfoStart = systemPrompt.length;
          systemPrompt += `

【提及的身份資訊】該帳戶資料提及以下身份
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;

          if (mentionsUser) {
            const verificationDesc =
              {
                verified: '藍色勾標認證',
                couple: '情侶認證',
                married: '已婚認證',
                vip: 'VIP認證',
              }[userXProfileInfo.verificationType] || '無認證';

            systemPrompt += `
使用者X平臺公開資料（僅供參考，禁止假扮）：
- 用戶名：${userXProfileInfo.name}
- 用戶控制碼：${userXProfileInfo.handle}
- 認證狀態：${verificationDesc}
${userXProfileInfo.publicIdentity ? `- 公眾身份：${userXProfileInfo.publicIdentity}` : ''}
${userXProfileInfo.bio ? `- 個人簡介：${userXProfileInfo.bio}` : ''}
`;

            // 讀取用戶的最近5條推文
            try {
              const userTweetsId = `userTweets_${currentAccountId || 'main'}`;
              const userTweetsData = await xDb.xUserTweets.get(userTweetsId);
              const recentUserTweets = userTweetsData?.tweets?.slice(0, 5) || [];

              if (recentUserTweets.length > 0) {
                systemPrompt += `
用戶近期推文（${recentUserTweets.length}條）：
`;
                recentUserTweets.forEach((tweet, index) => {
                  systemPrompt += `
${index + 1}. "${tweet.content}"
   - 時間：${tweet.time || '最近'}
   - 互動：${tweet.stats?.likes || 0}喜歡，${tweet.stats?.retweets || 0}轉發，${tweet.stats?.comments || 0}評論
${
  tweet.image
    ? `   - 媒體：${tweet.image.type === 'description' ? tweet.image.content.substring(0, 50) + '...' : '包含圖片'}\n`
    : ''
}`;
                });
              }
            } catch (error) {
              console.warn('讀取用戶推文失敗:', error);
            }
          }

          if (mentionedCharacters.length > 0) {
            systemPrompt += `
提及的角色X平臺資料（僅供參考，禁止假扮）：
`;
            for (const { character, xProfile } of mentionedCharacters) {
              systemPrompt += `
- ${character.name} - X身份：${xProfile.xName} (${xProfile.xHandle})
  ${xProfile.publicIdentity ? `公眾身份：${xProfile.publicIdentity}` : ''}
  ${xProfile.xBio ? `簡介：${xProfile.xBio}` : ''}
`;

              // 讀取角色的最近5條推文（從角色的帳戶主頁數據中）
              try {
                const cleanCharHandle = xProfile.xHandle.replace('@', '');
                const charAccountProfile = await xDb.xAccountProfiles.get(cleanCharHandle);
                const recentCharTweets = charAccountProfile?.tweets?.slice(0, 5) || [];

                if (recentCharTweets.length > 0) {
                  systemPrompt += `
  ${xProfile.xName} 的近期推文（${recentCharTweets.length}條）：
`;
                  recentCharTweets.forEach((tweet, index) => {
                    systemPrompt += `
  ${index + 1}. "${tweet.content}"
     - 時間：${tweet.time || '最近'}
     - 互動：${tweet.stats?.likes || 0}喜歡，${tweet.stats?.retweets || 0}轉發
${
  tweet.media && tweet.media.length > 0 ? `     - 媒體：${tweet.media[0].description.substring(0, 50) + '...'}\n` : ''
}`;
                  });
                }
              } catch (error) {
                console.warn(`讀取角色 ${xProfile.xName} 的推文失敗:`, error);
              }
            }
          }

          systemPrompt += `
互動說明：
- ${accountData.name} 可以討論或評論上述身份和他們的推文內容
- 可以基於上述推文內容生成相關的互動或回應
- 但 ${accountData.name} 不是上述任何身份，是獨立的個體
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;

          const mentionedInfo = systemPrompt.substring(mentionedInfoStart);
          tokenCount = TokenUtils.logTokenUsage('帳戶主頁生成器', '提及身份資訊與推文', mentionedInfo, tokenCount);
        } else {
          // 情況D：完全無關的陌生帳戶 → 只提供最基本的用戶身份
          systemPrompt += `

【使用者身份資訊】無關聯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
使用者基本標識（僅供參考，禁止假扮）：
- 用戶名：${userXProfileInfo.name}
- 用戶控制碼：${userXProfileInfo.handle}

身份關係：
- ${accountData.name} 與用戶無任何關聯
- ${accountData.name} 和 ${userXProfileInfo.name} 是完全獨立的不同個體
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
        }
      }

      // 5.2.5 🆕 統一添加X平臺私信記憶（所有帳戶類型通用）
      if (accountData.xMessageHistory && accountData.xMessageHistory.length > 0) {
        const xMessageSectionStart = systemPrompt.length;
        console.log(`📝 [帳戶主頁生成器] 開始處理私信記憶，總數: ${accountData.xMessageHistory.length} 條`);
        systemPrompt += `

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
【X平臺私信記憶】（該帳戶與使用者的私信對話記錄）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
        const recentXMessages = accountData.xMessageHistory.slice(-50);
        let xMemCount = 0;
        for (const msg of recentXMessages) {
          const sender = msg.isOwn ? '用戶' : accountData.name;
          let content = '';

          if (msg.type === 'text') {
            content = msg.content;
          } else if (msg.type === 'image') {
            content = msg.isOwn ? '[使用者發送了圖片]' : `[圖片: ${msg.imageDescription || '圖片'}]`;
          } else if (msg.type === 'voice') {
            content = `[語音: ${msg.voiceText || '語音訊息'}]`;
          } else if (msg.type === 'sticker') {
            content = '[表情包]';
          } else if (msg.type === 'transfer') {
            const amount = msg.amount ? `$${msg.amount}` : '';
            const note = msg.note ? ` (${msg.note})` : '';
            content = `[轉帳${amount}${note}]`;
          } else if (msg.type === 'link') {
            content = `[分享連結: ${msg.title || '連結'}]`;
          } else if (msg.type === 'quoteTweet') {
            content = `[轉發推文: ${msg.tweet?.content || ''}]`;
          } else if (msg.type === 'quoteProfile') {
            content = `[分享主頁: ${msg.profile?.name || ''}]`;
          } else {
            content = `[${msg.type}消息]`;
          }

          if (content) {
            const displayContent = content.length > 80 ? `${content.substring(0, 80)}...` : content;
            systemPrompt += `${sender}: ${displayContent}\n`;
            xMemCount++;
          }

          if (xMemCount >= 50) break;
        }
        systemPrompt += `
⚠️ 重要說明：
- 這些是在X平臺私信功能中的真實對話記錄
- 無論帳戶類型（角色/NPC/陌生人），這些對話都是客觀存在的
- 生成帳戶主頁時，可以基於這些互動記錄展現關係和溝通風格
- 不要在公開推文中直接提及私密的私信內容
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
        const xMessageSection = systemPrompt.substring(xMessageSectionStart);
        const xMessageTokens = TokenUtils.estimateTokens(xMessageSection);
        console.log(
          `📊 [私信] ${
            accountData.accountType === 'character' ? '角色' : accountData.accountType === 'npc' ? 'NPC' : '帳戶'
          } ${accountData.name}: ${xMemCount}條, ~${xMessageTokens} tokens`,
        );
        tokenCount = TokenUtils.logTokenUsage('帳戶主頁生成器', 'X平臺私信記憶', xMessageSection, tokenCount);
      } else {
        console.log(`ℹ️ [帳戶主頁生成器] 該帳戶無私信記憶資料`);
      }

      // 5.3 統一的核心禁令（所有情況共用）
      systemPrompt += `

🚫🚫🚫 核心禁令（最高優先順序）🚫🚫🚫
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
【絕對禁止】假扮使用者發佈任何內容！

身份識別：
當前帳戶：${accountData.name} (${accountData.handle})
用戶帳戶：${userXProfileInfo.name} (${userXProfileInfo.handle})
⚠️ 這是兩個完全不同的獨立個體！

生成規則：
✅ 可以生成：${accountData.name} (${accountData.handle}) 發佈的推文/評論/回復
✅ 可以生成：虛構的普通X平臺用戶（自創用戶名和控制碼）
❌ 絕對禁止：以 ${userXProfileInfo.name} (${userXProfileInfo.handle}) 的身份發佈任何內容
❌ 絕對禁止：在 user.name 或 user.handle 欄位中使用用戶的名稱或控制碼

⚠️ 重要提醒：
所有推文的 user 欄位必須是 ${accountData.name} (${accountData.handle})
所有評論的 user 欄位必須是虛構用戶（不得是 ${userXProfileInfo.name} 或 ${userXProfileInfo.handle}）${
        accountData.accountType === 'relationshipNpc'
          ? `
特殊說明：該NPC與 ${accountData.ownerXProfile.xName} (${accountData.ownerXProfile.xHandle}) 有關係，
評論區可以出現 ${accountData.ownerXProfile.xName} 的互動，但必須嚴格使用其X平臺身份資訊`
          : ''
      }
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;

      const userConstraints = systemPrompt.substring(userConstraintsStart);
      tokenCount = TokenUtils.logTokenUsage('帳戶主頁生成器', '身份約束與核心禁令', userConstraints, tokenCount);

      // 6. JSON返回格式
      if (isProgressMode) {
        systemPrompt += `

【JSON返回格式】：
\`\`\`json
{"tweets": [推文陣列], "accountReplies": [回復陣列], "accountLikes": [喜歡陣列]}
\`\`\`

**注意**：推進模式下不需要返回accountInfo，只需返回新的推文、回復和喜歡`;
      } else {
        systemPrompt += `

【JSON返回格式】：
\`\`\`json
{"accountInfo": {...}, "tweets": [推文陣列], "accountReplies": [回復陣列], "accountLikes": [喜歡陣列]}
\`\`\`

accountInfo物件結構：
- name, handle, avatar, verified (已提供的必須完全一致)
- verificationType: ${
          accountData.verified
            ? `"${accountData.verificationType || 'verified'}" (必須使用此值，不可修改)`
            : '"none" (不可修改)'
        }
- cover: 可補充
- bio: ${accountData.bio ? `"${accountData.bio}" (已提供，必須使用此值，不可修改)` : '可補充'}
- customTag1/2: {icon, text, color} (可選)
- followingCount: 可補充
- followersCount: ${
          accountData.followersCount ? `"${accountData.followersCount}" (已提供，必須使用此值，不可修改)` : '可補充'
        }`;
      }

      systemPrompt += `

tweets陣列（3-5條）：
- user: {name, handle, avatar, verified, verificationType}
- content: 推文文本
- time: 時間描述
- stats: {comments, retweets, likes, views} (純數字)
- media: [{type:"description", description:"圖片描述，至少20字"}] (可選)
- comments: [評論陣列] (1-5條，必須生成，10-20%的評論可帶圖)
- pinned: true/false (可選，第一條推文可置頂，顯示"已置頂"標識)

評論物件結構（重要）：
- id: 評論唯一ID（可留空，系統自動生成）
- user: {name, handle, avatar, verified}
- content: 評論文本
- timeOffset: 相對推文發佈的分鐘數（負數，如-5表示推文發佈後5分鐘的評論）
- image: {type: "description", content: "圖片文字描述"} (可選，10-20%的評論帶圖，用於展示圖片視頻等媒體)
- replies: [樓中樓回復陣列] (可選，0-2條)

樓中樓回復物件結構：
- id: 回復唯一ID（可留空，系統自動生成）
- user: {name, handle, avatar, verified}
- content: 回復文本
- timeOffset: 相對推文發佈的分鐘數（負數，如-10表示推文發佈後10分鐘的回復）
- image: {type: "description", content: "圖片文字描述"} (可選，少量回復可帶圖)
- replyTo: "@被回復者控制碼" (必填)

accountReplies陣列（2-4條，帳戶的回復記錄）：
🚨 重要：每條回復都必須包含完整的三部分資料結構

結構說明：
- type: "tweet" | "comment" (回復推文或回復評論)
- originalTweet: 原始推文對象（🚨必填！無論type是什麼）
  {
    user: {name, handle, avatar, verified},
    content: "推文內容",
    time: "時間描述",
    stats: {comments: 數字, retweets: 數字, likes: 數字, views: 數字},
    media: [{type:"description", description:"圖片描述"}] //可選
  }
- originalComment: 原始評論對象（⚠️僅當type="comment"時必填）
  {
    user: {name, handle, avatar, verified},
    content: "評論內容",
    time: "時間描述"
  }
- accountReply: 帳戶的回復物件（🚨必填！）
  {
    user: {name, handle, avatar, verified}, //必須使用目標帳戶資訊
    content: "回復內容",
    time: "時間描述",
    stats: {comments: 數字, retweets: 數字, likes: 數字, views: 數字}
  }

📋 示例1（回復推文）：
{
  "type": "tweet",
  "originalTweet": {完整推文對象},
  "accountReply": {帳戶回復物件}
}

📋 示例2（回復評論）：
{
  "type": "comment",
  "originalTweet": {完整推文物件}, ← 必須提供！評論所屬的推文
  "originalComment": {完整評論物件}, ← 必須提供！被回復的評論
  "accountReply": {帳戶回復物件}
}

accountLikes陣列（3-5條，帳戶喜歡的推文）：
- user: {name, handle, avatar, verified, verificationType}
- content: 推文文本
- time: 時間描述
- stats: {comments, retweets, likes, views} (純數字)
- media: [{type:"description", description:"圖片描述"}] (可選，30-40%的推文可帶媒體)
- comments: [評論陣列] (1-3條即可，比主頁推文評論少一些)

📋 喜歡推文示例：
{
  "user": {
    "name": "某用戶",
    "handle": "@someuser",
    "avatar": "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg",
    "verified": false
  },
  "content": "推文內容",
  "time": "2小時",
  "stats": {
    "comments": 45,
    "retweets": 128,
    "likes": 892,
    "views": 12400
  },
  "comments": [...]
}

⚠️ accountLikes特殊要求：
- 喜歡的推文來自其他用戶，不是帳戶自己的推文
- 推文內容應該與帳戶的興趣、身份、人設相關
- 如果是角色帳戶，喜歡的內容要符合角色性格
- 如果是關係NPC，可以喜歡所屬角色的推文
- 推文的互動資料應該合理（likes數應該較高，因為值得被喜歡）
- 時間描述應該是相對時間（如"3小時"、"昨天"、"2天"等）

關鍵規則：
1. accountInfo已提供欄位必須與輸入完全一致，不得修改
2. 未提供欄位由AI合理補充
3. verified必須是布林值(true/false)
4. 如果該帳戶在角色X資料或NPC設置中標注為情侶關係，必須設置verificationType為"couple"
5. ${
        isProgressMode
          ? '**禁止生成置頂推文**：所有推文的 pinned 必須為 false 或不設置'
          : '建議將最重要或最新的一條推文設置為pinned: true（置頂）'
      }
6. stats所有數位必須是純數位，不帶引號
7. 每條推文必須包含1-5條評論，評論內容要與推文相關
8. 評論可以包含樓中樓回復（replies陣列），形成對話鏈
9. 🚨 accountReplies必須生成2-4條，每條都必須包含完整資料：
   - type="tweet": 必須有 originalTweet + accountReply
   - type="comment": 必須有 originalTweet + originalComment + accountReply（三個都要！）
10. accountReplies中的accountReply.user必須使用目標帳戶的資訊
11. 🚨 accountLikes必須生成3-5條，每條都是完整的推文對象：
   - 必須包含user、content、time、stats欄位
   - user不能是目標帳戶本人（帳戶不能喜歡自己的推文）
   - 推文內容要與帳戶興趣相關，體現帳戶的品味和關注點
12. 除了角色和npc以外所有帳號都使用統一頭像：https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg
13. 默認背景圖：https://i.postimg.cc/tT8Rfsf1/mmexport1759603246385.jpg
14. 🚫 **禁止假扮用戶**：絕對不可在user欄位使用 ${userXProfileInfo.name} 或 ${
        userXProfileInfo.handle
      }，這是用戶身份，不可假扮
15. ${
        accountData.accountType === 'character'
          ? `🚫 **嚴禁自創角色關係**：除非明確提供的關係資訊，不要讓目標角色(${accountData.name})在推文/評論中聲稱與其他角色有特殊關係（如情侶、家人等）。所有評論者必須是虛構用戶，不要使用其他已知角色的身份。`
          : accountData.accountType === 'relationshipNpc'
          ? `✅ **關係NPC互動規則**：該NPC與 ${accountData.ownerXProfile.xName} (${accountData.ownerXProfile.xHandle}) 有 ${accountData.relationshipType} 關係。評論區可以出現 ${accountData.ownerXProfile.xName} 的互動，必須嚴格使用其X平臺身份資訊。其他評論者應為虛構用戶。`
          : '評論者應為虛構的普通用戶，保持身份的獨立性'
      }`;

      const formatSection = systemPrompt.substring(systemPrompt.lastIndexOf('【JSON返回格式】'));
      tokenCount = TokenUtils.logTokenUsage('帳戶主頁生成器', 'JSON格式要求', formatSection, tokenCount);

      // ▲▲▲ 構建SystemPrompt ▲▲▲

      const messages = [{ role: 'user', content: `請生成帳戶 ${accountData.name} (${accountData.handle}) 的主頁內容` }];

      // 最終統計
      TokenUtils.logFinalPrompt('帳戶主頁生成器', systemPrompt, messages[0].content);

      // 判斷API類型並發送請求
      let isGemini = proxyUrl.includes('generativelanguage');
      let response;

      try {
        if (isGemini) {
          const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models';
          const geminiConfig = {
            url: `${GEMINI_API_URL}/${model}:generateContent?key=${getRandomValue(apiKey)}`,
            data: {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                contents: [
                  {
                    parts: [
                      {
                        text: systemPrompt + '\n\n' + messages.map(m => m.content).join('\n'),
                      },
                    ],
                  },
                ],
                generationConfig: {
                  temperature: 0.7,
                },
              }),
            },
          };
          console.log('🌐 [帳戶主頁] 正在調用 Gemini API...');
          response = await fetch(geminiConfig.url, geminiConfig.data);
        } else {
          const openAiPayload = {
            model: model,
            messages: [{ role: 'system', content: systemPrompt }, ...messages],
            temperature: 0.7,
            stream: false,
          };
          console.log(`🌐 [帳戶主頁] 正在調用 API: ${proxyUrl}`);
          response = await fetch(`${proxyUrl}/v1/chat/completions`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              Authorization: `Bearer ${apiKey}`,
            },
            body: JSON.stringify(openAiPayload),
          });
        }
      } catch (fetchError) {
        console.error('❌ [帳戶主頁] 網路請求失敗:', fetchError);
        throw new Error(
          `網路請求失敗，請檢查：\n1. API配置是否正確\n2. 網路連接是否正常\n3. 代理位址是否可訪問\n\n詳細錯誤: ${fetchError.message}`,
        );
      }

      if (!response.ok) {
        let errorMessage = `API錯誤: ${response.status} - ${response.statusText}`;
        try {
          const errorData = await response.json();
          errorMessage = `API錯誤: ${response.status} - ${errorData.error?.message || response.statusText}`;
        } catch (e) {
          // 無法解析錯誤回應
        }
        throw new Error(errorMessage);
      }

      const data = await response.json();
      let aiResponseContent;

      if (isGemini) {
        aiResponseContent = data.candidates?.[0]?.content?.parts?.[0]?.text || '';
      } else {
        aiResponseContent = data.choices?.[0]?.message?.content || '';
      }

      console.log('AI原始回應:', aiResponseContent);

      // 解析AI返回的JSON資料
      const cleanedResponse = aiResponseContent
        .replace(/```json\s*/i, '')
        .replace(/```\s*$/, '')
        .trim();

      if (!cleanedResponse) {
        throw new Error('AI返回了空的回應內容');
      }

      let profileData;
      try {
        profileData = JSON.parse(cleanedResponse);
      } catch (parseError) {
        console.error('JSON解析失敗:', parseError);
        console.error('嘗試解析的內容:', cleanedResponse.substring(0, 500) + '...');
        throw new Error(`AI返回的資料不是有效的JSON格式: ${parseError.message}`);
      }

      // 🚫 篩選用戶身份冒用（最優先）
      profileData = StringBuilders.filterUserImpersonation(profileData, userXProfileInfo.handle, userXProfileInfo.name);

      // 🔧 強制修正所有頭像
      await StringBuilders.enforceAvatarRules(profileData, userXProfileInfo.handle);

      // 驗證資料格式
      if (isProgressMode) {
        // 推進模式下只需要推文資料
        if (!profileData.tweets) {
          throw new Error('AI返回的資料格式不正確：缺少推文數據');
        }

        // 推進模式：檢測並過濾重複推文
        if (existingTweets && existingTweets.length > 0) {
          const newTweets = profileData.tweets || [];

          // 過濾重複推文
          const filteredTweets = newTweets.filter(newTweet => {
            const newContent = newTweet.content.toLowerCase().trim();

            // 檢查是否與已有推文重複
            const isDuplicate = existingTweets.some(existingTweet => {
              const existingContent = existingTweet.content.toLowerCase().trim();

              // 完全相同
              if (existingContent === newContent) return true;

              // 計算相似度（使用簡單的字元匹配演算法）
              const similarity = calculateSimilarity(existingContent, newContent);

              // 相似度超過70%視為重複
              if (similarity > 0.7) {
                console.log(
                  `🚫 [帳戶主頁推進] 檢測到重複推文（相似度${(similarity * 100).toFixed(1)}%）:`,
                  newContent.substring(0, 50),
                );
                return true;
              }

              return false;
            });

            return !isDuplicate;
          });

          const removedCount = newTweets.length - filteredTweets.length;
          if (removedCount > 0) {
            console.log(`🔍 [帳戶主頁推進] 過濾了 ${removedCount} 條重複推文`);
            profileData.tweets = filteredTweets;
          }

          // 如果所有推文都被過濾了，提示錯誤
          if (filteredTweets.length === 0) {
            throw new Error('AI生成的所有推文都與已有內容重複，請重新生成');
          }
        }

        // 推進模式：檢測並過濾重複回復
        if (existingReplies && existingReplies.length > 0 && profileData.accountReplies) {
          const newReplies = profileData.accountReplies || [];

          const filteredReplies = newReplies.filter(newReply => {
            const newContent = newReply.accountReply?.content?.toLowerCase().trim() || '';
            if (!newContent) return true;

            const isDuplicate = existingReplies.some(existingReply => {
              const existingContent = existingReply.accountReply?.content?.toLowerCase().trim() || '';
              if (!existingContent) return false;

              if (existingContent === newContent) return true;

              const similarity = calculateSimilarity(existingContent, newContent);
              if (similarity > 0.7) {
                console.log(
                  `🚫 [帳戶主頁推進] 檢測到重複回復（相似度${(similarity * 100).toFixed(1)}%）:`,
                  newContent.substring(0, 50),
                );
                return true;
              }

              return false;
            });

            return !isDuplicate;
          });

          const removedCount = newReplies.length - filteredReplies.length;
          if (removedCount > 0) {
            console.log(`🔍 [帳戶主頁推進] 過濾了 ${removedCount} 條重複回復`);
            profileData.accountReplies = filteredReplies;
          }
        }
      } else {
        // 正常模式需要完整資料
        if (!profileData.accountInfo || !profileData.tweets) {
          throw new Error('AI返回的資料格式不正確');
        }

        // 強制使用正確的 verificationType，防止 AI 錯誤生成
        if (profileData.accountInfo) {
          const correctVerificationType = accountData.verificationType || 'verified';
          profileData.accountInfo.verificationType = correctVerificationType;
          console.log(`🔒 [帳戶主頁生成] 強制設置帳戶認證類型: ${correctVerificationType}`);
        }
      }

      // 強制修正所有推文和回復中的 verificationType
      const correctVerificationType = accountData.verificationType || 'verified';
      const accountHandle = accountData.handle;
      let fixedCount = 0;

      // 修正推文中的認證類型
      if (profileData.tweets && profileData.tweets.length > 0) {
        profileData.tweets.forEach(tweet => {
          if (tweet.user && tweet.user.handle === accountHandle) {
            if (tweet.user.verificationType !== correctVerificationType) {
              tweet.user.verificationType = correctVerificationType;
              fixedCount++;
            }
          }

          // 修正推文評論中的認證類型
          if (tweet.comments && tweet.comments.length > 0) {
            tweet.comments.forEach(comment => {
              if (comment.user && comment.user.handle === accountHandle) {
                if (comment.user.verificationType !== correctVerificationType) {
                  comment.user.verificationType = correctVerificationType;
                  fixedCount++;
                }
              }

              // 修正樓中樓回復中的認證類型
              if (comment.replies && comment.replies.length > 0) {
                comment.replies.forEach(reply => {
                  if (reply.user && reply.user.handle === accountHandle) {
                    if (reply.user.verificationType !== correctVerificationType) {
                      reply.user.verificationType = correctVerificationType;
                      fixedCount++;
                    }
                  }
                });
              }
            });
          }
        });
      }

      // 修正回復記錄中的認證類型
      if (profileData.accountReplies && profileData.accountReplies.length > 0) {
        profileData.accountReplies.forEach(replyRecord => {
          if (
            replyRecord.accountReply &&
            replyRecord.accountReply.user &&
            replyRecord.accountReply.user.handle === accountHandle
          ) {
            if (replyRecord.accountReply.user.verificationType !== correctVerificationType) {
              replyRecord.accountReply.user.verificationType = correctVerificationType;
              fixedCount++;
            }
          }
        });
      }

      if (fixedCount > 0) {
        console.log(`🔒 [帳戶主頁生成] 共修正了 ${fixedCount} 處認證類型錯誤`);
      }

      // 為推文、評論、喜歡分配唯一ID和時間戳記
      const timestamp = Date.now();
      profileData.tweets.forEach((tweet, tweetIndex) => {
        // 為推文分配ID（如果沒有）
        if (!tweet.id) {
          tweet.id = `account_tweet_${timestamp}_${tweetIndex}`;
        }

        // 為推文添加timestamp（如果沒有）
        if (!tweet.timestamp) {
          // 根據索引生成不同的時間戳記（越前面的推文越新）
          const hoursAgo = tweetIndex * 2 + Math.floor(Math.random() * 2);
          tweet.timestamp = timestamp - hoursAgo * 60 * 60 * 1000;
        }

        // 確保stats欄位存在
        if (!tweet.stats) {
          tweet.stats = {
            comments: tweet.comments?.length || 0,
            retweets: 0,
            likes: 0,
            views: 0,
          };
        }

        // 為評論分配ID和時間戳記
        if (tweet.comments && tweet.comments.length > 0) {
          tweet.comments.forEach((comment, commentIndex) => {
            if (!comment.id) {
              comment.id = `account_comment_${timestamp}_${tweetIndex}_${commentIndex}`;
            }

            // 轉換timeOffset為實際時間戳記
            if (comment.timeOffset !== undefined) {
              comment.timestamp = tweet.timestamp + Math.abs(comment.timeOffset) * 60 * 1000;
              delete comment.timeOffset;
            } else if (!comment.timestamp) {
              // 如果沒有timeOffset，隨機生成一個時間戳記
              comment.timestamp = tweet.timestamp + (5 + Math.random() * 30) * 60 * 1000;
            }

            // 為樓中樓回復分配ID和時間戳記
            if (comment.replies && comment.replies.length > 0) {
              comment.replies.forEach((reply, replyIndex) => {
                if (!reply.id) {
                  reply.id = `account_reply_${timestamp}_${tweetIndex}_${commentIndex}_${replyIndex}`;
                }

                // 轉換timeOffset為實際時間戳記
                if (reply.timeOffset !== undefined) {
                  reply.timestamp = tweet.timestamp + Math.abs(reply.timeOffset) * 60 * 1000;
                  delete reply.timeOffset;
                } else if (!reply.timestamp) {
                  // 回復時間應該比評論晚
                  reply.timestamp = comment.timestamp + (1 + Math.random() * 10) * 60 * 1000;
                }
              });
            }
          });
        }
      });

      // 為喜歡的推文分配ID和時間戳記
      if (profileData.accountLikes && profileData.accountLikes.length > 0) {
        profileData.accountLikes.forEach((likedTweet, likeIndex) => {
          // 為喜歡的推文分配ID（如果沒有）
          if (!likedTweet.id) {
            likedTweet.id = `account_liked_${timestamp}_${likeIndex}`;
          }

          // 為喜歡的推文添加timestamp（如果沒有）
          if (!likedTweet.timestamp) {
            // 喜歡的推文時間戳記應該比帳戶推文更早一些
            const daysAgo = likeIndex + 1 + Math.floor(Math.random() * 2);
            likedTweet.timestamp = timestamp - daysAgo * 24 * 60 * 60 * 1000;
          }

          // 確保stats欄位存在
          if (!likedTweet.stats) {
            likedTweet.stats = {
              comments: likedTweet.comments?.length || 0,
              retweets: 0,
              likes: 0,
              views: 0,
            };
          }

          // 為喜歡推文的評論分配ID和時間戳記
          if (likedTweet.comments && likedTweet.comments.length > 0) {
            likedTweet.comments.forEach((comment, commentIndex) => {
              if (!comment.id) {
                comment.id = `liked_comment_${timestamp}_${likeIndex}_${commentIndex}`;
              }

              // 轉換timeOffset為實際時間戳記
              if (comment.timeOffset !== undefined) {
                comment.timestamp = likedTweet.timestamp + Math.abs(comment.timeOffset) * 60 * 1000;
                delete comment.timeOffset;
              } else if (!comment.timestamp) {
                comment.timestamp = likedTweet.timestamp + (5 + Math.random() * 30) * 60 * 1000;
              }
            });
          }
        });
      }

      // 顯示手機樣式通知
      const isEnglish = currentLanguage === 'en';
      const userAvatar = window.userProfileData?.avatar || 'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg';
      showPhoneNotification({
        title: 'X',
        message: isEnglish ? 'Account profile has been generated!' : '帳戶主頁已生成！',
        avatar: userAvatar,
        leftIcon: 'x',
      });
      return profileData;
    } catch (error) {
      console.error('生成帳戶主頁內容失敗:', error);
      showXToast(`生成失敗: ${error.message}`, 'error');
      return null;
    }
  }

  // 渲染帳戶主頁
  function renderAccountProfile(accountData) {
    console.log('渲染帳戶主頁:', accountData);

    // 填充帳戶信息
    const accountInfo = accountData.accountInfo || accountData;

    // 設置巡覽列標題和推文數
    document.getElementById('account-profile-nav-name').textContent = accountInfo.name || accountData.name;
    const tweetCount = (accountData.tweets && accountData.tweets.length) || 0;
    document.getElementById('account-profile-nav-count').textContent = `${DataUtils.formatNumber(
      tweetCount,
    )} ${getI18nText('accountPostsCount')}`;

    // 設置背景圖
    const coverImage = document.getElementById('account-cover-image');
    coverImage.style.backgroundImage = `url('${
      accountInfo.cover || accountData.cover || 'https://i.postimg.cc/tT8Rfsf1/mmexport1759603246385.jpg'
    }')`;

    // 設置頭像
    document.getElementById('account-avatar-image').src = accountInfo.avatar || accountData.avatar;

    // 設置名稱
    document.getElementById('account-display-name').textContent = accountInfo.name || accountData.name;

    // 設置認證徽章（根據認證類型顯示不同圖示）
    const verifiedBadge = document.getElementById('account-verified-badge');
    const verificationType = accountInfo.verificationType || accountData.verificationType || 'verified';

    if (accountInfo.verified || accountData.verified) {
      // 情侶認證使用心形圖示
      if (verificationType === 'couple') {
        verifiedBadge.innerHTML = `
          <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);">
            <g><path d="M16.697 5.5c-1.222-.06-2.679.51-3.89 2.16l-.805 1.09-.806-1.09C9.984 6.01 8.526 5.44 7.304 5.5c-1.243.07-2.349.78-2.91 1.91-.552 1.12-.633 2.78.479 4.82 1.074 1.97 3.257 4.27 7.129 6.61 3.87-2.34 6.052-4.64 7.126-6.61 1.111-2.04 1.03-3.7.477-4.82-.561-1.13-1.666-1.84-2.908-1.91zm4.187 7.69c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g>
          </svg>
        `;
      } else {
        // 默認藍色勾標
        verifiedBadge.innerHTML = `
          <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-accent);">
            <g><path d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.27 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.46 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z"></path></g>
          </svg>
        `;
      }
      verifiedBadge.style.display = 'inline-flex';
      verifiedBadge.style.alignItems = 'center';
    } else {
      verifiedBadge.style.display = 'none';
    }

    // 設置控制碼（添加@首碼）
    const handle = accountInfo.handle || accountData.handle;
    document.getElementById('account-handle-text').textContent = handle.startsWith('@') ? handle : `@${handle}`;

    // 設置簡介
    const bioElement = document.getElementById('account-bio-text');
    if (accountInfo.bio || accountData.bio) {
      bioElement.textContent = accountInfo.bio || accountData.bio;
      bioElement.style.display = 'block';
    } else {
      bioElement.style.display = 'none';
    }

    // 設置自訂標籤
    const tagsContainer = document.getElementById('account-tags-container');
    tagsContainer.innerHTML = '';

    const customTag1 = accountInfo.customTag1 || accountData.customTag1;
    const customTag2 = accountInfo.customTag2 || accountData.customTag2;

    if (customTag1 && customTag1.text) {
      const tag1 = document.createElement('div');
      tag1.style.cssText = `display: flex; align-items: center; gap: 4px; color: ${
        customTag1.color || '#71767b'
      }; font-size: 15px;`;
      tag1.innerHTML = `<span>${customTag1.icon || ''}</span><span>${customTag1.text}</span>`;
      tagsContainer.appendChild(tag1);
    }

    if (customTag2 && customTag2.text) {
      const tag2 = document.createElement('div');
      tag2.style.cssText = `display: flex; align-items: center; gap: 4px; color: ${
        customTag2.color || '#71767b'
      }; font-size: 15px;`;
      tag2.innerHTML = `<span>${customTag2.icon || ''}</span><span>${customTag2.text}</span>`;
      tagsContainer.appendChild(tag2);
    }

    // 設置關注數據
    document.getElementById('account-following-count').textContent =
      accountInfo.followingCount || accountData.followingCount || '0';
    document.getElementById('account-followers-count').textContent =
      accountInfo.followersCount || accountData.followersCount || '0';

    // 初始化關注按鈕文本
    const followBtn = document.getElementById('account-follow-btn');
    if (followBtn && followBtn.textContent.includes('關注')) {
      followBtn.textContent = getI18nText('accountFollow');
    } else if (followBtn && followBtn.textContent.includes('Following')) {
      followBtn.textContent = getI18nText('accountFollow');
    }

    // 渲染推文
    const tweetsContainer = document.getElementById('account-tweets-container');
    tweetsContainer.innerHTML = '';

    if (accountData.tweets && accountData.tweets.length > 0) {
      accountData.tweets.forEach(tweet => {
        const tweetElement = createAccountTweetElement(tweet, accountInfo);
        tweetsContainer.appendChild(tweetElement);
      });
    } else {
      tweetsContainer.innerHTML =
        '<div style="padding: 40px; text-align: center; color: #71767b;">該帳戶還沒有發佈推文</div>';
    }

    // 顯示帳戶主頁
    document.querySelectorAll('.x-page').forEach(page => (page.style.display = 'none'));
    document.getElementById('account-profile-page').style.display = 'flex';

    showXToast(`已載入 ${accountInfo.name || accountData.name} 的主頁`, 'success');
  }

  // 創建帳戶回復元素
  function createAccountReplyElement(reply) {
    const replyEl = document.createElement('div');
    replyEl.style.cssText = 'border-bottom: 1px solid #2f3336;';

    const accountInfo = currentViewingAccount.accountInfo || currentViewingAccount;

    // 資料完整性檢查
    if (!reply || !reply.type) {
      console.warn('⚠️ [帳戶回復] 回復資料不完整:', reply);
      replyEl.innerHTML = '<div style="padding: 16px; color: #71767b;">回復資料不完整</div>';
      return replyEl;
    }

    // 構建帳戶認證圖示HTML
    let accountVerifiedBadgeHtml = '';
    if (accountInfo.verified) {
      if (accountInfo.verificationType === 'couple') {
        accountVerifiedBadgeHtml =
          '<svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-text-primary);"><g><path d="M16.697 5.5c-1.222-.06-2.679.51-3.89 2.16l-.805 1.09-.806-1.09C9.984 6.01 8.526 5.44 7.304 5.5c-1.243.07-2.349.78-2.91 1.91-.552 1.12-.633 2.78.479 4.82 1.074 1.97 3.257 4.27 7.129 6.61 3.87-2.34 6.052-4.64 7.126-6.61 1.111-2.04 1.03-3.7.477-4.82-.561-1.13-1.666-1.84-2.908-1.91zm4.187 7.69c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g></svg>';
      } else {
        accountVerifiedBadgeHtml =
          '<svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-accent);"><g><path d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.27 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.46 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z"></path></g></svg>';
      }
    }

    if (reply.type === 'tweet') {
      // 資料完整性檢查
      if (!reply.originalTweet || !reply.originalTweet.user || !reply.accountReply) {
        console.warn('⚠️ [帳戶回復] 推文回復資料不完整:', reply);
        replyEl.innerHTML = '<div style="padding: 16px; color: #71767b;">推文回復資料不完整</div>';
        return replyEl;
      }

      // 回復推文的樣式
      const originalUser = reply.originalTweet.user;
      const accountReply = reply.accountReply;

      // 構建原推文作者認證圖示
      let originalVerifiedHtml = '';
      if (originalUser.verified) {
        originalVerifiedHtml =
          '<svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-accent);"><g><path d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.27 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.46 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z"></path></g></svg>';
      }

      replyEl.innerHTML = `
        <div style="padding: 12px 16px;">
          <!-- 原始推文 -->
          <div style="display: flex; gap: 12px; margin-bottom: 8px;">
            <img src="${originalUser.avatar}" style="width: 40px; height: 40px; border-radius: 50%; flex-shrink: 0;">
            <div style="flex: 1; min-width: 0;">
              <div style="display: flex; align-items: center; gap: 4px; margin-bottom: 2px; flex-wrap: wrap;">
                <span style="color: #fff; font-weight: 800; font-size: 15px;">${originalUser.name}</span>
                ${originalVerifiedHtml}
                <span style="color: #71767b; font-size: 15px;">${
                  originalUser.handle.startsWith('@') ? originalUser.handle : '@' + originalUser.handle
                }</span>
                <span style="color: #71767b; font-size: 15px; margin: 0 4px;">·</span>
                <span class="tweet-time" data-timestamp="${
                  reply.originalTweet.timestamp || Date.now()
                }" style="color: #71767b; font-size: 15px;">${
        reply.originalTweet.timestamp
          ? getRelativeTime(reply.originalTweet.timestamp)
          : reply.originalTweet.time || '剛剛'
      }</span>
              </div>
              <div style="color: #fff; font-size: 15px; line-height: 20px; word-wrap: break-word;">${processContent(
                reply.originalTweet.content,
              )}</div>
              ${
                reply.originalTweet.media && reply.originalTweet.media.length > 0
                  ? `
                <div style="background-color: var(--x-bg-secondary); border-radius: 16px; padding: 12px; margin-top: 12px; border: 1px solid var(--x-border-color);">
                  <div style="color: var(--x-text-primary); font-size: 15px; line-height: 20px;">${reply.originalTweet.media[0].description}</div>
                </div>
              `
                  : ''
              }
            </div>
          </div>

          <!-- 連接線和帳戶回復 -->
          <div style="display: flex; gap: 12px;">
            <!-- 左側連接線 -->
            <div style="width: 40px; display: flex; justify-content: center; position: relative;">
              <div style="width: 2px; height: 100%; background-color: #2f3336;"></div>
            </div>
            <div style="flex: 1;"></div>
          </div>

          <!-- 帳戶的回復 -->
          <div style="display: flex; gap: 12px; margin-top: 8px;">
            <img src="${accountInfo.avatar}" style="width: 40px; height: 40px; border-radius: 50%; flex-shrink: 0;">
            <div style="flex: 1; min-width: 0;">
              <div style="display: flex; align-items: center; gap: 4px; margin-bottom: 2px; flex-wrap: wrap;">
                <span style="color: #fff; font-weight: 800; font-size: 15px;">${accountInfo.name}</span>
                ${accountVerifiedBadgeHtml}
                <span style="color: #71767b; font-size: 15px;">${
                  accountInfo.handle.startsWith('@') ? accountInfo.handle : '@' + accountInfo.handle
                }</span>
                <span style="color: #71767b; font-size: 15px; margin: 0 4px;">·</span>
                <span class="tweet-time" data-timestamp="${
                  accountReply.timestamp || Date.now()
                }" style="color: #71767b; font-size: 15px;">${
        accountReply.timestamp ? getRelativeTime(accountReply.timestamp) : accountReply.time || '剛剛'
      }</span>
              </div>
              <div style="color: #71767b; font-size: 15px; margin-bottom: 4px;">${getI18nText(
                'accountReplyTo',
              )} <span style="color: var(--x-accent);">${
        originalUser.handle.startsWith('@') ? originalUser.handle : '@' + originalUser.handle
      }</span></div>
              <div style="color: #fff; font-size: 15px; line-height: 20px; margin-bottom: 12px; word-wrap: break-word;">${processContent(
                accountReply.content,
              )}</div>
              
              <!-- 互動按鈕 -->
              <div style="display: flex; justify-content: space-between; max-width: 425px;">
                <div style="display: flex; align-items: center; gap: 4px; color: #71767b; cursor: pointer;" onmouseover="this.style.color='var(--x-accent)'" onmouseout="this.style.color='#71767b'">
                  <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M1.751 10c0-4.42 3.584-8 8.005-8h4.366c4.49 0 8.129 3.64 8.129 8.13 0 2.96-1.607 5.68-4.196 7.11l-8.054 4.46v-3.69h-.067c-4.49.1-8.183-3.51-8.183-8.01zm8.005-6c-3.317 0-6.005 2.69-6.005 6 0 3.37 2.77 6.08 6.138 6.01l.351-.01h1.761v2.3l5.087-2.81c1.951-1.08 3.163-3.13 3.163-5.36 0-3.39-2.744-6.13-6.129-6.13H9.756z"></path></g></svg>
                  <span style="font-size: 13px;">${DataUtils.formatNumber(accountReply.stats.comments || 0)}</span>
                </div>
                <div style="display: flex; align-items: center; gap: 4px; color: #71767b; cursor: pointer;" onmouseover="this.style.color='#00ba7c'" onmouseout="this.style.color='#71767b'">
                  <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M4.5 3.88l4.432 4.14-1.364 1.46L5.5 7.55V16c0 1.1.896 2 2 2H13v2H7.5c-2.209 0-4-1.79-4-4V7.55L1.432 9.48.068 8.02 4.5 3.88zM16.5 6H11V4h5.5c2.209 0 4 1.79 4 4v8.45l2.068-1.93 1.364 1.46-4.432 4.14-4.432-4.14 1.364-1.46 2.068 1.93V8c0-1.1-.896-2-2-2z"></path></g></svg>
                  <span style="font-size: 13px;">${DataUtils.formatNumber(accountReply.stats.retweets || 0)}</span>
                </div>
                <div style="display: flex; align-items: center; gap: 4px; color: #71767b; cursor: pointer;" onmouseover="this.style.color='#f91880'" onmouseout="this.style.color='#71767b'">
                  <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M16.697 5.5c-1.222-.06-2.679.51-3.89 2.16l-.805 1.09-.806-1.09C9.984 6.01 8.526 5.44 7.304 5.5c-1.243.07-2.349.78-2.91 1.91-.552 1.12-.633 2.78.479 4.82 1.074 1.97 3.257 4.27 7.129 6.61 3.87-2.34 6.052-4.64 7.126-6.61 1.111-2.04 1.03-3.7.477-4.82-.561-1.13-1.666-1.84-2.908-1.91zm4.187 7.69c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g></svg>
                  <span style="font-size: 13px;">${DataUtils.formatNumber(accountReply.stats.likes || 0)}</span>
                </div>
                <div style="display: flex; align-items: center; gap: 4px; color: #71767b; cursor: pointer;" onmouseover="this.style.color='var(--x-accent)'" onmouseout="this.style.color='#71767b'">
                  <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M8.75 21V3h2v18h-2zM18 21V8.5h2V21h-2zM4 21l.004-10h2L6 21H4zm9.248 0v-7h2v7h-2z"></path></g></svg>
                  <span style="font-size: 13px;">${DataUtils.formatNumber(accountReply.stats.views || 0)}</span>
                </div>
              </div>
            </div>
          </div>
        </div>
      `;
    } else if (reply.type === 'comment') {
      // 資料完整性檢查
      if (
        !reply.originalTweet ||
        !reply.originalTweet.user ||
        !reply.originalComment ||
        !reply.originalComment.user ||
        !reply.accountReply
      ) {
        console.warn('⚠️ [帳戶回復] 評論回復資料不完整:', reply);
        replyEl.innerHTML = '<div style="padding: 16px; color: #71767b;">評論回復資料不完整</div>';
        return replyEl;
      }

      // 回復評論的樣式（樓中樓）
      const originalTweetUser = reply.originalTweet.user;
      const originalCommentUser = reply.originalComment.user;
      const accountReply = reply.accountReply;

      // 構建認證圖示
      let tweetVerifiedHtml = '';
      if (originalTweetUser.verified) {
        tweetVerifiedHtml =
          '<svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-accent);"><g><path d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.27 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.46 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z"></path></g></svg>';
      }

      let commentVerifiedHtml = '';
      if (originalCommentUser.verified) {
        commentVerifiedHtml =
          '<svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-accent);"><g><path d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.27 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.46 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z"></path></g></svg>';
      }

      replyEl.innerHTML = `
        <div style="padding: 12px 16px;">
          <!-- 原始推文 -->
          <div style="display: flex; gap: 12px; margin-bottom: 4px;">
            <img src="${
              originalTweetUser.avatar
            }" style="width: 40px; height: 40px; border-radius: 50%; flex-shrink: 0;">
            <div style="flex: 1; min-width: 0;">
              <div style="display: flex; align-items: center; gap: 4px; margin-bottom: 2px; flex-wrap: wrap;">
                <span style="color: #fff; font-weight: 800; font-size: 15px;">${originalTweetUser.name}</span>
                ${tweetVerifiedHtml}
                <span style="color: #71767b; font-size: 15px;">${
                  originalTweetUser.handle.startsWith('@') ? originalTweetUser.handle : '@' + originalTweetUser.handle
                }</span>
                <span style="color: #71767b; font-size: 15px; margin: 0 4px;">·</span>
                <span class="tweet-time" data-timestamp="${
                  reply.originalTweet.timestamp || Date.now()
                }" style="color: #71767b; font-size: 15px;">${
        reply.originalTweet.timestamp
          ? getRelativeTime(reply.originalTweet.timestamp)
          : reply.originalTweet.time || '剛剛'
      }</span>
              </div>
              <div style="color: #fff; font-size: 15px; line-height: 20px; word-wrap: break-word;">${processContent(
                reply.originalTweet.content,
              )}</div>
              ${
                reply.originalTweet.media && reply.originalTweet.media.length > 0
                  ? `
                <div style="background-color: var(--x-bg-secondary); border-radius: 16px; padding: 12px; margin-top: 12px; border: 1px solid var(--x-border-color);">
                  <div style="color: var(--x-text-primary); font-size: 15px; line-height: 20px;">${reply.originalTweet.media[0].description}</div>
                </div>
              `
                  : ''
              }
            </div>
          </div>

          <!-- 連接線和原始評論 -->
          <div style="display: flex; gap: 12px; margin-top: 8px;">
            <div style="width: 40px; display: flex; justify-content: center;">
              <div style="width: 2px; background-color: #2f3336; height: 100%;"></div>
            </div>
            <div style="flex: 1; padding-top: 4px;">
              <div style="display: flex; gap: 12px;">
                <img src="${
                  originalCommentUser.avatar
                }" style="width: 40px; height: 40px; border-radius: 50%; flex-shrink: 0;">
                <div style="flex: 1; min-width: 0;">
                  <div style="display: flex; align-items: center; gap: 4px; margin-bottom: 2px; flex-wrap: wrap;">
                    <span style="color: #fff; font-weight: 800; font-size: 15px;">${originalCommentUser.name}</span>
                    ${commentVerifiedHtml}
                    <span style="color: #71767b; font-size: 15px;">${
                      originalCommentUser.handle.startsWith('@')
                        ? originalCommentUser.handle
                        : '@' + originalCommentUser.handle
                    }</span>
                    <span style="color: #71767b; font-size: 15px; margin: 0 4px;">·</span>
                    <span class="tweet-time" data-timestamp="${
                      reply.originalComment.timestamp || Date.now()
                    }" style="color: #71767b; font-size: 15px;">${
        reply.originalComment.timestamp
          ? getRelativeTime(reply.originalComment.timestamp)
          : reply.originalComment.time || '剛剛'
      }</span>
                  </div>
                  <div style="color: #fff; font-size: 15px; line-height: 20px; word-wrap: break-word;">${processContent(
                    reply.originalComment.content,
                  )}</div>
                </div>
              </div>
            </div>
          </div>

          <!-- 連接線和帳戶回復 -->
          <div style="display: flex; gap: 12px; margin-top: 8px;">
            <div style="width: 40px; display: flex; justify-content: center;">
              <div style="width: 2px; background-color: #2f3336; height: 100%;"></div>
            </div>
            <div style="flex: 1; padding-top: 4px;">
              <div style="display: flex; gap: 12px;">
                <img src="${accountInfo.avatar}" style="width: 40px; height: 40px; border-radius: 50%; flex-shrink: 0;">
                <div style="flex: 1; min-width: 0;">
                  <div style="display: flex; align-items: center; gap: 4px; margin-bottom: 2px; flex-wrap: wrap;">
                    <span style="color: #fff; font-weight: 800; font-size: 15px;">${accountInfo.name}</span>
                    ${accountVerifiedBadgeHtml}
                    <span style="color: #71767b; font-size: 15px;">${
                      accountInfo.handle.startsWith('@') ? accountInfo.handle : '@' + accountInfo.handle
                    }</span>
                    <span style="color: #71767b; font-size: 15px; margin: 0 4px;">·</span>
                    <span class="tweet-time" data-timestamp="${
                      accountReply.timestamp || Date.now()
                    }" style="color: #71767b; font-size: 15px;">${
        accountReply.timestamp ? getRelativeTime(accountReply.timestamp) : accountReply.time || '剛剛'
      }</span>
                  </div>
                  <div style="color: #71767b; font-size: 15px; margin-bottom: 4px;">${getI18nText(
                    'accountReplyTo',
                  )} <span style="color: var(--x-accent);">${
        originalCommentUser.handle.startsWith('@') ? originalCommentUser.handle : '@' + originalCommentUser.handle
      }</span></div>
                  <div style="color: #fff; font-size: 15px; line-height: 20px; margin-bottom: 12px; word-wrap: break-word;">${processContent(
                    accountReply.content,
                  )}</div>
                  
                  <!-- 互動按鈕 -->
                  <div style="display: flex; justify-content: space-between; max-width: 425px;">
                    <div style="display: flex; align-items: center; gap: 4px; color: #71767b; cursor: pointer;" onmouseover="this.style.color='var(--x-accent)'" onmouseout="this.style.color='#71767b'">
                      <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M1.751 10c0-4.42 3.584-8 8.005-8h4.366c4.49 0 8.129 3.64 8.129 8.13 0 2.96-1.607 5.68-4.196 7.11l-8.054 4.46v-3.69h-.067c-4.49.1-8.183-3.51-8.183-8.01zm8.005-6c-3.317 0-6.005 2.69-6.005 6 0 3.37 2.77 6.08 6.138 6.01l.351-.01h1.761v2.3l5.087-2.81c1.951-1.08 3.163-3.13 3.163-5.36 0-3.39-2.744-6.13-6.129-6.13H9.756z"></path></g></svg>
                      <span style="font-size: 13px;">${DataUtils.formatNumber(accountReply.stats.comments || 0)}</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 4px; color: #71767b; cursor: pointer;" onmouseover="this.style.color='#00ba7c'" onmouseout="this.style.color='#71767b'">
                      <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M4.5 3.88l4.432 4.14-1.364 1.46L5.5 7.55V16c0 1.1.896 2 2 2H13v2H7.5c-2.209 0-4-1.79-4-4V7.55L1.432 9.48.068 8.02 4.5 3.88zM16.5 6H11V4h5.5c2.209 0 4 1.79 4 4v8.45l2.068-1.93 1.364 1.46-4.432 4.14-4.432-4.14 1.364-1.46 2.068 1.93V8c0-1.1-.896-2-2-2z"></path></g></svg>
                      <span style="font-size: 13px;">${DataUtils.formatNumber(accountReply.stats.retweets || 0)}</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 4px; color: #71767b; cursor: pointer;" onmouseover="this.style.color='#f91880'" onmouseout="this.style.color='#71767b'">
                      <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M16.697 5.5c-1.222-.06-2.679.51-3.89 2.16l-.805 1.09-.806-1.09C9.984 6.01 8.526 5.44 7.304 5.5c-1.243.07-2.349.78-2.91 1.91-.552 1.12-.633 2.78.479 4.82 1.074 1.97 3.257 4.27 7.129 6.61 3.87-2.34 6.052-4.64 7.126-6.61 1.111-2.04 1.03-3.7.477-4.82-.561-1.13-1.666-1.84-2.908-1.91zm4.187 7.69c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g></svg>
                      <span style="font-size: 13px;">${DataUtils.formatNumber(accountReply.stats.likes || 0)}</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 4px; color: #71767b; cursor: pointer;" onmouseover="this.style.color='var(--x-accent)'" onmouseout="this.style.color='#71767b'">
                      <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M8.75 21V3h2v18h-2zM18 21V8.5h2V21h-2zM4 21l.004-10h2L6 21H4zm9.248 0v-7h2v7h-2z"></path></g></svg>
                      <span style="font-size: 13px;">${DataUtils.formatNumber(accountReply.stats.views || 0)}</span>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      `;
    }

    return replyEl;
  }

  // 創建喜歡的推文元素（X風格，帶"已喜歡"提示）
  function createLikedTweetElement(tweet, accountInfo) {
    const tweetEl = document.createElement('div');
    tweetEl.style.cssText = 'border-bottom: 1px solid var(--x-border-color);';

    const user = tweet.user;

    // 構建認證圖示HTML
    let verifiedBadgeHtml = '';
    if (user.verified) {
      if (user.verificationType === 'couple') {
        verifiedBadgeHtml =
          '<svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-text-primary);"><g><path d="M16.697 5.5c-1.222-.06-2.679.51-3.89 2.16l-.805 1.09-.806-1.09C9.984 6.01 8.526 5.44 7.304 5.5c-1.243.07-2.349.78-2.91 1.91-.552 1.12-.633 2.78.479 4.82 1.074 1.97 3.257 4.27 7.129 6.61 3.87-2.34 6.052-4.64 7.126-6.61 1.111-2.04 1.03-3.7.477-4.82-.561-1.13-1.666-1.84-2.908-1.91zm4.187 7.69c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g></svg>';
      } else {
        verifiedBadgeHtml =
          '<svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-accent);"><g><path d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.27 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.46 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z"></path></g></svg>';
      }
    }

    tweetEl.innerHTML = `
      <!-- "已喜歡"提示 -->
      <div style="padding: 12px 16px 0; display: flex; align-items: center; gap: 12px;">
        <div style="width: 40px; display: flex; justify-content: flex-end;">
          <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: var(--x-text-secondary);">
            <g><path d="M16.697 5.5c-1.222-.06-2.679.51-3.89 2.16l-.805 1.09-.806-1.09C9.984 6.01 8.526 5.44 7.304 5.5c-1.243.07-2.349.78-2.91 1.91-.552 1.12-.633 2.78.479 4.82 1.074 1.97 3.257 4.27 7.129 6.61 3.87-2.34 6.052-4.64 7.126-6.61 1.111-2.04 1.03-3.7.477-4.82-.561-1.13-1.666-1.84-2.908-1.91zm4.187 7.69c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g>
          </svg>
        </div>
        <span style="color: var(--x-text-secondary); font-size: 13px; font-weight: 700;">${
          accountInfo.name
        } ${getI18nText('accountLiked')}</span>
      </div>
      <!-- 推文內容 -->
      <div style="padding: 12px 16px; display: flex; gap: 12px; position: relative;">
        <img src="${user.avatar}" alt="${
      user.name
    }" style="width: 40px; height: 40px; border-radius: 50%; flex-shrink: 0;">
        <div style="flex: 1; min-width: 0;">
          <div style="display: flex; align-items: center; gap: 2px; margin-bottom: 2px; flex-wrap: wrap;">
            <span style="color: var(--x-text-primary); font-weight: 800; font-size: 15px;">${user.name}</span>
            ${verifiedBadgeHtml}
            <span style="color: var(--x-text-secondary); font-size: 15px; margin-left: 4px;">${
              user.handle.startsWith('@') ? user.handle : '@' + user.handle
            }</span>
            <span style="color: var(--x-text-secondary); font-size: 15px; margin: 0 4px;">·</span>
            <span class="tweet-time" data-timestamp="${
              tweet.timestamp || Date.now()
            }" style="color: var(--x-text-secondary); font-size: 15px;">${
      tweet.timestamp ? getRelativeTime(tweet.timestamp) : tweet.time || '剛剛'
    }</span>
          </div>
          <div style="color: var(--x-text-primary); font-size: 15px; line-height: 20px; margin-bottom: 12px; word-wrap: break-word;">${processContent(
            tweet.content,
          )}</div>
          ${
            tweet.media && tweet.media.length > 0
              ? `
            <div style="background-color: var(--x-bg-secondary); border-radius: 16px; padding: 12px; margin-bottom: 12px; border: 1px solid var(--x-border-color);">
              <div style="color: var(--x-text-primary); font-size: 15px; line-height: 20px;">${tweet.media[0].description}</div>
            </div>
          `
              : ''
          }
          <div style="display: flex; justify-content: space-between; max-width: 425px; margin-top: 12px;">
            <div onclick="showLikedTweetDetail('${
              tweet.id || Date.now()
            }')" style="display: flex; align-items: center; gap: 4px; color: var(--x-text-secondary); cursor: pointer; padding: 0;" onmouseover="this.style.color='var(--x-accent)'" onmouseout="this.style.color='var(--x-text-secondary)'">
              <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M1.751 10c0-4.42 3.584-8 8.005-8h4.366c4.49 0 8.129 3.64 8.129 8.13 0 2.96-1.607 5.68-4.196 7.11l-8.054 4.46v-3.69h-.067c-4.49.1-8.183-3.51-8.183-8.01zm8.005-6c-3.317 0-6.005 2.69-6.005 6 0 3.37 2.77 6.08 6.138 6.01l.351-.01h1.761v2.3l5.087-2.81c1.951-1.08 3.163-3.13 3.163-5.36 0-3.39-2.744-6.13-6.129-6.13H9.756z"></path></g></svg>
              <span style="font-size: 13px;">${DataUtils.formatNumber(tweet.stats.comments || 0)}</span>
            </div>
            <div style="display: flex; align-items: center; gap: 4px; color: var(--x-text-secondary); cursor: pointer; padding: 0;" onmouseover="this.style.color='#00ba7c'" onmouseout="this.style.color='var(--x-text-secondary)'">
              <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M4.5 3.88l4.432 4.14-1.364 1.46L5.5 7.55V16c0 1.1.896 2 2 2H13v2H7.5c-2.209 0-4-1.79-4-4V7.55L1.432 9.48.068 8.02 4.5 3.88zM16.5 6H11V4h5.5c2.209 0 4 1.79 4 4v8.45l2.068-1.93 1.364 1.46-4.432 4.14-4.432-4.14 1.364-1.46 2.068 1.93V8c0-1.1-.896-2-2-2z"></path></g></svg>
              <span style="font-size: 13px;">${DataUtils.formatNumber(tweet.stats.retweets || 0)}</span>
            </div>
            <div style="display: flex; align-items: center; gap: 4px; color: #f91880; cursor: pointer; padding: 0;" onmouseover="this.style.color='#f91880'" onmouseout="this.style.color='#f91880'">
              <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M16.697 5.5c-1.222-.06-2.679.51-3.89 2.16l-.805 1.09-.806-1.09C9.984 6.01 8.526 5.44 7.304 5.5c-1.243.07-2.349.78-2.91 1.91-.552 1.12-.633 2.78.479 4.82 1.074 1.97 3.257 4.27 7.129 6.61 3.87-2.34 6.052-4.64 7.126-6.61 1.111-2.04 1.03-3.7.477-4.82-.561-1.13-1.666-1.84-2.908-1.91zm4.187 7.69c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g></svg>
              <span style="font-size: 13px;">${DataUtils.formatNumber(tweet.stats.likes || 0)}</span>
            </div>
            <div style="display: flex; align-items: center; gap: 4px; color: var(--x-text-secondary); cursor: pointer; padding: 0;" onmouseover="this.style.color='var(--x-accent)'" onmouseout="this.style.color='var(--x-text-secondary)'">
              <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M8.75 21V3h2v18h-2zM18 21V8.5h2V21h-2zM4 21l.004-10h2L6 21H4zm9.248 0v-7h2v7h-2z"></path></g></svg>
              <span style="font-size: 13px;">${DataUtils.formatNumber(tweet.stats.views || 0)}</span>
            </div>
            <div style="display: flex; align-items: center; gap: 8px; color: var(--x-text-secondary); cursor: pointer; padding: 0;">
              <div style="display: flex; align-items: center;" onmouseover="this.style.color='var(--x-accent)'" onmouseout="this.style.color='var(--x-text-secondary)'">
                <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M4 4.5C4 3.12 5.119 2 6.5 2h11C18.881 2 20 3.12 20 4.5v18.44l-8-5.71-8 5.71V4.5zM6.5 4c-.276 0-.5.22-.5.5v14.56l6-4.29 6 4.29V4.5c0-.28-.224-.5-.5-.5h-11z"></path></g></svg>
              </div>
              <div style="display: flex; align-items: center;" onmouseover="this.style.color='var(--x-accent)'" onmouseout="this.style.color='var(--x-text-secondary)'">
                <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M12 2.59l5.7 5.7-1.41 1.42L13 6.41V16h-2V6.41l-3.3 3.3-1.41-1.42L12 2.59zM21 15l-.02 3.51c0 1.38-1.12 2.49-2.5 2.49H5.5C4.11 21 3 19.88 3 18.5V15h2v3.5c0 .28.22.5.5.5h12.98c.28 0 .5-.22.5-.5L19 15h2z"></path></g></svg>
              </div>
            </div>
          </div>
        </div>
        <!-- 右上角三點菜單 -->
        <div style="position: absolute; top: 12px; right: 16px; cursor: pointer; padding: 4px; border-radius: 50%; transition: background-color 0.2s;" onmouseover="this.style.backgroundColor='rgba(29,155,240,0.1)'" onmouseout="this.style.backgroundColor='transparent'">
          <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-text-secondary);">
            <g><path d="M3 12c0-1.1.9-2 2-2s2 .9 2 2-.9 2-2 2-2-.9-2-2zm9 2c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm7 0c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2z"></path></g>
          </svg>
        </div>
      </div>
    `;

    // 將推文資料臨時存儲，方便後續點擊查看詳情
    tweetEl.dataset.tweetData = JSON.stringify(tweet);

    return tweetEl;
  }

  // 創建帳戶推文元素（按圖片樣式設計）
  function createAccountTweetElement(tweet, accountInfo) {
    const tweetEl = document.createElement('div');
    tweetEl.style.cssText = 'border-bottom: 1px solid var(--x-border-color);';

    const user = tweet.user || accountInfo;
    const isPinned = tweet.pinned || false;

    // 構建認證圖示HTML
    let verifiedBadgeHtml = '';
    if (user.verified) {
      if (user.verificationType === 'couple') {
        verifiedBadgeHtml =
          '<svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-text-primary);"><g><path d="M16.697 5.5c-1.222-.06-2.679.51-3.89 2.16l-.805 1.09-.806-1.09C9.984 6.01 8.526 5.44 7.304 5.5c-1.243.07-2.349.78-2.91 1.91-.552 1.12-.633 2.78.479 4.82 1.074 1.97 3.257 4.27 7.129 6.61 3.87-2.34 6.052-4.64 7.126-6.61 1.111-2.04 1.03-3.7.477-4.82-.561-1.13-1.666-1.84-2.908-1.91zm4.187 7.69c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g></svg>';
      } else {
        verifiedBadgeHtml =
          '<svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-accent);"><g><path d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.27 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.46 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z"></path></g></svg>';
      }
    }

    tweetEl.innerHTML = `
      ${
        isPinned
          ? `
        <div style="padding: 12px 16px 0; display: flex; align-items: center; gap: 12px;">
          <div style="width: 40px; display: flex; justify-content: flex-end;">
            <svg viewBox="0 0 32 32" style="width: 16px; height: 16px; fill: #71767b;">
              <path d="M20.743 14.815l-0.933-12.065h5.191c0.414 0 0.75-0.336 0.75-0.75s-0.336-0.75-0.75-0.75v0h-18c-0.414 0-0.75 0.336-0.75 0.75s0.336 0.75 0.75 0.75v0h5.432l-1.275 12.103c-3.213 0.959-5.574 3.738-5.904 7.113l-0.003 0.034c0 0.414 0.336 0.75 0.75 0.75h9.25v7.25c0 0.414 0.336 0.75 0.75 0.75s0.75-0.336 0.75-0.75v0-7.25h9.25c0.414-0 0.75-0.336 0.75-0.75v0c0-3.017-2.35-5.787-6.007-7.185zM12.104 16.081c0.096-0.035 0.179-0.085 0.249-0.148l-0.001 0.001 0.005-0.003c0.126-0.117 0.211-0.275 0.233-0.453l0-0.004 0.011-0.022 1.337-12.701h4.367l0.979 12.681c0.033 0.35 0.303 0.627 0.647 0.67l0.004 0c2.542 0.682 4.512 2.623 5.222 5.096l0.013 0.052h-18.341c0.729-2.54 2.714-4.49 5.222-5.157l0.052-0.012z"></path>
            </svg>
          </div>
          <span style="color: #71767b; font-size: 13px; font-weight: 700;">${getI18nText('accountPinned')}</span>
        </div>
      `
          : ''
      }
      <div style="padding: 12px 16px; display: flex; gap: 12px; position: relative;">
        <img src="${user.avatar}" alt="${
      user.name
    }" style="width: 40px; height: 40px; border-radius: 50%; flex-shrink: 0;">
        <div style="flex: 1; min-width: 0;">
          <div style="display: flex; align-items: center; gap: 2px; margin-bottom: 2px; flex-wrap: wrap;">
            <span style="color: #fff; font-weight: 800; font-size: 15px;">${user.name}</span>
            ${verifiedBadgeHtml}
            <span style="color: #71767b; font-size: 15px; margin-left: 4px;">${
              user.handle.startsWith('@') ? user.handle : '@' + user.handle
            }</span>
            <span style="color: #71767b; font-size: 15px; margin: 0 4px;">·</span>
            <span class="tweet-time" data-timestamp="${
              tweet.timestamp || Date.now()
            }" style="color: #71767b; font-size: 15px;">${
      tweet.timestamp ? getRelativeTime(tweet.timestamp) : tweet.time || '剛剛'
    }</span>
          </div>
          <div style="color: #fff; font-size: 15px; line-height: 20px; margin-bottom: 12px; word-wrap: break-word;">${processContent(
            tweet.content,
          )}</div>
          ${
            tweet.media && tweet.media.length > 0
              ? `
            <div style="background-color: var(--x-bg-secondary); border-radius: 16px; padding: 12px; margin-bottom: 12px; border: 1px solid var(--x-border-color);">
              <div style="color: var(--x-text-primary); font-size: 15px; line-height: 20px;">${tweet.media[0].description}</div>
            </div>
          `
              : ''
          }
          <div style="display: flex; justify-content: space-between; max-width: 425px; margin-top: 12px;">
            <div onclick="showAccountTweetDetail('${
              tweet.id
            }')" style="display: flex; align-items: center; gap: 4px; color: #71767b; cursor: pointer; padding: 0;" onmouseover="this.style.color='var(--x-accent)'" onmouseout="this.style.color='#71767b'">
              <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M1.751 10c0-4.42 3.584-8 8.005-8h4.366c4.49 0 8.129 3.64 8.129 8.13 0 2.96-1.607 5.68-4.196 7.11l-8.054 4.46v-3.69h-.067c-4.49.1-8.183-3.51-8.183-8.01zm8.005-6c-3.317 0-6.005 2.69-6.005 6 0 3.37 2.77 6.08 6.138 6.01l.351-.01h1.761v2.3l5.087-2.81c1.951-1.08 3.163-3.13 3.163-5.36 0-3.39-2.744-6.13-6.129-6.13H9.756z"></path></g></svg>
              <span style="font-size: 13px;">${DataUtils.formatNumber(tweet.stats.comments || 0)}</span>
            </div>
            <div onclick="handleQuoteRetweetFromAccountTweet('${
              tweet.id
            }')" style="display: flex; align-items: center; gap: 4px; color: #71767b; cursor: pointer; padding: 0;" onmouseover="this.style.color='#00ba7c'" onmouseout="this.style.color='#71767b'">
              <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M4.5 3.88l4.432 4.14-1.364 1.46L5.5 7.55V16c0 1.1.896 2 2 2H13v2H7.5c-2.209 0-4-1.79-4-4V7.55L1.432 9.48.068 8.02 4.5 3.88zM16.5 6H11V4h5.5c2.209 0 4 1.79 4 4v8.45l2.068-1.93 1.364 1.46-4.432 4.14-4.432-4.14 1.364-1.46 2.068 1.93V8c0-1.1-.896-2-2-2z"></path></g></svg>
              <span style="font-size: 13px;">${DataUtils.formatNumber(tweet.stats.retweets || 0)}</span>
            </div>
            <div class="tweet-action like" onclick="toggleLike('${tweet.id}', this)" data-liked="false" data-likes="${
      tweet.stats.likes || 0
    }" style="display: flex; align-items: center; gap: 4px; color: #71767b; cursor: pointer; padding: 0;" onmouseover="this.style.color='#f91880'" onmouseout="this.style.color='#71767b'">
              <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M16.697 5.5c-1.222-.06-2.679.51-3.89 2.16l-.805 1.09-.806-1.09C9.984 6.01 8.526 5.44 7.304 5.5c-1.243.07-2.349.78-2.91 1.91-.552 1.12-.633 2.78.479 4.82 1.074 1.97 3.257 4.27 7.129 6.61 3.87-2.34 6.052-4.64 7.126-6.61 1.111-2.04 1.03-3.7.477-4.82-.561-1.13-1.666-1.84-2.908-1.91zm4.187 7.69c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g></svg>
              <span class="like-count" style="font-size: 13px;">${DataUtils.formatNumber(tweet.stats.likes || 0)}</span>
            </div>
            <div style="display: flex; align-items: center; gap: 4px; color: #71767b; cursor: pointer; padding: 0;" onmouseover="this.style.color='var(--x-accent)'" onmouseout="this.style.color='#71767b'">
              <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M8.75 21V3h2v18h-2zM18 21V8.5h2V21h-2zM4 21l.004-10h2L6 21H4zm9.248 0v-7h2v7h-2z"></path></g></svg>
              <span style="font-size: 13px;">${DataUtils.formatNumber(tweet.stats.views || 0)}</span>
            </div>
            <div style="display: flex; align-items: center; gap: 8px; color: #71767b; cursor: pointer; padding: 0;">
              <div onclick="toggleBookmark('${
                tweet.id
              }', this)" data-bookmarked="false" style="display: flex; align-items: center;" onmouseover="this.style.color='var(--x-accent)'" onmouseout="this.style.color='#71767b'">
                <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M4 4.5C4 3.12 5.119 2 6.5 2h11C18.881 2 20 3.12 20 4.5v18.44l-8-5.71-8 5.71V4.5zM6.5 4c-.276 0-.5.22-.5.5v14.56l6-4.29 6 4.29V4.5c0-.28-.224-.5-.5-.5h-11z"></path></g></svg>
              </div>
              <div style="display: flex; align-items: center;" onmouseover="this.style.color='var(--x-accent)'" onmouseout="this.style.color='#71767b'">
                <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M12 2.59l5.7 5.7-1.41 1.42L13 6.41V16h-2V6.41l-3.3 3.3-1.41-1.42L12 2.59zM21 15l-.02 3.51c0 1.38-1.12 2.49-2.5 2.49H5.5C4.11 21 3 19.88 3 18.5V15h2v3.5c0 .28.22.5.5.5h12.98c.28 0 .5-.22.5-.5L19 15h2z"></path></g></svg>
              </div>
            </div>
          </div>
        </div>
        <!-- 右上角三點菜單 -->
        <div style="position: absolute; top: 12px; right: 16px; cursor: pointer; padding: 4px; border-radius: 50%; transition: background-color 0.2s;" onmouseover="this.style.backgroundColor='rgba(29,155,240,0.1)'" onmouseout="this.style.backgroundColor='transparent'">
          <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: #71767b;">
            <g><path d="M3 12c0-1.1.9-2 2-2s2 .9 2 2-.9 2-2 2-2-.9-2-2zm9 2c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm7 0c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2z"></path></g>
          </svg>
        </div>
      </div>
    `;

    return tweetEl;
  }

  // 關閉帳戶主頁
  window.closeAccountProfile = function () {
    // 重置推進模式
    if (isProgressMode) {
      isProgressMode = false;
      updateRefreshButtonUI();
    }

    document.getElementById('account-profile-page').style.display = 'none';

    // 檢查是否需要返回搜尋網頁
    if (isInSearchResults && currentSearchQuery) {
      console.log('📖 [返回] 從帳戶主頁返回搜索結果頁');

      // 恢復搜索結果視圖
      document.getElementById('trending-view').style.display = 'none';
      document.getElementById('search-results-view').style.display = 'flex';

      // 顯示返回按鈕，隱藏刷新按鈕
      const backBtn = document.getElementById('search-back-btn');
      if (backBtn) backBtn.style.display = 'flex';
      const refreshBtn = document.querySelector('.refresh-trends-btn');
      if (refreshBtn) refreshBtn.style.display = 'none';

      // 顯示搜尋網頁
      document.getElementById('x-search-page').style.display = 'flex';
    } else {
      // 默認返回主頁
      document.getElementById('x-home-page').style.display = 'flex';
    }
  };

  // 顯示帳戶推文詳情
  window.showAccountTweetDetail = async function (tweetId) {
    if (!currentViewingAccount || !currentViewingAccount.tweets) {
      showXToast('無法找到推文資料', 'error');
      return;
    }

    // 從當前帳戶資料中查找推文
    const tweet = currentViewingAccount.tweets.find(t => t.id === tweetId);
    if (!tweet) {
      showXToast('未找到該推文', 'error');
      return;
    }

    // 標記資料來源為帳戶推文（避免與用戶推文混淆）
    tweet._source = 'account';
    tweet._accountHandle = (currentViewingAccount.accountInfo || currentViewingAccount).handle;

    // 使用現有的showTweetDetail函數顯示詳情
    await showTweetDetail(tweet);
  };

  // 顯示喜歡的推文詳情
  window.showLikedTweetDetail = async function (tweetId) {
    if (!currentViewingAccount || !currentViewingAccount.accountLikes) {
      showXToast('無法找到喜歡資料', 'error');
      return;
    }

    // 從喜歡列表中查找推文
    const tweet = currentViewingAccount.accountLikes.find(t => t.id === tweetId);
    if (!tweet) {
      showXToast('未找到該推文', 'error');
      return;
    }

    // 標記資料來源為喜歡的推文
    tweet._source = 'liked';
    tweet._accountHandle = (currentViewingAccount.accountInfo || currentViewingAccount).handle;

    // 使用現有的showTweetDetail函數顯示詳情
    await showTweetDetail(tweet);
  };

  // 切換關注狀態
  window.toggleAccountFollow = function () {
    const followBtn = document.getElementById('account-follow-btn');
    const notifyBtn = document.getElementById('account-notify-btn');

    const followText = getI18nText('accountFollow');
    const followingText = getI18nText('accountFollowing');

    // 獲取當前主題的顏色
    const bgPrimary = getComputedStyle(document.getElementById('x-social-screen'))
      .getPropertyValue('--x-bg-primary')
      .trim();
    const textPrimary = getComputedStyle(document.getElementById('x-social-screen'))
      .getPropertyValue('--x-text-primary')
      .trim();
    const borderColor = getComputedStyle(document.getElementById('x-social-screen'))
      .getPropertyValue('--x-border-color')
      .trim();

    if (followBtn.textContent === followText) {
      // 關注帳戶
      followBtn.textContent = followingText;
      followBtn.style.backgroundColor = bgPrimary || '#000';
      followBtn.style.color = textPrimary || '#fff';
      followBtn.style.border = `1px solid ${borderColor || '#536471'}`;
      notifyBtn.style.display = 'flex';
      showXToast('已關注該帳戶', 'success');
    } else {
      // 取消關注
      followBtn.textContent = followText;
      // 未關注狀態：反轉顏色
      followBtn.style.backgroundColor = textPrimary || '#fff';
      followBtn.style.color = bgPrimary || '#000';
      followBtn.style.border = 'none';
      notifyBtn.style.display = 'none';
      showXToast('已取消關注', 'info');
    }
  };

  // 切換通知設置
  window.toggleAccountNotifications = function () {
    showXToast('通知設置已更新', 'success');
  };

  // 發送私信
  window.sendMessageToAccount = function () {
    if (!currentViewingAccount) {
      showXToast('無法獲取帳戶資訊', 'error');
      return;
    }

    console.log('📨 從帳戶主頁打開私信詳情頁');

    // 獲取帳戶資訊
    const accountInfo = currentViewingAccount.accountInfo || currentViewingAccount;

    // 🔧 使用帳戶控制碼生成固定的 ID，避免每次都生成新 ID
    const cleanHandle = accountInfo.handle.replace('@', '');
    const accountId = `msg_account_${cleanHandle}`;

    // 構建私信資料（messageData格式）
    const messageData = {
      id: accountId,
      userName: accountInfo.name,
      userHandle: accountInfo.handle,
      userAvatar: accountInfo.avatar,
      user: {
        name: accountInfo.name,
        handle: accountInfo.handle,
        avatar: accountInfo.avatar,
        verified: accountInfo.verified || false,
      },
      lastMessage: '',
      timestamp: new Date().toISOString(),
      unread: false,
    };

    // 構建帳戶資料資料
    const profileData = {
      name: accountInfo.name,
      handle: accountInfo.handle,
      avatar: accountInfo.avatar,
      bio: accountInfo.bio || '',
      followersCount: accountInfo.followersCount || '0',
      verified: accountInfo.verified || false,
    };

    // 標記當前消息
    currentMessageConversation = messageData;
    userMessageQueue = [];

    // 隱藏帳戶主頁
    document.getElementById('account-profile-page').style.display = 'none';

    // 顯示私信詳情頁面
    document.getElementById('x-message-detail-page').style.display = 'flex';

    // 載入私信詳情
    loadCharacterMessageDetail(messageData, profileData);

    console.log('✅ 已打開私信詳情頁');
  };

  // 切換帳戶標籤
  window.switchAccountTab = function (tabName) {
    // 更新標籤樣式
    const tabs = document.querySelectorAll('.account-tab');
    tabs.forEach(tab => {
      if (tab.onclick.toString().includes(tabName)) {
        tab.style.fontWeight = '700';
        tab.style.color = '#fff';
        tab.style.borderBottom = '4px solid var(--x-accent)';
      } else {
        tab.style.fontWeight = '500';
        tab.style.color = '#71767b';
        tab.style.borderBottom = '4px solid transparent';
      }
    });

    const tweetsContainer = document.getElementById('account-tweets-container');
    tweetsContainer.innerHTML = '';

    if (tabName === 'posts') {
      // 渲染推文
      if (currentViewingAccount && currentViewingAccount.tweets) {
        const accountInfo = currentViewingAccount.accountInfo || currentViewingAccount;
        currentViewingAccount.tweets.forEach(tweet => {
          const tweetElement = createAccountTweetElement(tweet, accountInfo);
          tweetsContainer.appendChild(tweetElement);
        });
      } else {
        tweetsContainer.innerHTML = `
          <div style="padding: 60px 32px; text-align: center;">
            <div style="color: #71767b; font-size: 31px; font-weight: 800; margin-bottom: 8px;">${getI18nText(
              'accountNoPosts',
            )}</div>
            <div style="color: #71767b; font-size: 15px;">${getI18nText('accountNoPostsDesc')}</div>
          </div>
        `;
      }
    } else if (tabName === 'replies') {
      // 渲染回復
      if (
        currentViewingAccount &&
        currentViewingAccount.accountReplies &&
        currentViewingAccount.accountReplies.length > 0
      ) {
        // 過濾掉無效的回復數據
        const validReplies = currentViewingAccount.accountReplies.filter(reply => {
          if (!reply) {
            console.warn('⚠️ [帳戶標籤] 跳過無效回復: null/undefined');
            return false;
          }
          if (!reply.type) {
            console.warn('⚠️ [帳戶標籤] 跳過無效回復: 缺少 type 欄位', reply);
            return false;
          }
          return true;
        });

        if (validReplies.length > 0) {
          validReplies.forEach(reply => {
            const replyElement = createAccountReplyElement(reply);
            tweetsContainer.appendChild(replyElement);
          });
        } else {
          tweetsContainer.innerHTML = `
          <div style="padding: 60px 32px; text-align: center;">
            <div style="color: #71767b; font-size: 31px; font-weight: 800; margin-bottom: 8px;">${getI18nText(
              'accountNoReplies',
            )}</div>
            <div style="color: #71767b; font-size: 15px;">${getI18nText('accountNoRepliesDesc')}</div>
          </div>
        `;
        }
      } else {
        tweetsContainer.innerHTML = `
        <div style="padding: 60px 32px; text-align: center;">
          <div style="color: #71767b; font-size: 31px; font-weight: 800; margin-bottom: 8px;">${getI18nText(
            'accountNoReplies',
          )}</div>
            <div style="color: #71767b; font-size: 15px;">${getI18nText('accountNoRepliesDesc')}</div>
          </div>
        `;
      }
    } else if (tabName === 'likes') {
      // 渲染喜歡列表
      console.log('🔍 [喜歡列表] 開始渲染喜歡列表');
      console.log('🔍 [喜歡列表] currentViewingAccount:', currentViewingAccount);
      console.log('🔍 [喜歡列表] accountLikes數量:', currentViewingAccount?.accountLikes?.length || 0);

      if (
        currentViewingAccount &&
        currentViewingAccount.accountLikes &&
        currentViewingAccount.accountLikes.length > 0
      ) {
        console.log('✅ [喜歡清單] 找到喜歡資料，開始渲染');
        const accountInfo = currentViewingAccount.accountInfo || currentViewingAccount;
        currentViewingAccount.accountLikes.forEach((likedTweet, index) => {
          console.log(`📋 [喜歡列表] 渲染第 ${index + 1} 條喜歡:`, likedTweet.content?.substring(0, 30));
          const tweetElement = createLikedTweetElement(likedTweet, accountInfo);
          tweetsContainer.appendChild(tweetElement);
        });
        console.log(`✅ [喜歡列表] 共渲染了 ${currentViewingAccount.accountLikes.length} 條喜歡`);
      } else {
        console.warn('⚠️ [喜歡清單] 無喜歡資料，顯示空狀態');
        tweetsContainer.innerHTML = `
          <div style="padding: 60px 32px; text-align: center;">
            <div style="color: var(--x-text-secondary); font-size: 31px; font-weight: 800; margin-bottom: 8px;">${getI18nText(
              'accountNoLikes',
            )}</div>
            <div style="color: var(--x-text-secondary); font-size: 15px;">${getI18nText('accountNoLikesDesc')}</div>
        </div>
      `;
      }
    }
  };

  // 保存帳戶主頁數據到資料庫
  async function saveAccountProfile(accountData) {
    try {
      const xDB = getXDB();
      const cleanHandle = accountData.accountInfo.handle.replace('@', '');

      // 準備保存的資料
      const profileToSave = {
        handle: cleanHandle,
        name: accountData.accountInfo.name,
        accountInfo: accountData.accountInfo,
        tweets: accountData.tweets || [],
        accountReplies: accountData.accountReplies || [],
        accountLikes: accountData.accountLikes || [], // 添加喜歡資料
        updatedAt: new Date().toISOString(),
      };

      await xDB.xAccountProfiles.put(profileToSave);
      console.log(
        '✅ 帳戶主頁數據已保存:',
        cleanHandle,
        '- 推文數:',
        profileToSave.tweets.length,
        '- 回復數:',
        profileToSave.accountReplies.length,
        '- 喜歡數:',
        profileToSave.accountLikes.length,
      );
    } catch (error) {
      console.error('保存帳戶主頁數據失敗:', error);
    }
  }

  // 🆕 將推文添加到帳戶主頁（用於智慧檢測生成的推文）
  async function addTweetToAccountProfile(userHandle, tweetData) {
    try {
      const xDB = getXDB();
      const cleanHandle = userHandle.replace('@', '');

      console.log(`📝 [帳戶主頁同步] 開始將推文添加到 ${cleanHandle} 的帳戶主頁`);

      // 獲取或創建帳戶主頁數據
      let accountProfile = await xDB.xAccountProfiles.get(cleanHandle);

      if (!accountProfile) {
        // 如果帳戶主頁不存在，創建新的
        console.log(`📝 [帳戶主頁同步] 帳戶主頁不存在，創建新的主頁數據`);
        accountProfile = {
          handle: cleanHandle,
          name: tweetData.user.name,
          accountInfo: {
            name: tweetData.user.name,
            handle: userHandle,
            avatar: tweetData.user.avatar,
            verified: tweetData.user.verified || false,
            verificationType: tweetData.user.verificationType || 'verified',
          },
          tweets: [],
          accountReplies: [],
          accountLikes: [],
          updatedAt: new Date().toISOString(),
        };
      }

      // 確保 tweets 陣列存在
      if (!accountProfile.tweets) {
        accountProfile.tweets = [];
      }

      // 檢查推文是否已存在（根據ID或時間戳記）
      const isDuplicate = accountProfile.tweets.some(
        tweet => tweet.id === tweetData.id || tweet.timestamp === tweetData.timestamp,
      );

      if (isDuplicate) {
        console.log(`⏭️ [帳戶主頁同步] 推文已存在，跳過添加`);
        return;
      }

      // 添加推文到陣列
      // 🔧 確保置頂推文始終在第一位
      const pinnedTweet = accountProfile.tweets.find(t => t.pinned);
      const unpinnedTweets = accountProfile.tweets.filter(t => !t.pinned);

      // 將新推文添加到非置頂推文的開頭
      unpinnedTweets.unshift(tweetData);

      // 按時間戳記排序非置頂推文（最新的在前）
      unpinnedTweets.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));

      // 重新組合：置頂推文 → 其他推文
      if (pinnedTweet) {
        accountProfile.tweets = [pinnedTweet, ...unpinnedTweets];
      } else {
        accountProfile.tweets = unpinnedTweets;
      }

      // 更新時間
      accountProfile.updatedAt = new Date().toISOString();

      // 保存到資料庫
      await xDB.xAccountProfiles.put(accountProfile);

      console.log(
        `✅ [帳戶主頁同步] 推文已添加到 ${cleanHandle} 的主頁，當前推文總數: ${accountProfile.tweets.length}`,
      );

      // 如果當前正在查看該帳戶的主頁，刷新顯示
      if (
        currentViewingAccount &&
        (currentViewingAccount.accountInfo?.handle === userHandle || currentViewingAccount.handle === userHandle)
      ) {
        console.log(`🔄 [帳戶主頁同步] 檢測到正在查看該帳戶主頁，刷新顯示`);
        // 更新當前查看的帳戶資料
        currentViewingAccount.tweets = accountProfile.tweets;
        // 重新渲染
        renderAccountProfile(currentViewingAccount);
      }
    } catch (error) {
      console.error('❌ [帳戶主頁同步] 添加推文到帳戶主頁失敗:', error);
    }
  }

  // 切換推進模式
  window.toggleProgressMode = function () {
    isProgressMode = !isProgressMode;
    updateRefreshButtonUI();

    if (isProgressMode) {
      showXToast('已切換到推進模式 - 將生成新內容並追加', 'success');
    } else {
      showXToast('已切換到重新生成模式 - 將覆蓋現有內容', 'info');
    }
  };

  // 更新刷新按鈕UI
  function updateRefreshButtonUI() {
    const refreshBtn = document.querySelector('#account-profile-page [onclick="refreshAccountProfile()"]');
    if (!refreshBtn) return;

    // 獲取當前主題的文本顏色
    const textColor =
      getComputedStyle(document.getElementById('x-social-screen')).getPropertyValue('--x-text-primary').trim() ||
      '#fff';

    if (isProgressMode) {
      // 推進模式 - 心電圖圖示
      refreshBtn.innerHTML = `
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="${textColor}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M3 12h4.5l1.5 -6l4 12l2 -9l1.5 3h4.5" />
        </svg>
      `;
      refreshBtn.setAttribute('title', '推進帳戶主頁（生成新內容並追加）');
    } else {
      // 重新生成模式 - 刷新圖示
      refreshBtn.innerHTML = `
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="${textColor}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M9 4.55a8 8 0 0 1 6 14.9m0 -4.45v5h5" />
          <path d="M5.63 7.16l0 .01" />
          <path d="M4.06 11l0 .01" />
          <path d="M4.63 15.1l0 .01" />
          <path d="M7.16 18.37l0 .01" />
          <path d="M11 19.94l0 .01" />
        </svg>
      `;
      refreshBtn.setAttribute('title', '重新生成帳戶主頁');
    }
  }

  // 刷新按鈕長按處理
  window.handleRefreshButtonMouseDown = function () {
    progressLongPressTimer = setTimeout(() => {
      toggleProgressMode();
    }, 800); // 長按800ms觸發
  };

  window.handleRefreshButtonMouseUp = function () {
    if (progressLongPressTimer) {
      clearTimeout(progressLongPressTimer);
      progressLongPressTimer = null;
    }
  };

  // 刷新帳戶主頁（重新生成或推進）
  window.refreshAccountProfile = async function () {
    // 清除長按計時器
    if (progressLongPressTimer) {
      clearTimeout(progressLongPressTimer);
      progressLongPressTimer = null;
    }

    if (!currentViewingAccount) {
      showXToast('未找到當前帳戶資訊', 'error');
      return;
    }

    try {
      if (isProgressMode) {
        // 推進模式：生成新內容並追加
        showXToast('正在推進帳戶主頁...', 'info');
        await progressAccountProfile();
      } else {
        // 重新生成模式：覆蓋現有內容
        showXToast('正在重新生成帳戶主頁...', 'info');

        // 從當前帳戶資料中提取基本資訊
        const accountInfo = currentViewingAccount.accountInfo || currentViewingAccount;

        // 查詢帳戶資料（重新判斷帳戶類型）
        const accountData = await queryAccountData(accountInfo.name, accountInfo.handle, accountInfo.avatar);

        if (!accountData) {
          showXToast('無法載入帳戶資訊', 'error');
          return;
        }

        // 調用AI重新生成帳戶主頁內容
        const profileData = await generateAccountProfileContent(accountData);

        if (profileData) {
          // 更新帳戶資料
          currentViewingAccount = { ...accountData, ...profileData };
          console.log('📊 [帳戶主頁] 重新生成資料統計:', {
            推文數: profileData.tweets?.length || 0,
            回復數: profileData.accountReplies?.length || 0,
            喜歡數: profileData.accountLikes?.length || 0,
          });
          renderAccountProfile(currentViewingAccount);

          // 保存到資料庫（覆蓋舊資料）
          await saveAccountProfile(currentViewingAccount);
          showXToast('帳戶主頁已刷新', 'success');
        }
      }
    } catch (error) {
      console.error('刷新帳戶主頁失敗:', error);
      showXToast(`刷新失敗: ${error.message}`, 'error');
    }
  };

  // 推進帳戶主頁（生成新內容並追加）
  async function progressAccountProfile() {
    try {
      const accountInfo = currentViewingAccount.accountInfo || currentViewingAccount;

      // 查詢帳戶資料
      const accountData = await queryAccountData(accountInfo.name, accountInfo.handle, accountInfo.avatar);

      if (!accountData) {
        showXToast('無法載入帳戶資訊', 'error');
        return;
      }

      // 調用AI生成新的推文和回復（傳入現有內容作為上下文）
      const newProfileData = await generateAccountProfileContent(accountData, {
        isProgressMode: true,
        existingTweets: currentViewingAccount.tweets || [],
        existingReplies: currentViewingAccount.accountReplies || [],
      });

      if (newProfileData) {
        // 確保新推文沒有置頂標記
        if (newProfileData.tweets) {
          newProfileData.tweets.forEach(tweet => {
            tweet.pinned = false;
          });
        }

        // 合併推文：置頂動態 → 新動態 → 舊動態
        const existingTweets = currentViewingAccount.tweets || [];
        const pinnedTweet = existingTweets.find(t => t.pinned);
        const unpinnedOldTweets = existingTweets.filter(t => !t.pinned);
        const newTweets = newProfileData.tweets || [];

        let updatedTweets;
        if (pinnedTweet) {
          // 如果有置頂：置頂 → 新推文 → 舊推文
          updatedTweets = [pinnedTweet, ...newTweets, ...unpinnedOldTweets];
        } else {
          // 如果沒有置頂：新推文 → 舊推文
          updatedTweets = [...newTweets, ...unpinnedOldTweets];
        }

        // 合併回復：新回復 → 舊回復
        const updatedReplies = [
          ...(newProfileData.accountReplies || []),
          ...(currentViewingAccount.accountReplies || []),
        ];

        // 合併喜歡：新喜歡 → 舊喜歡
        const updatedLikes = [...(newProfileData.accountLikes || []), ...(currentViewingAccount.accountLikes || [])];

        console.log('📊 [推進模式] 資料合併統計:', {
          新推文: newProfileData.tweets?.length || 0,
          舊推文: (currentViewingAccount.tweets || []).filter(t => !t.pinned).length,
          合併後推文: updatedTweets.length,
          新回復: newProfileData.accountReplies?.length || 0,
          舊回復: (currentViewingAccount.accountReplies || []).length,
          合併後回復: updatedReplies.length,
          新喜歡: newProfileData.accountLikes?.length || 0,
          舊喜歡: (currentViewingAccount.accountLikes || []).length,
          合併後喜歡: updatedLikes.length,
        });

        // 更新帳戶資料
        currentViewingAccount = {
          ...currentViewingAccount,
          tweets: updatedTweets,
          accountReplies: updatedReplies,
          accountLikes: updatedLikes,
          // 保持 accountInfo 不變
          accountInfo: currentViewingAccount.accountInfo || accountInfo,
        };

        renderAccountProfile(currentViewingAccount);

        // 保存到資料庫
        await saveAccountProfile(currentViewingAccount);

        showXToast(
          `已推進：新增 ${newProfileData.tweets?.length || 0} 條推文，${
            newProfileData.accountReplies?.length || 0
          } 條回復，${newProfileData.accountLikes?.length || 0} 條喜歡`,
          'success',
        );
      }
    } catch (error) {
      console.error('推進帳戶主頁失敗:', error);
      showXToast(`推進失敗: ${error.message}`, 'error');
    }
  }
  // ▲▲▲ 【主要！！！】第七個情景：帳戶主頁生成器 ▲▲▲

  // ============================================
  // 語言切換功能
  // ============================================

  // 語言配置物件
  const languageConfig = {
    zh: {
      // 底部巡覽列
      navHome: '主頁',
      navSearch: '搜索',
      navNotifications: '通知',
      navMessages: '消息',

      // 主頁
      homeTitle: '主頁',
      homeForYou: '為你推薦',
      homeFollowing: '正在關注',
      homeCompose: '有什麼新鮮事?',
      homeNoTweets: '暫無推文',
      homeNoTweetsDesc: '開始關注一些人，或刷新查看推薦內容',

      // 搜尋網頁面
      searchTitle: '搜索',
      searchPlaceholder: '搜索',
      searchTrending: '熱門話題',
      searchNoResults: '無搜索結果',
      searchRefresh: '刷新熱搜',

      // 通知頁面
      notificationsTitle: '通知',
      notificationsTabAll: '全部',
      notificationsTabMentions: '提及',
      notificationsEmpty: '暫無通知',
      notificationsEmptyDesc: '當有人點贊、評論或關注你時，你會在這裡看到通知',
      notificationsRecommended: '推薦關注',
      notificationsLiked: '喜歡了你的帖子',
      notificationsFollowed: '關注了你',
      notificationsReplied: '回復了你',
      notificationsMentioned: '提及了你',
      notificationsRetweeted: '轉推了你的帖子',

      // 私信頁面
      messagesTitle: '私信',
      messagesEmpty: '暫無私信',
      messagesEmptyDesc: '發送私信與朋友保持聯繫',
      messageFollowers: '位關注者',
      messageInputPlaceholder: '開始寫私信',

      // 使用者資料頁面
      profileTitle: '個人資料',
      profileEditProfile: '編輯個人資料',
      profileFollowing: '正在關注',
      profileFollowers: '關注者',
      profilePosts: '帖子',
      profilePostsCount: '帖子',
      profileLikes: '喜歡',
      profileHighlights: '亮點',
      profileArticles: '文章',
      profileMedia: '媒體',
      profileNoLikes: '還沒有喜歡的推文',
      profileNoLikesDesc: '當你喜歡一條推文時，它會顯示在這裡。',
      profileNoHighlights: '還沒有收藏',
      profileNoHighlightsDesc: '點擊推文下方的書簽按鈕來收藏喜歡的內容',
      profileNoArticles: '還沒有文章',
      profileNoArticlesDesc: '發佈的文章會顯示在這裡。',
      profileNoMedia: '還沒有媒體',
      profileNoMediaDesc: '包含照片和視頻的推文會顯示在這裡。',
      profileAccountManager: '帳號管理',

      // 推文詳情頁
      tweetDetailTitle: '帖子',
      tweetDetailReply: '回復',
      tweetDetailReplyPlaceholder: '發佈你的回復',
      tweetDetailRerollTooltip: '重新生成回復',
      tweetDetailRetweets: '轉推',
      tweetDetailLikes: '喜歡',
      tweetDetailBookmarks: '書簽',
      tweetDetailViews: '查看',

      // 評論頁面
      commentsTitle: '發帖',
      commentsReply: '回復',
      commentsReplyPlaceholder: '發佈你的回復',

      // 帳戶主頁
      accountPostsCount: '個帖子',
      accountFollow: '關注',
      accountFollowing: '正在關注',
      accountFollowingLabel: '正在關注',
      accountFollowersLabel: '關注者',
      accountFollowsYou: '關注你',
      accountPostsTab: '帖子',
      accountRepliesTab: '回復',
      accountLikesTab: '喜歡',
      accountPinned: '已置頂',
      accountNoPosts: '還沒有帖子',
      accountNoPostsDesc: '該帳戶的帖子會顯示在這裡。',
      accountNoReplies: '還沒有回復',
      accountNoRepliesDesc: '該帳戶的回復會顯示在這裡。',
      accountNoLikes: '還沒有喜歡',
      accountNoLikesDesc: '該帳戶喜歡的內容會顯示在這裡。',
      accountReplyTo: '回復',
      accountLiked: '已喜歡',

      // 設置頁面
      settingsTitle: '設置',
      settingsPrompt: '提示詞',
      settingsPromptPlaceholder: '輸入系統提示詞...',
      settingsWorldView: '世界觀設定',
      settingsWorldViewPlaceholder: '描述角色所在的世界觀、背景設定...',
      settingsCharacterBinding: '綁定角色',
      settingsCharacterBindingDesc: '開啟後，綁定的角色可以在X上發佈推文',
      settingsSelectCharacter: '選擇要綁定的角色',
      settingsRelationship: '角色關係冊',
      settingsRelationshipDesc: '開啟後，可以為已綁定的角色建立關係網絡，設置角色之間的雙向關係',
      settingsRelationshipGraph: '角色關係圖',
      settingsEditGraph: '編輯關係圖',
      settingsNPCBinding: '綁定NPC',
      settingsNPCBindingDesc: '開啟後，可以創建和管理自訂NPC，設置其人設、發帖習慣和綁定用戶',
      settingsNPCList: 'NPC列表',
      settingsCreateNPC: '+ 創建NPC',
      settingsSave: '保存設置',
      settingsSavePreset: '保存為預設',
      settingsImport: '導入數據',
      settingsExport: '匯出數據',
      settingsPresetManagement: '預設管理',
      settingsWorldBooks: '世界書管理',
      settingsWorldBooksDesc: '世界書可以為AI提供額外的知識庫，支援綁定到不同場景和角色',
      settingsWorldBooksButton: '打開世界書管理面板',
      settingsAutoTweetDetection: '智慧發推檢測',
      settingsAutoTweetDetectionDesc: '開啟後，每隔5分鐘自動檢測已綁定角色的聊天記憶，生成New Tweet通知',
      settingsAutoTweetDetectionNote: '僅對設置了"角色身份識別"和"專屬用戶人設"的角色生效',
      settingsDetectionRunning: '檢測服務運行中',
      settingsNextDetectionTime: '下次檢測時間',
      settingsAutoRefreshFeed: '智能刷新主頁',
      settingsAutoRefreshFeedDesc: '開啟後，每隔10分鐘自動刷新主頁推文',
      settingsRefreshRunning: '刷新服務運行中',
      settingsNextRefreshTime: '下次刷新時間',

      // 關係圖相關
      relationshipNoData: '暫無關係數據',
      relationshipNoDataHint: '點擊上方按鈕開始創建角色關係',
      relationshipCharacterCount: '角色數',
      relationshipLinkCount: '關係數',
      relationshipAddCharacter: '+ 添加角色',
      relationshipSave: '保存關係圖',
      relationshipClose: '關閉',
      relationshipEmptyState: '暫無角色',
      relationshipEmptyStateHint: '點擊上方按鈕添加角色',

      // Toast 提示
      toastThemeLight: '已切換到日間模式',
      toastThemeDark: '已切換到夜間模式',
      toastLanguageChinese: '已切換到中文',
      toastLanguageEnglish: '已切換到英文',

      // 通用按鈕
      btnSave: '保存',
      btnCancel: '取消',
      btnEdit: '編輯',
      btnDelete: '刪除',
      btnConfirm: '確認',
    },
    en: {
      // 底部巡覽列
      navHome: 'Home',
      navSearch: 'Explore',
      navNotifications: 'Notifications',
      navMessages: 'Messages',

      // 主頁
      homeTitle: 'Home',
      homeForYou: 'For you',
      homeFollowing: 'Following',
      homeCompose: "What's happening?",
      homeNoTweets: 'No posts yet',
      homeNoTweetsDesc: 'Follow people or refresh to see recommended content',

      // 搜尋網頁面
      searchTitle: 'Explore',
      searchPlaceholder: 'Search',
      searchTrending: "What's happening",
      searchNoResults: 'No results found',
      searchRefresh: 'Refresh trends',

      // 通知頁面
      notificationsTitle: 'Notifications',
      notificationsTabAll: 'All',
      notificationsTabMentions: 'Mentions',
      notificationsEmpty: 'No notifications yet',
      notificationsEmptyDesc: "When someone likes, comments, or follows you, you'll see it here",
      notificationsRecommended: 'Recommended',
      notificationsLiked: 'liked your post',
      notificationsFollowed: 'followed you',
      notificationsReplied: 'replied to you',
      notificationsMentioned: 'mentioned you',
      notificationsRetweeted: 'retweeted your post',

      // 私信頁面
      messagesTitle: 'Messages',
      messagesEmpty: 'No messages yet',
      messagesEmptyDesc: 'Send a message to stay in touch with friends',
      messageFollowers: 'followers',
      messageInputPlaceholder: 'Start a message',

      // 使用者資料頁面
      profileTitle: 'Profile',
      profileEditProfile: 'Edit profile',
      profileFollowing: 'Following',
      profileFollowers: 'Followers',
      profilePosts: 'Posts',
      profilePostsCount: 'posts',
      profileLikes: 'Likes',
      profileHighlights: 'Highlights',
      profileArticles: 'Articles',
      profileMedia: 'Media',
      profileNoLikes: 'No liked posts yet',
      profileNoLikesDesc: 'When you like a post, it will show up here.',
      profileNoHighlights: 'No bookmarks yet',
      profileNoHighlightsDesc: 'Tap the bookmark button below posts to save your favorites',
      profileNoArticles: 'No articles yet',
      profileNoArticlesDesc: 'Published articles will show up here.',
      profileNoMedia: 'No media yet',
      profileNoMediaDesc: 'Posts with photos and videos will show up here.',
      profileAccountManager: 'Account Manager',

      // 推文詳情頁
      tweetDetailTitle: 'Post',
      tweetDetailReply: 'Reply',
      tweetDetailReplyPlaceholder: 'Post your reply',
      tweetDetailRerollTooltip: 'Regenerate replies',
      tweetDetailRetweets: 'Reposts',
      tweetDetailLikes: 'Likes',
      tweetDetailBookmarks: 'Bookmarks',
      tweetDetailViews: 'Views',

      // 評論頁面
      commentsTitle: 'Post',
      commentsReply: 'Reply',
      commentsReplyPlaceholder: 'Post your reply',

      // 帳戶主頁
      accountPostsCount: 'posts',
      accountFollow: 'Follow',
      accountFollowing: 'Following',
      accountFollowingLabel: 'Following',
      accountFollowersLabel: 'Followers',
      accountFollowsYou: 'Follows you',
      accountPostsTab: 'Posts',
      accountRepliesTab: 'Replies',
      accountLikesTab: 'Likes',
      accountPinned: 'Pinned',
      accountNoPosts: 'No posts yet',
      accountNoPostsDesc: 'Posts from this account will show up here.',
      accountNoReplies: 'No replies yet',
      accountNoRepliesDesc: 'Replies from this account will show up here.',
      accountNoLikes: 'No likes yet',
      accountNoLikesDesc: 'Liked posts will show up here.',
      accountReplyTo: 'Replying to',
      accountLiked: 'liked',

      // 設置頁面
      settingsTitle: 'Settings',
      settingsPrompt: 'System Prompt',
      settingsPromptPlaceholder: 'Enter system prompt...',
      settingsWorldView: 'World Setting',
      settingsWorldViewPlaceholder: 'Describe the world setting and background...',
      settingsCharacterBinding: 'Character Binding',
      settingsCharacterBindingDesc: 'When enabled, bound characters can post on X',
      settingsSelectCharacter: 'Select Character to Bind',
      settingsRelationship: 'Character Relations',
      settingsRelationshipDesc: 'When enabled, create relationship networks for bound characters',
      settingsRelationshipGraph: 'Relationship Graph',
      settingsEditGraph: 'Edit Graph',
      settingsNPCBinding: 'NPC Binding',
      settingsNPCBindingDesc: 'When enabled, create and manage custom NPCs',
      settingsNPCList: 'NPC List',
      settingsCreateNPC: '+ Create NPC',
      settingsSave: 'Save Settings',
      settingsSavePreset: 'Save as Preset',
      settingsImport: 'Import Data',
      settingsExport: 'Export Data',
      settingsPresetManagement: 'Preset Management',
      settingsWorldBooks: 'World Books',
      settingsWorldBooksDesc:
        'World books provide additional knowledge base for AI, can be bound to different scenes and characters',
      settingsWorldBooksButton: 'Open World Books Panel',
      settingsAutoTweetDetection: 'Auto Tweet Detection',
      settingsAutoTweetDetectionDesc:
        'When enabled, automatically detect chat history of bound characters every 5 minutes and generate New Tweet notifications',
      settingsAutoTweetDetectionNote:
        'Only effective for characters with "Identity Recognition" and "Exclusive User Persona" settings',
      settingsDetectionRunning: 'Detection service running',
      settingsNextDetectionTime: 'Next detection time',
      settingsAutoRefreshFeed: 'Auto Refresh Feed',
      settingsAutoRefreshFeedDesc: 'When enabled, automatically refresh feed every 10 minutes',
      settingsRefreshRunning: 'Refresh service running',
      settingsNextRefreshTime: 'Next refresh time',

      // 關係圖相關
      relationshipNoData: 'No relationship data',
      relationshipNoDataHint: 'Click button above to create character relationships',
      relationshipCharacterCount: 'Characters',
      relationshipLinkCount: 'Relations',
      relationshipAddCharacter: '+ Add Character',
      relationshipSave: 'Save Graph',
      relationshipClose: 'Close',
      relationshipEmptyState: 'No characters',
      relationshipEmptyStateHint: 'Click button above to add characters',

      // Toast 提示
      toastThemeLight: 'Switched to Light Mode',
      toastThemeDark: 'Switched to Dark Mode',
      toastLanguageChinese: 'Switched to Chinese',
      toastLanguageEnglish: 'Switched to English',

      // 通用按鈕
      btnSave: 'Save',
      btnCancel: 'Cancel',
      btnEdit: 'Edit',
      btnDelete: 'Delete',
      btnConfirm: 'Confirm',
    },
  };

  // 當前語言
  let currentLanguage = 'zh';

  // 切換語言
  async function toggleXLanguage() {
    try {
      // 切換語言
      currentLanguage = currentLanguage === 'zh' ? 'en' : 'zh';

      // 應用語言
      applyLanguage(currentLanguage);

      // 保存語言偏好到資料庫
      const xDb = getXDB();
      const settingsId = `xLanguage_${currentAccountId || 'main'}`;
      await xDb.xSettings.put({
        id: settingsId,
        language: currentLanguage,
        updatedAt: new Date().toISOString(),
      });

      console.log(`🌐 語言已切換為: ${currentLanguage === 'zh' ? '中文' : 'English'}`);
      showXToast(
        currentLanguage === 'zh' ? languageConfig.zh.toastLanguageChinese : languageConfig.en.toastLanguageEnglish,
        'success',
      );
    } catch (error) {
      console.error('語言切換失敗:', error);
      showXToast('Language switch failed', 'error');
    }
  }

  // 獲取當前語言的翻譯文本
  function getI18nText(key) {
    const config = languageConfig[currentLanguage] || languageConfig['zh'];
    return config[key] || key;
  }

  // 應用語言到介面
  function applyLanguage(lang) {
    const config = languageConfig[lang];
    if (!config) return;

    console.log(`🌐 正在應用語言: ${lang}`);

    // 更新語言按鈕文本
    const languageText = document.getElementById('language-text');
    if (languageText) {
      languageText.textContent = lang === 'zh' ? '中文' : 'EN';
    }

    // 更新所有帶 data-i18n 屬性的元素
    document.querySelectorAll('[data-i18n]').forEach(el => {
      const key = el.getAttribute('data-i18n');
      if (config[key]) {
        if (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA') {
          el.placeholder = config[key];
        } else {
          // 對於其他元素，更新文本內容
          el.textContent = config[key];
        }
      }
    });

    // 更新用戶主頁頂部的帖子計數（需要動態生成）
    const profileHeaderCount = document.getElementById('x-profile-header-count');
    if (profileHeaderCount && profileHeaderCount.textContent) {
      const count = profileHeaderCount.textContent.match(/\d+/);
      if (count) {
        profileHeaderCount.textContent = `${count[0]} ${config.profilePostsCount}`;
      }
    }

    // 更新推文詳情頁的動態內容
    updateTweetDetailLanguage(config);

    // 更新帳戶主頁的動態內容
    updateAccountProfileLanguage(config);

    // 保存當前語言
    console.log(`✅ 語言已應用: ${lang === 'zh' ? '中文' : 'English'}`);
  }

  // 更新帳戶主頁的語言
  function updateAccountProfileLanguage(config) {
    // 更新帖子計數
    const accountNavCount = document.getElementById('account-profile-nav-count');
    if (accountNavCount && accountNavCount.textContent) {
      const count = accountNavCount.textContent.match(/\d+/);
      if (count) {
        accountNavCount.textContent = `${count[0]} ${config.accountPostsCount}`;
      }
    }

    // 更新關注按鈕文本
    const followBtn = document.getElementById('account-follow-btn');
    if (followBtn) {
      if (followBtn.textContent.includes('Following') || followBtn.textContent.includes('正在關注')) {
        followBtn.textContent = config.accountFollowing;
      } else if (followBtn.textContent.includes('Follow') || followBtn.textContent.includes('關注')) {
        followBtn.textContent = config.accountFollow;
      }
    }
  }

  // 更新推文詳情頁的語言
  function updateTweetDetailLanguage(config) {
    // 更新互動資料標籤
    const statsDiv = document.getElementById('tweet-detail-stats');
    if (statsDiv) {
      const spans = statsDiv.querySelectorAll('span[style*="color: #71767b"]');
      if (spans.length >= 3) {
        spans[0].textContent = config.tweetDetailRetweets;
        spans[1].textContent = config.tweetDetailLikes;
        spans[2].textContent = config.tweetDetailBookmarks;
      }
    }

    // 更新查看次數標籤
    const viewsLabel = document.getElementById('tweet-detail-views-label');
    if (viewsLabel) {
      viewsLabel.textContent = config.tweetDetailViews;
    }
  }

  // 載入保存的語言偏好
  async function loadLanguagePreference() {
    try {
      const xDb = getXDB();
      const settingsId = `xLanguage_${currentAccountId || 'main'}`;
      const savedSettings = await xDb.xSettings.get(settingsId);

      if (savedSettings && savedSettings.language) {
        currentLanguage = savedSettings.language;
        applyLanguage(currentLanguage);
      }
    } catch (error) {
      console.error('載入語言偏好失敗:', error);
    }
  }

  // ============================================
  // 主題切換功能
  // ============================================

  // 切換日間/夜間主題
  async function toggleXTheme() {
    try {
      const xSocialScreen = document.getElementById('x-social-screen');
      if (!xSocialScreen) return;

      const isLightMode = xSocialScreen.classList.contains('x-theme-light');
      const newTheme = isLightMode ? 'dark' : 'light';

      // 切換主題類
      if (newTheme === 'light') {
        xSocialScreen.classList.add('x-theme-light');
      } else {
        xSocialScreen.classList.remove('x-theme-light');
      }

      // 更新圖示顯示
      const darkIcon = document.getElementById('theme-icon-dark');
      const lightIcon = document.getElementById('theme-icon-light');

      if (newTheme === 'light') {
        darkIcon.style.display = 'none';
        lightIcon.style.display = 'block';
      } else {
        darkIcon.style.display = 'block';
        lightIcon.style.display = 'none';
      }

      // 保存主題偏好到資料庫
      const xDb = getXDB();
      const settingsId = `xTheme_${currentAccountId || 'main'}`;
      await xDb.xSettings.put({
        id: settingsId,
        theme: newTheme,
        updatedAt: new Date().toISOString(),
      });

      // 應用主題到所有動態元素
      applyThemeToElements(newTheme);

      // 重新渲染關係圖畫布（如果當前打開）
      const relationshipModal = document.getElementById('character-relationship-graph-modal');
      if (relationshipModal && relationshipModal.style.display !== 'none') {
        renderRelationshipGraph();
      }

      // 重新渲染關係預覽畫布（如果關係冊已開啟）
      const relationshipArea = document.getElementById('relationship-binding-area');
      if (relationshipArea && relationshipArea.style.display !== 'none') {
        setTimeout(() => {
          updateRelationshipPreview();
        }, 100);
      }

      console.log(`🎨 主題已切換為: ${newTheme === 'light' ? '日間模式' : '夜間模式'}`);
      const config = languageConfig[currentLanguage] || languageConfig.zh;
      showXToast(newTheme === 'light' ? config.toastThemeLight : config.toastThemeDark, 'success');
    } catch (error) {
      console.error('主題切換失敗:', error);
      showXToast('主題切換失敗', 'error');
    }
  }

  // 應用主題到動態元素
  function applyThemeToElements(theme) {
    const xSocialScreen = document.getElementById('x-social-screen');
    if (!xSocialScreen) return;

    const isLight = theme === 'light';

    // 更新所有需要動態更新的元素
    const elementsToUpdate = {
      // 背景色
      '.x-top-bar, .x-bottom-nav, .settings-header, .tweet-detail-header, .compose-header, .modal-header, .account-header':
        {
          backgroundColor: isLight ? '#fff' : '#000',
          borderBottomColor: isLight ? '#eff3f4' : '#2f3336',
        },
      // 文本色
      '.tweet-user-name, .tweet-content, .comment-content': {
        color: isLight ? '#0f1419' : '#fff',
      },
      // 次要文本色
      '.tweet-user-handle, .tweet-time, .comment-time': {
        color: isLight ? '#536471' : '#71767b',
      },
      // 邊框色
      '.tweet-item, .comment-item, .settings-section': {
        borderBottomColor: isLight ? '#eff3f4' : '#2f3336',
      },
      // 輸入框背景
      'textarea, input[type="text"]': {
        backgroundColor: isLight ? '#f7f9f9' : '#1a1a1a',
        borderColor: isLight ? '#eff3f4' : '#333',
        color: isLight ? '#0f1419' : '#fff',
      },
    };

    // 應用樣式（這些樣式會在下次頁面渲染時生效，當前頁面的內聯樣式會覆蓋）
    // 主要是為新生成的元素設置正確的主題
  }

  // 載入保存的主題偏好
  async function loadXThemePreference() {
    try {
      const xDb = getXDB();
      const settingsId = `xTheme_${currentAccountId || 'main'}`;
      const themeSettings = await xDb.xSettings.get(settingsId);

      if (themeSettings && themeSettings.theme) {
        const xSocialScreen = document.getElementById('x-social-screen');
        if (!xSocialScreen) return;

        if (themeSettings.theme === 'light') {
          xSocialScreen.classList.add('x-theme-light');

          // 更新圖示顯示
          const darkIcon = document.getElementById('theme-icon-dark');
          const lightIcon = document.getElementById('theme-icon-light');
          if (darkIcon && lightIcon) {
            darkIcon.style.display = 'none';
            lightIcon.style.display = 'block';
          }

          applyThemeToElements('light');
        }

        console.log(`🎨 已載入主題偏好: ${themeSettings.theme === 'light' ? '日間模式' : '夜間模式'}`);
      }
    } catch (error) {
      console.error('載入主題偏好失敗:', error);
    }
  }

  // ============================================
  // 主題色自訂功能
  // ============================================

  // 預設主題色
  const presetAccentColors = [
    { name: 'Twitter藍', color: '#1d9bf0' },
    { name: '薰衣草紫', color: '#7856ff' },
    { name: '玫瑰粉', color: '#f91880' },
    { name: '翡翠綠', color: '#00ba7c' },
    { name: '橙色', color: '#ff7a00' },
    { name: '紅色', color: '#f4212e' },
    { name: '黃色', color: '#ffd400' },
    { name: '青色', color: '#00d4ff' },
  ];

  // 打開主題色選擇器
  function openAccentColorPicker() {
    // 創建彈窗
    const modal = document.createElement('div');
    modal.id = 'accent-color-picker-modal';
    modal.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      backdrop-filter: blur(4px);
    `;

    const xSocialScreen = document.getElementById('x-social-screen');
    const currentAccent = getComputedStyle(xSocialScreen).getPropertyValue('--x-accent').trim();

    modal.innerHTML = `
      <div style="
        background-color: var(--x-bg-primary);
        border-radius: 16px;
        width: 90%;
        max-width: 400px;
        border: 1px solid var(--x-border-color);
        overflow: hidden;
      ">
        <!-- 彈窗頭部 -->
        <div style="
          padding: 20px;
          border-bottom: 1px solid var(--x-border-color);
          display: flex;
          align-items: center;
          justify-content: space-between;
        ">
          <h3 style="margin: 0; color: var(--x-text-primary); font-size: 20px; font-weight: 700;">選擇主題色</h3>
          <button onclick="closeAccentColorPicker()" style="
            background: transparent;
            border: none;
            color: var(--x-text-secondary);
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            transition: background-color 0.2s;
          " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
             onmouseout="this.style.backgroundColor='transparent'">
            <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: currentColor;">
              <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
            </svg>
          </button>
        </div>

        <!-- 預設顏色 -->
        <div style="padding: 20px;">
          <div style="color: var(--x-text-primary); font-size: 15px; font-weight: 600; margin-bottom: 12px;">預設顏色</div>
          <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px; margin-bottom: 20px;">
            ${presetAccentColors
              .map(
                preset => `
              <div onclick="applyAccentColor('${preset.color}')" style="
                cursor: pointer;
                aspect-ratio: 1;
                border-radius: 8px;
                background-color: ${preset.color};
                border: 3px solid ${preset.color === currentAccent ? 'var(--x-text-primary)' : 'transparent'};
                transition: all 0.2s;
                position: relative;
                display: flex;
                align-items: center;
                justify-content: center;
              " onmouseover="this.style.transform='scale(1.05)'"
                 onmouseout="this.style.transform='scale(1)'">
                ${
                  preset.color === currentAccent
                    ? '<svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: #fff;"><path d="M9 16.17L5.53 12.7l-1.06 1.06L9 18.3l9.54-9.54-1.06-1.06L9 16.17z"/></svg>'
                    : ''
                }
              </div>
            `,
              )
              .join('')}
          </div>

          <!-- 自訂顏色 -->
          <div style="color: var(--x-text-primary); font-size: 15px; font-weight: 600; margin-bottom: 12px;">自訂顏色</div>
          <div style="display: flex; gap: 12px; align-items: center;">
            <input type="color" id="custom-accent-color" value="${currentAccent}" style="
              width: 60px;
              height: 40px;
              border: 2px solid var(--x-border-color);
              border-radius: 8px;
              cursor: pointer;
              background: transparent;
            ">
            <button onclick="applyAccentColor(document.getElementById('custom-accent-color').value)" style="
              flex: 1;
              background-color: var(--x-accent);
              color: #fff;
              border: none;
              border-radius: 20px;
              padding: 10px 20px;
              font-size: 15px;
              font-weight: 700;
              cursor: pointer;
              transition: opacity 0.2s;
            " onmouseover="this.style.opacity='0.9'"
               onmouseout="this.style.opacity='1'">
              應用
            </button>
          </div>

          <!-- 重新開機按鈕 -->
          <button onclick="applyAccentColor('#1d9bf0')" style="
            width: 100%;
            margin-top: 16px;
            background: transparent;
            color: var(--x-text-secondary);
            border: 1px solid var(--x-border-color);
            border-radius: 20px;
            padding: 10px 20px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s;
          " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
             onmouseout="this.style.backgroundColor='transparent'">
            重置為默認色
          </button>
        </div>
      </div>
    `;

    document.body.appendChild(modal);

    // 點擊背景關閉
    modal.addEventListener('click', e => {
      if (e.target === modal) {
        closeAccentColorPicker();
      }
    });
  }

  // 關閉主題色選擇器
  function closeAccentColorPicker() {
    const modal = document.getElementById('accent-color-picker-modal');
    if (modal) {
      modal.remove();
    }
  }

  // 應用主題色
  async function applyAccentColor(color) {
    try {
      const xSocialScreen = document.getElementById('x-social-screen');
      if (!xSocialScreen) return;

      // 更新CSS變數
      xSocialScreen.style.setProperty('--x-accent', color);

      // 保存到資料庫
      const xDb = getXDB();
      const settingsId = `xAccentColor_${currentAccountId || 'main'}`;
      await xDb.xSettings.put({
        id: settingsId,
        accentColor: color,
        updatedAt: new Date().toISOString(),
      });

      showXToast('主題色已更新', 'success');
      closeAccentColorPicker();

      console.log('✅ 主題色已應用:', color);
    } catch (error) {
      console.error('應用主題色失敗:', error);
      showXToast('應用主題色失敗', 'error');
    }
  }

  // 載入保存的主題色
  async function loadAccentColorPreference() {
    try {
      const xDb = getXDB();
      const settingsId = `xAccentColor_${currentAccountId || 'main'}`;
      const savedSettings = await xDb.xSettings.get(settingsId);

      if (savedSettings && savedSettings.accentColor) {
        const xSocialScreen = document.getElementById('x-social-screen');
        if (xSocialScreen) {
          xSocialScreen.style.setProperty('--x-accent', savedSettings.accentColor);
          console.log('✅ 已載入主題色:', savedSettings.accentColor);
        }
      }
    } catch (error) {
      console.error('載入主題色偏好失敗:', error);
    }
  }
  // ============================================
  // 帳戶提問箱功能
  // ============================================

  // 帳戶提問箱資料（臨時存儲）
  let accountAskboxData = {
    avatar: 'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg',
    nickname: '⩌⌯⩌',
    prompt: '在這裡輸入你的匿名提問，或點擊下方按鈕生成隨機提問...',
    background: 'https://i.postimg.cc/tJvBC00j/mmexport1759642131681.jpg',
    answeredQuestions: [],
  };

  // 🎯 使用者當前輸入的提問（臨時存儲，不保存到資料庫）
  let currentUserQuestion = '';

  // 帳戶提問箱多選刪除相關變數
  let isAccountAskboxMultiSelectMode = false;
  let selectedAccountQuestions = new Set();
  let accountQuestionLongPressTimer = null;

  // 打開帳戶提問箱
  window.openAccountAskbox = async function () {
    if (!currentViewingAccount) {
      showXToast('未找到當前帳戶資訊', 'error');
      return;
    }

    try {
      // 載入該帳戶的提問箱資料
      await loadAccountAskboxData();

      // 隱藏帳戶主頁，顯示提問箱頁面
      document.getElementById('account-profile-page').style.display = 'none';
      document.getElementById('account-askbox-page').style.display = 'flex';
    } catch (error) {
      console.error('打開帳戶提問箱失敗:', error);
      showXToast('打開提問箱失敗: ' + error.message, 'error');
    }
  };

  // 關閉帳戶提問箱
  window.closeAccountAskbox = function () {
    // 退出多選模式
    if (isAccountAskboxMultiSelectMode) {
      exitAccountAskboxMultiSelectMode();
    }

    document.getElementById('account-askbox-page').style.display = 'none';
    document.getElementById('account-profile-page').style.display = 'flex';
  };

  // 從資料庫載入帳戶提問箱資料
  async function loadAccountAskboxDataFromDB() {
    try {
      const xDb = getXDB();
      const accountInfo = currentViewingAccount.accountInfo || currentViewingAccount;
      const accountHandle = accountInfo.handle.replace('@', '');
      const askboxId = `account_askbox_${accountHandle}`;

      const savedData = await xDb.xAccountAskbox.get(askboxId);

      if (savedData) {
        // 從資料庫載入
        Object.assign(accountAskboxData, savedData);
        console.log('✅ 帳戶提問箱資料已從資料庫載入:', accountHandle);
      } else {
        // 使用預設資料並保存到資料庫
        accountAskboxData = {
          avatar: 'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg',
          nickname: '⩌⌯⩌',
          prompt: '在這裡輸入你的匿名提問，或點擊下方按鈕生成隨機提問...',
          background: 'https://i.postimg.cc/tJvBC00j/mmexport1759642131681.jpg',
          answeredQuestions: [],
          id: askboxId,
        };
        await xDb.xAccountAskbox.put(accountAskboxData);
        console.log('✅ 已創建預設帳戶提問箱資料:', accountHandle);
      }
    } catch (error) {
      console.error('❌ 載入帳戶提問箱資料失敗:', error);
    }
  }

  // 保存帳戶提問箱資料到資料庫
  async function saveAccountAskboxDataToDB() {
    try {
      const xDb = getXDB();
      const accountInfo = currentViewingAccount.accountInfo || currentViewingAccount;
      const accountHandle = accountInfo.handle.replace('@', '');
      const askboxId = `account_askbox_${accountHandle}`;

      accountAskboxData.id = askboxId;
      await xDb.xAccountAskbox.put(accountAskboxData);
      console.log('✅ 帳戶提問箱資料已保存到資料庫:', accountHandle);
    } catch (error) {
      console.error('❌ 保存帳戶提問箱資料失敗:', error);
    }
  }

  // 載入帳戶提問箱資料到UI
  async function loadAccountAskboxData() {
    // 從資料庫載入
    await loadAccountAskboxDataFromDB();

    // 🎯 清空用戶提問（每次進入都重置）
    currentUserQuestion = '';

    // 更新UI
    const avatarEl = document.getElementById('account-askbox-avatar');
    const nicknameEl = document.getElementById('account-askbox-nickname');
    const promptEl = document.getElementById('account-askbox-prompt');
    const backgroundEl = document.getElementById('account-askbox-background');

    if (avatarEl) avatarEl.src = accountAskboxData.avatar;
    if (nicknameEl) nicknameEl.textContent = accountAskboxData.nickname;
    // 🎯 每次進入都恢復預設文字
    if (promptEl) promptEl.textContent = '在這裡輸入你的匿名提問，或點擊下方按鈕生成隨機提問...';
    if (backgroundEl) backgroundEl.style.backgroundImage = `url('${accountAskboxData.background}')`;

    // 渲染已回答的提問列表
    renderAccountAnsweredQuestions();
  }

  // 修改帳戶提問箱頭像
  window.changeAccountAskboxAvatar = async function () {
    const newAvatar = prompt('請輸入新的頭像URL:', accountAskboxData.avatar);
    if (newAvatar && newAvatar.trim()) {
      accountAskboxData.avatar = newAvatar.trim();
      const avatarEl = document.getElementById('account-askbox-avatar');
      if (avatarEl) avatarEl.src = accountAskboxData.avatar;

      // 保存到資料庫
      await saveAccountAskboxDataToDB();
      showXToast('頭像已更新並保存', 'success');
    }
  };

  // 保存帳戶提問箱昵稱（原處編輯）
  window.saveAccountAskboxNickname = async function () {
    const nicknameEl = document.getElementById('account-askbox-nickname');
    if (!nicknameEl) return;

    const newNickname = nicknameEl.textContent.trim();
    if (newNickname && newNickname !== accountAskboxData.nickname) {
      accountAskboxData.nickname = newNickname;
      await saveAccountAskboxDataToDB();
      console.log('✅ 昵稱已自動保存:', newNickname);
    }
  };

  // 保存帳戶提問卡片文字（使用者提問輸入）
  window.saveAccountAskboxPrompt = async function () {
    const promptEl = document.getElementById('account-askbox-prompt');
    if (!promptEl) return;

    const newText = promptEl.textContent.trim();
    const defaultPrompt = '在這裡輸入你的匿名提問，或點擊下方按鈕生成隨機提問...';

    // 🎯 如果不是預設文字，則視為使用者輸入的提問
    if (newText && newText !== defaultPrompt) {
      currentUserQuestion = newText;
      console.log('📝 [提問箱] 用戶輸入了提問:', currentUserQuestion);
    } else {
      currentUserQuestion = '';
      console.log('📝 [提問箱] 用戶清空了提問');
    }
  };

  // 打開帳戶提問箱設置
  window.openAccountAskboxSettings = function () {
    const newBackground = prompt('請輸入新的背景圖URL:', accountAskboxData.background);
    if (newBackground && newBackground.trim()) {
      accountAskboxData.background = newBackground.trim();
      const backgroundEl = document.getElementById('account-askbox-background');
      if (backgroundEl) backgroundEl.style.backgroundImage = `url('${accountAskboxData.background}')`;

      // 保存到資料庫
      saveAccountAskboxDataToDB();
      showXToast('背景圖已更新並保存', 'success');
    }
  };

  // 獲取新的提問（帳戶提問箱AI生成）
  window.getNewAccountQuestion = async function () {
    if (!currentViewingAccount) {
      showXToast('未找到當前帳戶資訊', 'error');
      return;
    }

    try {
      // 🔍 檢查是否有用戶提問
      const isUserQuestion = currentUserQuestion && currentUserQuestion.trim().length > 0;

      if (isUserQuestion) {
        console.log('🎯 [提問箱] 檢測到用戶提問，準備生成回答:', currentUserQuestion);
        showXToast('正在生成回答...', 'info');
      } else {
        console.log('🎲 [提問箱] 沒有用戶提問，生成隨機問答');
        showXToast('正在生成新的提問...', 'info');
      }

      // 從資料庫讀取API配置和X設置
      const db = getDB();
      const xDb = getXDB();

      const apiConfig = await db.apiConfig.get('main');
      if (!apiConfig || !apiConfig.proxyUrl || !apiConfig.apiKey || !apiConfig.model) {
        showXToast('請先配置API設置', 'error');
        return;
      }

      const { proxyUrl, apiKey, model } = apiConfig;

      // 從X設置中讀取配置（按帳號讀取）
      const settingsId = `xSettings_${currentAccountId || 'main'}`;
      const xSettings = await xDb.xSettings.get(settingsId);
      const userPrompt = xSettings?.systemPrompt || '';
      const worldSetting = xSettings?.worldSetting || '';

      // 獲取帳戶資訊
      const accountInfo = currentViewingAccount.accountInfo || currentViewingAccount;
      const accountHandle = accountInfo.handle.replace('@', '');

      // 🎯 使用統一資料獲取系統
      const accountProfile = await StringBuilders.getUnifiedProfile(accountInfo.handle);

      if (!accountProfile) {
        showXToast('無法獲取帳戶資料', 'error');
        return;
      }

      console.log('📋 [提問箱] 帳戶類型:', accountProfile.type);

      // 使用工具函數格式化帳戶資料
      let accountDetailInfo = StringBuilders.formatProfileForPrompt(accountProfile, {
        includeType: true,
        includeTweets: false, // 推文資訊單獨處理
        includeRelationships: true,
      });

      // 獲取該帳戶已有的推文（最近5條）
      let accountTweetsInfo = '';
      if (currentViewingAccount.tweets && currentViewingAccount.tweets.length > 0) {
        accountTweetsInfo = `\n【該帳戶最近發佈的推文】：\n`;
        currentViewingAccount.tweets.slice(0, 5).forEach((tweet, i) => {
          accountTweetsInfo += `${i + 1}. ${tweet.content}${tweet.time ? ` (${tweet.time})` : ''}`;
          // 添加圖片資訊
          if (tweet.image) {
            if (tweet.image.type === 'description') {
              accountTweetsInfo += `\n   [圖片描述: ${tweet.image.content}]`;
            } else if (tweet.image.type === 'upload') {
              accountTweetsInfo += `\n   [包含上傳的圖片]`;
            }
          }
          // 添加媒體資訊（如果使用media欄位）
          if (tweet.media && tweet.media.length > 0) {
            tweet.media.forEach(m => {
              if (m.type === 'description' && m.description) {
                accountTweetsInfo += `\n   [圖片描述: ${m.description}]`;
              }
            });
          }
          accountTweetsInfo += '\n';
        });
      }

      // 獲取使用者的X資料（提問者的身份資訊）
      const userXProfileInfo = StringBuilders.buildUserXProfileInfo(window.userProfileData);

      // 獲取情侶角色的X資料（如果有的話）
      let coupleCharacterInfo = '';
      if (accountProfile.relationships && accountProfile.relationships.length > 0) {
        const coupleRelation = accountProfile.relationships.find(rel => rel.relationshipType === '戀人');
        if (coupleRelation) {
          coupleCharacterInfo = `\n【該帳戶的情侶關係】：\n與 ${coupleRelation.npcName}（${coupleRelation.npcHandle}）是戀人關係`;
          if (coupleRelation.description) {
            coupleCharacterInfo += `\n${coupleRelation.description}`;
          }
        }
      }

      // 收集已有的提問（如果要重新生成）
      let existingQuestionsContext = '';
      if (accountAskboxData.answeredQuestions.length > 0) {
        existingQuestionsContext = `\n【已有的提問清單（需要重新生成回答）】：\n`;
        accountAskboxData.answeredQuestions.forEach((q, i) => {
          existingQuestionsContext += `${i + 1}. ${q.question}\n`;
        });
      }

      // 構建系統提示詞
      let systemPrompt = StringBuilders.buildBaseSystemPrompt({
        userPrompt,
        worldSetting,
      });

      // 🎯 根據是否有使用者提問，構建不同的提示詞
      let userQuestionContext = '';
      if (isUserQuestion) {
        userQuestionContext = `\n【🔴 用戶匿名提問（必須回答）】：\n"${currentUserQuestion}"\n`;
      }

      systemPrompt += `

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 核心任務說明 - 帳戶提問箱生成 🎯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
你需要為該帳戶生成匿名提問，並以該帳戶的身份回答這些提問。

${accountDetailInfo}
${accountTweetsInfo}
${coupleCharacterInfo}
${userQuestionContext}
${existingQuestionsContext}

【生成要求】：
1. ${
        isUserQuestion
          ? `必須回答用戶的匿名提問"${currentUserQuestion}"，同時額外生成2-5個隨機問答`
          : existingQuestionsContext
          ? '如果有已有提問列表，請基於這些提問重新生成回答'
          : '生成3-10個適合該帳戶身份的匿名提問'
      }
2. ${isUserQuestion ? '用戶提問是完全匿名的，不要在回答中假設提問者的身份' : '提問要自然、真實，符合匿名提問箱的風格'}
3. ${isUserQuestion ? '' : '提問內容要與帳戶的X平臺公開信息相關（X姓名、簡介、公開身份、最近推文）'}
4. ${
        accountProfile.type === 'character' || accountProfile.type === 'npc'
          ? '回答必須嚴格符合角色/NPC的人設和性格特點'
          : '回答要自然、真實'
      }
5. ${
        isUserQuestion
          ? '回答用戶提問時要自然、真誠，體現帳戶的性格和口吻'
          : `提問可以是：
   - 關於最近推文內容的追問或評論
   - 關於生活經驗、情感態度的詢問
   - 關於興趣愛好、日常生活的好奇
   - 輕鬆幽默或真誠的話題`
      }
6. ${isUserQuestion ? '' : '提問長度適中（10-50字）'}
7. 回答要體現該帳戶的性格和口吻，長度適中（20-100字）
8. ${isUserQuestion ? '' : '避免過於私密、冒犯或不適當的問題'}

${
  !isUserQuestion
    ? `【🔒 隱私保護規則 - 匿名提問限制】：
🚨 匿名提問者只能基於該帳戶的X平臺公開信息：
  ✅ 可以基於：X姓名、X控制碼、X簡介、公開身份、公開的推文內容
  ❌ 禁止提及：真實姓名、真實職業、私密關係、未公開的身份資訊
  ❌ 禁止使用：只有親密關係才知道的稱呼（如"老師"、"同學"等，除非是公開身份）
  
示例說明：
- ✅ 正確："姐姐你平時喜歡什麼類型的音樂啊？"（基於公開稱呼）
- ❌ 錯誤："張老師今天上課講了什麼內容？"（洩露了真實姓氏和職業）
- ❌ 錯誤："同學你這次考試考得怎麼樣？"（假裝是同學關係）

⚠️ 回答也要注意：不要在回答中主動洩露私密資訊，除非是角色本人想公開`
    : ''
}

【返回格式】：
返回JSON陣列，每個物件包含question和answer欄位：

\`\`\`json
[
  {"question": "提問內容1", "answer": "該帳戶的回答1"},
  {"question": "提問內容2", "answer": "該帳戶的回答2"},
  {"question": "提問內容3", "answer": "該帳戶的回答3"}
]
\`\`\`

【重要】：
- 必須返回有效的JSON陣列格式
- question是匿名提問的內容
- answer是該帳戶以自己的身份和人設回答的內容
- ${
        isUserQuestion
          ? `請務必包含用戶提問"${currentUserQuestion}"的回答，並額外生成2-5組隨機問答，將用戶問答自然混入其中，不要特殊化`
          : existingQuestionsContext
          ? `請基於已有的${accountAskboxData.answeredQuestions.length}個提問重新生成回答`
          : '生成3-10組問答'
      }

現在，請生成JSON格式的問答內容：`;

      const messages = [
        {
          role: 'user',
          content: isUserQuestion
            ? `請回答用戶的匿名提問"${currentUserQuestion}"，同時生成2-5組隨機問答，將用戶問答自然混入其中，返回JSON陣列格式`
            : existingQuestionsContext
            ? `請基於已有的${accountAskboxData.answeredQuestions.length}個提問，以該帳戶的身份重新生成回答，返回JSON陣列格式`
            : '請生成3-10組問答，返回JSON陣列格式',
        },
      ];

      // 判斷API類型並發送請求
      let isGemini = proxyUrl.includes('generativelanguage');
      let response;

      if (isGemini) {
        const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models';
        const geminiConfig = {
          url: `${GEMINI_API_URL}/${model}:generateContent?key=${getRandomValue(apiKey)}`,
          data: {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              contents: [
                {
                  parts: [
                    {
                      text: systemPrompt + '\n\n' + messages.map(m => m.content).join('\n'),
                    },
                  ],
                },
              ],
              generationConfig: {
                temperature: 0.9,
              },
            }),
          },
        };
        response = await fetch(geminiConfig.url, geminiConfig.data);
      } else {
        const openAiPayload = {
          model: model,
          messages: [{ role: 'system', content: systemPrompt }, ...messages],
          temperature: 0.9,
          stream: false,
        };
        response = await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${apiKey}`,
          },
          body: JSON.stringify(openAiPayload),
        });
      }

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(`API錯誤: ${response.status} - ${errorData.error?.message || response.statusText}`);
      }

      const data = await response.json();
      let aiResponseContent;

      if (isGemini) {
        // Gemini格式
        if (data.candidates && data.candidates[0] && data.candidates[0].content && data.candidates[0].content.parts) {
          aiResponseContent = data.candidates[0].content.parts[0].text || '';
        }
      } else {
        // OpenAI格式
        aiResponseContent = data.choices?.[0]?.message?.content || '';
      }

      console.log('AI生成的問答:', aiResponseContent);

      // 解析JSON格式的回答
      let qaArray;
      try {
        // 提取JSON內容（可能被包裹在```json```中）
        let jsonText = aiResponseContent.trim();
        const jsonMatch = jsonText.match(/```(?:json)?\s*(\[\s*\{[\s\S]*?\}\s*\])\s*```/);
        if (jsonMatch) {
          jsonText = jsonMatch[1];
        } else if (jsonText.startsWith('[') && jsonText.endsWith(']')) {
          // 直接是JSON陣列
          jsonText = jsonText;
        } else {
          throw new Error('未找到有效的JSON格式');
        }

        qaArray = JSON.parse(jsonText);

        if (!Array.isArray(qaArray) || qaArray.length === 0) {
          throw new Error('AI返回的不是有效的陣列或陣列為空');
        }
      } catch (parseError) {
        console.error('JSON解析失敗:', parseError);
        throw new Error(`解析AI回答失敗: ${parseError.message}`);
      }

      console.log(`✅ 解析到 ${qaArray.length} 組問答:`, qaArray);

      // 如果是重新生成，清空原有提問
      if (existingQuestionsContext) {
        accountAskboxData.answeredQuestions = [];
      }

      // 為每個問答創建物件並添加到陣列
      const newQuestions = qaArray.map((qa, index) => ({
        id: `q_${Date.now()}_${index}_${Math.random().toString(36).substr(2, 9)}`,
        question: qa.question || '',
        answer: qa.answer || '',
        date: new Date().toISOString(),
      }));

      // 批量添加到最前面
      accountAskboxData.answeredQuestions.unshift(...newQuestions);

      // 保存到資料庫
      await saveAccountAskboxDataToDB();

      // 重新渲染提問列表
      renderAccountAnsweredQuestions();

      // 🎯 如果是用戶提問，清空提問並恢復預設文字
      if (isUserQuestion) {
        showXToast('已生成回答！', 'success');
        currentUserQuestion = ''; // 清空提問
        const promptEl = document.getElementById('account-askbox-prompt');
        if (promptEl) {
          promptEl.textContent = '在這裡輸入你的匿名提問，或點擊下方按鈕生成隨機提問...';
        }
        console.log(`✅ [提問箱] 用戶提問已回答，問題已混入${newQuestions.length}組問答中`);
      } else {
        showXToast(
          `${existingQuestionsContext ? '已重新生成回答' : `生成了 ${newQuestions.length} 組問答`}`,
          'success',
        );
      }

      // 檢查是否是已綁定角色的提問箱，如果是則隨機觸發角色主動發消息
      if (accountProfile.type === 'character' && accountProfile.characterData) {
        // 🎲 隨機概率觸發（30%概率）
        const triggerProbability = 0.3;
        const shouldTrigger = Math.random() < triggerProbability;

        console.log('🔔 檢測到角色提問箱');
        console.log(`🎲 觸發概率: ${(triggerProbability * 100).toFixed(0)}%, 本次${shouldTrigger ? '觸發' : '不觸發'}`);

        if (!shouldTrigger) {
          console.log('⏭️ 本次未觸發角色主動發消息');
          return; // 不觸發，直接返回
        }

        console.log('✅ 準備觸發角色主動發消息');
        console.log('📋 角色數據:', accountProfile.characterData.originalName, accountProfile.characterData.id);

        // 獲取角色ID
        const characterId = accountProfile.characterData.id;

        // 構建提問箱內容摘要（最多3條最新問答）
        const askboxSummary = accountAskboxData.answeredQuestions
          .slice(0, 3)
          .map((qa, index) => `${index + 1}. Q: ${qa.question}\n   A: ${qa.answer}`)
          .join('\n\n');

        // 將函數暴露到全域
        window.openAccentColorPicker = openAccentColorPicker;
        window.closeAccentColorPicker = closeAccentColorPicker;
        window.applyAccentColor = applyAccentColor;

        // 延遲1秒後觸發（讓用戶看到提問箱生成成功的提示）
        setTimeout(async () => {
          try {
            // 查找或創建與該角色的私信對話
            const messageId = `msg_${characterId}`;

            // 檢查是否已存在該私信
            const messagesListId = `messagesList_${currentAccountId || 'main'}`;
            const messagesListData = await xDb.xAccountProfiles.get(messagesListId);

            let existingMessage = null;
            if (messagesListData && messagesListData.data) {
              existingMessage = messagesListData.data.find(msg => msg.id === messageId);
            }

            // 如果沒有該私信，創建一個
            if (!existingMessage) {
              const newMessage = {
                id: messageId,
                user: {
                  name: accountData.name,
                  handle: accountData.handle,
                  avatar: accountData.avatar,
                  verified: accountData.verified || false,
                },
                preview: '發現你在看我的提問箱...',
                time: '剛剛',
                unread: true,
                unreadCount: 1,
              };

              if (messagesListData && messagesListData.data) {
                messagesListData.data.unshift(newMessage);
                await xDb.xAccountProfiles.put(messagesListData);
              } else {
                await xDb.xAccountProfiles.put({
                  handle: messagesListId,
                  name: 'messagesList',
                  data: [newMessage],
                  updatedAt: new Date().toISOString(),
                });
              }

              existingMessage = newMessage;
              sampleMessagesData.unshift(newMessage);
            }

            // 檢查是否有現有對話記錄
            // 🔧 多帳戶隔離：包含帳戶ID
            const conversationId = `messageConversation_${currentAccountId || 'main'}_${messageId}`;
            const existingConversation = await xDb.xAccountProfiles.get(conversationId);
            const hasHistory =
              existingConversation &&
              existingConversation.data &&
              existingConversation.data.messages &&
              existingConversation.data.messages.length > 0;

            console.log('🎯 觸發角色主動發消息（提問箱查看）');
            console.log(
              `📖 現有對話記錄: ${
                hasHistory ? existingConversation.data.messages.length + '條消息' : '無（首次對話）'
              }`,
            );

            // 調用第九個情景生成器，使用特殊模式：askboxViewed
            const aiMessages = await generateMessageConversation(
              existingMessage,
              true, // 續寫模式
              {
                isAskboxViewed: true, // 新增：提問箱查看模式
                askboxContent: askboxSummary, // 提問箱內容
                characterId: characterId,
              },
            );

            if (aiMessages && aiMessages.length > 0) {
              // 保存AI消息到資料庫
              await saveAIMessagesToDB(aiMessages, existingMessage);

              // 更新私信清單（標記為未讀）
              if (messagesListData && messagesListData.data) {
                const msgIndex = messagesListData.data.findIndex(msg => msg.id === messageId);
                if (msgIndex !== -1) {
                  messagesListData.data[msgIndex].preview =
                    aiMessages[0].content || aiMessages[0].voiceText || '[消息]';
                  messagesListData.data[msgIndex].time = aiMessages[0].time || '剛剛';
                  messagesListData.data[msgIndex].unread = true;
                  messagesListData.data[msgIndex].unreadCount =
                    (messagesListData.data[msgIndex].unreadCount || 0) + aiMessages.length;

                  await xDb.xAccountProfiles.put(messagesListData);
                  sampleMessagesData = messagesListData.data;
                }
              }

              console.log(`✅ 角色已發送 ${aiMessages.length} 條私信`);
              showXToast(`${accountProfile.name} 給你發來了新消息`, 'info');
            }
          } catch (error) {
            console.error('觸發角色主動發消息失敗:', error);
          }
        }, 1000);
      }
    } catch (error) {
      console.error('生成提問失敗:', error);
      showXToast(`生成失敗: ${error.message}`, 'error');
    }
  };

  // 渲染帳戶已回答的提問列表
  function renderAccountAnsweredQuestions() {
    const container = document.getElementById('account-answered-questions-list');
    const titleEl = document.getElementById('account-answered-questions-title');
    if (!container) return;

    if (accountAskboxData.answeredQuestions.length === 0) {
      // 隱藏標題
      if (titleEl) titleEl.style.display = 'none';

      container.innerHTML = `
        <div style="
          text-align: center;
          color: rgba(255,255,255,0.6);
          font-size: 14px;
          padding: 40px 20px;
        ">
          暫無提問
        </div>
      `;
      return;
    }

    // 顯示標題
    if (titleEl) titleEl.style.display = 'block';

    container.innerHTML = accountAskboxData.answeredQuestions
      .map((q, index) => {
        const date = new Date(q.date);
        const dateStr = date.toLocaleDateString('zh-CN', { month: 'short', day: 'numeric' });
        const isSelected = selectedAccountQuestions.has(q.id);

        return `
      <div 
        class="account-askbox-question-item"
        data-question-id="${q.id}"
        style="
        background-color: rgba(255,255,255,0.9);
        backdrop-filter: blur(10px);
        border-radius: 16px;
        overflow: hidden;
        margin-bottom: 16px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        transition: all 0.2s;
        ${
          isSelected
            ? 'border: 3px solid var(--x-accent); background-color: color-mix(in srgb, var(--x-accent) , 0.1);'
            : ''
        }
        ${isAccountAskboxMultiSelectMode ? 'border-left: 3px solid var(--x-accent);' : ''}
      " 
      onmouseover="if(!${isAccountAskboxMultiSelectMode}){this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(0,0,0,0.2)';}"
      onmouseout="if(!${isAccountAskboxMultiSelectMode}){this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.15)';}"
      onmousedown="startAccountQuestionLongPress('${q.id}')"
      onmouseup="endAccountQuestionLongPress()"
      onmouseleave="endAccountQuestionLongPress()"
      ontouchstart="handleAccountQuestionTouchStart(event, '${q.id}')"
      ontouchend="handleAccountQuestionTouchEnd(event, '${q.id}')"
      ontouchcancel="endAccountQuestionLongPress()"
      onclick="if(${isAccountAskboxMultiSelectMode}){toggleAccountQuestionSelection('${
          q.id
        }');event.stopPropagation();}"
      >
        <!-- 提問區域（淺黑灰色） -->
        <div style="
          background: linear-gradient(135deg, #3a3a3a 0%, #2a2a2a 100%);
          padding: 20px;
          color: #fff;
        ">
          <div style="font-size: 15px; line-height: 1.6; word-break: break-word;">
            ${q.question}
          </div>
        </div>
        
        <!-- 回復區域（白色，可編輯） -->
        <div style="
          background-color: #fff;
          padding: 20px;
          min-height: 60px;
          color: #333;
        ">
          <div id="account-answer-${q.id}" 
            contenteditable="true"
            data-question-id="${q.id}"
            style="
              font-size: 14px; 
              line-height: 1.6; 
              word-break: break-word;
              outline: none;
              cursor: text;
              min-height: 20px;
              ${q.answer ? '' : 'color: #999; text-align: center;'}
            "
            onblur="saveAccountQuestionAnswer('${q.id}')"
            onkeydown="if(event.key==='Enter'&&!event.shiftKey){event.preventDefault();this.blur();}"
            onfocus="if(this.textContent==='點擊此處回復...'){this.textContent='';this.style.color='#333';this.style.textAlign='left';}">${
              q.answer || '點擊此處回復...'
            }</div>
        </div>
        
        <!-- 日期標籤 -->
        <div style="
          background-color: #f5f5f5;
          padding: 8px 20px;
          color: #999;
          font-size: 12px;
          text-align: right;
        ">
          ${dateStr}
        </div>
      </div>
    `;
      })
      .join('');
  }

  // 保存帳戶提問回復（原處編輯）
  window.saveAccountQuestionAnswer = async function (questionId) {
    const answerEl = document.getElementById(`account-answer-${questionId}`);
    if (!answerEl) return;

    const question = accountAskboxData.answeredQuestions.find(q => q.id === questionId);
    if (!question) return;

    let newAnswer = answerEl.textContent.trim();

    // 如果是預留位置文字，則清空
    if (newAnswer === '點擊此處回復...') {
      newAnswer = '';
    }

    if (newAnswer !== question.answer) {
      question.answer = newAnswer;
      await saveAccountAskboxDataToDB();
      console.log('✅ 回復已自動保存:', questionId);
    }
  };

  // ============================================
  // 帳戶提問箱多選刪除功能
  // ============================================

  // 開始長按提問卡片
  window.startAccountQuestionLongPress = function (questionId) {
    if (isAccountAskboxMultiSelectMode) return;

    accountQuestionLongPressTimer = setTimeout(() => {
      enterAccountAskboxMultiSelectMode();
      toggleAccountQuestionSelection(questionId);
    }, 500);
  };

  // 結束長按
  window.endAccountQuestionLongPress = function () {
    if (accountQuestionLongPressTimer) {
      clearTimeout(accountQuestionLongPressTimer);
      accountQuestionLongPressTimer = null;
    }
  };

  // 處理觸摸開始（移動端）
  window.handleAccountQuestionTouchStart = function (event, questionId) {
    // 如果已經在多選模式，不啟動長按計時器
    if (isAccountAskboxMultiSelectMode) {
      return;
    }

    // 記錄觸摸開始時間和位置，用於判斷是否是滑動
    window.accountQuestionTouchStartTime = Date.now();
    window.accountQuestionTouchStartY = event.touches[0].clientY;

    // 啟動長按計時器
    accountQuestionLongPressTimer = setTimeout(() => {
      enterAccountAskboxMultiSelectMode();
      toggleAccountQuestionSelection(questionId);
    }, 500);
  };

  // 處理觸摸結束（移動端）
  window.handleAccountQuestionTouchEnd = function (event, questionId) {
    // 清除長按計時器
    if (accountQuestionLongPressTimer) {
      clearTimeout(accountQuestionLongPressTimer);
      accountQuestionLongPressTimer = null;
    }

    // 如果在多選模式下，觸摸結束時切換選擇狀態
    if (isAccountAskboxMultiSelectMode) {
      // 檢查是否是快速點擊（不是滑動）
      const touchDuration = Date.now() - (window.accountQuestionTouchStartTime || 0);
      const touchMoveY = Math.abs(
        (event.changedTouches[0]?.clientY || window.accountQuestionTouchStartY || 0) -
          (window.accountQuestionTouchStartY || 0),
      );

      // 如果觸摸時間短且移動距離小，認為是點擊
      if (touchDuration < 500 && touchMoveY < 10) {
        event.preventDefault(); // 阻止默認行為和後續的click事件
        toggleAccountQuestionSelection(questionId);
      }
    }
  };

  // 切換提問選擇狀態
  window.toggleAccountQuestionSelection = function (questionId) {
    if (!isAccountAskboxMultiSelectMode) {
      enterAccountAskboxMultiSelectMode();
    }

    const questionEl = document.querySelector(`.account-askbox-question-item[data-question-id="${questionId}"]`);
    if (!questionEl) return;

    if (selectedAccountQuestions.has(questionId)) {
      selectedAccountQuestions.delete(questionId);
      questionEl.style.border = '';
      questionEl.style.backgroundColor = 'rgba(255,255,255,0.9)';
    } else {
      selectedAccountQuestions.add(questionId);
      questionEl.style.border = '3px solid var(--x-accent)';
      questionEl.style.backgroundColor = 'color-mix(in srgb, var(--x-accent) , 0.1)';
    }

    updateAccountAskboxDeleteUI();
  };

  // 進入帳戶提問箱多選模式
  function enterAccountAskboxMultiSelectMode() {
    isAccountAskboxMultiSelectMode = true;
    showAccountAskboxDeleteToolbar();

    document.querySelectorAll('.account-askbox-question-item').forEach(item => {
      item.style.borderLeft = '3px solid var(--x-accent)';
    });

    console.log('✅ 已進入帳戶提問箱多選模式');
  }

  // 退出帳戶提問箱多選模式
  window.exitAccountAskboxMultiSelectMode = function () {
    isAccountAskboxMultiSelectMode = false;
    selectedAccountQuestions.clear();
    hideAccountAskboxDeleteToolbar();

    // 清除長按相關的計時器和臨時變數
    if (accountQuestionLongPressTimer) {
      clearTimeout(accountQuestionLongPressTimer);
      accountQuestionLongPressTimer = null;
    }
    window.accountQuestionTouchStartTime = null;
    window.accountQuestionTouchStartY = null;

    document.querySelectorAll('.account-askbox-question-item').forEach(item => {
      item.style.border = '';
      item.style.borderLeft = '';
      item.style.backgroundColor = 'rgba(255,255,255,0.9)';
    });

    console.log('✅ 已退出帳戶提問箱多選模式');
  };

  // 顯示帳戶提問箱刪除工具列
  function showAccountAskboxDeleteToolbar() {
    let toolbar = document.getElementById('account-askbox-delete-toolbar');
    if (!toolbar) {
      toolbar = document.createElement('div');
      toolbar.id = 'account-askbox-delete-toolbar';
      toolbar.style.cssText = `
        position: fixed;
        bottom: 80px;
        left: 50%;
        transform: translateX(-50%);
        background-color: rgba(0,0,0,0.95);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255,255,255,0.2);
        border-radius: 24px;
        padding: 12px 20px;
        display: flex;
        align-items: center;
        gap: 16px;
        z-index: 2000;
        box-shadow: 0 4px 20px rgba(0,0,0,0.5);
      `;

      toolbar.innerHTML = `
        <button onclick="selectAllAccountQuestions()" style="
          background-color: var(--x-accent); 
          color: #fff; 
          border: none; 
          border-radius: 20px; 
          padding: 8px 16px; 
          font-size: 14px; 
          font-weight: 600;
          cursor: pointer;
          transition: all 0.2s;
        " onmouseover="this.style.backgroundColor='#1a8cd8'" onmouseout="this.style.backgroundColor='var(--x-accent)'">
          全選
        </button>
        <span id="account-askbox-selected-count" style="color: #fff; font-size: 14px; font-weight: 500;">已選擇 0 個</span>
        <button onclick="deleteSelectedAccountQuestions()" style="
          background-color: #f91880; 
          color: #fff; 
          border: none; 
          border-radius: 20px; 
          padding: 8px 16px; 
          font-size: 14px; 
          font-weight: 600;
          cursor: pointer;
          transition: all 0.2s;
        " onmouseover="this.style.backgroundColor='#d0155f'" onmouseout="this.style.backgroundColor='#f91880'">
          刪除
        </button>
        <button onclick="exitAccountAskboxMultiSelectMode()" style="
          background-color: rgba(255,255,255,0.15); 
          color: #fff; 
          border: none; 
          border-radius: 20px; 
          padding: 8px 16px; 
          font-size: 14px; 
          font-weight: 600;
          cursor: pointer;
          transition: all 0.2s;
        " onmouseover="this.style.backgroundColor='rgba(255,255,255,0.25)'" onmouseout="this.style.backgroundColor='rgba(255,255,255,0.15)'">
          取消
        </button>
      `;

      document.body.appendChild(toolbar);
    }
    toolbar.style.display = 'flex';
  }

  // 隱藏帳戶提問箱刪除工具列
  function hideAccountAskboxDeleteToolbar() {
    const toolbar = document.getElementById('account-askbox-delete-toolbar');
    if (toolbar) {
      toolbar.style.display = 'none';
    }
  }

  // 更新帳戶提問箱刪除UI
  function updateAccountAskboxDeleteUI() {
    const countEl = document.getElementById('account-askbox-selected-count');
    if (countEl) {
      countEl.textContent = `已選擇 ${selectedAccountQuestions.size} 個`;
    }
  }

  // 全選帳戶提問
  window.selectAllAccountQuestions = function () {
    document.querySelectorAll('.account-askbox-question-item').forEach(item => {
      const questionId = item.dataset.questionId;
      if (!selectedAccountQuestions.has(questionId)) {
        selectedAccountQuestions.add(questionId);
        item.style.border = '3px solid var(--x-accent)';
        item.style.backgroundColor = 'color-mix(in srgb, var(--x-accent) , 0.1)';
      }
    });
    updateAccountAskboxDeleteUI();
  };

  // 刪除選中的帳戶提問
  window.deleteSelectedAccountQuestions = async function () {
    if (selectedAccountQuestions.size === 0) {
      showXToast('請先選擇要刪除的提問', 'warning');
      return;
    }

    const confirmDelete = confirm(`確定要刪除選中的 ${selectedAccountQuestions.size} 個提問嗎？刪除後無法恢復。`);
    if (!confirmDelete) return;

    try {
      accountAskboxData.answeredQuestions = accountAskboxData.answeredQuestions.filter(
        q => !selectedAccountQuestions.has(q.id),
      );
      await saveAccountAskboxDataToDB();
      showXToast(`已刪除 ${selectedAccountQuestions.size} 個提問`, 'success');
      window.exitAccountAskboxMultiSelectMode();
      renderAccountAnsweredQuestions();
    } catch (error) {
      console.error('刪除提問失敗:', error);
      showXToast('刪除失敗: ' + error.message, 'error');
    }
  };

  // X設置頁面相關功能
  let xSettingsData = {
    systemPrompt: '',
    worldSetting: '',
    characterBinding: false,
    boundCharacters: [],
    worldBooks: [], // 世界書陣列
  };

  // 使用者資料資料 - 初始化全域變數（實際資料將在loadUserProfile時從資料庫載入）
  if (!window.userProfileData) {
    window.userProfileData = {
      name: '我',
      handle: '@me',
      avatar: 'https://i.postimg.cc/pXxk1JXk/IMG-6442.jpg',
      coverImage: 'https://i.postimg.cc/qRzMB6nQ/default-cover.jpg',
      bio: '歡迎來到我的X主頁！',
      verified: false,
      verificationType: 'none',
      coupleCharacterId: '',
      coupleCharacterName: '',
      customTag1: '科技愛好者',
      customTag1Icon: '✨',
      customTag1Color: '#71767b',
      customTag2: '2024年加入',
      customTag2Icon: '📅',
      customTag2Color: '#71767b',
      following: '156',
      followers: '89',
      knownIdentityCharacters: [],
      publicIdentity: '',
      showRealName: false,
      realName: '',
    };
  }

  // 創建局部引用指向全域變數（確保所有地方都訪問同一個物件）
  let userProfileData = window.userProfileData;

  // 獲取用戶認證類型描述
  function getUserVerificationTypeDescription(userProfile) {
    const verificationType = userProfile.verificationType || 'none';
    const descriptions = {
      none: '無認證',
      verified: '已認證（藍色勾標）',
      couple: '情侶認證（白色心形）',
      married: '已婚認證（白色圓環）',
      vip: 'VIP認證（白色菱形）',
    };
    return descriptions[verificationType] || '無認證';
  }

  // 初始化X設置
  async function initializeXSettings() {
    try {
      const db = getXDB();

      // 先載入全域世界書（所有帳戶共用）
      await loadGlobalWorldBooks();

      // 按帳號載入設置
      const settingsId = `xSettings_${currentAccountId || 'main'}`;
      const savedSettings = await db.xSettings.get(settingsId);
      if (savedSettings) {
        // 🔧 保存全域世界書引用，避免被帳戶設置覆蓋
        const globalWorldBooks = xSettingsData.worldBooks;
        xSettingsData = savedSettings;
        // 恢復全域世界書
        xSettingsData.worldBooks = globalWorldBooks;
      } else {
        // 如果當前帳號沒有設置，使用默認設置（worldBooks已經從全域載入）
        const globalWorldBooks = xSettingsData.worldBooks;
        xSettingsData = {
          systemPrompt: '',
          worldSetting: '',
          characterBinding: false,
          boundCharacters: [],
          npcBinding: false,
          worldBooks: globalWorldBooks,
        };
      }

      // 載入UI
      await loadXSettingsToUI();

      // 載入預設列表
      loadXPresetsList();

      console.log('✅ X設置已載入 (帳戶:', currentAccountId || 'main', ')');
      console.log('📚 全域世界書:', xSettingsData.worldBooks?.length || 0, '個');

      // 🔧 注意：已移除智慧檢測和刷新的自動恢復功能（改為用戶手動開啟）
    } catch (error) {
      console.error('初始化X設置失敗:', error);
    }
  }

  // 將設置數據載入到UI
  async function loadXSettingsToUI() {
    document.getElementById('x-system-prompt').value = xSettingsData.systemPrompt || '';
    document.getElementById('x-world-setting').value = xSettingsData.worldSetting || '';

    // 確保 boundCharacters 陣列存在
    if (!xSettingsData.boundCharacters) {
      xSettingsData.boundCharacters = [];
    }

    // 確保 worldBooks 陣列存在
    if (!xSettingsData.worldBooks) {
      xSettingsData.worldBooks = [];
    }

    updateCharacterToggleUI();

    // 如果開啟了角色綁定，顯示角色選擇區域
    const bindingArea = document.getElementById('character-binding-area');
    if (xSettingsData.characterBinding) {
      bindingArea.style.display = 'block';
      loadCharactersList();
    } else {
      bindingArea.style.display = 'none';
    }

    // 更新角色關係冊UI
    updateRelationshipToggleUI();

    // 如果開啟了角色關係冊，顯示關係冊管理區域並更新預覽
    const relationshipArea = document.getElementById('relationship-binding-area');
    if (xSettingsData.characterRelationship?.enabled) {
      relationshipArea.style.display = 'block';
      await loadRelationshipData();
      setTimeout(() => {
        updateRelationshipPreview();
      }, 200);
    } else {
      relationshipArea.style.display = 'none';
    }

    // 更新NPC綁定UI
    updateNPCToggleUI();

    // 如果開啟了NPC綁定，顯示NPC管理區域
    const npcArea = document.getElementById('npc-binding-area');
    if (xSettingsData.npcBinding) {
      npcArea.style.display = 'block';
      loadNPCsList();
    } else {
      npcArea.style.display = 'none';
    }
  }

  // 切換角色綁定 (已被新版本替換，在新位置)

  // 保存全域世界書（所有帳戶共用）
  async function saveGlobalWorldBooks() {
    try {
      const db = getXDB();
      await db.xSettings.put({
        id: 'globalWorldBooks',
        worldBooks: xSettingsData.worldBooks || [],
        lastUpdated: new Date().toISOString(),
      });
      console.log('✅ 全域世界書已保存');
    } catch (error) {
      console.error('保存全域世界書失敗:', error);
      throw error;
    }
  }

  // 載入全域世界書（所有帳戶共用）
  async function loadGlobalWorldBooks() {
    try {
      const db = getXDB();
      const globalData = await db.xSettings.get('globalWorldBooks');
      if (globalData && globalData.worldBooks && globalData.worldBooks.length > 0) {
        xSettingsData.worldBooks = globalData.worldBooks;
        console.log('✅ 全域世界書已載入:', xSettingsData.worldBooks.length, '個');
      } else {
        // 🔧 資料移轉：如果全域世界書為空，嘗試從當前帳戶設置中遷移
        console.log('📦 [世界書遷移] 全域世界書為空，嘗試從帳戶設置遷移...');
        const settingsId = `xSettings_${currentAccountId || 'main'}`;
        const accountSettings = await db.xSettings.get(settingsId);

        if (accountSettings && accountSettings.worldBooks && accountSettings.worldBooks.length > 0) {
          console.log(
            `📦 [世界書遷移] 發現帳戶設置中有 ${accountSettings.worldBooks.length} 個世界書，正在遷移到全域設置...`,
          );
          xSettingsData.worldBooks = accountSettings.worldBooks;
          // 保存到全域設置
          await saveGlobalWorldBooks();
          console.log('✅ [世界書遷移] 遷移完成！');
        } else {
          xSettingsData.worldBooks = [];
          console.log('ℹ️ [世界書] 無世界書資料');
        }
      }
    } catch (error) {
      console.error('載入全域世界書失敗:', error);
      xSettingsData.worldBooks = [];
    }
  }

  // 保存X設置（按帳號存儲）
  async function saveXSettings() {
    try {
      // 獲取UI中的資料
      xSettingsData.systemPrompt = document.getElementById('x-system-prompt').value;
      xSettingsData.worldSetting = document.getElementById('x-world-setting').value;

      const db = getXDB();
      const settingsId = `xSettings_${currentAccountId || 'main'}`;

      // 創建設置資料副本，移除worldBooks（因為它是全域的）
      const settingsToSave = { ...xSettingsData };
      delete settingsToSave.worldBooks;

      await db.xSettings.put({
        id: settingsId,
        ...settingsToSave,
        lastUpdated: new Date().toISOString(),
      });

      console.log('✅ X設置已保存 (帳戶:', currentAccountId || 'main', ')');
      showXToast('設置已保存', 'success');
    } catch (error) {
      console.error('保存設置失敗:', error);
      showXToast('保存失敗: ' + error.message, 'error');
    }
  }

  // ============================================
  // 世界書管理功能
  // ============================================

  // 打開世界書管理彈窗
  window.openWorldBooksManageModal = async function () {
    // 🔧 先載入全域世界書資料，確保顯示最新內容
    await loadGlobalWorldBooks();

    const modal = document.createElement('div');
    modal.id = 'world-books-manage-modal';
    modal.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(4px);
      z-index: 10000;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 12px;
      box-sizing: border-box;
    `;

    modal.innerHTML = `
      <div style="
        background-color: var(--x-bg-primary);
        border-radius: 16px;
        width: 100%;
        max-width: 700px;
        max-height: calc(100vh - 24px);
        display: flex;
        flex-direction: column;
        border: 1px solid var(--x-border-color);
        box-sizing: border-box;
      " onclick="event.stopPropagation()">
        <!-- 彈窗頭部 -->
        <div style="
          display: flex;
          align-items: center;
          justify-content: space-between;
          padding: 16px 20px;
          border-bottom: 1px solid var(--x-border-color);
          flex-shrink: 0;
        ">
          <h2 style="
            color: var(--x-text-primary);
            font-size: 20px;
            font-weight: 700;
            margin: 0;
          ">世界書管理<span style="font-size: 14px; color: var(--x-text-secondary); font-weight: 400; margin-left: 8px;">(全域共用)</span></h2>
          <div style="display: flex; gap: 12px; align-items: center;">
            <button onclick="openCreateWorldBookModal()" style="
              background-color: var(--x-accent);
              color: #fff;
              border: none;
              border-radius: 20px;
              padding: 8px 16px;
              font-size: 14px;
              font-weight: 600;
              cursor: pointer;
              transition: all 0.2s;
            " onmouseover="this.style.opacity='0.9'" onmouseout="this.style.opacity='1'">
              + 添加世界書
            </button>
            <div onclick="closeWorldBooksManageModal()" style="
              cursor: pointer;
              padding: 8px;
              border-radius: 50%;
              transition: background-color 0.2s;
            " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
               onmouseout="this.style.backgroundColor='transparent'">
              <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);">
                <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
              </svg>
            </div>
          </div>
        </div>

        <!-- 彈窗內容 -->
        <div id="world-books-manage-list" style="
          flex: 1;
          overflow-y: auto;
          padding: 16px 20px;
        ">
          <!-- 世界書清單將通過JavaScript動態生成 -->
        </div>
      </div>
    `;

    // 添加到 X 社交螢幕容器中以繼承主題變數
    const xScreen = document.getElementById('x-social-screen');
    if (xScreen) {
      xScreen.appendChild(modal);
    } else {
      document.body.appendChild(modal);
    }

    // 渲染世界書列表
    renderWorldBooksManageList();

    // 點擊背景關閉
    modal.addEventListener('click', e => {
      if (e.target === modal) {
        closeWorldBooksManageModal();
      }
    });
  };

  // 關閉世界書管理彈窗
  window.closeWorldBooksManageModal = function () {
    const modal = document.getElementById('world-books-manage-modal');
    if (modal) {
      modal.remove();
    }
  };

  // 渲染世界書管理列表
  function renderWorldBooksManageList() {
    const container = document.getElementById('world-books-manage-list');
    if (!container) return;

    if (!xSettingsData.worldBooks || xSettingsData.worldBooks.length === 0) {
      container.innerHTML = `
        <div style="
          color: var(--x-text-secondary);
          font-size: 15px;
          text-align: center;
          padding: 60px 20px;
          background-color: var(--x-bg-secondary);
          border-radius: 16px;
          border: 2px dashed var(--x-border-color);
        ">
          <svg viewBox="0 0 24 24" style="width: 48px; height: 48px; fill: var(--x-text-secondary); margin-bottom: 16px;">
            <g><path d="M3 5.5C3 4.119 4.119 3 5.5 3h13C19.881 3 21 4.119 21 5.5v13c0 1.381-1.119 2.5-2.5 2.5h-13C4.119 21 3 19.881 3 18.5v-13zM5.5 5c-.276 0-.5.224-.5.5v13c0 .276.224.5.5.5h13c.276 0 .5-.224.5-.5v-13c0-.276-.224-.5-.5-.5h-13z"></path></g>
          </svg>
          <div style="font-weight: 600; margin-bottom: 8px; font-size: 16px;">暫無世界書</div>
          <div style="font-size: 13px;">點擊右上角"添加世界書"按鈕創建第一個世界書</div>
        </div>
      `;
      return;
    }

    const sceneLabels = {
      global: '全域',
      messages: '私信',
      search: '搜索',
      trending: '熱搜',
      profile: '主頁',
      feed: '首頁',
      tweetDetail: '詳情',
    };

    container.innerHTML = `
      <div style="display: flex; flex-direction: column; gap: 12px;">
        ${xSettingsData.worldBooks
          .map((wb, index) => {
            const sceneTags = wb.scenes?.map(s => sceneLabels[s] || s).join(', ') || '未綁定場景';
            let bindInfo = [];
            if (wb.bindToAll) bindInfo.push('全域對話');
            if (wb.bindToCharacterOnly) bindInfo.push('僅角色對話');
            if (wb.boundCharacters && wb.boundCharacters.length > 0) {
              bindInfo.push(`${wb.boundCharacters.length}個指定角色`);
            }
            const bindText = bindInfo.length > 0 ? bindInfo.join(' + ') : '未綁定目標';

            // 判斷是否為閒置狀態
            const isIdle = wb.isIdle || (wb.targetType === 'none' && (!wb.scenes || wb.scenes.length === 0));

            return `
              <div style="
                background-color: var(--x-bg-secondary);
                border: 1px solid var(--x-border-color);
                border-radius: 16px;
                padding: 16px;
                transition: all 0.2s;
              " onmouseover="this.style.borderColor='var(--x-accent)'"
                 onmouseout="this.style.borderColor='var(--x-border-color)'">
                <div style="display: flex; align-items: start; justify-content: space-between; margin-bottom: 12px;">
                  <div style="flex: 1; min-width: 0;">
                    <div style="
                      color: var(--x-text-primary);
                      font-size: 17px;
                      font-weight: 700;
                      margin-bottom: 8px;
                    ">${wb.name}</div>
                    <div style="
                      display: flex;
                      flex-wrap: wrap;
                      gap: 6px;
                      margin-bottom: 8px;
                    ">
                      ${
                        isIdle
                          ? `
                      <span style="
                        display: inline-flex;
                        align-items: center;
                        background-color: rgba(113, 118, 123, 0.2);
                        color: var(--x-text-secondary);
                        padding: 4px 10px;
                        border-radius: 12px;
                        font-size: 12px;
                        font-weight: 600;
                      ">
                        <svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: var(--x-text-secondary); margin-right: 4px;">
                          <g><path d="M8 7c0 2.21-1.79 4-4 4S0 9.21 0 7s1.79-4 4-4 4 1.79 4 4zm5-4c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm9 0c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4z"></path></g>
                        </svg>
                        閒置狀態（暫未啟用）
                      </span>
                      `
                          : `
                      <span style="
                        display: inline-flex;
                        align-items: center;
                        background-color: #1d9bf0;
                        color: #ffffff;
                        padding: 4px 10px;
                        border-radius: 12px;
                        font-size: 12px;
                        font-weight: 600;
                      ">
                        <svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: #ffffff; margin-right: 4px;">
                          <g><path d="M12 7c-1.93 0-3.5 1.57-3.5 3.5S10.07 14 12 14s3.5-1.57 3.5-3.5S13.93 7 12 7zm0 5c-.827 0-1.5-.673-1.5-1.5S11.173 9 12 9s1.5.673 1.5 1.5S12.827 12 12 12zm0-10c-4.687 0-8.5 3.813-8.5 8.5 0 5.967 7.621 11.116 7.945 11.332l.555.37.555-.37c.324-.216 7.945-5.365 7.945-11.332C20.5 5.813 16.687 2 12 2zm0 17.77c-1.665-1.241-6.5-5.196-6.5-9.27C5.5 6.916 8.416 4 12 4s6.5 2.916 6.5 6.5c0 4.073-4.835 8.028-6.5 9.27z"></path></g>
                        </svg>
                        ${sceneTags}
                      </span>
                      <span style="
                        display: inline-flex;
                        align-items: center;
                        background-color: rgba(29, 155, 240, 0.15);
                        color: #1d9bf0;
                        padding: 4px 10px;
                        border-radius: 12px;
                        font-size: 12px;
                        font-weight: 600;
                      ">
                        <svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: #1d9bf0; margin-right: 4px;">
                          <g><path d="M17.863 13.44c1.477 1.58 2.366 3.8 2.632 6.46l.11 1.1H3.395l.11-1.1c.266-2.66 1.155-4.88 2.632-6.46C7.627 11.85 9.648 11 12 11s4.373.85 5.863 2.44zM12 2C9.791 2 8 3.79 8 6s1.791 4 4 4 4-1.79 4-4-1.791-4-4-4z"></path></g>
                        </svg>
                        ${bindText}
                      </span>
                      `
                      }
                    </div>
                  </div>
                  <div style="display: flex; gap: 8px; flex-shrink: 0; margin-left: 12px;">
                    <button onclick="editWorldBookInManage(${index})" style="
                      background-color: var(--x-accent);
                      color: #fff;
                      border: none;
                      border-radius: 18px;
                      padding: 8px 16px;
                      font-size: 13px;
                      font-weight: 600;
                      cursor: pointer;
                      transition: opacity 0.2s;
                    " onmouseover="this.style.opacity='0.9'" onmouseout="this.style.opacity='1'">編輯</button>
                    <button onclick="deleteWorldBookInManage(${index})" style="
                      background-color: #f4212e;
                      color: #fff;
                      border: none;
                      border-radius: 18px;
                      padding: 8px 16px;
                      font-size: 13px;
                      font-weight: 600;
                      cursor: pointer;
                      transition: opacity 0.2s;
                    " onmouseover="this.style.opacity='0.9'" onmouseout="this.style.opacity='1'">刪除</button>
                  </div>
                </div>
                <div style="
                  color: var(--x-text-secondary);
                  font-size: 14px;
                  line-height: 1.6;
                  max-height: 80px;
                  overflow: hidden;
                  text-overflow: ellipsis;
                  background-color: var(--x-bg-primary);
                  padding: 12px;
                  border-radius: 8px;
                ">${wb.content.substring(0, 150)}${wb.content.length > 150 ? '...' : ''}</div>
              </div>
            `;
          })
          .join('')}
      </div>
    `;
  }

  // 在管理面板中編輯世界書
  window.editWorldBookInManage = function (index) {
    const worldBook = xSettingsData.worldBooks[index];
    openWorldBookModal(worldBook, index);
  };

  // 在管理面板中刪除世界書
  window.deleteWorldBookInManage = async function (index) {
    if (!confirm('確定要刪除這個世界書嗎？')) return;

    xSettingsData.worldBooks.splice(index, 1);
    await saveGlobalWorldBooks();
    renderWorldBooksManageList();
    showXToast('世界書已刪除', 'success');
  };

  // 打開創建世界書彈窗
  window.openCreateWorldBookModal = function () {
    openWorldBookModal();
  };

  // 打開世界書編輯彈窗
  function openWorldBookModal(worldBook = null, editIndex = null) {
    const isEdit = worldBook !== null;

    // 創建彈窗
    const modal = document.createElement('div');
    modal.id = 'world-book-modal';
    modal.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(4px);
      z-index: 10000;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 12px;
      box-sizing: border-box;
    `;

    modal.innerHTML = `
      <div style="
        background-color: var(--x-bg-primary);
        border-radius: 16px;
        width: 100%;
        max-width: 600px;
        max-height: calc(100vh - 24px);
        overflow-y: auto;
        border: 1px solid var(--x-border-color);
        box-sizing: border-box;
      " onclick="event.stopPropagation()">
        <!-- 彈窗頭部 -->
        <div style="
          display: flex;
          align-items: center;
          justify-content: space-between;
          padding: 14px 16px;
          border-bottom: 1px solid var(--x-border-color);
          position: sticky;
          top: 0;
          background-color: var(--x-bg-primary);
          z-index: 1;
        ">
          <h2 style="
            color: var(--x-text-primary);
            font-size: 18px;
            font-weight: 700;
            margin: 0;
          ">${isEdit ? '編輯世界書' : '創建世界書'}</h2>
          <div onclick="closeWorldBookModal()" style="
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            transition: background-color 0.2s;
          " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
             onmouseout="this.style.backgroundColor='transparent'">
            <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);">
              <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
            </svg>
          </div>
        </div>

        <!-- 彈窗內容 -->
        <div style="padding: 16px;">
          <form id="world-book-form" onsubmit="saveWorldBook(event)">
            <!-- 世界書名稱 -->
            <div style="margin-bottom: 16px;">
              <label style="
                display: block;
                color: var(--x-text-primary);
                font-size: 14px;
                font-weight: 600;
                margin-bottom: 6px;
              ">世界書名稱 *</label>
              <input type="text" id="wb-name" required
                value="${worldBook?.name || ''}"
                placeholder="例如：表情包庫、角色關係設定..."
                style="
                  width: 100%;
                  background-color: var(--x-bg-secondary);
                  border: 1px solid var(--x-border-color);
                  border-radius: 8px;
                  color: var(--x-text-primary);
                  padding: 10px 12px;
                  font-size: 14px;
                  outline: none;
                  box-sizing: border-box;
                "
                onfocus="this.style.borderColor='var(--x-accent)'"
                onblur="this.style.borderColor='var(--x-border-color)'">
            </div>

            <!-- 世界書內容 -->
            <div style="margin-bottom: 16px;">
              <label style="
                display: block;
                color: var(--x-text-primary);
                font-size: 14px;
                font-weight: 600;
                margin-bottom: 6px;
              ">世界書內容 *</label>
              <textarea id="wb-content" required rows="6"
                placeholder="輸入世界書內容，例如：&#10;表情包連結：&#10;- 開心：https://example.com/happy.gif&#10;- 生氣：https://example.com/angry.gif&#10;&#10;或其他設定內容..."
                style="
                  width: 100%;
                  background-color: var(--x-bg-secondary);
                  border: 1px solid var(--x-border-color);
                  border-radius: 8px;
                  color: var(--x-text-primary);
                  padding: 10px 12px;
                  font-size: 14px;
                  resize: vertical;
                  outline: none;
                  font-family: inherit;
                  line-height: 1.5;
                  box-sizing: border-box;
                "
                onfocus="this.style.borderColor='var(--x-accent)'"
                onblur="this.style.borderColor='var(--x-border-color)'">${worldBook?.content || ''}</textarea>
            </div>

            <!-- 綁定場景 -->
            <div style="margin-bottom: 16px;">
              <label style="
                display: block;
                color: var(--x-text-primary);
                font-size: 14px;
                font-weight: 600;
                margin-bottom: 4px;
              ">綁定場景（可多選）</label>
              <div style="
                color: var(--x-text-secondary);
                font-size: 12px;
                margin-bottom: 8px;
                line-height: 1.4;
              ">💡 提示：如果不綁定任何場景和目標，世界書將處於閒置狀態，不會被應用到任何場景</div>
              <div style="
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                gap: 6px;
              ">
                ${['global', 'messages', 'search', 'trending', 'profile', 'feed', 'tweetDetail']
                  .map(scene => {
                    const labels = {
                      global: '全域',
                      messages: '私信介面',
                      search: '搜索介面',
                      trending: '熱搜介面',
                      profile: '角色主頁',
                      feed: '首頁推文',
                      tweetDetail: '推文詳情',
                    };
                    const checked = worldBook?.scenes?.includes(scene) || false;
                    return `
                    <label style="
                      display: flex;
                      align-items: center;
                      padding: 8px 10px;
                      background-color: var(--x-bg-secondary);
                      border: 1px solid var(--x-border-color);
                      border-radius: 8px;
                      cursor: pointer;
                      transition: all 0.2s;
                    " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
                       onmouseout="this.style.backgroundColor='var(--x-bg-secondary)'">
                      <input type="checkbox" name="wb-scenes" value="${scene}" ${checked ? 'checked' : ''}
                        style="margin-right: 6px; cursor: pointer;">
                      <span style="color: var(--x-text-primary); font-size: 13px;">${labels[scene]}</span>
                    </label>
                  `;
                  })
                  .join('')}
              </div>
            </div>

            <!-- 綁定角色 -->
            <div style="margin-bottom: 16px;">
              <label style="
                display: block;
                color: var(--x-text-primary);
                font-size: 14px;
                font-weight: 600;
                margin-bottom: 8px;
              ">綁定目標（可選）</label>
              
              <!-- 全域對話 -->
              <label style="
                display: flex;
                align-items: center;
                padding: 8px 10px;
                background-color: var(--x-bg-secondary);
                border: 1px solid var(--x-border-color);
                border-radius: 8px;
                cursor: pointer;
                margin-bottom: 6px;
              ">
                <input type="checkbox" id="wb-bind-all" ${worldBook?.bindToAll ? 'checked' : ''}
                  style="margin-right: 6px; cursor: pointer;">
                <span style="color: var(--x-text-primary); font-size: 13px;">綁定到全域對話</span>
              </label>

              <!-- 僅角色對話 -->
              <label style="
                display: flex;
                align-items: center;
                padding: 8px 10px;
                background-color: var(--x-bg-secondary);
                border: 1px solid var(--x-border-color);
                border-radius: 8px;
                cursor: pointer;
                margin-bottom: 6px;
              ">
                <input type="checkbox" id="wb-bind-character-only" ${worldBook?.bindToCharacterOnly ? 'checked' : ''}
                  style="margin-right: 6px; cursor: pointer;">
                <span style="color: var(--x-text-primary); font-size: 13px;">綁定到僅角色對話</span>
              </label>

              <!-- 角色選擇 -->
              <div style="margin-top: 6px;">
                <label style="
                  display: block;
                  color: var(--x-text-secondary);
                  font-size: 12px;
                  margin-bottom: 6px;
                ">綁定到指定角色（任何相關情景都會使用）：</label>
                <div id="wb-character-list" style="
                  max-height: 160px;
                  overflow-y: auto;
                  background-color: var(--x-bg-secondary);
                  border: 1px solid var(--x-border-color);
                  border-radius: 8px;
                  padding: 6px;
                ">
                  <!-- 角色清單將通過JavaScript動態生成 -->
                </div>
              </div>
            </div>

            <!-- 按鈕組 -->
            <div style="display: flex; gap: 10px; margin-top: 20px;">
              <button type="button" onclick="closeWorldBookModal()" style="
                flex: 1;
                background-color: var(--x-bg-secondary);
                border: 1px solid var(--x-border-color);
                border-radius: 20px;
                padding: 11px;
                color: var(--x-text-primary);
                font-size: 14px;
                font-weight: 600;
                cursor: pointer;
                box-sizing: border-box;
              ">取消</button>
              <button type="submit" style="
                flex: 1;
                background-color: var(--x-accent);
                border: none;
                border-radius: 20px;
                padding: 11px;
                color: #fff;
                font-size: 14px;
                font-weight: 600;
                cursor: pointer;
                box-sizing: border-box;
              ">${isEdit ? '保存修改' : '創建世界書'}</button>
            </div>
          </form>
        </div>
      </div>
    `;

    // 添加到 X 社交螢幕容器中以繼承主題變數
    const xScreen = document.getElementById('x-social-screen');
    if (xScreen) {
      xScreen.appendChild(modal);
    } else {
      document.body.appendChild(modal);
    }

    // 設置編輯索引
    if (isEdit) {
      modal.setAttribute('data-edit-index', editIndex);
    }

    // 載入角色列表
    loadWorldBookCharactersList(worldBook?.boundCharacters || []);

    // 點擊背景關閉
    modal.addEventListener('click', e => {
      if (e.target === modal) {
        closeWorldBookModal();
      }
    });
  }

  // 載入世界書角色選擇列表
  async function loadWorldBookCharactersList(selectedCharacters = []) {
    try {
      const db = getDB();
      const allChats = await db.chats.toArray();
      const characters = allChats.filter(chat => !chat.isGroup);

      const container = document.getElementById('wb-character-list');
      if (!container) return;

      if (characters.length === 0) {
        container.innerHTML = `
          <div style="
            color: var(--x-text-secondary);
            font-size: 12px;
            text-align: center;
            padding: 16px;
          ">暫無可綁定的角色</div>
        `;
        return;
      }

      container.innerHTML = characters
        .map(
          char => `
        <label style="
          display: flex;
          align-items: center;
          padding: 6px 8px;
          border-radius: 6px;
          cursor: pointer;
          transition: background-color 0.2s;
        " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
           onmouseout="this.style.backgroundColor='transparent'">
          <input type="checkbox" name="wb-characters" value="${char.id}"
            ${selectedCharacters.includes(char.id) ? 'checked' : ''}
            style="margin-right: 6px; cursor: pointer;">
          <span style="color: var(--x-text-primary); font-size: 13px;">${char.name}</span>
        </label>
      `,
        )
        .join('');
    } catch (error) {
      console.error('載入角色列表失敗:', error);
    }
  }

  // 關閉世界書彈窗
  window.closeWorldBookModal = function () {
    const modal = document.getElementById('world-book-modal');
    if (modal) {
      modal.remove();
    }
  };

  // 保存世界書
  window.saveWorldBook = async function (event) {
    event.preventDefault();

    const name = document.getElementById('wb-name').value.trim();
    const content = document.getElementById('wb-content').value.trim();

    if (!name || !content) {
      showXToast('請填寫完整資訊', 'error');
      return;
    }

    // 獲取選中的場景
    const sceneCheckboxes = document.querySelectorAll('input[name="wb-scenes"]:checked');
    const scenes = Array.from(sceneCheckboxes).map(cb => cb.value);

    // 獲取綁定目標
    const bindToAll = document.getElementById('wb-bind-all').checked;
    const bindToCharacterOnly = document.getElementById('wb-bind-character-only').checked;

    // 獲取選中的角色
    const characterCheckboxes = document.querySelectorAll('input[name="wb-characters"]:checked');
    const boundCharacters = Array.from(characterCheckboxes).map(cb => cb.value);

    // 確定目標類型和選擇的角色列表
    let targetType = 'none'; // 'none' = 未綁定（閒置）, 'all' = 全域對話, 'characterOnly' = 僅角色對話, 'specific' = 指定角色
    let selectedCharacters = [];

    if (bindToAll) {
      targetType = 'all';
    } else if (bindToCharacterOnly) {
      targetType = 'characterOnly';
    } else if (boundCharacters.length > 0) {
      targetType = 'specific';
      selectedCharacters = [...boundCharacters];
    }
    // 如果都沒有選擇，targetType 保持為 'none'

    // 判斷是否是閒置狀態（沒有任何綁定）
    const isIdle = targetType === 'none' && (!scenes || scenes.length === 0);

    const worldBook = {
      name,
      content,
      scenes,
      targetType, // 'none' | 'all' | 'characterOnly' | 'specific'
      selectedCharacters, // 角色ID陣列
      bindToAll,
      bindToCharacterOnly,
      boundCharacters,
      isIdle, // 標記是否為閒置狀態
      createdAt: new Date().toISOString(),
    };

    // 檢查是否是編輯模式
    const modal = document.getElementById('world-book-modal');
    const editIndex = modal?.getAttribute('data-edit-index');

    if (!xSettingsData.worldBooks) {
      xSettingsData.worldBooks = [];
    }

    if (editIndex !== null && editIndex !== undefined) {
      // 編輯模式
      xSettingsData.worldBooks[parseInt(editIndex)] = worldBook;
      showXToast('世界書已更新', 'success');
    } else {
      // 創建模式
      xSettingsData.worldBooks.push(worldBook);
      showXToast('世界書已創建', 'success');
    }

    // 保存全域世界書（不再保存到帳戶設置中）
    await saveGlobalWorldBooks();

    // 如果管理面板打開，刷新管理面板的列表
    const manageModal = document.getElementById('world-books-manage-modal');
    if (manageModal) {
      renderWorldBooksManageList();
    }

    closeWorldBookModal();
  };

  // 保存為預設
  async function saveXPreset() {
    const presetName = prompt('請輸入預設名稱:');
    if (!presetName || presetName.trim() === '') {
      showXToast('預設名稱不能為空', 'error');
      return;
    }

    try {
      // 只保存提示詞和世界觀設定
      const presetData = {
        systemPrompt: document.getElementById('x-system-prompt').value,
        worldSetting: document.getElementById('x-world-setting').value,
        characterBinding: xSettingsData.characterBinding || false,
        boundCharacters: xSettingsData.boundCharacters || [],
      };

      const db = getXDB();

      await db.xPresets.add({
        name: presetName.trim(),
        ...presetData,
        createdAt: new Date().toISOString(),
      });

      showXToast(`預設"${presetName}"已保存`, 'success');
      loadXPresetsList(); // 刷新預設列表
    } catch (error) {
      console.error('保存預設失敗:', error);
      showXToast('保存預設失敗: ' + error.message, 'error');
    }
  }

  // 載入預設列表
  async function loadXPresetsList() {
    try {
      const db = getXDB();

      const presets = await db.xPresets.orderBy('createdAt').reverse().toArray();
      const presetsList = document.getElementById('x-presets-list');

      if (presets.length === 0) {
        presetsList.innerHTML =
          '<p style="color: #71767b; font-size: 14px; text-align: center; margin: 20px 0;">暫無保存的預設</p>';
        return;
      }

      presetsList.innerHTML = presets
        .map(
          preset => `
                <div class="preset-item" style="display: flex; align-items: center; justify-content: space-between; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; padding: 12px; margin-bottom: 8px;">
                  <div style="flex: 1; min-width: 0;">
                    <div style="color: #fff; font-weight: 600; font-size: 15px; margin-bottom: 4px; word-wrap: break-word;">${
                      preset.name
                    }</div>
                    <div style="color: #71767b; font-size: 13px;">${new Date(preset.createdAt).toLocaleString()}</div>
                  </div>
                  <div style="display: flex; gap: 8px; flex-shrink: 0;">
                    <button onclick="loadXPreset(${preset.id})" 
                      style="background-color: var(--x-accent); color: #fff; border: none; border-radius: 15px; padding: 6px 12px; font-size: 12px; cursor: pointer; white-space: nowrap;">
                      載入
                    </button>
                    <button onclick="deleteXPreset(${preset.id})" 
                      style="background-color: #f4212e; color: #fff; border: none; border-radius: 15px; padding: 6px 12px; font-size: 12px; cursor: pointer; white-space: nowrap;">
                      刪除
                    </button>
                  </div>
                </div>
              `,
        )
        .join('');
    } catch (error) {
      console.error('載入預設列表失敗:', error);
    }
  }

  // 載入預設
  async function loadXPreset(presetId) {
    try {
      const db = getXDB();
      const preset = await db.xPresets.get(presetId);
      if (preset) {
        // 先更新xSettingsData對象
        xSettingsData.systemPrompt = preset.systemPrompt || '';
        xSettingsData.worldSetting = preset.worldSetting || '';
        xSettingsData.characterBinding = preset.characterBinding || false;
        xSettingsData.boundCharacters = preset.boundCharacters || [];

        // 然後更新UI（會從xSettingsData讀取資料）
        await loadXSettingsToUI();

        showXToast(`已載入預設"${preset.name}"`, 'success');
      }
    } catch (error) {
      console.error('載入預設失敗:', error);
      showXToast('載入預設失敗: ' + error.message, 'error');
    }
  }

  // 刪除預設
  async function deleteXPreset(presetId) {
    if (!confirm('確定要刪除這個預設嗎？')) return;

    try {
      const db = getXDB();

      await db.xPresets.delete(presetId);
      showXToast('預設已刪除', 'success');
      loadXPresetsList(); // 刷新預設列表
    } catch (error) {
      console.error('刪除預設失敗:', error);
      showXToast('刪除預設失敗: ' + error.message, 'error');
    }
  }

  // 匯出所有X資料
  async function exportXData() {
    try {
      const xDb = getXDB();

      // 匯出所有X資料庫內容
      const exportData = {
        // X設置（包含全域世界書）
        xSettings: await xDb.xSettings.toArray(),
        // 使用者資料（所有帳戶）
        xUserProfile: await xDb.xUserProfile.toArray(),
        // 推文數據
        xTweetsData: await xDb.xTweetsData.toArray(),
        // 用戶發佈的推文（所有帳戶）
        xUserTweets: await xDb.xUserTweets.toArray(),
        // 角色X資料
        xCharacterProfiles: await xDb.xCharacterProfiles.toArray(),
        // 預設
        xPresets: await xDb.xPresets.toArray(),
        // 使用者提問箱資料（所有帳戶）
        xAskbox: await xDb.xAskbox.toArray(),
        // 當前活躍帳戶
        xActiveAccount: await xDb.xActiveAccount.toArray(),
        // 帳戶列表
        xAccountList: await xDb.xAccountList.toArray(),
        // NPC設置（所有帳戶）
        xNPCs: await xDb.xNPCs.toArray(),
        // 帳戶主頁數據（包含私信對話、陌生人消息、mentions通知等）
        xAccountProfiles: await xDb.xAccountProfiles.toArray(),
        // 帳戶提問箱資料
        xAccountAskbox: await xDb.xAccountAskbox.toArray(),
        // 書簽資料（所有帳戶）
        xBookmarks: await xDb.xBookmarks.toArray(),
        // 角色關係冊資料（所有帳戶）
        xCharacterRelationships: await xDb.xCharacterRelationships.toArray(),
        // 中繼資料
        exportTime: new Date().toISOString(),
        version: '2.1',
        dataType: 'x-social-full-backup',
      };

      const dataStr = JSON.stringify(exportData, null, 2);
      const dataBlob = new Blob([dataStr], { type: 'application/json' });

      const link = document.createElement('a');
      link.href = URL.createObjectURL(dataBlob);
      link.download = `x-data-backup-${new Date().toISOString().split('T')[0]}.json`;
      link.click();

      showXToast('所有資料已匯出', 'success');
      console.log('✅ X資料匯出成功，包含:', {
        設置數: exportData.xSettings.length,
        使用者資料數: exportData.xUserProfile.length,
        推文數據數: exportData.xTweetsData.length,
        用戶推文數: exportData.xUserTweets.length,
        角色X資料數: exportData.xCharacterProfiles.length,
        預設數: exportData.xPresets.length,
        用戶提問箱數: exportData.xAskbox.length,
        活躍帳戶數: exportData.xActiveAccount.length,
        帳戶列表數: exportData.xAccountList.length,
        NPC設置數: exportData.xNPCs.length,
        帳戶主頁數據數: exportData.xAccountProfiles.length,
        帳戶提問箱數: exportData.xAccountAskbox.length,
        書簽數: exportData.xBookmarks.length,
        關係冊數: exportData.xCharacterRelationships.length,
      });
    } catch (error) {
      console.error('❌ 匯出數據失敗:', error);
      showXToast('匯出失敗: ' + error.message, 'error');
    }
  }

  // 導入所有X資料
  function importXData() {
    if (
      !confirm(
        '⚠️ 警告：導入資料將完全替換當前所有X資料（包括使用者資料、推文、帖子、設置等），此操作不可撤銷！\n\n確定要繼續嗎？',
      )
    ) {
      return;
    }

    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';

    input.onchange = async function (event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = async function (e) {
        try {
          const importData = JSON.parse(e.target.result);

          // 驗證資料格式
          if (!importData || importData.dataType !== 'x-social-full-backup') {
            showXToast('導入失敗: 不是有效的X資料備份檔', 'error');
            return;
          }

          showXToast('正在導入資料，請稍候...', 'info');

          const xDb = getXDB();

          // 清空現有資料
          await xDb.xSettings.clear();
          await xDb.xUserProfile.clear();
          await xDb.xTweetsData.clear();
          await xDb.xUserTweets.clear();
          await xDb.xCharacterProfiles.clear();
          await xDb.xPresets.clear();
          await xDb.xAskbox.clear();
          await xDb.xActiveAccount.clear();
          await xDb.xAccountList.clear();
          await xDb.xNPCs.clear();
          await xDb.xAccountProfiles.clear();
          await xDb.xAccountAskbox.clear();
          await xDb.xBookmarks.clear();
          await xDb.xCharacterRelationships.clear();

          console.log('✅ 已清空舊數據');

          // 導入新數據
          if (importData.xSettings && importData.xSettings.length > 0) {
            await xDb.xSettings.bulkAdd(importData.xSettings);
          }
          if (importData.xUserProfile && importData.xUserProfile.length > 0) {
            await xDb.xUserProfile.bulkAdd(importData.xUserProfile);
          }
          if (importData.xTweetsData && importData.xTweetsData.length > 0) {
            await xDb.xTweetsData.bulkAdd(importData.xTweetsData);
          }
          if (importData.xUserTweets && importData.xUserTweets.length > 0) {
            await xDb.xUserTweets.bulkAdd(importData.xUserTweets);
          }
          if (importData.xCharacterProfiles && importData.xCharacterProfiles.length > 0) {
            await xDb.xCharacterProfiles.bulkAdd(importData.xCharacterProfiles);
          }
          if (importData.xPresets && importData.xPresets.length > 0) {
            await xDb.xPresets.bulkAdd(importData.xPresets);
          }
          if (importData.xAskbox && importData.xAskbox.length > 0) {
            await xDb.xAskbox.bulkAdd(importData.xAskbox);
          }
          if (importData.xActiveAccount && importData.xActiveAccount.length > 0) {
            await xDb.xActiveAccount.bulkAdd(importData.xActiveAccount);
          }
          if (importData.xAccountList && importData.xAccountList.length > 0) {
            await xDb.xAccountList.bulkAdd(importData.xAccountList);
          }
          if (importData.xNPCs && importData.xNPCs.length > 0) {
            await xDb.xNPCs.bulkAdd(importData.xNPCs);
          }
          if (importData.xAccountProfiles && importData.xAccountProfiles.length > 0) {
            await xDb.xAccountProfiles.bulkAdd(importData.xAccountProfiles);
          }
          if (importData.xAccountAskbox && importData.xAccountAskbox.length > 0) {
            await xDb.xAccountAskbox.bulkAdd(importData.xAccountAskbox);
          }
          if (importData.xBookmarks && importData.xBookmarks.length > 0) {
            await xDb.xBookmarks.bulkAdd(importData.xBookmarks);
          }
          if (importData.xCharacterRelationships && importData.xCharacterRelationships.length > 0) {
            await xDb.xCharacterRelationships.bulkAdd(importData.xCharacterRelationships);
          }

          console.log('✅ X資料導入成功，包含:', {
            設置數: importData.xSettings?.length || 0,
            使用者資料數: importData.xUserProfile?.length || 0,
            推文數據數: importData.xTweetsData?.length || 0,
            用戶推文數: importData.xUserTweets?.length || 0,
            角色X資料數: importData.xCharacterProfiles?.length || 0,
            預設數: importData.xPresets?.length || 0,
            用戶提問箱數: importData.xAskbox?.length || 0,
            活躍帳戶數: importData.xActiveAccount?.length || 0,
            帳戶列表數: importData.xAccountList?.length || 0,
            NPC設置數: importData.xNPCs?.length || 0,
            帳戶主頁數據數: importData.xAccountProfiles?.length || 0,
            帳戶提問箱數: importData.xAccountAskbox?.length || 0,
            書簽數: importData.xBookmarks?.length || 0,
            關係冊數: importData.xCharacterRelationships?.length || 0,
          });

          showXToast('資料導入成功！頁面即將刷新...', 'success');

          // 延遲刷新，讓用戶看到成功提示
          setTimeout(() => {
            window.location.reload();
          }, 1500);
        } catch (error) {
          console.error('❌ 導入數據失敗:', error);
          showXToast('導入失敗: ' + error.message, 'error');
        }
      };
      reader.readAsText(file);
    };

    input.click();
  }

  // 切換角色綁定
  function toggleCharacterBinding() {
    xSettingsData.characterBinding = !xSettingsData.characterBinding;
    updateCharacterToggleUI();

    const bindingArea = document.getElementById('character-binding-area');
    if (xSettingsData.characterBinding) {
      bindingArea.style.display = 'block';
      loadCharactersList();
    } else {
      bindingArea.style.display = 'none';
      // 清空綁定的角色
      if (!xSettingsData.boundCharacters) xSettingsData.boundCharacters = [];
    }
  }

  // 更新角色綁定切換按鈕UI
  function updateCharacterToggleUI() {
    const toggle = document.getElementById('x-character-toggle');
    const circle = toggle.querySelector('.toggle-circle');

    if (xSettingsData.characterBinding) {
      toggle.style.backgroundColor = 'var(--x-accent)';
      circle.style.left = '22px';
    } else {
      toggle.style.backgroundColor = '#333';
      circle.style.left = '2px';
    }
  }

  // 載入角色列表
  async function loadCharactersList() {
    try {
      // 獲取所有聊天中的非群組角色
      const db = getDB(); // 修正：chats表在全域資料庫中
      const allChats = await db.chats.toArray();
      const characters = allChats.filter(chat => !chat.isGroup);

      const charactersList = document.getElementById('characters-list');

      if (characters.length === 0) {
        charactersList.innerHTML = TemplateBuilders.buildEmptyState('暫無可綁定的角色，請先創建角色聊天');
        return;
      }

      if (!xSettingsData.boundCharacters) xSettingsData.boundCharacters = [];

      charactersList.innerHTML = characters
        .map(character => {
          const isChecked = xSettingsData.boundCharacters.includes(character.id);
          return TemplateBuilders.buildCharacterItem(character, isChecked);
        })
        .join('');
    } catch (error) {
      ValidationUtils.handleError(error, '載入角色列表');
      document.getElementById('characters-list').innerHTML = TemplateBuilders.buildErrorState('載入角色列表失敗');
    }
  }

  // 切換角色選擇狀態
  function toggleCharacterSelection(characterId) {
    if (!xSettingsData.boundCharacters) {
      xSettingsData.boundCharacters = [];
    }

    const index = xSettingsData.boundCharacters.indexOf(characterId);
    if (index > -1) {
      xSettingsData.boundCharacters.splice(index, 1);
    } else {
      xSettingsData.boundCharacters.push(characterId);
    }

    // 更新UI
    const checkbox = document.querySelector(`[data-character-id="${characterId}"]`);
    if (checkbox) {
      const isChecked = xSettingsData.boundCharacters.includes(characterId);
      checkbox.outerHTML = TemplateBuilders.buildCheckbox(characterId, isChecked);
    }
  }

  // 長按相關變數
  let longPressTimer = null;
  let longPressTarget = null;

  // 開始長按
  function startLongPress(characterId) {
    longPressTarget = characterId;
    longPressTimer = setTimeout(() => {
      if (longPressTarget === characterId) {
        openCharacterXProfile(characterId);
      }
    }, 500); // 500ms長按觸發
  }

  // 結束長按
  function endLongPress() {
    if (longPressTimer) {
      clearTimeout(longPressTimer);
      longPressTimer = null;
    }
    longPressTarget = null;
  }

  // 打開角色X資料設置
  async function openCharacterXProfile(characterId) {
    try {
      // 首先檢查彈窗元素是否存在
      const modalElement = document.getElementById('character-x-profile-modal');
      if (!modalElement) {
        console.error('❌ 角色X資料彈窗元素不存在於DOM中');
        showXToast('無法打開X資料設置，請先綁定角色', 'error');
        return;
      }

      const db = getDB(); // 修正：chats表在全域資料庫中
      const xDb = getXDB(); // X專用資料庫用於xCharacterProfiles

      const character = await db.chats.get(characterId);
      if (!character) {
        showXToast('未找到角色資訊', 'error');
        return;
      }

      // 載入現有的X資料
      let xProfile = await xDb.xCharacterProfiles.get(characterId);
      if (!xProfile) {
        // 創建預設X資料
        xProfile = {
          characterId: characterId,
          xName: character.name,
          xHandle: character.name.toLowerCase().replace(/\s+/g, '_'),
          xAvatar: 'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg',
          xVerified: false,
          xBio: '',
          relationships: [],
        };
      }

      // 確保有relationships欄位
      if (!xProfile.relationships) {
        xProfile.relationships = [];
      }

      // 檢查表單元素是否存在
      const formElement = document.getElementById('character-x-profile-form');
      if (!formElement) {
        console.error('❌ 角色X資料表單不存在，彈窗可能未正確載入');
        showXToast('彈窗載入失敗，請先勾選綁定該角色，然後刷新頁面重試', 'error');
        // 關閉彈窗
        const modal = document.getElementById('character-x-profile-modal');
        if (modal) modal.style.display = 'none';
        return;
      }

      // 填充彈窗內容
      const infoDisplay = document.getElementById('character-info-display');
      if (infoDisplay) {
        infoDisplay.innerHTML = TemplateBuilders.buildCharacterInfoDisplay(character);
      }

      // 獲取所有表單元素（使用安全的方式）
      const avatarElement = document.getElementById('character-x-avatar');
      const avatarUrlElement = document.getElementById('character-x-avatar-url');
      const coverPreviewElement = document.getElementById('character-x-cover-preview');
      const coverUrlElement = document.getElementById('character-x-cover-url');
      const nameElement = document.getElementById('character-x-name');
      const handleElement = document.getElementById('character-x-handle');
      const verifiedElement = document.getElementById('character-x-verified');
      const tag1IconElement = document.getElementById('character-tag1-icon');
      const tag1TextElement = document.getElementById('character-custom-tag1');
      const tag1ColorElement = document.getElementById('character-tag1-color');
      const tag2IconElement = document.getElementById('character-tag2-icon');
      const tag2TextElement = document.getElementById('character-custom-tag2');
      const tag2ColorElement = document.getElementById('character-tag2-color');
      const followingCountElement = document.getElementById('character-following-count');
      const followersCountElement = document.getElementById('character-followers-count');
      const bioElement = document.getElementById('character-x-bio');
      const publicIdentityElement = document.getElementById('character-public-identity');
      const showRealNameElement = document.getElementById('character-show-real-name');
      const realNameElement = document.getElementById('character-real-name');

      // 安全地設置元素值 - 統一使用預設頭像
      const defaultAvatar = 'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg';
      const defaultCover = 'https://i.postimg.cc/qRzMB6nQ/default-cover.jpg';

      // 頭像設置
      if (avatarElement) avatarElement.src = xProfile.xAvatar || defaultAvatar;
      if (avatarUrlElement) avatarUrlElement.value = xProfile.xAvatar || defaultAvatar;

      // 背景圖設置
      if (coverPreviewElement) coverPreviewElement.src = xProfile.xCover || defaultCover;
      if (coverUrlElement) coverUrlElement.value = xProfile.xCover || '';

      // 基本資訊設置（必填欄位提供預設值）
      if (nameElement) nameElement.value = xProfile.xName || character.name || '';
      if (handleElement) handleElement.value = xProfile.xHandle || '';
      if (verifiedElement) verifiedElement.checked = xProfile.xVerified || false;

      // 自訂標籤設置
      if (tag1IconElement) tag1IconElement.value = xProfile.customTag1?.icon || '';
      if (tag1TextElement) tag1TextElement.value = xProfile.customTag1?.text || '';
      if (tag1ColorElement) tag1ColorElement.value = xProfile.customTag1?.color || '#71767b';
      if (tag2IconElement) tag2IconElement.value = xProfile.customTag2?.icon || '';
      if (tag2TextElement) tag2TextElement.value = xProfile.customTag2?.text || '';
      if (tag2ColorElement) tag2ColorElement.value = xProfile.customTag2?.color || '#71767b';

      // 關注數量設置
      if (followingCountElement) followingCountElement.value = xProfile.followingCount || '';
      if (followersCountElement) followersCountElement.value = xProfile.followersCount || '';

      // 簡介和公眾身份設置
      if (bioElement) bioElement.value = xProfile.xBio || '';
      if (publicIdentityElement) publicIdentityElement.value = xProfile.publicIdentity || '';

      // 真名設置
      if (showRealNameElement) showRealNameElement.checked = xProfile.showRealName || false;
      if (realNameElement) realNameElement.value = xProfile.realName || '';

      // 根據核取方塊狀態顯示/隱藏真名輸入框
      toggleCharacterRealNameInput();

      // 自動發消息設置
      const autoMessageEnabledElement = document.getElementById('character-auto-message-enabled');
      const autoMessageIntervalElement = document.getElementById('character-auto-message-interval');

      if (autoMessageEnabledElement) {
        autoMessageEnabledElement.checked = xProfile.autoMessageEnabled || false;
      }
      if (autoMessageIntervalElement) {
        autoMessageIntervalElement.value = xProfile.autoMessageInterval || 60;
      }

      // 根據核取方塊狀態顯示/隱藏時間設置
      window.toggleAutoMessageSettings();

      // 更新字元計數
      updateCharacterXProfileCounts();

      // 設置當前編輯的角色ID（formElement已在前面聲明）
      formElement.setAttribute('data-character-id', characterId);

      // 渲染關係列表
      console.log('📖 [打開X資料] 載入關係資料，關係數:', (xProfile.relationships || []).length);
      renderRelationshipsList(xProfile.relationships || []);

      // 顯示彈窗
      const modal = document.getElementById('character-x-profile-modal');
      if (modal) {
        modal.style.display = 'block';
      }
    } catch (error) {
      ValidationUtils.handleError(error, '打開角色X資料');
    }
  }

  // 關閉角色X資料設置彈窗
  function closeCharacterXProfileModal() {
    const modal = document.getElementById('character-x-profile-modal');
    if (modal) {
      modal.style.display = 'none';
    }
  }

  // 更新角色X頭像
  function updateCharacterXAvatar(url) {
    const avatarImg = document.getElementById('character-x-avatar');

    if (!url || url.trim() === '') {
      // 如果URL為空，使用默認頭像
      avatarImg.src = 'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg';
      return;
    }

    // 驗證URL格式
    try {
      new URL(url);
    } catch (e) {
      avatarImg.src = 'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg';
      return;
    }

    // 驗證是否為圖片URL
    const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp'];
    const isImageUrl = imageExtensions.some(ext => url.toLowerCase().includes(ext));

    if (!isImageUrl) {
      // 不是明顯的圖片URL，但仍然嘗試載入
      avatarImg.onerror = function () {
        this.src = 'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg';
        showXToast('頭像連結無效，已使用預設頭像', 'warning');
      };
    }

    avatarImg.src = url;
  }

  // 更新角色X背景圖
  function updateCharacterXCover(url) {
    const coverImg = document.getElementById('character-x-cover-preview');

    if (!url || url.trim() === '') {
      coverImg.src = 'https://i.postimg.cc/qRzMB6nQ/default-cover.jpg';
      return;
    }

    try {
      new URL(url);
    } catch (e) {
      coverImg.src = 'https://i.postimg.cc/qRzMB6nQ/default-cover.jpg';
      return;
    }

    const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp'];
    const isImageUrl = imageExtensions.some(ext => url.toLowerCase().includes(ext));

    if (!isImageUrl) {
      coverImg.onerror = function () {
        this.src = 'https://i.postimg.cc/qRzMB6nQ/default-cover.jpg';
        showXToast('背景圖連結無效，已使用預設背景', 'warning');
      };
    }

    coverImg.src = url;
  }

  // 更新簡介字元計數（保持相容性）
  function updateCharacterBioCount() {
    updateCharacterXProfileCounts();
  }

  // 更新角色X資料所有字元計數
  function updateCharacterXProfileCounts() {
    // 更新簡介計數
    const bioTextarea = document.getElementById('character-x-bio');
    const bioCountSpan = document.getElementById('character-bio-count');
    if (bioTextarea && bioCountSpan) {
      bioCountSpan.textContent = bioTextarea.value.length;
    }

    // 角色公眾身份已移除字元限制，無需計數

    // 更新真實姓名計數
    const realNameInput = document.getElementById('character-real-name');
    const realNameCountSpan = document.getElementById('character-real-name-count');
    if (realNameInput && realNameCountSpan) {
      realNameCountSpan.textContent = realNameInput.value.length;
    }
  }

  // 保存角色X資料
  async function saveCharacterXProfile(event) {
    event.preventDefault();

    const formElement = document.getElementById('character-x-profile-form');
    if (!formElement) {
      showXToast('表單元素未找到', 'error');
      return;
    }

    const characterId = formElement.getAttribute('data-character-id');
    if (!characterId) {
      showXToast('角色ID未找到', 'error');
      return;
    }

    // 獲取表單值，使用安全的訪問方式
    const getElementValue = (id, defaultValue = '') => {
      const element = document.getElementById(id);
      return element ? element.value.trim() : defaultValue;
    };

    const getElementChecked = (id, defaultValue = false) => {
      const element = document.getElementById(id);
      return element ? element.checked : defaultValue;
    };

    const xName = getElementValue('character-x-name');
    const xHandle = getElementValue('character-x-handle');
    const xAvatarUrl = getElementValue('character-x-avatar-url');
    const xAvatar = xAvatarUrl || 'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg';
    const xVerified = getElementChecked('character-x-verified');
    const xCoverUrl = getElementValue('character-x-cover-url');
    const xCover = xCoverUrl || 'https://i.postimg.cc/qRzMB6nQ/default-cover.jpg';
    const tag1Icon = getElementValue('character-tag1-icon');
    const tag1Text = getElementValue('character-custom-tag1');
    const tag1ColorElement = document.getElementById('character-tag1-color');
    const tag1Color = tag1ColorElement ? tag1ColorElement.value : '#71767b';
    const tag2Icon = getElementValue('character-tag2-icon');
    const tag2Text = getElementValue('character-custom-tag2');
    const tag2ColorElement = document.getElementById('character-tag2-color');
    const tag2Color = tag2ColorElement ? tag2ColorElement.value : '#71767b';
    const followingCount = getElementValue('character-following-count');
    const followersCount = getElementValue('character-followers-count');
    const xBio = getElementValue('character-x-bio');
    const publicIdentity = getElementValue('character-public-identity');
    const showRealName = getElementChecked('character-show-real-name');
    const realName = getElementValue('character-real-name');
    const autoMessageEnabled = getElementChecked('character-auto-message-enabled');
    const autoMessageInterval = parseInt(getElementValue('character-auto-message-interval')) || 60;

    // 僅驗證必填欄位（用戶名和控制碼）
    if (!xName) {
      showXToast('X用戶名不能為空', 'error');
      return;
    }

    if (!xHandle) {
      showXToast('X控制碼不能為空', 'error');
      return;
    }

    // 驗證長度限制（僅對已填寫的欄位）
    if (xName.length > 50) {
      showXToast('X用戶名不能超過50個字元', 'error');
      return;
    }

    if (xHandle.length > 15) {
      showXToast('X控制碼不能超過15個字元', 'error');
      return;
    }

    if (xBio && xBio.length > 160) {
      showXToast('X簡介不能超過160個字元', 'error');
      return;
    }

    if (showRealName && realName && realName.length > 50) {
      showXToast('真實姓名不能超過50個字元', 'error');
      return;
    }

    // 如果選擇公開真名但未填寫，給予警告但不阻止保存
    if (showRealName && !realName) {
      showXToast('建議填寫真實姓名', 'warning');
    }

    // 驗證自動發消息間隔
    if (autoMessageEnabled) {
      if (autoMessageInterval < 10) {
        showXToast('自動發消息間隔不能少於10秒', 'error');
        return;
      }
      if (autoMessageInterval > 3600) {
        showXToast('自動發消息間隔不能超過3600秒', 'error');
        return;
      }
    }

    // 驗證頭像URL（如果填寫了）
    if (xAvatarUrl) {
      try {
        new URL(xAvatarUrl);
      } catch (e) {
        showXToast('頭像URL格式無效，將使用默認頭像', 'warning');
      }
    }

    try {
      const db = getXDB();

      console.log('💾 [保存X資料] 開始保存，當前關係數:', currentRelationships.length);

      // 🔧 修復：先讀取現有的xProfile，保留userPersona欄位
      const existingProfile = await db.xCharacterProfiles.get(characterId);
      const userPersona = existingProfile?.userPersona || ''; // 保留現有的用戶人設

      console.log('💾 [保存X資料] 保留現有使用者人設，長度:', userPersona.length, '字元');

      // 保存X資料（使用全域的 currentRelationships，而不是重新從資料庫讀取）
      await db.xCharacterProfiles.put({
        characterId: characterId,
        xName: xName,
        xHandle: xHandle,
        xAvatar: xAvatar,
        xVerified: xVerified,
        xCover: xCover,
        customTag1: tag1Text ? { icon: tag1Icon, text: tag1Text, color: tag1Color } : null,
        customTag2: tag2Text ? { icon: tag2Icon, text: tag2Text, color: tag2Color } : null,
        followingCount: followingCount,
        followersCount: followersCount,
        xBio: xBio,
        publicIdentity: publicIdentity,
        showRealName: showRealName,
        realName: showRealName ? realName : '', // 只有選擇公開時才保存真名
        relationships: JSON.parse(JSON.stringify(currentRelationships)), // 深拷貝避免引用問題
        autoMessageEnabled: autoMessageEnabled,
        autoMessageInterval: autoMessageInterval,
        userPersona: userPersona, // 🔧 保留用戶人設欄位
        lastUpdated: new Date().toISOString(),
      });

      console.log('✅ [保存X資料] X資料已保存，關係數:', currentRelationships.length);
      showXToast('X資料已保存', 'success');

      // 重啟自動發消息系統以應用新設置
      if (typeof stopAutoMessageSystem === 'function' && typeof startAutoMessageSystem === 'function') {
        stopAutoMessageSystem();
        setTimeout(() => {
          startAutoMessageSystem();
        }, 500);
      }

      closeCharacterXProfileModal();
    } catch (error) {
      console.error('❌ [保存X資料] 保存角色X資料失敗:', error);
      showXToast('保存失敗: ' + error.message, 'error');
    }
  }

  // NPC關係綁定功能

  // 當前編輯的關係ID（用於編輯模式）
  let currentEditingRelationshipId = null;
  // 當前關係列表
  let currentRelationships = [];

  // 渲染關係列表
  function renderRelationshipsList(relationships) {
    // 深拷貝陣列，避免引用問題導致資料不同步
    currentRelationships = relationships ? JSON.parse(JSON.stringify(relationships)) : [];
    console.log('📋 [渲染關係列表] 當前關係數:', currentRelationships.length);

    const container = document.getElementById('character-relationships-list');

    if (currentRelationships.length === 0) {
      container.innerHTML = `
                <div style="text-align: center; color: #71767b; font-size: 13px; padding: 20px;">
                  暫無綁定關係，點擊上方"添加關係"按鈕開始綁定NPC
                </div>
              `;
      return;
    }

    container.innerHTML = currentRelationships
      .map(
        rel => `
              <div style="background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; padding: 12px; margin-bottom: 8px;">
                <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px;">
                  <div style="flex: 1;">
                    <div style="color: #fff; font-weight: 600; font-size: 14px; margin-bottom: 4px;">
                      ${rel.npcName} <span style="color: #71767b; font-weight: normal;">${rel.npcHandle}</span>
                    </div>
                    <div style="color: var(--x-accent); font-size: 12px; background-color: rgba(29,155,240,0.1); padding: 2px 8px; border-radius: 12px; display: inline-block; margin-bottom: 6px;">
                      ${rel.relationshipType}
                    </div>
                  </div>
                  <div style="display: flex; gap: 8px;">
                    <button onclick="editRelationship('${rel.id}')" 
                      style="background: none; border: none; color: var(--x-accent); cursor: pointer; padding: 4px 8px; font-size: 12px;">
                      編輯
                    </button>
                    <button onclick="deleteRelationship('${rel.id}')" 
                      style="background: none; border: none; color: #f4212e; cursor: pointer; padding: 4px 8px; font-size: 12px;">
                      刪除
                    </button>
                  </div>
                </div>
                ${
                  rel.description
                    ? `<div style="color: #71767b; font-size: 12px; line-height: 1.4;">${rel.description}</div>`
                    : ''
                }
              </div>
            `,
      )
      .join('');
  }

  // 打開添加關係彈窗
  function openAddRelationshipModal() {
    currentEditingRelationshipId = null;
    document.getElementById('relationship-modal-title').textContent = '添加NPC關係';

    // 清空表單
    document.getElementById('relationship-npc-name').value = '';
    document.getElementById('relationship-npc-handle').value = '';
    document.getElementById('relationship-type').value = '朋友';
    document.getElementById('relationship-description').value = '';
    updateRelationshipDescCount();

    document.getElementById('relationship-modal').style.display = 'block';
  }

  // 編輯關係
  function editRelationship(relationshipId) {
    const relationship = currentRelationships.find(rel => rel.id === relationshipId);
    if (!relationship) return;

    currentEditingRelationshipId = relationshipId;
    document.getElementById('relationship-modal-title').textContent = '編輯NPC關係';

    // 填充表單
    document.getElementById('relationship-npc-name').value = relationship.npcName;
    document.getElementById('relationship-npc-handle').value = relationship.npcHandle;
    document.getElementById('relationship-type').value = relationship.relationshipType;
    document.getElementById('relationship-description').value = relationship.description || '';
    updateRelationshipDescCount();

    document.getElementById('relationship-modal').style.display = 'block';
  }

  // 刪除關係
  async function deleteRelationship(relationshipId) {
    if (!confirm('確定要刪除這個關係綁定嗎？')) return;

    try {
      console.log('🗑️ [刪除關係] 開始刪除關係:', relationshipId);
      console.log('🗑️ [刪除關係] 刪除前關係數:', currentRelationships.length);

      // 從當前列表中移除
      const beforeLength = currentRelationships.length;
      currentRelationships = currentRelationships.filter(rel => rel.id !== relationshipId);
      const afterLength = currentRelationships.length;

      console.log('🗑️ [刪除關係] 刪除後關係數:', afterLength);

      if (beforeLength === afterLength) {
        console.warn('⚠️ [刪除關係] 未找到要刪除的關係');
        showXToast('未找到要刪除的關係', 'warning');
        return;
      }

      // 保存到資料庫
      await saveRelationshipsToDatabase();

      // 更新介面
      renderRelationshipsList(currentRelationships);

      showXToast('關係已刪除', 'success');
    } catch (error) {
      console.error('❌ [刪除關係] 刪除關係失敗:', error);
      showXToast(`刪除失敗: ${error.message}`, 'error');
    }
  }

  // 關閉關係編輯彈窗
  function closeRelationshipModal() {
    document.getElementById('relationship-modal').style.display = 'none';
    currentEditingRelationshipId = null;
  }

  // 更新關係描述字元計數
  function updateRelationshipDescCount() {
    const descTextarea = document.getElementById('relationship-description');
    const countSpan = document.getElementById('relationship-desc-count');
    countSpan.textContent = descTextarea.value.length;
  }

  // 保存關係到資料庫
  async function saveRelationshipsToDatabase() {
    const characterId = document.getElementById('character-x-profile-form').getAttribute('data-character-id');
    if (!characterId) {
      console.error('❌ [保存關係] 無法獲取角色ID');
      throw new Error('無法獲取角色ID，保存失敗');
    }

    try {
      const db = getXDB();

      // 獲取當前X資料
      const currentProfile = await db.xCharacterProfiles.get(characterId);
      if (!currentProfile) {
        console.error('❌ [保存關係] 未找到角色資料:', characterId);
        throw new Error('未找到角色資料');
      }

      // 更新關係資料（深拷貝陣列，避免引用問題）
      currentProfile.relationships = JSON.parse(JSON.stringify(currentRelationships));
      await db.xCharacterProfiles.put(currentProfile);

      console.log('✅ [保存關係] 關係已保存到資料庫，當前關係數:', currentProfile.relationships.length);
    } catch (error) {
      console.error('❌ [保存關係] 保存關係到資料庫失敗:', error);
      throw error;
    }
  }

  // 保存關係表單
  async function saveRelationshipForm(event) {
    event.preventDefault();

    const npcName = document.getElementById('relationship-npc-name').value.trim();
    const npcHandle = document.getElementById('relationship-npc-handle').value.trim();
    const relationshipType = document.getElementById('relationship-type').value;
    const description = document.getElementById('relationship-description').value.trim();

    // 驗證資料
    if (!npcName) {
      showXToast('NPC名稱不能為空', 'error');
      return;
    }

    if (!npcHandle) {
      showXToast('NPC控制碼不能為空', 'error');
      return;
    }

    // 確保控制碼格式正確
    const handleFormatted = npcHandle.startsWith('@') ? npcHandle : `@${npcHandle}`;

    try {
      if (currentEditingRelationshipId) {
        // 編輯模式
        const relationshipIndex = currentRelationships.findIndex(rel => rel.id === currentEditingRelationshipId);
        if (relationshipIndex !== -1) {
          currentRelationships[relationshipIndex] = {
            ...currentRelationships[relationshipIndex],
            npcName: npcName,
            npcHandle: handleFormatted,
            relationshipType: relationshipType,
            description: description,
            updatedAt: new Date().toISOString(),
          };
        }
      } else {
        // 添加模式
        const newRelationship = {
          id: 'rel_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
          npcName: npcName,
          npcHandle: handleFormatted,
          relationshipType: relationshipType,
          description: description,
          createdAt: new Date().toISOString(),
        };
        currentRelationships.push(newRelationship);
      }

      // 保存到資料庫
      await saveRelationshipsToDatabase();

      // 更新介面
      renderRelationshipsList(currentRelationships);

      // 關閉彈窗
      closeRelationshipModal();

      showXToast(currentEditingRelationshipId ? '關係已更新' : '關係已添加', 'success');
    } catch (error) {
      console.error('保存關係失敗:', error);
      showXToast('保存失敗', 'error');
    }
  }

  // ============================================
  // 角色關係冊功能
  // ============================================

  // 角色關係冊資料結構
  let characterRelationshipData = {
    characters: [], // 已綁定角色列表
    links: [], // 關係連線列表 { id, charA, charB, relationAtoB, relationBtoA }
  };

  // 當前編輯的關係連線ID
  let currentEditingLinkId = null;

  // 切換角色關係冊開關
  async function toggleCharacterRelationship() {
    if (!xSettingsData.characterRelationship) {
      xSettingsData.characterRelationship = {};
    }
    xSettingsData.characterRelationship.enabled = !xSettingsData.characterRelationship.enabled;

    // 更新UI
    updateRelationshipToggleUI();

    // 顯示/隱藏關係冊管理區域
    const relationshipArea = document.getElementById('relationship-binding-area');
    if (xSettingsData.characterRelationship.enabled) {
      relationshipArea.style.display = 'block';
      await loadRelationshipData();
      // 稍微延遲更新預覽，確保畫布已渲染
      setTimeout(() => {
        updateRelationshipPreview();
      }, 100);
    } else {
      relationshipArea.style.display = 'none';
    }

    // 自動保存設置
    await saveXSettings();
  }

  // 更新關係冊切換按鈕UI
  function updateRelationshipToggleUI() {
    const toggle = document.getElementById('x-relationship-toggle');
    const circle = toggle?.querySelector('.toggle-circle');

    if (!toggle || !circle) return;

    const enabled = xSettingsData.characterRelationship?.enabled || false;

    if (enabled) {
      toggle.style.backgroundColor = 'var(--x-accent)';
      circle.style.left = '22px';
    } else {
      toggle.style.backgroundColor = '#333';
      circle.style.left = '2px';
    }
  }

  // 載入關係冊資料
  async function loadRelationshipData() {
    try {
      const db = getXDB();
      const currentAccount = currentAccountId || 'main';
      const dataId = `xCharacterRelationships_${currentAccount}`;

      const savedData = await db.xCharacterRelationships.get(dataId);

      // 獲取當前綁定的所有角色
      const boundChars = xSettingsData.boundCharacters || [];
      const mainDB = getDB();
      const allChats = await mainDB.chats.toArray();

      const currentBoundCharacters = allChats
        .filter(chat => !chat.isGroup && boundChars.includes(chat.id))
        .map(chat => ({
          id: chat.id,
          name: chat.name,
          avatar: chat.settings?.aiAvatar || 'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg',
        }));

      if (savedData && savedData.data) {
        // 已有保存資料：合併角色列表，保留關係連線
        characterRelationshipData = savedData.data;

        // 同步角色列表：添加新綁定的角色，移除已解綁的角色
        const existingCharIds = new Set(characterRelationshipData.characters.map(c => c.id));
        const currentCharIds = new Set(currentBoundCharacters.map(c => c.id));

        // 添加新角色（保留位置資訊）
        currentBoundCharacters.forEach(char => {
          if (!existingCharIds.has(char.id)) {
            characterRelationshipData.characters.push(char);
            console.log('➕ 新增角色到關係冊:', char.name);
          }
        });

        // 移除已解綁的角色，並刪除相關的連線
        characterRelationshipData.characters = characterRelationshipData.characters.filter(char => {
          const isStillBound = currentCharIds.has(char.id);
          if (!isStillBound) {
            console.log('➖ 從關係冊移除角色:', char.name);
            // 刪除與該角色相關的所有連線
            characterRelationshipData.links = characterRelationshipData.links.filter(
              link => link.charA !== char.id && link.charB !== char.id,
            );
          }
          return isStillBound;
        });

        // 更新現有角色的名稱和頭像（可能被修改過）
        characterRelationshipData.characters.forEach(char => {
          const updatedChar = currentBoundCharacters.find(c => c.id === char.id);
          if (updatedChar) {
            char.name = updatedChar.name;
            char.avatar = updatedChar.avatar;
          }
        });
      } else {
        // 無保存資料：初始化
        characterRelationshipData.characters = currentBoundCharacters;
        characterRelationshipData.links = [];
      }

      console.log('✅ 已載入角色關係資料:', {
        角色數: characterRelationshipData.characters.length,
        關係數: characterRelationshipData.links.length,
        角色列表: characterRelationshipData.characters.map(c => c.name),
      });
    } catch (error) {
      console.error('❌ 載入關係資料失敗:', error);
    }
  }

  // 更新預覽畫布
  function updateRelationshipPreview() {
    const canvas = document.getElementById('relationship-preview-canvas');
    const placeholder = document.getElementById('relationship-preview-placeholder');
    const stats = document.getElementById('relationship-stats');

    if (!canvas) return;

    const linkCount = characterRelationshipData.links?.length || 0;
    const charCount = characterRelationshipData.characters?.length || 0;
    const chars = characterRelationshipData.characters || [];
    const links = characterRelationshipData.links || [];

    if (charCount > 0) {
      placeholder.style.display = 'none';
      stats.style.display = 'block';
      document.getElementById('relationship-character-count').textContent = charCount;
      document.getElementById('relationship-link-count').textContent = linkCount;

      // 繪製縮小版關係圖預覽
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // 讀取當前主題的顏色
      const computedStyle = getComputedStyle(document.documentElement);
      const accentColor = computedStyle.getPropertyValue('--x-accent').trim() || '#1d9bf0';
      const bgColor = computedStyle.getPropertyValue('--x-bg-primary').trim() || '#000';
      const textColor = computedStyle.getPropertyValue('--x-text-primary').trim() || '#fff';

      // 縮放比例
      const scale = 0.5;
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const radius = Math.min(canvas.width, canvas.height) / 2 - 20;

      // 計算角色位置
      chars.forEach((char, index) => {
        const angle = (index / chars.length) * Math.PI * 2 - Math.PI / 2;
        char.previewX = centerX + radius * Math.cos(angle);
        char.previewY = centerY + radius * Math.sin(angle);
      });

      // 繪製連線
      ctx.strokeStyle = accentColor;
      ctx.lineWidth = 1.5;
      links.forEach(link => {
        const charA = chars.find(c => c.id === link.charA);
        const charB = chars.find(c => c.id === link.charB);

        if (charA && charB) {
          ctx.beginPath();
          ctx.moveTo(charA.previewX, charA.previewY);
          ctx.lineTo(charB.previewX, charB.previewY);
          ctx.stroke();
        }
      });

      // 繪製角色節點
      chars.forEach(char => {
        ctx.beginPath();
        ctx.arc(char.previewX, char.previewY, 15, 0, Math.PI * 2);
        ctx.fillStyle = accentColor;
        ctx.fill();
        ctx.strokeStyle = bgColor;
        ctx.lineWidth = 2;
        ctx.stroke();

        // 繪製首字母
        ctx.fillStyle = textColor;
        ctx.font = 'bold 10px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(char.name.charAt(0), char.previewX, char.previewY);
      });
    } else {
      placeholder.style.display = 'block';
      stats.style.display = 'none';
    }
  }

  // 視窗大小改變時重新渲染（用於處理設備旋轉等情況）
  let resizeTimeout;
  function handleRelationshipCanvasResize() {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
      const modal = document.getElementById('character-relationship-graph-modal');
      if (modal && modal.style.display !== 'none') {
        initRelationshipCanvas();
        renderRelationshipGraph();
      }
    }, 300);
  }

  // ESC 鍵處理函數
  function handleRelationshipGraphKeyPress(event) {
    if (event.key === 'Escape' && isSelectingCharsForLink) {
      // 取消選擇模式
      isSelectingCharsForLink = false;
      selectedCharForLink = null;
      renderRelationshipGraph();
      showXToast('已取消選擇', 'info');
      console.log('📍 已退出角色選擇模式');
    }
  }

  // 打開關係圖編輯器
  async function openCharacterRelationshipGraph() {
    await loadRelationshipData();

    const modal = document.getElementById('character-relationship-graph-modal');
    if (modal) {
      modal.style.display = 'block';
      document.body.style.overflow = 'hidden';

      // 初始化畫布
      setTimeout(() => {
        initRelationshipCanvas();
        renderRelationshipGraph();
        renderRelationshipList();
      }, 100);

      // 監聽視窗大小改變
      window.addEventListener('resize', handleRelationshipCanvasResize);
      window.addEventListener('orientationchange', handleRelationshipCanvasResize);

      // 監聽鍵盤事件（用於 ESC 取消選擇）
      window.addEventListener('keydown', handleRelationshipGraphKeyPress);
    }
  }

  // 關閉關係圖編輯器
  function closeCharacterRelationshipGraph(event) {
    if (event && event.target !== event.currentTarget) return;

    const modal = document.getElementById('character-relationship-graph-modal');
    if (modal) {
      modal.style.display = 'none';
      document.body.style.overflow = 'auto';

      // 重置選擇狀態
      isSelectingCharsForLink = false;
      selectedCharForLink = null;

      // 移除事件監聽器
      window.removeEventListener('resize', handleRelationshipCanvasResize);
      window.removeEventListener('orientationchange', handleRelationshipCanvasResize);
      window.removeEventListener('keydown', handleRelationshipGraphKeyPress);
    }
  }

  // 拖拽狀態
  let isDragging = false;
  let draggedCharId = null;
  let dragOffsetX = 0;
  let dragOffsetY = 0;

  // 角色選擇狀態（用於創建連線）
  let isSelectingCharsForLink = false;
  let selectedCharForLink = null;

  // 初始化關係圖畫布
  function initRelationshipCanvas() {
    const canvas = document.getElementById('relationship-graph-canvas');
    if (!canvas) return;

    // 設置畫布實際大小
    const container = canvas.parentElement;
    canvas.width = container.clientWidth;
    canvas.height = container.clientHeight;

    // 綁定滑鼠事件
    canvas.onmousedown = handleCanvasMouseDown;
    canvas.onmousemove = handleCanvasMouseMove;
    canvas.onmouseup = handleCanvasMouseUp;
    canvas.onclick = handleCanvasClick;

    // 綁定觸摸事件（移動端支持）
    canvas.addEventListener('touchstart', handleCanvasTouchStart, { passive: false });
    canvas.addEventListener('touchmove', handleCanvasTouchMove, { passive: false });
    canvas.addEventListener('touchend', handleCanvasTouchEnd, { passive: false });
  }

  // 緩存載入的頭像圖片
  const avatarImageCache = {};

  // 渲染關係圖
  function renderRelationshipGraph() {
    const canvas = document.getElementById('relationship-graph-canvas');
    const emptyState = document.getElementById('graph-empty-state');

    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    const chars = characterRelationshipData.characters || [];
    const links = characterRelationshipData.links || [];

    // 讀取當前主題的顏色
    const computedStyle = getComputedStyle(document.documentElement);
    const accentColor = computedStyle.getPropertyValue('--x-accent').trim() || '#1d9bf0';
    const bgPrimary = computedStyle.getPropertyValue('--x-bg-primary').trim() || '#000';
    const bgSecondary = computedStyle.getPropertyValue('--x-bg-secondary').trim() || '#1a1a1a';
    const textPrimary = computedStyle.getPropertyValue('--x-text-primary').trim() || '#fff';

    // 判斷是否為暗色主題（用於設置半透明背景）
    const isDark = bgPrimary.includes('#000') || bgPrimary.includes('0, 0, 0');
    const textBgColor = isDark ? 'rgba(0, 0, 0, 0.7)' : 'rgba(255, 255, 255, 0.85)';

    // 更新統計
    document.getElementById('graph-character-count').textContent = `${chars.length} 角色`;
    document.getElementById('graph-link-count').textContent = `${links.length} 關係`;

    if (chars.length === 0) {
      emptyState.style.display = 'block';
      return;
    }

    emptyState.style.display = 'none';
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // 繪製選擇模式提示
    if (isSelectingCharsForLink) {
      const tipText = selectedCharForLink ? '請點擊第二個角色' : '請點擊第一個角色';
      ctx.fillStyle = accentColor;
      ctx.font = 'bold 16px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(tipText, canvas.width / 2, 30);

      // 繪製取消按鈕提示
      ctx.fillStyle = textPrimary;
      ctx.font = '12px sans-serif';
      ctx.fillText('(按 ESC 鍵取消)', canvas.width / 2, 50);
    }

    // 初始化位置（圓形佈局）- 只在沒有位置時設置
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const radius = Math.min(canvas.width, canvas.height) / 3;

    chars.forEach((char, index) => {
      if (char.x === undefined || char.y === undefined) {
        const angle = (index / chars.length) * Math.PI * 2 - Math.PI / 2;
        char.x = centerX + radius * Math.cos(angle);
        char.y = centerY + radius * Math.sin(angle);
      }
    });

    // 繪製連線
    links.forEach(link => {
      const charA = chars.find(c => c.id === link.charA);
      const charB = chars.find(c => c.id === link.charB);

      if (charA && charB) {
        ctx.beginPath();
        ctx.moveTo(charA.x, charA.y);
        ctx.lineTo(charB.x, charB.y);
        ctx.strokeStyle = accentColor;
        ctx.lineWidth = 2;
        ctx.stroke();

        // 繪製關係文本
        const midX = (charA.x + charB.x) / 2;
        const midY = (charA.y + charB.y) / 2;

        // 動態計算文字方塊大小
        const isMobile = window.innerWidth < 768;
        const textBoxWidth = isMobile ? 70 : 80;
        const textBoxHeight = isMobile ? 30 : 35;
        const fontSize = isMobile ? '10px' : '11px';

        // 繪製文本背景
        ctx.fillStyle = textBgColor;
        ctx.fillRect(midX - textBoxWidth / 2, midY - textBoxHeight / 2, textBoxWidth, textBoxHeight);

        ctx.fillStyle = accentColor;
        ctx.font = fontSize + ' sans-serif';
        ctx.textAlign = 'center';
        const lineSpacing = isMobile ? 12 : 15;
        ctx.fillText(link.relationAtoB || '關係', midX, midY - lineSpacing / 2);
        ctx.fillText(link.relationBtoA || '關係', midX, midY + lineSpacing / 2);
      }
    });

    // 動態計算頭像大小（移動端縮小）
    const isMobile = window.innerWidth < 768;
    const avatarRadius = isMobile ? 25 : 35;
    const avatarInnerRadius = avatarRadius - 2;

    // 繪製角色頭像和名稱
    chars.forEach(char => {
      // 檢查是否為選中的角色
      const isSelected = isSelectingCharsForLink && selectedCharForLink === char.id;

      // 繪製選中高亮圈（外圈）
      if (isSelected) {
        ctx.beginPath();
        ctx.arc(char.x, char.y, avatarRadius + 5, 0, Math.PI * 2);
        ctx.strokeStyle = accentColor;
        ctx.lineWidth = 3;
        ctx.stroke();
      }

      // 繪製圓形背景
      ctx.beginPath();
      ctx.arc(char.x, char.y, avatarRadius, 0, Math.PI * 2);
      ctx.fillStyle = isSelected ? '#FFA500' : accentColor; // 選中時使用橙色
      ctx.fill();
      ctx.strokeStyle = bgPrimary;
      ctx.lineWidth = 2;
      ctx.stroke();

      // 繪製頭像圖片
      if (char.avatar) {
        if (avatarImageCache[char.avatar]) {
          // 使用緩存的圖片
          const img = avatarImageCache[char.avatar];
          ctx.save();
          ctx.beginPath();
          ctx.arc(char.x, char.y, avatarInnerRadius, 0, Math.PI * 2);
          ctx.closePath();
          ctx.clip();
          ctx.drawImage(
            img,
            char.x - avatarInnerRadius,
            char.y - avatarInnerRadius,
            avatarInnerRadius * 2,
            avatarInnerRadius * 2,
          );
          ctx.restore();
        } else {
          // 載入圖片
          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.onload = () => {
            avatarImageCache[char.avatar] = img;
            renderRelationshipGraph(); // 重新渲染
          };
          img.onerror = () => {
            // 載入失敗，顯示預設文本
            ctx.fillStyle = textPrimary;
            ctx.font = 'bold 14px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(char.name.charAt(0), char.x, char.y);
          };
          img.src = char.avatar;

          // 在圖片載入前顯示首字母
          ctx.fillStyle = textPrimary;
          ctx.font = 'bold 14px sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(char.name.charAt(0), char.x, char.y);
        }
      } else {
        // 沒有頭像，顯示首字母
        ctx.fillStyle = textPrimary;
        ctx.font = 'bold 14px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(char.name.charAt(0), char.x, char.y);
      }

      // 繪製名稱
      ctx.fillStyle = textPrimary;
      ctx.font = isMobile ? 'bold 11px sans-serif' : 'bold 12px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      ctx.fillText(char.name, char.x, char.y + avatarRadius + 10);

      // 保存頭像半徑到角色資料，用於點擊檢測
      char.radius = avatarRadius;
    });
  }

  // 滑鼠按下處理
  function handleCanvasMouseDown(event) {
    const canvas = event.target;
    const rect = canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;

    const chars = characterRelationshipData.characters || [];

    // 檢查是否點擊了角色
    for (const char of chars) {
      const dx = x - char.x;
      const dy = y - char.y;
      const radius = char.radius || 35;
      if (Math.sqrt(dx * dx + dy * dy) < radius) {
        isDragging = true;
        draggedCharId = char.id;
        dragOffsetX = dx;
        dragOffsetY = dy;
        canvas.style.cursor = 'grabbing';
        return;
      }
    }
  }

  // 觸摸開始處理（移動端）
  function handleCanvasTouchStart(event) {
    event.preventDefault();
    const canvas = event.target;
    const rect = canvas.getBoundingClientRect();
    const touch = event.touches[0];
    const x = touch.clientX - rect.left;
    const y = touch.clientY - rect.top;

    // 記錄觸摸開始資訊
    touchStartTime = Date.now();
    touchStartX = x;
    touchStartY = y;

    const chars = characterRelationshipData.characters || [];

    // 檢查是否觸摸了角色（但不立即設置為拖拽狀態）
    for (const char of chars) {
      const dx = x - char.x;
      const dy = y - char.y;
      const radius = char.radius || 35;
      if (Math.sqrt(dx * dx + dy * dy) < radius) {
        // 記錄可能被拖拽的角色，但不立即設置為拖拽狀態
        draggedCharId = char.id;
        dragOffsetX = dx;
        dragOffsetY = dy;
        return;
      }
    }
  }

  // 滑鼠移動處理
  function handleCanvasMouseMove(event) {
    const canvas = event.target;
    const rect = canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;

    const chars = characterRelationshipData.characters || [];

    if (isDragging && draggedCharId) {
      // 拖拽角色
      const char = chars.find(c => c.id === draggedCharId);
      if (char) {
        char.x = x - dragOffsetX;
        char.y = y - dragOffsetY;
        renderRelationshipGraph();
      }
    } else {
      // 檢查是否懸停在角色上
      const hoveredChar = chars.find(char => {
        const dx = x - char.x;
        const dy = y - char.y;
        const radius = char.radius || 35;
        return Math.sqrt(dx * dx + dy * dy) < radius;
      });

      canvas.style.cursor = hoveredChar ? 'grab' : 'default';
    }
  }

  // 觸摸移動處理（移動端）
  function handleCanvasTouchMove(event) {
    event.preventDefault();
    const canvas = event.target;
    const rect = canvas.getBoundingClientRect();
    const touch = event.touches[0];
    const x = touch.clientX - rect.left;
    const y = touch.clientY - rect.top;

    const chars = characterRelationshipData.characters || [];

    // 如果已記錄了拖拽目標但還未進入拖拽狀態，檢查移動距離
    if (draggedCharId && !isDragging) {
      const dx = x - touchStartX;
      const dy = y - touchStartY;
      const distance = Math.sqrt(dx * dx + dy * dy);

      // 移動距離超過10px才認為是拖拽
      if (distance > 10) {
        isDragging = true;
        console.log('📍 開始拖拽角色');
      }
    }

    if (isDragging && draggedCharId) {
      // 拖拽角色
      const char = chars.find(c => c.id === draggedCharId);
      if (char) {
        char.x = x - dragOffsetX;
        char.y = y - dragOffsetY;
        renderRelationshipGraph();
      }
    }
  }

  // 滑鼠釋放處理
  function handleCanvasMouseUp(event) {
    if (isDragging) {
      isDragging = false;
      draggedCharId = null;
      event.target.style.cursor = 'default';
    }
  }

  // 觸摸結束處理（移動端）
  let touchStartTime = 0;
  let touchStartX = 0;
  let touchStartY = 0;

  function handleCanvasTouchEnd(event) {
    event.preventDefault();

    const wasDragging = isDragging;

    // 重置拖拽狀態
    if (isDragging) {
      isDragging = false;
      draggedCharId = null;
    } else if (draggedCharId) {
      // 即使沒有進入拖拽狀態，也要清除記錄的角色ID
      draggedCharId = null;
    }

    // 如果沒有拖拽，檢測是否是點擊
    if (!wasDragging && event.changedTouches && event.changedTouches.length > 0) {
      const canvas = event.target;
      const rect = canvas.getBoundingClientRect();
      const touch = event.changedTouches[0];
      const x = touch.clientX - rect.left;
      const y = touch.clientY - rect.top;

      const chars = characterRelationshipData.characters || [];
      const links = characterRelationshipData.links || [];

      // 優先處理選擇模式
      if (isSelectingCharsForLink) {
        // 檢查是否觸摸了角色
        for (const char of chars) {
          const dx = x - char.x;
          const dy = y - char.y;
          const radius = char.radius || 35;
          if (Math.sqrt(dx * dx + dy * dy) < radius) {
            handleCharacterSelection(char);
            return;
          }
        }
        return; // 選擇模式下不處理其他點擊
      }

      // 檢查是否點擊了連線
      for (const link of links) {
        const charA = chars.find(c => c.id === link.charA);
        const charB = chars.find(c => c.id === link.charB);

        if (charA && charB) {
          const dist = distanceToLine(x, y, charA.x, charA.y, charB.x, charB.y);
          // 移動端增大點擊區域
          if (dist < 20) {
            openEditRelationshipDetailModal(link);
            return;
          }
        }
      }
    }
  }

  // 畫布點擊處理
  function handleCanvasClick(event) {
    // 如果剛才在拖拽，不觸發點擊事件
    if (isDragging) return;

    const canvas = event.target;
    const rect = canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;

    const chars = characterRelationshipData.characters || [];
    const links = characterRelationshipData.links || [];

    // 優先處理選擇模式
    if (isSelectingCharsForLink) {
      // 檢查是否點擊了角色
      for (const char of chars) {
        const dx = x - char.x;
        const dy = y - char.y;
        const radius = char.radius || 35;
        if (Math.sqrt(dx * dx + dy * dy) < radius) {
          handleCharacterSelection(char);
          return;
        }
      }
      return; // 選擇模式下不處理其他點擊
    }

    // 檢查是否點擊了連線
    for (const link of links) {
      const charA = chars.find(c => c.id === link.charA);
      const charB = chars.find(c => c.id === link.charB);

      if (charA && charB) {
        const dist = distanceToLine(x, y, charA.x, charA.y, charB.x, charB.y);
        if (dist < 15) {
          openEditRelationshipDetailModal(link);
          return;
        }
      }
    }
  }

  // 處理角色選擇（用於創建連線）
  function handleCharacterSelection(char) {
    if (!selectedCharForLink) {
      // 選擇第一個角色
      selectedCharForLink = char.id;
      console.log('✅ 已選擇第一個角色:', char.name);
      showXToast(`已選擇 ${char.name}，請點擊第二個角色`, 'info');
      renderRelationshipGraph(); // 重新渲染以高亮選中的角色
    } else {
      // 選擇第二個角色
      if (selectedCharForLink === char.id) {
        showXToast('請選擇不同的角色', 'error');
        return;
      }

      // 檢查是否已存在這條關係
      const existingLink = characterRelationshipData.links.find(
        link =>
          (link.charA === selectedCharForLink && link.charB === char.id) ||
          (link.charA === char.id && link.charB === selectedCharForLink),
      );

      if (existingLink) {
        showXToast('這兩個角色已存在關係，請直接點擊連線編輯', 'error');
        // 退出選擇模式
        isSelectingCharsForLink = false;
        selectedCharForLink = null;
        renderRelationshipGraph();
        return;
      }

      console.log('✅ 已選擇第二個角色:', char.name);

      // 創建新關係
      const newLink = {
        id: 'link_' + Date.now(),
        charA: selectedCharForLink,
        charB: char.id,
        relationAtoB: '',
        relationBtoA: '',
        story: '',
      };

      characterRelationshipData.links.push(newLink);

      // 退出選擇模式
      isSelectingCharsForLink = false;
      selectedCharForLink = null;

      // 立即渲染
      renderRelationshipGraph();
      renderRelationshipList();

      // 更新全域引用
      window.characterRelationshipData = characterRelationshipData;

      // 延遲打開編輯，確保渲染完成
      setTimeout(() => {
        openEditRelationshipDetailModal(newLink);
      }, 100);
    }
  }

  // 計算點到線段的距離
  function distanceToLine(px, py, x1, y1, x2, y2) {
    const A = px - x1;
    const B = py - y1;
    const C = x2 - x1;
    const D = y2 - y1;

    const dot = A * C + B * D;
    const lenSq = C * C + D * D;
    let param = -1;

    if (lenSq !== 0) param = dot / lenSq;

    let xx, yy;

    if (param < 0) {
      xx = x1;
      yy = y1;
    } else if (param > 1) {
      xx = x2;
      yy = y2;
    } else {
      xx = x1 + param * C;
      yy = y1 + param * D;
    }

    const dx = px - xx;
    const dy = py - yy;
    return Math.sqrt(dx * dx + dy * dy);
  }

  // 添加關係連線
  function addRelationshipLink() {
    const chars = characterRelationshipData.characters || [];

    if (chars.length < 2) {
      showXToast('至少需要2個已綁定角色才能創建關係', 'error');
      return;
    }

    // 進入選擇模式
    isSelectingCharsForLink = true;
    selectedCharForLink = null;

    showXToast('請點擊選擇第一個角色', 'info');
    console.log('📍 進入角色選擇模式');

    // 重新渲染以顯示選擇提示
    renderRelationshipGraph();
  }

  // 打開編輯關係詳情彈窗
  function openEditRelationshipDetailModal(link) {
    currentEditingLinkId = link.id;

    const chars = characterRelationshipData.characters || [];
    const charA = chars.find(c => c.id === link.charA);
    const charB = chars.find(c => c.id === link.charB);

    if (!charA || !charB) return;

    document.getElementById('char-a-name').textContent = charA.name;
    document.getElementById('char-b-name').textContent = charB.name;
    document.getElementById('char-a-to-b-label').textContent = `${charA.name} 是 ${charB.name} 的：`;
    document.getElementById('char-b-to-a-label').textContent = `${charB.name} 是 ${charA.name} 的：`;
    document.getElementById('relationship-a-to-b').value = link.relationAtoB || '';
    document.getElementById('relationship-b-to-a').value = link.relationBtoA || '';
    document.getElementById('relationship-story').value = link.story || '';

    const modal = document.getElementById('edit-relationship-detail-modal');
    if (modal) {
      modal.style.display = 'block';
    }
  }

  // 關閉編輯關係詳情彈窗
  function closeEditRelationshipDetail(event) {
    if (event && event.target !== event.currentTarget) return;

    const modal = document.getElementById('edit-relationship-detail-modal');
    if (modal) {
      modal.style.display = 'none';
    }
    currentEditingLinkId = null;
  }

  // 保存關係詳情
  async function saveRelationshipDetail() {
    if (!currentEditingLinkId) return;

    const link = characterRelationshipData.links.find(l => l.id === currentEditingLinkId);
    if (!link) return;

    link.relationAtoB = document.getElementById('relationship-a-to-b').value.trim();
    link.relationBtoA = document.getElementById('relationship-b-to-a').value.trim();
    link.story = document.getElementById('relationship-story').value.trim();

    renderRelationshipGraph();
    renderRelationshipList();
    closeEditRelationshipDetail();

    // 自動保存到資料庫
    try {
      const db = getXDB();
      const currentAccount = currentAccountId || 'main';
      const dataId = `xCharacterRelationships_${currentAccount}`;

      await db.xCharacterRelationships.put({
        id: dataId,
        accountId: currentAccount,
        data: characterRelationshipData,
        lastUpdated: new Date().toISOString(),
      });

      updateRelationshipPreview();

      showXToast('關係已更新並保存', 'success');
      console.log('✅ 關係已自動保存:', link);
    } catch (error) {
      console.error('❌ 保存關係失敗:', error);
      showXToast('關係已更新但保存失敗', 'error');
    }
  }

  // 刪除關係連線
  async function deleteRelationshipLink() {
    if (!currentEditingLinkId) return;

    if (!confirm('確定要刪除這條關係嗎？')) return;

    characterRelationshipData.links = characterRelationshipData.links.filter(l => l.id !== currentEditingLinkId);

    renderRelationshipGraph();
    renderRelationshipList();
    closeEditRelationshipDetail();

    // 自動保存到資料庫
    try {
      const db = getXDB();
      const currentAccount = currentAccountId || 'main';
      const dataId = `xCharacterRelationships_${currentAccount}`;

      await db.xCharacterRelationships.put({
        id: dataId,
        accountId: currentAccount,
        data: characterRelationshipData,
        lastUpdated: new Date().toISOString(),
      });

      updateRelationshipPreview();

      showXToast('關係已刪除', 'success');
    } catch (error) {
      console.error('❌ 刪除關係失敗:', error);
      showXToast('關係已刪除但保存失敗', 'error');
    }
  }

  // 清空所有關係
  async function clearAllRelationships() {
    if (!confirm('確定要清空所有關係嗎？此操作不可恢復。')) return;

    characterRelationshipData.links = [];
    renderRelationshipGraph();
    renderRelationshipList();

    // 自動保存到資料庫
    try {
      const db = getXDB();
      const currentAccount = currentAccountId || 'main';
      const dataId = `xCharacterRelationships_${currentAccount}`;

      await db.xCharacterRelationships.put({
        id: dataId,
        accountId: currentAccount,
        data: characterRelationshipData,
        lastUpdated: new Date().toISOString(),
      });

      updateRelationshipPreview();

      showXToast('已清空所有關係', 'success');
    } catch (error) {
      console.error('❌ 清空關係失敗:', error);
      showXToast('已清空但保存失敗', 'error');
    }
  }

  // 渲染關係列表
  function renderRelationshipList() {
    const listContainer = document.getElementById('relationship-links-list');
    if (!listContainer) return;

    const links = characterRelationshipData.links || [];
    const chars = characterRelationshipData.characters || [];

    if (links.length === 0) {
      listContainer.innerHTML = '<div style="color: #71767b; text-align: center; padding: 20px;">暫無關係</div>';
      return;
    }

    listContainer.innerHTML = links
      .map(link => {
        const charA = chars.find(c => c.id === link.charA);
        const charB = chars.find(c => c.id === link.charB);

        if (!charA || !charB) return '';

        const storyPreview = link.story
          ? `
          <div style="color: #71767b; font-size: 11px; margin-top: 6px; padding-top: 6px; border-top: 1px solid #2f3336;">
            ${link.story.length > 50 ? link.story.substring(0, 50) + '...' : link.story}
          </div>
        `
          : '';

        return `
        <div style="
          background-color: #1a1a1a;
          border: 1px solid #333;
          border-radius: 8px;
          padding: 12px;
          margin-bottom: 8px;
          cursor: pointer;
          transition: background-color 0.2s;
        " onclick="openEditRelationshipDetailModal(window.characterRelationshipData.links.find(l => l.id === '${
          link.id
        }'))" 
          onmouseover="this.style.backgroundColor='#2a2a2a'" 
          onmouseout="this.style.backgroundColor='#1a1a1a'">
          <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
            <div style="display: flex; align-items: center; gap: 8px;">
              <span style="color: #fff; font-weight: 600; font-size: 14px;">${charA.name}</span>
              <span style="color: #71767b;">⇆</span>
              <span style="color: #fff; font-weight: 600; font-size: 14px;">${charB.name}</span>
            </div>
          </div>
          <div style="display: flex; gap: 12px; font-size: 12px;">
            <div style="color: var(--x-accent);">${charA.name}: ${link.relationAtoB || '(未設置)'}</div>
            <div style="color: var(--x-accent);">${charB.name}: ${link.relationBtoA || '(未設置)'}</div>
          </div>
          ${storyPreview}
        </div>
      `;
      })
      .join('');
  }

  // 保存關係圖
  async function saveRelationshipGraph() {
    try {
      const db = getXDB();
      const currentAccount = currentAccountId || 'main';
      const dataId = `xCharacterRelationships_${currentAccount}`;

      await db.xCharacterRelationships.put({
        id: dataId,
        accountId: currentAccount,
        data: characterRelationshipData,
        lastUpdated: new Date().toISOString(),
      });

      updateRelationshipPreview();
      closeCharacterRelationshipGraph();

      showXToast('關係圖已保存', 'success');
      console.log('✅ 關係圖已保存:', characterRelationshipData);
    } catch (error) {
      console.error('❌ 保存關係圖失敗:', error);
      showXToast('保存失敗', 'error');
    }
  }

  // ============================================
  // NPC綁定功能
  // ============================================

  // 當前編輯的NPC ID
  let currentEditingNPCId = null;

  // 切換NPC綁定開關
  async function toggleNPCBinding() {
    xSettingsData.npcBinding = !xSettingsData.npcBinding;

    // 更新UI
    updateNPCToggleUI();

    // 顯示/隱藏NPC管理區域
    const npcArea = document.getElementById('npc-binding-area');
    if (xSettingsData.npcBinding) {
      npcArea.style.display = 'block';
      await loadNPCsList();
    } else {
      npcArea.style.display = 'none';
    }

    // 自動保存設置
    await saveXSettings();
  }

  // 更新NPC綁定切換按鈕UI
  function updateNPCToggleUI() {
    const toggle = document.getElementById('x-npc-toggle');
    const circle = toggle.querySelector('.toggle-circle');

    if (xSettingsData.npcBinding) {
      toggle.style.backgroundColor = 'var(--x-accent)';
      circle.style.left = '22px';
    } else {
      toggle.style.backgroundColor = '#333';
      circle.style.left = '2px';
    }
  }

  // 載入NPC列表
  async function loadNPCsList() {
    try {
      const db = getXDB();
      const npcId = 'xNPCs_global'; // 全域存儲，所有帳號共用
      const npcData = await db.xNPCs.get(npcId);
      const allNPCs = npcData?.npcs || [];

      // 過濾出綁定了當前帳號的NPC
      const currentAccount = currentAccountId || 'main';
      const npcs = allNPCs.filter(npc => npc.boundUsers && npc.boundUsers.includes(currentAccount));

      const npcsList = document.getElementById('npcs-list');

      if (npcs.length === 0) {
        npcsList.innerHTML =
          '<p style="color: #71767b; font-size: 14px; text-align: center; padding: 20px 0;">暫無綁定到此帳號的NPC，點擊上方按鈕創建</p>';
        return;
      }

      npcsList.innerHTML = npcs
        .map(
          npc => `
          <div style="
            background-color: #0a0a0a;
            border: 1px solid #2f3336;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 12px;
          ">
            <img src="${npc.avatar || 'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg'}" 
              style="width: 48px; height: 48px; border-radius: 50%; flex-shrink: 0;" 
              alt="${npc.name}">
            <div style="flex: 1; min-width: 0;">
              <div style="color: #fff; font-weight: 600; font-size: 15px; margin-bottom: 2px;">${npc.name}</div>
              <div style="color: #71767b; font-size: 14px;">${npc.handle}</div>
              <div style="color: #71767b; font-size: 13px; margin-top: 4px;">
                綁定用戶: ${npc.boundUsers?.length || 0}個
              </div>
            </div>
            <div style="display: flex; gap: 8px; flex-shrink: 0;">
              <button onclick="editNPC('${npc.id}')" style="
                background-color: var(--x-accent);
                color: #fff;
                border: none;
                border-radius: 15px;
                padding: 6px 12px;
                font-size: 13px;
                cursor: pointer;
                white-space: nowrap;
                transition: all 0.2s;
              " onmouseover="this.style.backgroundColor='#1a8cd8'" onmouseout="this.style.backgroundColor='var(--x-accent)'">
                編輯
              </button>
              <button onclick="deleteNPC('${npc.id}')" style="
                background-color: #f4212e;
                color: #fff;
                border: none;
                border-radius: 15px;
                padding: 6px 12px;
                font-size: 13px;
                cursor: pointer;
                white-space: nowrap;
                transition: all 0.2s;
              " onmouseover="this.style.backgroundColor='#d11a29'" onmouseout="this.style.backgroundColor='#f4212e'">
                刪除
              </button>
            </div>
          </div>
        `,
        )
        .join('');
    } catch (error) {
      console.error('載入NPC列表失敗:', error);
      document.getElementById('npcs-list').innerHTML =
        '<p style="color: #f4212e; font-size: 14px; text-align: center; padding: 20px 0;">載入失敗，請重試</p>';
    }
  }

  // 打開創建NPC彈窗
  function openCreateNPCModal() {
    currentEditingNPCId = null;

    // 清空表單
    document.getElementById('npc-name').value = '';
    document.getElementById('npc-handle').value = '';
    document.getElementById('npc-avatar').value = '';
    document.getElementById('npc-personality').value = '';
    document.getElementById('npc-posting-habits').value = '';
    document.getElementById('npc-homepage').value = '';

    // 更新標題
    document.getElementById('npc-modal-title').textContent = '創建NPC';

    // 載入用戶列表
    loadNPCBindUsersList();

    // 顯示彈窗
    document.getElementById('npc-edit-modal').style.display = 'block';
    document.body.style.overflow = 'hidden';
  }

  // 編輯NPC
  async function editNPC(npcId) {
    try {
      const db = getXDB();
      const npcDataId = 'xNPCs_global'; // 全域存儲，所有帳號共用
      const npcData = await db.xNPCs.get(npcDataId);
      const npcs = npcData?.npcs || [];
      const npc = npcs.find(n => n.id === npcId);

      if (!npc) {
        showXToast('NPC不存在', 'error');
        return;
      }

      currentEditingNPCId = npcId;

      // 填充表單
      document.getElementById('npc-name').value = npc.name || '';
      document.getElementById('npc-handle').value = npc.handle || '';
      document.getElementById('npc-avatar').value = npc.avatar || '';
      document.getElementById('npc-personality').value = npc.personality || '';
      document.getElementById('npc-posting-habits').value = npc.postingHabits || '';
      document.getElementById('npc-homepage').value = npc.homepage || '';

      // 更新標題
      document.getElementById('npc-modal-title').textContent = '編輯NPC';

      // 載入用戶列表並選中已綁定的用戶
      await loadNPCBindUsersList(npc.boundUsers || []);

      // 顯示彈窗
      document.getElementById('npc-edit-modal').style.display = 'block';
      document.body.style.overflow = 'hidden';
    } catch (error) {
      console.error('載入NPC數據失敗:', error);
      showXToast('載入失敗', 'error');
    }
  }

  // 載入綁定用戶列表
  async function loadNPCBindUsersList(selectedUsers = []) {
    try {
      const db = getXDB();
      const accounts = await db.xAccountList.toArray();

      const usersList = document.getElementById('npc-bind-users');

      if (accounts.length === 0) {
        usersList.innerHTML =
          '<p style="color: #71767b; font-size: 14px; text-align: center; padding: 10px 0;">暫無帳號</p>';
        return;
      }

      usersList.innerHTML = accounts
        .map(account => {
          const isChecked = selectedUsers.includes(account.accountId);
          return `
          <label style="
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px;
            cursor: pointer;
            border-radius: 6px;
            transition: background-color 0.2s;
          " onmouseover="this.style.backgroundColor='rgba(255,255,255,0.05)'"
            onmouseout="this.style.backgroundColor='transparent'">
            <input 
              type="checkbox" 
              value="${account.accountId}" 
              ${isChecked ? 'checked' : ''}
              style="width: 16px; height: 16px; accent-color: var(--x-accent); cursor: pointer;">
            <img src="${account.avatar}" style="width: 32px; height: 32px; border-radius: 50%;" alt="${account.name}">
            <div style="flex: 1;">
              <div style="color: #fff; font-size: 14px; font-weight: 600;">${account.name}</div>
              <div style="color: #71767b; font-size: 13px;">帳號ID: ${account.accountId}</div>
            </div>
          </label>
        `;
        })
        .join('');
    } catch (error) {
      console.error('載入用戶列表失敗:', error);
    }
  }

  // 保存NPC
  async function saveNPC() {
    try {
      const name = document.getElementById('npc-name').value.trim();
      const handle = document.getElementById('npc-handle').value.trim();
      const avatar = document.getElementById('npc-avatar').value.trim();
      const personality = document.getElementById('npc-personality').value.trim();
      const postingHabits = document.getElementById('npc-posting-habits').value.trim();
      const homepage = document.getElementById('npc-homepage').value.trim();

      // 獲取選中的用戶
      const boundUsers = Array.from(document.querySelectorAll('#npc-bind-users input[type="checkbox"]:checked')).map(
        input => input.value,
      );

      // 驗證資料
      if (!name) {
        showXToast('NPC姓名不能為空', 'error');
        return;
      }

      if (!handle) {
        showXToast('NPC控制碼不能為空', 'error');
        return;
      }

      // 確保控制碼格式正確
      const handleFormatted = handle.startsWith('@') ? handle : `@${handle}`;

      const db = getXDB();
      const npcDataId = 'xNPCs_global'; // 全域存儲，所有帳號共用
      const npcData = await db.xNPCs.get(npcDataId);
      let npcs = npcData?.npcs || [];

      if (currentEditingNPCId) {
        // 編輯模式
        const index = npcs.findIndex(n => n.id === currentEditingNPCId);
        if (index !== -1) {
          npcs[index] = {
            ...npcs[index],
            name,
            handle: handleFormatted,
            avatar: avatar || 'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg',
            personality,
            postingHabits,
            homepage,
            boundUsers,
            updatedAt: new Date().toISOString(),
          };
        }
      } else {
        // 創建模式
        const newNPC = {
          id: 'npc_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
          name,
          handle: handleFormatted,
          avatar: avatar || 'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg',
          personality,
          postingHabits,
          homepage,
          boundUsers,
          createdAt: new Date().toISOString(),
        };
        npcs.push(newNPC);
      }

      // 保存到資料庫
      await db.xNPCs.put({
        id: npcDataId,
        npcs,
        lastUpdated: new Date().toISOString(),
      });

      console.log(`✅ NPC已${currentEditingNPCId ? '更新' : '創建'}:`, name, handle);
      console.log('📎 綁定帳號數量:', boundUsers.length);
      console.log('📎 綁定帳號列表:', boundUsers.length > 0 ? boundUsers : '無');

      // 刷新列表
      await loadNPCsList();

      // 關閉彈窗
      closeNPCEditModal();

      showXToast(currentEditingNPCId ? 'NPC已更新' : 'NPC已創建', 'success');
    } catch (error) {
      console.error('保存NPC失敗:', error);
      showXToast('保存失敗: ' + error.message, 'error');
    }
  }

  // 刪除NPC
  async function deleteNPC(npcId) {
    if (!confirm('確定要刪除這個NPC嗎？\n此操作將影響所有綁定了此NPC的帳號。')) return;

    try {
      const db = getXDB();
      const npcDataId = 'xNPCs_global'; // 全域存儲，所有帳號共用
      const npcData = await db.xNPCs.get(npcDataId);
      let npcs = npcData?.npcs || [];

      npcs = npcs.filter(n => n.id !== npcId);

      await db.xNPCs.put({
        id: npcDataId,
        npcs,
        lastUpdated: new Date().toISOString(),
      });

      await loadNPCsList();

      showXToast('NPC已刪除', 'success');
    } catch (error) {
      console.error('刪除NPC失敗:', error);
      showXToast('刪除失敗', 'error');
    }
  }

  // 關閉NPC編輯彈窗
  function closeNPCEditModal(event) {
    if (event && event.target !== event.currentTarget) return;

    document.getElementById('npc-edit-modal').style.display = 'none';
    document.body.style.overflow = 'auto';
    currentEditingNPCId = null;
  }

  // 用戶主頁相關功能

  // 切換主頁標籤
  function switchProfileTab(tabName) {
    // 重置所有標籤樣式
    document.querySelectorAll('.profile-tab').forEach(tab => {
      tab.classList.remove('active');
      tab.style.color = '#71767b';
      tab.querySelector('.tab-indicator').style.display = 'none';
    });

    // 隱藏所有內容區域
    document.querySelectorAll('.profile-tab-content').forEach(content => {
      content.style.display = 'none';
    });

    // 啟動選中的標籤
    const activeTab = document.querySelector(`.profile-tab[onclick="switchProfileTab('${tabName}')"]`);
    if (activeTab) {
      activeTab.classList.add('active');
      activeTab.style.color = '#fff';
      activeTab.querySelector('.tab-indicator').style.display = 'block';
    }

    // 顯示對應的內容區域
    const contentArea = document.getElementById(`profile-${tabName}-content`);
    if (contentArea) {
      contentArea.style.display = 'block';
    }

    // 根據標籤載入相應內容
    if (tabName === 'posts') {
      loadUserProfileTweets();
    } else if (tabName === 'highlights') {
      loadHighlights();
    } else if (tabName === 'likes') {
      loadLikes();
    }
  }

  // 編輯個人資料
  function editProfile() {
    openEditProfileModal();
  }

  // 載入使用者資料到UI
  function loadUserProfileToUI() {
    // 使用window.userProfileData確保讀取最新資料
    const profile = window.userProfileData;

    // 更新頂欄頭像
    const topBarAvatar = document.getElementById('top-bar-avatar');
    if (topBarAvatar) {
      topBarAvatar.src = profile.avatar;
    }

    // 更新主頁資訊
    const profileElements = {
      'x-profile-header-name': profile.name,
      'x-profile-user-name': profile.name,
      'x-profile-user-handle': profile.handle,
      'x-profile-bio': profile.bio,
      'x-profile-following-count': profile.following,
      'x-profile-followers-count': profile.followers,
    };

    Object.entries(profileElements).forEach(([id, value]) => {
      const element = document.getElementById(id);
      if (element) {
        element.textContent = value;
      }
    });

    // 更新自訂標籤內容、圖示和顏色
    const tag1Element = document.getElementById('x-profile-tag1');
    const tag1IconElement = document.getElementById('x-profile-tag1-icon');
    const tag2Element = document.getElementById('x-profile-tag2');
    const tag2IconElement = document.getElementById('x-profile-tag2-icon');

    if (tag1Element) {
      tag1Element.textContent = profile.customTag1;
      tag1Element.style.color = profile.customTag1Color || '#71767b';
    }
    if (tag1IconElement) {
      tag1IconElement.textContent = profile.customTag1Icon || '✨';
    }
    if (tag2Element) {
      tag2Element.textContent = profile.customTag2;
      tag2Element.style.color = profile.customTag2Color || '#71767b';
    }
    if (tag2IconElement) {
      tag2IconElement.textContent = profile.customTag2Icon || '📅';
    }

    // 更新頭像
    const mainAvatar = document.getElementById('x-profile-main-avatar');
    if (mainAvatar) {
      mainAvatar.src = profile.avatar;
    }

    // 更新封面圖
    const coverImage = document.getElementById('x-profile-cover-image');
    if (coverImage) {
      coverImage.src = profile.coverImage;
    }

    // 更新認證徽章
    updateVerificationBadge();

    // 更新評論輸入區域的頭像
    const commentInputAvatar = document.querySelector('#comment-input-area img, .comment-input-area img');
    if (commentInputAvatar) {
      commentInputAvatar.src = profile.avatar;
    }

    // 更新主頁評論輸入框頭像
    const commentUserAvatar = document.getElementById('comment-user-avatar');
    if (commentUserAvatar) {
      commentUserAvatar.src = profile.avatar;
    }

    // 更新詳情頁評論輸入框頭像
    const detailCommentUserAvatar = document.getElementById('detail-comment-user-avatar');
    if (detailCommentUserAvatar) {
      detailCommentUserAvatar.src = profile.avatar;
    }

    // 更新所有回復輸入框頭像
    const replyUserAvatars = document.querySelectorAll('.reply-user-avatar');
    replyUserAvatars.forEach(avatar => {
      avatar.src = profile.avatar;
    });

    // 更新發帖彈窗頭像
    const composeUserAvatar = document.getElementById('compose-user-avatar');
    if (composeUserAvatar) {
      composeUserAvatar.src = profile.avatar;
    }

    console.log('✅ UI已更新，當前使用者資料:', profile.name);
  }

  // 更新認證徽章顯示
  function updateVerificationBadge() {
    const verifiedBadge = document.getElementById('x-profile-verified-badge');
    if (!verifiedBadge) return;

    const verificationType = userProfileData.verificationType || 'none';

    // 如果是無認證，隱藏徽章
    if (verificationType === 'none') {
      verifiedBadge.style.display = 'none';
      return;
    }

    // 顯示徽章
    verifiedBadge.style.display = 'inline-block';

    // 根據認證類型設置不同的圖示和顏色
    let badgeColor = '#1d9bf0'; // 默認藍色
    let badgePath = ''; // SVG路徑

    switch (verificationType) {
      case 'verified':
        // 藍色勾 - 已認證（保持原樣）
        badgeColor = '#1d9bf0';
        badgePath =
          'M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.27 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.46 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z';
        break;
      case 'couple':
        // 心形 - 情侶認證（自我調整主題顏色：日間黑色，夜間白色）
        badgeColor =
          getComputedStyle(document.getElementById('x-social-screen')).getPropertyValue('--x-text-primary').trim() ||
          '#fff';
        badgePath =
          'M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z';
        break;
      case 'married':
        // 圓環 - 已婚認證（自我調整主題顏色：日間黑色，夜間白色）
        badgeColor =
          getComputedStyle(document.getElementById('x-social-screen')).getPropertyValue('--x-text-primary').trim() ||
          '#fff';
        badgePath =
          'M12 4c4.42 0 8 3.58 8 8s-3.58 8-8 8-8-3.58-8-8 3.58-8 8-8zm0 2c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6-2.69-6-6-6z';
        break;
      case 'vip':
        // 菱形 - VIP認證（自我調整主題顏色：日間黑色，夜間白色）
        badgeColor =
          getComputedStyle(document.getElementById('x-social-screen')).getPropertyValue('--x-text-primary').trim() ||
          '#fff';
        badgePath = 'M12 3l6 6-6 6-6-6 6-6zm0 2.83L8.83 9 12 12.17 15.17 9 12 5.83z';
        break;
      default:
        // 默認藍色勾
        badgeColor = '#1d9bf0';
        badgePath =
          'M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.27 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.46 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z';
        break;
    }

    // 更新徽章顏色和圖示
    verifiedBadge.style.fill = badgeColor;

    // 更新SVG路徑
    const pathElement = verifiedBadge.querySelector('path');
    if (pathElement) {
      pathElement.setAttribute('d', badgePath);
    }

    // 添加情侶認證的特殊提示
    if (verificationType === 'couple' && userProfileData.coupleCharacterName) {
      verifiedBadge.setAttribute('title', `情侶認證 - 與${userProfileData.coupleCharacterName}是情侶關係`);
    } else {
      // 設置其他認證類型的提示
      const titles = {
        verified: '已認證帳戶',
        married: '已婚認證',
        vip: 'VIP認證',
        couple: '情侶認證',
      };
      verifiedBadge.setAttribute('title', titles[verificationType] || '已認證帳戶');
    }
  }

  // 為角色設置情侶認證
  async function setCoupleVerificationForCharacter(characterId, userNameAsCouple) {
    try {
      const db = getXDB();
      // 獲取角色的X資料
      let xProfile = await db.xCharacterProfiles.get(characterId);

      if (xProfile) {
        // 為角色設置情侶認證
        xProfile.xVerified = true;
        xProfile.verificationType = 'couple';
        xProfile.couplePartnerName = userNameAsCouple;

        // 保存更新
        await db.xCharacterProfiles.put(xProfile);

        console.log(`已為角色 ${xProfile.xName} 設置情侶認證，情侶對象: ${userNameAsCouple}`);
      }
    } catch (error) {
      console.error('為角色設置情侶認證失敗:', error);
    }
  }

  // 同步用戶頭像到所有位置
  function syncUserAvatar(newAvatarUrl) {
    userProfileData.avatar = newAvatarUrl;

    // 更新所有頭像位置
    const avatarSelectors = [
      '#top-bar-avatar',
      '#x-profile-main-avatar',
      '.comment-input-area img',
      '#comment-user-avatar',
      '#detail-comment-user-avatar',
      '#compose-user-avatar',
    ];

    avatarSelectors.forEach(selector => {
      const element = document.querySelector(selector);
      if (element) {
        element.src = newAvatarUrl;
      }
    });

    // 更新所有回復輸入框頭像
    document.querySelectorAll('.reply-user-avatar').forEach(avatar => {
      avatar.src = newAvatarUrl;
    });

    // 更新用戶發佈的評論中的頭像
    document.querySelectorAll('.comment-item img[alt="我"], .comment-item img[alt="Your avatar"]').forEach(img => {
      img.src = newAvatarUrl;
    });
  }

  // 渲染用戶的推文到主頁
  function renderUserTweets() {
    const container = document.getElementById('x-profile-tweets-container');
    if (!container) return;

    // 獲取用戶發佈的推文（這裡簡化為空，實際應該從資料中篩選）
    const userTweets = [];

    if (userTweets.length === 0) {
      container.innerHTML = `
                <div style="padding: 60px 32px; text-align: center;">
                  <div style="color: #71767b; font-size: 31px; font-weight: 800; margin-bottom: 8px;">還沒有發帖</div>
                  <div style="color: #71767b; font-size: 15px;">當你發佈推文時，它們會顯示在這裡。</div>
                </div>
              `;
    } else {
      container.innerHTML = '';
      userTweets.forEach(tweet => {
        const tweetElement = createTweetElement(tweet);
        container.appendChild(tweetElement);
      });
    }

    // 更新帖子數量
    const headerCount = document.getElementById('x-profile-header-count');
    if (headerCount) {
      headerCount.textContent = `${userTweets.length} 帖子`;
    }
  }

  // ============================================
  // 粉絲數動態浮動系統
  // ============================================

  let followersFluctuationTimer = null;

  // 啟動粉絲數浮動系統
  function startFollowersFluctuationSystem() {
    if (followersFluctuationTimer) {
      clearInterval(followersFluctuationTimer);
    }

    console.log('📊 [粉絲數浮動] 系統已啟動');

    // 立即執行一次
    setTimeout(() => {
      triggerFollowersFluctuation();
    }, 5000); // 5秒後首次觸發

    // 設置隨機間隔觸發（10-30分鐘）
    const scheduleNext = () => {
      const randomInterval = (10 + Math.random() * 20) * 60 * 1000; // 10-30分鐘
      console.log(`📊 [粉絲數浮動] 下次觸發時間: ${(randomInterval / 60000).toFixed(1)}分鐘後`);

      followersFluctuationTimer = setTimeout(() => {
        triggerFollowersFluctuation();
        scheduleNext(); // 遞迴調度下一次
      }, randomInterval);
    };

    scheduleNext();
  }

  // 停止粉絲數浮動系統
  function stopFollowersFluctuationSystem() {
    if (followersFluctuationTimer) {
      clearTimeout(followersFluctuationTimer);
      followersFluctuationTimer = null;
      console.log('📊 [粉絲數浮動] 系統已停止');
    }
  }

  // 觸發粉絲數浮動
  async function triggerFollowersFluctuation() {
    try {
      console.log('📊 [粉絲數浮動] 開始檢查所有帳戶...');

      // 1. 更新用戶主帳戶粉絲數
      await updateUserFollowersCount();

      // 2. 更新所有已綁定角色的粉絲數
      await updateAllCharactersFollowersCount();

      console.log('✅ [粉絲數浮動] 所有帳戶粉絲數已更新');
    } catch (error) {
      console.error('❌ [粉絲數浮動] 觸發失敗:', error);
    }
  }

  // 更新用戶主帳戶粉絲數
  async function updateUserFollowersCount() {
    try {
      const xDb = getXDB();

      // 獲取用戶最近3條推文
      const userTweetsId = `userTweets_${currentAccountId || 'main'}`;
      const userTweetsData = await xDb.xUserTweets.get(userTweetsId);
      const recentTweets = userTweetsData?.tweets?.slice(0, 3) || [];

      // 解析當前粉絲數
      const originalFollowersStr = window.userProfileData.followers || '0';
      const currentFollowersNum = parseFollowersCount(originalFollowersStr);

      // 計算浮動
      const fluctuation = calculateFollowersFluctuation({
        publicIdentity: window.userProfileData.publicIdentity || '',
        bio: window.userProfileData.bio || '',
        recentTweets: recentTweets,
        currentFollowers: currentFollowersNum,
      });

      if (fluctuation === 0) {
        console.log('📊 [用戶粉絲數] 本次無變化');
        return;
      }

      // 計算新粉絲數並格式化
      const newFollowersNum = Math.max(0, currentFollowersNum + fluctuation);
      const newFollowersStr = formatFollowersCount(newFollowersNum, originalFollowersStr);

      window.userProfileData.followers = newFollowersStr;
      window.userProfileData.followersCount = newFollowersStr; // 同步更新
      window.userProfileData.lastUpdated = new Date().toISOString();

      // 保存到資料庫
      await xDb.xUserProfile.put({
        id: currentAccountId || 'main',
        ...window.userProfileData,
      });

      // 更新UI
      const followersElement = document.getElementById('x-profile-followers-count');
      if (followersElement) {
        followersElement.textContent = newFollowersStr;
      }

      console.log(
        `📊 [用戶粉絲數] ${fluctuation > 0 ? '+' : ''}${fluctuation} (${originalFollowersStr} → ${newFollowersStr})`,
      );

      // 顯示通知（僅大幅變化時）
      if (Math.abs(fluctuation) >= 50) {
        const isEnglish = currentLanguage === 'en';
        showPhoneNotification({
          title: 'X',
          message: isEnglish
            ? `Followers ${fluctuation > 0 ? 'increased' : 'decreased'} by ${Math.abs(fluctuation)}`
            : `粉絲數${fluctuation > 0 ? '增加' : '減少'}了 ${Math.abs(fluctuation)}`,
          leftIcon: 'x',
          duration: 3000,
        });
      }
    } catch (error) {
      console.error('❌ [用戶粉絲數] 更新失敗:', error);
    }
  }

  // 更新所有已綁定角色的粉絲數
  async function updateAllCharactersFollowersCount() {
    try {
      const xDb = getXDB();

      // 獲取所有角色X資料
      const allCharacterProfiles = await xDb.xCharacterProfiles.toArray();

      if (allCharacterProfiles.length === 0) {
        console.log('📊 [角色粉絲數] 無已綁定角色');
        return;
      }

      console.log(`📊 [角色粉絲數] 檢查 ${allCharacterProfiles.length} 個角色`);

      for (const xProfile of allCharacterProfiles) {
        // 跳過沒有設置粉絲數的角色
        if (!xProfile.followersCount || xProfile.followersCount === '') {
          continue;
        }

        // 獲取角色的帳戶主頁數據（如果有）
        const cleanHandle = xProfile.xHandle.replace('@', '');
        const accountProfile = await xDb.xAccountProfiles.get(cleanHandle);
        const recentTweets = accountProfile?.tweets?.slice(0, 3) || [];

        // 解析當前粉絲數
        const originalFollowersStr = xProfile.followersCount;
        const currentFollowersNum = parseFollowersCount(originalFollowersStr);

        // 計算浮動
        const fluctuation = calculateFollowersFluctuation({
          publicIdentity: xProfile.publicIdentity || '',
          bio: xProfile.xBio || '',
          recentTweets: recentTweets,
          currentFollowers: currentFollowersNum,
        });

        if (fluctuation === 0) {
          continue;
        }

        // 計算新粉絲數並格式化
        const newFollowersNum = Math.max(0, currentFollowersNum + fluctuation);
        const newFollowersStr = formatFollowersCount(newFollowersNum, originalFollowersStr);

        xProfile.followersCount = newFollowersStr;

        // 保存到資料庫
        await xDb.xCharacterProfiles.put(xProfile);

        console.log(
          `📊 [角色粉絲數] ${xProfile.xName}: ${
            fluctuation > 0 ? '+' : ''
          }${fluctuation} (${originalFollowersStr} → ${newFollowersStr})`,
        );

        // 同步更新帳戶主頁數據（如果存在）
        if (accountProfile) {
          accountProfile.accountInfo.followersCount = newFollowersStr;
          await xDb.xAccountProfiles.put(accountProfile);
          console.log(`  └─ 已同步到帳戶主頁 ${cleanHandle}`);
        }
      }
    } catch (error) {
      console.error('❌ [角色粉絲數] 更新失敗:', error);
    }
  }

  // 解析粉絲數字串為數位
  function parseFollowersCount(followersStr) {
    if (!followersStr || followersStr === '') return 0;

    const str = followersStr.toString().toLowerCase().trim();

    // 處理 "k" 格式（千）
    if (str.includes('k')) {
      const num = parseFloat(str.replace('k', ''));
      return Math.round(num * 1000);
    }

    // 處理 "w" 格式（萬）
    if (str.includes('w')) {
      const num = parseFloat(str.replace('w', ''));
      return Math.round(num * 10000);
    }

    // 處理 "m" 格式（百萬）
    if (str.includes('m')) {
      const num = parseFloat(str.replace('m', ''));
      return Math.round(num * 1000000);
    }

    // 純數字
    const num = parseInt(str);
    return isNaN(num) ? 0 : num;
  }

  // 格式化粉絲數為字串（智慧選擇格式）
  function formatFollowersCount(count, originalFormat = '') {
    if (count === 0) return '0';

    // 檢測原始格式偏好
    const originalLower = originalFormat.toString().toLowerCase();
    const usesK = originalLower.includes('k');
    const usesW = originalLower.includes('w');
    const usesM = originalLower.includes('m');

    // 如果原始是 "w" 格式，優先使用 "w"
    if (usesW) {
      if (count >= 10000) {
        const wValue = count / 10000;
        // 保留一位小數，但去掉不必要的 .0
        return wValue % 1 === 0 ? `${Math.round(wValue)}w` : `${wValue.toFixed(1)}w`;
      }
      // 小於1w的情況，顯示純數位
      return count.toString();
    }

    // 如果原始是 "m" 格式，優先使用 "m"
    if (usesM) {
      if (count >= 1000000) {
        const mValue = count / 1000000;
        return mValue % 1 === 0 ? `${Math.round(mValue)}m` : `${mValue.toFixed(1)}m`;
      } else if (count >= 1000) {
        const kValue = count / 1000;
        return kValue % 1 === 0 ? `${Math.round(kValue)}k` : `${kValue.toFixed(1)}k`;
      }
      return count.toString();
    }

    // 如果原始是 "k" 格式或沒有特定格式，使用國際通用格式（k、m）
    if (usesK || !usesW) {
      if (count >= 1000000) {
        const mValue = count / 1000000;
        return mValue % 1 === 0 ? `${Math.round(mValue)}m` : `${mValue.toFixed(1)}m`;
      } else if (count >= 1000) {
        const kValue = count / 1000;
        return kValue % 1 === 0 ? `${Math.round(kValue)}k` : `${kValue.toFixed(1)}k`;
      }
    }

    // 小於1000，顯示純數位
    return count.toString();
  }

  // 計算粉絲數浮動
  function calculateFollowersFluctuation({ publicIdentity, bio, recentTweets, currentFollowers }) {
    // 1. 檢測身份類型
    const isHighExposure =
      /明星|網紅|博主|演員|歌手|藝人|主播|up主|偶像|導演|製片|編劇|作家|influencer|celebrity|singer|actor|artist|streamer|idol/i.test(
        publicIdentity + ' ' + bio,
      );

    // 2. 分析最近推文品質
    let tweetQualityScore = 0; // -1到1之間
    if (recentTweets.length > 0) {
      let totalScore = 0;
      recentTweets.forEach(tweet => {
        const stats = tweet.stats || {};
        const likes = stats.likes || 0;
        const retweets = stats.retweets || 0;
        const comments = stats.comments || 0;
        const views = stats.views || 0;

        // 計算互動率（相對於流覽量）
        const engagementRate = views > 0 ? (likes + retweets * 2 + comments * 3) / views : 0;

        // 根據互動率評分
        if (engagementRate > 0.1) {
          totalScore += 1; // 高互動
        } else if (engagementRate > 0.05) {
          totalScore += 0.5; // 中等互動
        } else if (engagementRate > 0.02) {
          totalScore += 0; // 低互動，中性
        } else {
          totalScore -= 0.5; // 極低互動
        }
      });

      tweetQualityScore = totalScore / recentTweets.length;
    }

    console.log(`  📊 推文品質評分: ${tweetQualityScore.toFixed(2)} (${recentTweets.length}條推文)`);

    // 3. 確定浮動方向和幅度
    let baseFluctuation = 0;
    let direction = 1; // 1為增長，-1為下降

    // 根據推文品質決定方向概率
    if (tweetQualityScore > 0.5) {
      // 高品質推文：80%增長
      direction = Math.random() < 0.8 ? 1 : -1;
    } else if (tweetQualityScore > 0) {
      // 中等品質：70%增長
      direction = Math.random() < 0.7 ? 1 : -1;
    } else if (tweetQualityScore > -0.5) {
      // 低品質：50%增長（隨機波動）
      direction = Math.random() < 0.5 ? 1 : -1;
    } else {
      // 極低品質：30%增長，70%下降
      direction = Math.random() < 0.3 ? 1 : -1;
    }

    // 4. 根據身份和推文情況確定浮動幅度
    if (isHighExposure) {
      // 高曝光身份：大幅浮動
      if (recentTweets.length > 0) {
        baseFluctuation = 100 + Math.random() * 400; // 100-500
      } else {
        baseFluctuation = 50 + Math.random() * 150; // 50-200（無推文時較小）
      }
    } else if (recentTweets.length > 0) {
      // 有推文的普通用戶：中等浮動
      baseFluctuation = 20 + Math.random() * 80; // 20-100
    } else {
      // 無推文的普通用戶：小幅浮動
      baseFluctuation = 5 + Math.random() * 25; // 5-30
    }

    // 5. 根據推文品質調整幅度
    const qualityMultiplier = 0.5 + Math.abs(tweetQualityScore) * 0.8; // 0.5-1.3倍
    baseFluctuation *= qualityMultiplier;

    // 6. 根據當前粉絲基數調整（粉絲越多，浮動越大）
    if (currentFollowers > 10000) {
      baseFluctuation *= 1.5;
    } else if (currentFollowers > 5000) {
      baseFluctuation *= 1.2;
    }

    // 7. 隨機決定是否觸發浮動（60%概率）
    if (Math.random() > 0.6) {
      console.log('  📊 本次隨機跳過浮動');
      return 0;
    }

    // 8. 計算最終浮動值
    const finalFluctuation = Math.round(baseFluctuation * direction);

    console.log(
      `  📊 浮動計算: ${isHighExposure ? '高曝光' : '普通'}身份, 方向${direction > 0 ? '↑' : '↓'}, 幅度${Math.abs(
        finalFluctuation,
      )}`,
    );

    return finalFluctuation;
  }

  // ============================================
  // 離開後自動消息觸發系統
  // ============================================

  // 觸發離開後的自動消息（僅綁定角色）
  window.triggerAutoMessageAfterAway = async function (messageId) {
    try {
      console.log('⏰ [離開後自動消息] 開始觸發，messageId:', messageId);

      const xDb = getXDB();
      const conversationId = `messageConversation_${currentAccountId || 'main'}_${messageId}`;
      const savedConversation = await xDb.xAccountProfiles.get(conversationId);

      if (!savedConversation) {
        console.log('⚠️ [離開後自動消息] 未找到對話資料');
        return;
      }

      // 檢查是否仍然處於離開狀態
      if (!savedConversation.isAway) {
        console.log('⚠️ [離開後自動消息] 對話已不再處於離開狀態');
        return;
      }

      // 檢查離開時間是否已到
      const now = new Date();
      const awayUntil = new Date(savedConversation.awayUntil);
      if (now < awayUntil) {
        console.log('⚠️ [離開後自動消息] 離開時間尚未結束');
        return;
      }

      // 清除離開狀態
      savedConversation.isAway = false;
      delete savedConversation.awayUntil;
      delete savedConversation.awayDuration;
      await xDb.xAccountProfiles.put(savedConversation);
      console.log('✅ [離開後自動消息] 已清除離開狀態');

      // 檢查是否是綁定角色
      const isCharacterMessage = messageId && messageId.startsWith('msg_') && messageId !== 'msg_001';
      if (!isCharacterMessage) {
        console.log('⚠️ [離開後自動消息] 不是綁定角色，跳過');
        return;
      }

      // 🔍 獲取角色資訊（從xCharacterProfiles或從對話資料中）
      let userName = '未知';
      let userHandle = '@unknown';
      let userAvatar = '';

      try {
        const characterId = messageId.replace('msg_', '');
        const xProfile = await xDb.xCharacterProfiles.get(characterId);

        if (xProfile) {
          userName = xProfile.xName;
          userHandle = xProfile.xHandle;
          userAvatar = xProfile.xAvatar;
          console.log(`✅ [離開後自動消息] 從xCharacterProfiles獲取角色資訊: ${userName}`);
        } else if (savedConversation.data && savedConversation.data.senderProfile) {
          // 從對話資料中獲取
          userName = savedConversation.data.senderProfile.name || '未知';
          userHandle = savedConversation.data.senderProfile.handle || '@unknown';
          userAvatar = savedConversation.data.senderProfile.avatar || '';
          console.log(`✅ [離開後自動消息] 從senderProfile獲取角色資訊: ${userName}`);
        } else if (savedConversation.data && savedConversation.data.user) {
          // 相容舊格式
          userName = savedConversation.data.user.name || '未知';
          userHandle = savedConversation.data.user.handle || '@unknown';
          userAvatar = savedConversation.data.user.avatar || '';
          console.log(`✅ [離開後自動消息] 從user獲取角色資訊: ${userName}`);
        }
      } catch (error) {
        console.error('❌ [離開後自動消息] 獲取角色資訊失敗:', error);
      }

      // 構建消息資料
      const messageData = {
        id: messageId,
        user: {
          name: userName,
          handle: userHandle,
          avatar: userAvatar,
        },
      };

      // 調用AI生成離開後的主動消息
      console.log('📤 [離開後自動消息] 開始生成AI主動消息');
      const aiMessages = await generateMessageConversation(messageData, true, {
        isAutoMessage: true,
        timeSinceLastMessage: savedConversation.awayDuration * 60 || 3600, // 使用離開時長作為時間間隔
        isAwayReturn: true, // 標記為離開後返回
      });

      if (aiMessages && aiMessages.length > 0) {
        // 保存AI消息到資料庫
        const updatedConversation = await xDb.xAccountProfiles.get(conversationId);
        if (updatedConversation && updatedConversation.data && updatedConversation.data.messages) {
          updatedConversation.data.messages.push(...aiMessages);
          await xDb.xAccountProfiles.put(updatedConversation);
          console.log('✅ [離開後自動消息] AI消息已保存');
        }

        // 標記為未讀並顯示通知
        const dataId = `messagesList_${currentAccountId || 'main'}`;
        const savedData = await xDb.xAccountProfiles.get(dataId);

        if (savedData && savedData.data) {
          const messagesList = savedData.data;
          const messageIndex = messagesList.findIndex(msg => msg.id === messageId);

          if (messageIndex !== -1) {
            messagesList[messageIndex].unread = true;
            messagesList[messageIndex].unreadCount = (messagesList[messageIndex].unreadCount || 0) + aiMessages.length;

            await xDb.xAccountProfiles.put({
              handle: dataId,
              name: 'messagesList',
              data: messagesList,
              updatedAt: new Date().toISOString(),
            });

            // 同步更新全域資料
            sampleMessagesData = messagesList;

            // 顯示手機樣式通知
            showMessageNotification(messageData.user.name, messageData.user.avatar, aiMessages.length);

            // 顯示私信提醒點
            showNavNotificationDot('messages');

            console.log('✅ [離開後自動消息] 已標記為未讀並顯示提醒');
          }
        }
      } else {
        console.log('⚠️ [離開後自動消息] AI未生成消息');
      }
    } catch (error) {
      console.error('❌ [離開後自動消息] 觸發失敗:', error);
    }
  };

  // 多帳戶管理功能

  // 當前啟動的帳戶ID - 使用全域變數確保所有地方都能訪問
  window.currentAccountId = window.currentAccountId || 'main';
  let currentAccountId = window.currentAccountId;

  // 切換個人主頁菜單
  function toggleProfileMenu() {
    const menu = document.getElementById('profile-dropdown-menu');
    const isVisible = menu.style.display !== 'none';

    if (isVisible) {
      menu.style.display = 'none';
    } else {
      menu.style.display = 'block';
    }
  }

  // 點擊其他地方關閉菜單
  document.addEventListener('click', function (event) {
    const menuBtn = document.getElementById('profile-menu-btn');
    const menu = document.getElementById('profile-dropdown-menu');

    if (!menuBtn || !menu) return;

    if (!menuBtn.contains(event.target) && !menu.contains(event.target)) {
      menu.style.display = 'none';
    }
  });

  // 打開帳號管理彈窗
  async function openAccountManager() {
    // 關閉下拉式功能表
    document.getElementById('profile-dropdown-menu').style.display = 'none';

    // 顯示帳號管理彈窗
    showAccountManagerModal();
  }

  // 顯示帳號管理彈窗
  async function showAccountManagerModal() {
    // 獲取所有帳戶
    const accounts = await getAllAccounts();

    // 創建彈窗
    const modal = document.createElement('div');
    modal.id = 'account-manager-modal';
    modal.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            backdrop-filter: blur(4px);
            `;

    modal.innerHTML = `
            <div style="
                background-color: #1a1a1a;
                border-radius: 16px;
                width: 90%;
                max-width: 480px;
                max-height: 70vh;
                overflow-y: auto;
                border: 1px solid #333;
                position: relative;
              ">
              <!-- 彈窗頭部 -->
              <div style="
                  padding: 20px;
                  border-bottom: 1px solid #333;
                  display: flex;
                  align-items: center;
                  justify-content: space-between;
                  position: sticky;
                  top: 0;
                  background-color: #1a1a1a;
                  z-index: 10;
                ">
                <div>
                  <h3 style="margin: 0; color: #fff; font-size: 20px; font-weight: 700;">帳號管理</h3>
                  <p style="margin: 4px 0 0; color: #71767b; font-size: 14px;">管理你的多個X帳戶</p>
                </div>
                <button onclick="closeAccountManager()" style="
                    background: transparent;
                    border: none;
                    color: #71767b;
                    cursor: pointer;
                    padding: 8px;
                    border-radius: 50%;
                    transition: background-color 0.2s;
                  " onmouseover="this.style.backgroundColor='rgba(255,255,255,0.1)'"
                  onmouseout="this.style.backgroundColor='transparent'">
                  <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: currentColor;">
                    <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
                  </svg>
                </button>
              </div>

              <!-- 帳戶列表 -->
              <div style="padding: 20px;">
                <div id="accounts-list" style="margin-bottom: 20px;">
                  ${await renderAccountsList(accounts)}
                </div>

                <!-- 新建帳戶按鈕 -->
                <button onclick="createNewAccount()" style="
                    width: 100%;
                    background-color: var(--x-accent);
                    color: #fff;
                    border: none;
                    border-radius: 12px;
                    padding: 16px;
                    font-size: 16px;
                    font-weight: 700;
                    cursor: pointer;
                    transition: all 0.2s;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    gap: 8px;
                  " onmouseover="this.style.backgroundColor='#1a8cd8'"
                  onmouseout="this.style.backgroundColor='var(--x-accent)'">
                  <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: currentColor;">
                    <g><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"></path></g>
                  </svg>
                  新建帳戶
                </button>
              </div>
            </div>
            `;

    document.body.appendChild(modal);
    document.body.style.overflow = 'hidden';

    // 點擊背景關閉彈窗
    modal.addEventListener('click', e => {
      if (e.target === modal) {
        closeAccountManager();
      }
    });
  }

  // 獲取所有帳戶
  async function getAllAccounts() {
    try {
      const db = getXDB();
      const accounts = await db.xAccountList.orderBy('createdAt').toArray();
      const activeAccount = await db.xActiveAccount.get('current');

      // 如果沒有帳戶記錄，創建預設帳戶
      if (accounts.length === 0) {
        const defaultAccount = {
          accountId: 'main',
          name: userProfileData.name || '我',
          avatar: userProfileData.avatar || 'https://i.postimg.cc/pXxk1JXk/IMG-6442.jpg',
          createdAt: new Date().toISOString(),
          isActive: true,
        };
        await db.xAccountList.put(defaultAccount);
        await db.xActiveAccount.put({ id: 'current', accountId: 'main' });
        return [defaultAccount];
      }

      // 標記當前啟動的帳戶
      accounts.forEach(account => {
        account.isActive = activeAccount && activeAccount.accountId === account.accountId;
      });

      return accounts;
    } catch (error) {
      console.error('獲取帳戶列表失敗:', error);
      return [];
    }
  }

  // 渲染帳戶列表
  async function renderAccountsList(accounts) {
    if (accounts.length === 0) {
      return `
            <div style="text-align: center; color: #71767b; padding: 40px 20px;">
              <div style="font-size: 16px; margin-bottom: 8px;">暫無帳戶</div>
              <div style="font-size: 14px;">創建你的第一個帳戶</div>
            </div>
            `;
    }

    return accounts
      .map(
        account => `
            <div style="
                border: 2px solid ${account.isActive ? 'var(--x-accent)' : '#333'};
                border-radius: 12px;
                padding: 16px;
                margin-bottom: 12px;
                cursor: pointer;
                transition: all 0.2s;
                background-color: ${account.isActive ? 'color-mix(in srgb, var(--x-accent) , 0.05)' : 'transparent'};
              " onclick="switchAccount('${account.accountId}')"
              onmouseover="if (!${account.isActive}) this.style.borderColor='#536471'"
              onmouseout="if (!${account.isActive}) this.style.borderColor='#333'">
              <div style="display: flex; align-items: center; gap: 12px;">
                <img src="${account.avatar}" style="width: 48px; height: 48px; border-radius: 50%;" alt="${
          account.name
        }">
                  <div style="flex: 1;">
                    <div style="color: #fff; font-size: 16px; font-weight: 700; margin-bottom: 4px;">
                      ${account.name}
                      ${
                        account.isActive
                          ? '<span style="color: var(--x-accent); font-size: 12px; margin-left: 8px;">● 當前帳戶</span>'
                          : ''
                      }
                    </div>
                    <div style="color: #71767b; font-size: 14px;">
                      創建於 ${new Date(account.createdAt).toLocaleDateString('zh-CN')}
                    </div>
                  </div>
                  ${
                    !account.isActive && account.accountId !== 'main'
                      ? `
                    <button onclick="event.stopPropagation(); deleteAccount('${account.accountId}')" style="
                      background: transparent;
                      border: 1px solid #ef4444;
                      color: #ef4444;
                      border-radius: 8px;
                      padding: 6px 8px;
                      font-size: 12px;
                      cursor: pointer;
                      transition: all 0.2s;
                    " onmouseover="this.style.backgroundColor='rgba(239, 68, 68, 0.1)'" 
                       onmouseout="this.style.backgroundColor='transparent'">
                      刪除
                    </button>
                  `
                      : ''
                  }
              </div>
            </div>
            `,
      )
      .join('');
  }

  // 關閉帳號管理彈窗
  function closeAccountManager() {
    const modal = document.getElementById('account-manager-modal');
    if (modal) {
      modal.remove();
    }
    document.body.style.overflow = 'auto';
  }

  // 切換帳戶
  async function switchAccount(accountId) {
    if (accountId === currentAccountId) {
      closeAccountManager();
      return;
    }

    try {
      // 先停止當前帳戶的聊天記憶檢測服務
      if (chatHistoryDetectionTimer) {
        clearInterval(chatHistoryDetectionTimer);
        chatHistoryDetectionTimer = null;
        chatHistoryDetectionEnabled = false;
      }

      const db = getXDB();

      // 更新啟動帳戶記錄
      await db.xActiveAccount.put({ id: 'current', accountId: accountId });

      // 更新當前帳戶ID（同步到全域和局部）
      currentAccountId = accountId;
      window.currentAccountId = accountId;

      // 載入新帳戶的資料
      await loadUserProfileFromDB(accountId);

      // 重新載入 X 設置（按帳號載入）
      await initializeXSettings();

      // 更新UI顯示
      loadUserProfileToUI();

      // 同步頭像到所有位置
      syncUserAvatar(userProfileData.avatar);

      // 重新載入個人主頁推文（按帳戶隔離）
      if (document.getElementById('x-profile-page').style.display !== 'none') {
        loadUserProfileTweets();
      }

      // 重新載入提問箱資料（按帳戶隔離）- 無論是否在提問箱頁面都要載入
      await loadAskboxDataFromDB();

      // 如果當前正在提問箱頁面，立即更新UI
      if (document.getElementById('x-askbox-page').style.display !== 'none') {
        await loadAskboxData();
      }

      // 更新發帖彈窗的使用者資訊
      const composeAvatar = document.getElementById('compose-user-avatar');
      if (composeAvatar) {
        composeAvatar.src = userProfileData.avatar;
      }

      // 重新載入主題色偏好（按帳戶隔離）
      await loadAccentColorPreference();

      // 🔧 重新載入錢包資料（按帳戶隔離）
      await loadWalletData();

      // 🔧 重新載入私信和通知資料（按帳戶隔離）
      // 如果當前在私信頁面，重新載入私信清單
      const messagesPage = document.getElementById('x-messages-page');
      if (messagesPage && messagesPage.style.display === 'flex') {
        await loadMessagesList();
      }

      // 如果當前在通知頁面，重新載入通知
      const notificationsPage = document.getElementById('x-notifications-page');
      if (notificationsPage && notificationsPage.style.display === 'flex') {
        await loadNotifications();
      }

      // 關閉彈窗
      closeAccountManager();

      showXToast(`已切換到帳戶：${userProfileData.name}`, 'success');
      console.log('✅ 已切換帳戶，綁定角色數:', xSettingsData.boundCharacters?.length || 0);
    } catch (error) {
      console.error('切換帳戶失敗:', error);
      showXToast('切換帳戶失敗', 'error');
    }
  }

  // 創建新帳戶
  async function createNewAccount() {
    try {
      const db = getXDB();

      // 生成新的帳戶ID
      const newAccountId = 'account_' + Date.now();

      // 使用統一的預設使用者資料配置
      const defaultProfile = getDefaultUserProfile(newAccountId);

      // 保存新帳戶的使用者資料
      await db.xUserProfile.put(defaultProfile);

      // 添加到帳戶列表
      const newAccount = {
        accountId: newAccountId,
        name: '新用戶',
        avatar: 'https://i.postimg.cc/pXxk1JXk/IMG-6442.jpg',
        createdAt: new Date().toISOString(),
      };
      await db.xAccountList.put(newAccount);

      // 為新帳戶創建空的提問箱資料
      const askboxId = `askbox_${newAccountId}`;
      await db.xAskbox.put({
        id: askboxId,
        avatar: 'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg',
        nickname: '= =',
        prompt: '請向我匿名提問!waiting...',
        background: 'https://i.postimg.cc/7LqVqxt4/mmexport1759588659314.jpg',
        answeredQuestions: [], // 新帳戶必須從空列表開始
      });
      console.log('✅ 已為新帳戶創建空提問箱:', newAccountId);

      // 自動切換到新帳戶
      await switchAccount(newAccountId);
    } catch (error) {
      console.error('創建新帳戶失敗:', error);
      showXToast('創建新帳戶失敗', 'error');
    }
  }

  // 刪除帳戶
  async function deleteAccount(accountId) {
    if (accountId === 'main') {
      showXToast('無法刪除默認帳戶', 'error');
      return;
    }

    if (!confirm('確定要刪除這個帳戶嗎？此操作無法撤銷。')) {
      return;
    }

    try {
      const db = getXDB();

      // 刪除帳戶的使用者資料
      await db.xUserProfile.delete(accountId);

      // 從帳戶列表中刪除
      await db.xAccountList.delete(accountId);

      // 刪除帳戶的提問箱資料
      const askboxId = `askbox_${accountId}`;
      await db.xAskbox.delete(askboxId);

      // 🔧 刪除帳戶的私信和通知資料
      // 刪除私信列表
      const messagesListId = `messagesList_${accountId}`;
      await db.xAccountProfiles.delete(messagesListId);

      // 刪除陌生人私信
      const strangerMessagesId = `strangerMessages_${accountId}`;
      await db.xAccountProfiles.delete(strangerMessagesId);

      // 刪除Mentions通知
      const mentionsId = `mentions_${accountId}`;
      await db.xAccountProfiles.delete(mentionsId);

      // 刪除所有該帳戶的私信對話資料
      const allConversations = await db.xAccountProfiles.where('name').equals('messageConversation').toArray();
      for (const conv of allConversations) {
        if (conv.accountId === accountId || conv.handle.startsWith(`messageConversation_${accountId}_`)) {
          await db.xAccountProfiles.delete(conv.handle);
        }
      }

      // 刪除帳戶的X設置和用戶推文
      await db.xSettings.delete(`xSettings_${accountId}`);
      await db.xUserTweets.delete(`userTweets_${accountId}`);

      // 刪除帳戶的書簽資料
      const bookmarks = await db.xBookmarks.where('accountId').equals(accountId).toArray();
      for (const bookmark of bookmarks) {
        await db.xBookmarks.delete(bookmark.id);
      }

      // 🔧 刪除帳戶的錢包資料
      const walletId = `wallet_${accountId}`;
      await db.xAccountProfiles.delete(walletId);

      console.log(`✅ 已清理帳戶 ${accountId} 的所有相關資料`);
      showXToast('帳戶已刪除', 'success');

      // 重新顯示帳戶管理彈窗
      closeAccountManager();
      setTimeout(() => {
        showAccountManagerModal();
      }, 300);
    } catch (error) {
      console.error('刪除帳戶失敗:', error);
      showXToast('刪除帳戶失敗', 'error');
    }
  }

  // 清空當前帳戶的提問箱資料（調試用）
  window.clearCurrentAskboxData = async function () {
    try {
      const xDb = getXDB();
      const accountId = currentAccountId || 'main';
      const askboxId = `askbox_${accountId}`;

      await xDb.xAskbox.put({
        id: askboxId,
        avatar: 'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg',
        nickname: '= =',
        prompt: '請向我匿名提問!waiting...',
        background: 'https://i.postimg.cc/7LqVqxt4/mmexport1759588659314.jpg',
        answeredQuestions: [],
      });

      // 重新載入數據
      await loadAskboxDataFromDB();

      // 如果在提問箱頁面，刷新UI
      if (document.getElementById('x-askbox-page').style.display !== 'none') {
        renderAnsweredQuestions();
      }

      console.log('✅ 已清空帳戶提問箱資料:', accountId);
      showXToast('提問箱數據已清空', 'success');
    } catch (error) {
      console.error('❌ 清空提問箱數據失敗:', error);
      showXToast('清空失敗: ' + error.message, 'error');
    }
  };

  // 初始化用戶主頁
  async function initializeUserProfile() {
    // 首先載入當前啟動的帳戶
    await loadActiveAccount();
    await loadUserProfileFromDB();
    loadUserProfileToUI();

    // 同步頭像到所有位置
    syncUserAvatar(userProfileData.avatar);

    // 載入當前帳戶的推文
    loadUserProfileTweets();

    // 🔧 載入錢包數據
    await loadWalletData();
  }

  // 載入當前啟動的帳戶
  async function loadActiveAccount() {
    try {
      const db = getXDB();

      // 初始化多帳戶系統
      await initializeMultiAccountSystem();

      const activeAccount = await db.xActiveAccount.get('current');
      if (activeAccount) {
        currentAccountId = activeAccount.accountId;
        window.currentAccountId = activeAccount.accountId; // 同步到全域
      } else {
        // 如果沒有啟動帳戶記錄，使用預設帳戶
        currentAccountId = 'main';
        window.currentAccountId = 'main'; // 同步到全域
        await db.xActiveAccount.put({ id: 'current', accountId: 'main' });
      }
      console.log('✅ 已載入啟動帳戶:', currentAccountId);
    } catch (error) {
      console.error('載入啟動帳戶失敗:', error);
      currentAccountId = 'main';
      window.currentAccountId = 'main'; // 同步到全域
    }
  }

  // 初始化多帳戶系統
  async function initializeMultiAccountSystem() {
    try {
      const db = getXDB();

      // 檢查是否存在預設帳戶記錄
      const defaultAccount = await db.xAccountList.get('main');
      if (!defaultAccount) {
        // 從現有的使用者資料創建預設帳戶記錄
        const existingProfile = await db.xUserProfile.get('main');
        const defaultAccountData = {
          accountId: 'main',
          name: existingProfile?.name || '我',
          avatar: existingProfile?.avatar || 'https://i.postimg.cc/pXxk1JXk/IMG-6442.jpg',
          createdAt: existingProfile?.lastUpdated || new Date().toISOString(),
        };
        await db.xAccountList.put(defaultAccountData);
        console.log('已創建預設帳戶記錄');
      }

      // 確保有啟動帳戶記錄
      const activeAccount = await db.xActiveAccount.get('current');
      if (!activeAccount) {
        await db.xActiveAccount.put({ id: 'current', accountId: 'main' });
        console.log('已設置默認啟動帳戶');
      }
    } catch (error) {
      console.error('初始化多帳戶系統失敗:', error);
    }
  }

  // 從資料庫載入使用者資料（多帳戶系統專用）
  async function loadUserProfileFromDB(accountId = null) {
    try {
      const db = getXDB();
      const targetAccountId = accountId || currentAccountId || 'main';
      const savedProfile = await db.xUserProfile.get(targetAccountId);

      if (savedProfile) {
        // 更新現有物件的屬性（保持引用一致）
        Object.assign(window.userProfileData, savedProfile);
      } else {
        // 如果沒有找到使用者資料，使用預設值（新帳戶的情況）
        console.log('⚠️ 未找到帳戶資料，使用預設值:', targetAccountId);
        const defaultProfile = getDefaultUserProfile(targetAccountId);
        Object.assign(window.userProfileData, defaultProfile);
      }

      // 確保所有必要欄位存在（使用統一的欄位驗證）
      ensureProfileFields(window.userProfileData);

      console.log('✅ 已載入使用者資料資料:', targetAccountId);
      if (window.userProfileData.knownIdentityCharacters && window.userProfileData.knownIdentityCharacters.length > 0) {
        console.log('📌 已知身份角色數量:', window.userProfileData.knownIdentityCharacters.length);
      }
    } catch (error) {
      console.error('❌ 載入使用者資料失敗，使用預設資料:', error);
      const defaultProfile = getDefaultUserProfile('main');
      Object.assign(window.userProfileData, defaultProfile);
    }
  }

  // 保存使用者資料到資料庫
  async function saveUserProfileToDB() {
    try {
      const db = getXDB();
      const targetAccountId = currentAccountId || 'main';

      await db.xUserProfile.put({
        id: targetAccountId,
        ...window.userProfileData, // 使用window.userProfileData確保使用最新資料
        lastUpdated: new Date().toISOString(),
      });

      // 同時更新帳戶清單中的基本資訊
      const existingAccount = await db.xAccountList.get(targetAccountId);
      if (existingAccount) {
        existingAccount.name = window.userProfileData.name;
        existingAccount.avatar = window.userProfileData.avatar;
        await db.xAccountList.put(existingAccount);
      }

      console.log('使用者資料已保存到資料庫，帳戶ID:', targetAccountId);
      if (window.userProfileData.knownIdentityCharacters && window.userProfileData.knownIdentityCharacters.length > 0) {
        console.log('已知身份角色:', window.userProfileData.knownIdentityCharacters.length + '個');
      }
    } catch (error) {
      console.error('保存使用者資料失敗:', error);
      throw error;
    }
  }

  // ============================================
  // 帳戶錢包功能
  // ============================================

  // 錢包數據
  let walletData = {
    accountId: 'main',
    isActivated: false,
    balance: 0,
    currency: 'USD',
    transactions: [],
    activatedAt: null,
    initialAmount: 0,
    creditScore: 100, // 信用值，初始100，影響商業轉帳的接收和發起
  };

  // 打開帳戶錢包
  async function openAccountWallet() {
    // 關閉下拉式功能表
    document.getElementById('profile-dropdown-menu').style.display = 'none';

    // 載入錢包數據
    await loadWalletData();

    // 啟動商業轉帳狀態檢查
    startBusinessTransferCheck();

    // 顯示錢包彈窗
    showWalletModal();
  }

  // 顯示錢包彈窗
  function showWalletModal() {
    const xSocialScreen = document.getElementById('x-social-screen');
    const isLightMode = xSocialScreen && xSocialScreen.classList.contains('x-theme-light');

    // 創建彈窗遮罩
    const modal = document.createElement('div');
    modal.id = 'wallet-modal';
    modal.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: ${isLightMode ? 'rgba(255, 255, 255, 0.85)' : 'rgba(0, 0, 0, 0.85)'};
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 25;
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
    `;

    // 創建錢包介面
    modal.innerHTML = `
      <div style="
        background-color: ${isLightMode ? 'rgba(255, 255, 255, 0.95)' : 'rgba(0, 0, 0, 0.95)'};
        backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px);
        border-radius: 24px;
        width: 90%;
        max-width: 360px;
        position: relative;
        overflow: hidden;
        box-shadow: ${
          isLightMode
            ? '0 20px 60px rgba(0, 0, 0, 0.15), 0 8px 32px rgba(0, 0, 0, 0.1)'
            : '0 20px 60px rgba(0, 0, 0, 0.8), 0 8px 32px rgba(255, 255, 255, 0.05)'
        };
        border: 2px solid ${isLightMode ? 'rgba(0, 0, 0, 0.1)' : 'rgba(255, 255, 255, 0.1)'};
      " onclick="event.stopPropagation()">
        
        <!-- 錢包頂部區域 -->
        <div style="
          background: linear-gradient(135deg, ${
            isLightMode ? 'rgba(248, 250, 252, 0.8)' : 'rgba(22, 24, 28, 0.8)'
          } 0%, ${isLightMode ? 'rgba(255, 255, 255, 0.6)' : 'rgba(0, 0, 0, 0.6)'} 100%);
          padding: 24px;
          text-align: center;
          border-bottom: 2px solid ${isLightMode ? 'rgba(0, 0, 0, 0.08)' : 'rgba(255, 255, 255, 0.08)'};
          position: relative;
        ">
          <!-- 關閉按鈕 -->
          <button onclick="closeWalletModal()" style="
            position: absolute;
            top: 16px;
            right: 16px;
            background: transparent;
            border: none;
            color: ${isLightMode ? '#536471' : '#71767b'};
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            transition: all 0.2s;
          " onmouseover="this.style.backgroundColor='${
            isLightMode ? 'rgba(0, 0, 0, 0.05)' : 'rgba(255, 255, 255, 0.05)'
          }';"
             onmouseout="this.style.backgroundColor='transparent'">
            <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: currentColor;">
              <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
            </svg>
          </button>

          <!-- 用戶頭像 -->
          <div style="margin-bottom: 16px;">
            <img src="${window.userProfileData?.avatar || userProfileData.avatar}" style="
              width: 64px;
              height: 64px;
              border-radius: 50%;
              border: 3px solid var(--x-accent);
              object-fit: cover;
            " alt="${window.userProfileData?.name || userProfileData.name}">
          </div>

          <!-- 用戶名 -->
          <div style="
            color: ${isLightMode ? '#0f1419' : '#ffffff'};
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 4px;
          ">${window.userProfileData?.name || userProfileData.name}</div>

          <!-- 錢包類型 -->
          <div style="
            color: ${isLightMode ? '#536471' : '#71767b'};
            font-size: 14px;
            margin-bottom: 16px;
          ">Digital Wallet</div>

          <!-- 狀態顯示 -->
          <div id="wallet-status" style="
            display: inline-block;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 700;
            letter-spacing: 1px;
            ${
              walletData.isActivated
                ? 'background-color: rgba(34, 197, 94, 0.15); color: #22c55e; border: 2px solid rgba(34, 197, 94, 0.4);'
                : `background-color: ${
                    isLightMode ? 'rgba(156, 163, 175, 0.15)' : 'rgba(156, 163, 175, 0.1)'
                  }; color: ${isLightMode ? '#6b7280' : '#9ca3af'}; border: 2px solid ${
                    isLightMode ? 'rgba(156, 163, 175, 0.3)' : 'rgba(156, 163, 175, 0.2)'
                  };`
            }
          ">${walletData.isActivated ? 'ACTIVATED' : 'INACTIVE'}</div>
        </div>

        <!-- 錢包內容區域 -->
        <div style="
          padding: 24px;
          background-color: ${isLightMode ? 'rgba(255, 255, 255, 0.3)' : 'rgba(0, 0, 0, 0.3)'};
        ">
          ${walletData.isActivated ? renderActivatedWallet(isLightMode) : renderInactiveWallet(isLightMode)}
        </div>

        <!-- 底部工具列 -->
        <div style="
          display: flex;
          justify-content: center;
          align-items: center;
          padding: 16px 24px;
          gap: 24px;
          border-top: 2px solid ${isLightMode ? 'rgba(0, 0, 0, 0.08)' : 'rgba(255, 255, 255, 0.08)'};
          background-color: ${isLightMode ? 'rgba(248, 250, 252, 0.5)' : 'rgba(22, 24, 28, 0.5)'};
        ">
          <div onclick="openBusinessTransferManager()" style="
            padding: 12px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s;
            color: ${isLightMode ? '#536471' : '#71767b'};
          " onmouseover="this.style.backgroundColor='${
            isLightMode ? 'rgba(0, 0, 0, 0.05)' : 'rgba(255, 255, 255, 0.05)'
          }'; this.style.color='var(--x-accent)';"
             onmouseout="this.style.backgroundColor='transparent'; this.style.color='${
               isLightMode ? '#536471' : '#71767b'
             }';" title="商業轉帳管理">
            <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: currentColor;">
              <g><path d="M20 6h-3V4c0-1.1-.9-2-2-2H9c-1.1 0-2 .9-2 2v2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zM9 4h6v2H9V4zm11 16H4V8h16v12z"></path><path d="M12 10L14.5 14L17 10L14.5 12L12 10ZM10 10L7.5 12L10 14L7.5 14L10 10Z"></path></g>
            </svg>
          </div>
          <div onclick="exportWallet()" style="
            padding: 12px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s;
            color: ${isLightMode ? '#536471' : '#71767b'};
          " onmouseover="this.style.backgroundColor='${
            isLightMode ? 'rgba(0, 0, 0, 0.05)' : 'rgba(255, 255, 255, 0.05)'
          }'; this.style.color='var(--x-accent)';"
             onmouseout="this.style.backgroundColor='transparent'; this.style.color='${
               isLightMode ? '#536471' : '#71767b'
             }';" title="匯出錢包">
            <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: currentColor;">
              <g><path d="M19 12v7H5v-7H3v7c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-7h-2zm-6 .67l2.59-2.58L17 11.5l-5 5-5-5 1.41-1.41L11 12.67V3h2v9.67z"></path></g>
            </svg>
          </div>
          <div onclick="copyWalletInfo()" style="
            padding: 12px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s;
            color: ${isLightMode ? '#536471' : '#71767b'};
          " onmouseover="this.style.backgroundColor='${
            isLightMode ? 'rgba(0, 0, 0, 0.05)' : 'rgba(255, 255, 255, 0.05)'
          }'; this.style.color='var(--x-accent)';"
             onmouseout="this.style.backgroundColor='transparent'; this.style.color='${
               isLightMode ? '#536471' : '#71767b'
             }';" title="複製錢包資訊">
            <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: currentColor;">
              <g><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></g>
            </svg>
          </div>
        </div>
      </div>
    `;

    document.body.appendChild(modal);
    document.body.style.overflow = 'hidden';

    // 點擊背景關閉彈窗
    modal.addEventListener('click', e => {
      if (e.target === modal) {
        closeWalletModal();
      }
    });

    // 添加入場動畫
    const walletCard = modal.querySelector('div');
    walletCard.style.transform = 'scale(0.8) translateY(20px)';
    walletCard.style.opacity = '0';

    requestAnimationFrame(() => {
      walletCard.style.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
      walletCard.style.transform = 'scale(1) translateY(0)';
      walletCard.style.opacity = '1';
    });
  }

  // 渲染未啟動錢包介面
  function renderInactiveWallet(isLightMode = false) {
    return `
      <div style="text-align: center;">
        <!-- 錢包圖示 -->
        <div style="
          width: 80px;
          height: 80px;
          margin: 0 auto 20px;
          background: linear-gradient(135deg, ${
            isLightMode ? 'rgba(248, 250, 252, 0.8)' : 'rgba(22, 24, 28, 0.8)'
          } 0%, ${isLightMode ? 'rgba(229, 231, 235, 0.6)' : 'rgba(55, 65, 81, 0.6)'} 100%);
          border-radius: 16px;
          display: flex;
          align-items: center;
          justify-content: center;
          border: 2px solid ${isLightMode ? 'rgba(0, 0, 0, 0.1)' : 'rgba(255, 255, 255, 0.1)'};
        ">
          <svg viewBox="0 0 24 24" style="width: 32px; height: 32px; fill: ${isLightMode ? '#6b7280' : '#9ca3af'};">
            <g><path d="M21 18v1c0 1.1-.9 2-2 2H5c-1.11 0-2-.9-2-2V5c0-1.1.89-2 2-2h14c1.1 0 2 .9 2 2v1h-9c-1.11 0-2 .9-2 2v8c0 1.1.89 2 2 2h9zm-9-2h10V8H12v8zm4-2.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"/></g>
          </svg>
        </div>

        <!-- 描述文字 -->
        <div style="
          color: ${isLightMode ? '#0f1419' : '#ffffff'};
          font-size: 16px;
          font-weight: 600;
          margin-bottom: 8px;
        ">啟動你的數字錢包</div>
        
        <div style="
          color: ${isLightMode ? '#536471' : '#71767b'};
          font-size: 14px;
          line-height: 1.5;
          margin-bottom: 24px;
        ">點擊下方按鈕啟動錢包<br>初始金額將根據你的公眾身份隨機生成</div>

        <!-- 啟動按鈕 -->
        <button id="activate-wallet-btn" onclick="activateWallet()" style="
          width: 100%;
          background: linear-gradient(135deg, var(--x-accent) 0%, #1a8cd8 100%);
          color: #fff;
          border: none;
          border-radius: 12px;
          padding: 16px 24px;
          font-size: 16px;
          font-weight: 700;
          cursor: pointer;
          transition: all 0.3s;
          position: relative;
          overflow: hidden;
        " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 8px 25px rgba(29, 155, 240, 0.3)'"
           onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'">
          <span id="activate-btn-text">🚀 啟動錢包</span>
          <div id="activate-btn-loader" style="display: none;">
            <svg style="animation: spin 1s linear infinite; width: 20px; height: 20px;" viewBox="0 0 24 24">
              <circle cx="12" cy="12" r="10" stroke="rgba(255,255,255,0.3)" stroke-width="2" fill="none"/>
              <path d="M4,12a8,8 0 1,1 16,0" stroke="#fff" stroke-width="2" fill="none" stroke-linecap="round"/>
            </svg>
          </div>
        </button>
      </div>
    `;
  }

  // 渲染已啟動錢包介面
  function renderActivatedWallet(isLightMode = false) {
    return `
      <div>
        <!-- 餘額顯示 -->
        <div style="
          background: linear-gradient(135deg, ${
            isLightMode ? 'rgba(248, 250, 252, 0.8)' : 'rgba(22, 24, 28, 0.8)'
          } 0%, ${isLightMode ? 'rgba(229, 231, 235, 0.6)' : 'rgba(55, 65, 81, 0.6)'} 100%);
          border: 2px solid ${isLightMode ? 'rgba(0, 0, 0, 0.1)' : 'rgba(255, 255, 255, 0.1)'};
          border-radius: 16px;
          padding: 20px;
          margin-bottom: 20px;
          text-align: center;
        ">
          <div style="
            color: ${isLightMode ? '#6b7280' : '#9ca3af'};
            font-size: 12px;
            font-weight: 600;
            letter-spacing: 1px;
            margin-bottom: 8px;
            text-transform: uppercase;
          ">Balance</div>
          
          <div style="
            color: ${isLightMode ? '#0f1419' : '#ffffff'};
            font-size: 32px;
            font-weight: 700;
            margin-bottom: 4px;
          ">$${walletData.balance.toFixed(2)}</div>
          
          <div style="
            color: ${isLightMode ? '#6b7280' : '#9ca3af'};
            font-size: 13px;
          ">${walletData.currency}</div>
        </div>

        <!-- 交易記錄 -->
        <div style="margin-bottom: 16px;">
          <div style="
            color: ${isLightMode ? '#6b7280' : '#9ca3af'};
            font-size: 12px;
            font-weight: 600;
            letter-spacing: 1px;
            margin-bottom: 12px;
            text-transform: uppercase;
          ">Recent Activity</div>
          
          ${walletData.transactions.length > 0 ? renderTransactions(isLightMode) : renderNoTransactions(isLightMode)}
        </div>

        <!-- 操作按鈕 -->
        <div style="display: flex; gap: 12px;">
          <button onclick="showIncomeHistory()" style="
            flex: 1;
            background-color: var(--x-accent);
            color: ${isLightMode ? '#0f1419' : '#ffffff'};
            border: none;
            border-radius: 12px;
            padding: 12px 16px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
          " onmouseover="this.style.backgroundColor='#1a8cd8'"
             onmouseout="this.style.backgroundColor='var(--x-accent)'">
            + Add Funds
            ${
              getIncomeRecordsCount() > 0
                ? `<span style="
              position: absolute;
              top: -2px;
              right: -2px;
              background: #22c55e;
              color: white;
              border-radius: 50%;
              width: 16px;
              height: 16px;
              font-size: 10px;
              display: flex;
              align-items: center;
              justify-content: center;
              font-weight: 700;
            ">${getIncomeRecordsCount()}</span>`
                : ''
            }
          </button>
          
          <button onclick="showExpenseHistory()" style="
            flex: 1;
            background-color: transparent;
            color: ${isLightMode ? '#0f1419' : '#ffffff'};
            border: none;
            border-radius: 12px;
            padding: 12px 16px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
          " onmouseover="this.style.backgroundColor='${
            isLightMode ? 'rgba(0, 0, 0, 0.05)' : 'rgba(255, 255, 255, 0.05)'
          }';"
             onmouseout="this.style.backgroundColor='transparent'">
            Send
            ${
              getExpenseRecordsCount() > 0
                ? `<span style="
              position: absolute;
              top: -2px;
              right: -2px;
              background: #ef4444;
              color: white;
              border-radius: 50%;
              width: 16px;
              height: 16px;
              font-size: 10px;
              display: flex;
              align-items: center;
              justify-content: center;
              font-weight: 700;
            ">${getExpenseRecordsCount()}</span>`
                : ''
            }
          </button>
        </div>
      </div>
    `;
  }

  // 渲染交易記錄
  function renderTransactions(isLightMode = false) {
    return walletData.transactions
      .slice(0, 2)
      .map(
        transaction => `
      <div style="
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px 0;
        border-bottom: 2px solid ${isLightMode ? 'rgba(0, 0, 0, 0.08)' : 'rgba(255, 255, 255, 0.08)'};
      ">
        <div>
          <div style="
            color: ${isLightMode ? '#0f1419' : '#ffffff'};
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 2px;
          ">${transaction.description}</div>
          <div style="
            color: ${isLightMode ? '#6b7280' : '#9ca3af'};
            font-size: 12px;
          ">${new Date(transaction.timestamp).toLocaleDateString()}</div>
        </div>
        <div style="
          color: ${transaction.amount > 0 ? '#22c55e' : '#ef4444'};
          font-size: 14px;
          font-weight: 700;
        ">${transaction.amount > 0 ? '+' : ''}$${Math.abs(transaction.amount).toFixed(2)}</div>
      </div>
    `,
      )
      .join('');
  }

  // 渲染無交易記錄
  function renderNoTransactions(isLightMode = false) {
    return `
      <div style="
        text-align: center;
        padding: 20px;
        color: ${isLightMode ? '#6b7280' : '#9ca3af'};
        font-size: 14px;
      ">
        <div style="margin-bottom: 8px; opacity: 0.6;">📋</div>
        <div>No transactions yet</div>
      </div>
    `;
  }

  // 啟動錢包
  async function activateWallet() {
    const activateBtn = document.getElementById('activate-wallet-btn');
    const btnText = document.getElementById('activate-btn-text');
    const btnLoader = document.getElementById('activate-btn-loader');

    // 顯示載入狀態
    btnText.style.display = 'none';
    btnLoader.style.display = 'block';
    activateBtn.disabled = true;
    activateBtn.style.cursor = 'not-allowed';

    // 模擬啟動過程
    await new Promise(resolve => setTimeout(resolve, 2000));

    try {
      // 根據公眾身份生成初始金額
      const initialAmount = generateInitialAmount();

      // 更新錢包資料
      walletData.isActivated = true;
      walletData.balance = initialAmount;
      walletData.initialAmount = initialAmount;
      walletData.activatedAt = new Date().toISOString();
      walletData.transactions = [
        {
          id: 'init_' + Date.now(),
          description: 'Initial Deposit',
          amount: initialAmount,
          timestamp: new Date().toISOString(),
          type: 'deposit',
        },
      ];

      // 保存到資料庫
      await saveWalletData();

      // 顯示成功動畫
      showWalletActivationSuccess(initialAmount);
    } catch (error) {
      console.error('啟動錢包失敗:', error);
      showXToast('錢包啟動失敗', 'error');

      // 恢復按鈕狀態
      btnText.style.display = 'block';
      btnLoader.style.display = 'none';
      activateBtn.disabled = false;
      activateBtn.style.cursor = 'pointer';
    }
  }

  // 根據公眾身份生成初始金額
  function generateInitialAmount() {
    // 使用window.userProfileData確保獲取最新資料
    const publicIdentity = window.userProfileData?.publicIdentity || '';
    const identityLower = publicIdentity.toLowerCase();

    // 定義不同身份的金額範圍
    const amountRanges = {
      // 超高知名度身份 (1000-5000)
      celebrity: {
        min: 1000,
        max: 5000,
        keywords: ['明星', '演員', '歌手', '導演', '藝人', 'celebrity', 'star', 'actor', 'singer'],
      },

      // 高知名度身份 (500-1500)
      influencer: {
        min: 500,
        max: 1500,
        keywords: ['網紅', '博主', '主播', 'influencer', 'streamer', 'youtuber', 'blogger'],
      },

      // 專業身份 (200-800)
      professional: {
        min: 200,
        max: 800,
        keywords: ['專家', '教授', '醫生', '律師', '工程師', 'expert', 'professor', 'doctor', 'lawyer', 'engineer'],
      },

      // 企業相關 (300-1000)
      business: {
        min: 300,
        max: 1000,
        keywords: ['企業家', 'CEO', '總裁', '創始人', 'entrepreneur', 'founder', 'executive'],
      },

      // 藝術創作者 (150-600)
      creator: {
        min: 150,
        max: 600,
        keywords: ['作家', '畫家', '設計師', '攝影師', 'writer', 'artist', 'designer', 'photographer'],
      },

      // 普通用戶 (50-200)
      regular: { min: 50, max: 200, keywords: [] },
    };

    // 檢查身份匹配
    for (const [category, config] of Object.entries(amountRanges)) {
      if (category === 'regular') continue; // 跳過普通用戶，作為預設值

      const hasMatch = config.keywords.some(keyword => identityLower.includes(keyword));
      if (hasMatch) {
        const amount = Math.random() * (config.max - config.min) + config.min;
        console.log(`💰 根據身份類型 "${category}" 生成初始金額: $${amount.toFixed(2)}`);
        return Math.round(amount * 100) / 100; // 保留兩位小數
      }
    }

    // 默認為普通用戶
    const regularRange = amountRanges.regular;
    const amount = Math.random() * (regularRange.max - regularRange.min) + regularRange.min;
    console.log(`💰 默認身份生成初始金額: $${amount.toFixed(2)}`);
    return Math.round(amount * 100) / 100;
  }

  // 顯示錢包啟動成功動畫
  function showWalletActivationSuccess(amount) {
    // 關閉當前錢包彈窗
    closeWalletModal();

    // 顯示成功彈窗
    const successModal = document.createElement('div');
    successModal.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.9);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 30;
      backdrop-filter: blur(12px);
    `;

    successModal.innerHTML = `
      <div style="
        background-color: var(--x-bg-primary);
        border-radius: 24px;
        padding: 40px;
        text-align: center;
        border: 1px solid var(--x-border-color);
        max-width: 320px;
        width: 90%;
        animation: walletSuccessIn 0.6s cubic-bezier(0.4, 0, 0.2, 1);
      ">
        <!-- 成功圖示 -->
        <div style="
          width: 80px;
          height: 80px;
          margin: 0 auto 24px;
          background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
          border-radius: 50%;
          display: flex;
          align-items: center;
          justify-content: center;
          animation: walletSuccessCheck 0.8s ease-in-out 0.3s both;
        ">
          <svg viewBox="0 0 24 24" style="width: 32px; height: 32px; fill: white;">
            <g><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/></g>
          </svg>
        </div>

        <!-- 成功文字 -->
        <div style="
          color: var(--x-text-primary);
          font-size: 20px;
          font-weight: 700;
          margin-bottom: 8px;
        ">錢包啟動成功！</div>
        
        <div style="
          color: #22c55e;
          font-size: 24px;
          font-weight: 700;
          margin-bottom: 16px;
        ">+$${amount.toFixed(2)}</div>
        
        <div style="
          color: var(--x-text-secondary);
          font-size: 14px;
          line-height: 1.5;
          margin-bottom: 24px;
        ">恭喜！你的數字錢包已成功啟動<br>初始資金已到賬</div>

        <!-- 確認按鈕 -->
        <button onclick="this.parentElement.parentElement.remove(); document.body.style.overflow='auto'; openAccountWallet();" style="
          background: linear-gradient(135deg, var(--x-accent) 0%, #1a8cd8 100%);
          color: #fff;
          border: none;
          border-radius: 12px;
          padding: 12px 24px;
          font-size: 14px;
          font-weight: 600;
          cursor: pointer;
          transition: all 0.2s;
        ">查看錢包</button>
      </div>
    `;

    document.body.appendChild(successModal);

    // 3秒後自動關閉
    setTimeout(() => {
      if (successModal.parentElement) {
        successModal.remove();
        document.body.style.overflow = 'auto';
      }
    }, 3000);
  }

  // 關閉錢包彈窗
  function closeWalletModal() {
    const modal = document.getElementById('wallet-modal');
    if (modal) {
      const walletCard = modal.querySelector('div');
      walletCard.style.transform = 'scale(0.9) translateY(20px)';
      walletCard.style.opacity = '0';

      setTimeout(() => {
        modal.remove();
        document.body.style.overflow = 'auto';
      }, 200);
    }
  }

  // 載入錢包數據
  async function loadWalletData() {
    try {
      const db = getXDB();
      const walletId = `wallet_${currentAccountId || 'main'}`;
      const savedWallet = await db.xAccountProfiles.get(walletId);

      if (savedWallet && savedWallet.data) {
        Object.assign(walletData, savedWallet.data);
        walletData.accountId = currentAccountId || 'main';
      } else {
        // 重置為預設狀態
        walletData = {
          accountId: currentAccountId || 'main',
          isActivated: false,
          balance: 0,
          currency: 'USD',
          transactions: [],
          activatedAt: null,
          initialAmount: 0,
          creditScore: 100, // 信用值，初始100
        };
      }

      console.log('✅ 錢包數據已載入:', walletData.accountId, walletData.isActivated ? '已啟動' : '未啟動');
    } catch (error) {
      console.error('載入錢包數據失敗:', error);
      // 使用預設資料
      walletData = {
        accountId: currentAccountId || 'main',
        isActivated: false,
        balance: 0,
        currency: 'USD',
        transactions: [],
        activatedAt: null,
        initialAmount: 0,
        creditScore: 100, // 信用值，初始100
      };
    }
  }

  // 保存錢包資料
  async function saveWalletData() {
    try {
      const db = getXDB();
      const walletId = `wallet_${currentAccountId || 'main'}`;

      await db.xAccountProfiles.put({
        handle: walletId,
        name: 'wallet',
        accountId: currentAccountId || 'main',
        data: { ...walletData },
        updatedAt: new Date().toISOString(),
      });

      console.log('✅ 錢包資料已保存');
    } catch (error) {
      console.error('保存錢包資料失敗:', error);
      throw error;
    }
  }

  // 獲取收款記錄數量
  function getIncomeRecordsCount() {
    return walletData.transactions.filter(t => t.amount > 0).length;
  }

  // 獲取付款記錄數量
  function getExpenseRecordsCount() {
    return walletData.transactions.filter(t => t.amount < 0).length;
  }

  // 顯示收款歷史
  window.showIncomeHistory = function () {
    const incomeRecords = walletData.transactions.filter(t => t.amount > 0);
    showTransactionHistory('收款記錄', incomeRecords, '#22c55e');
  };

  // 顯示付款歷史
  window.showExpenseHistory = function () {
    const expenseRecords = walletData.transactions.filter(t => t.amount < 0);
    showTransactionHistory('付款記錄', expenseRecords, '#ef4444');
  };

  // 顯示交易歷史彈窗
  function showTransactionHistory(title, transactions, accentColor) {
    const xSocialScreen = document.getElementById('x-social-screen');
    const isLightMode = xSocialScreen && xSocialScreen.classList.contains('x-theme-light');

    // 創建彈窗遮罩
    const modal = document.createElement('div');
    modal.id = 'transaction-history-modal';
    modal.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: ${isLightMode ? 'rgba(255, 255, 255, 0.85)' : 'rgba(0, 0, 0, 0.85)'};
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 26;
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
    `;

    modal.innerHTML = `
      <div style="
        background-color: ${isLightMode ? 'rgba(255, 255, 255, 0.95)' : 'rgba(0, 0, 0, 0.95)'};
        backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px);
        border-radius: 24px;
        width: 90%;
        max-width: 400px;
        max-height: 80vh;
        position: relative;
        overflow: hidden;
        box-shadow: ${
          isLightMode
            ? '0 20px 60px rgba(0, 0, 0, 0.15), 0 8px 32px rgba(0, 0, 0, 0.1)'
            : '0 20px 60px rgba(0, 0, 0, 0.8), 0 8px 32px rgba(255, 255, 255, 0.05)'
        };
        border: 2px solid ${isLightMode ? 'rgba(0, 0, 0, 0.1)' : 'rgba(255, 255, 255, 0.1)'};
      " onclick="event.stopPropagation()">
        
        <!-- 頭部 -->
        <div style="
          background: linear-gradient(135deg, ${
            isLightMode ? 'rgba(0, 0, 0, 0.03)' : 'rgba(255, 255, 255, 0.05)'
          } 0%, ${isLightMode ? 'rgba(0, 0, 0, 0.01)' : 'rgba(255, 255, 255, 0.02)'} 100%);
          padding: 24px;
          text-align: center;
          border-bottom: 1px dashed ${isLightMode ? 'rgba(0, 0, 0, 0.15)' : 'rgba(255, 255, 255, 0.15)'};
          position: relative;
        ">
          <!-- 票券孔 -->
          <div style="
            position: absolute;
            left: -10px;
            bottom: -10px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: ${isLightMode ? 'rgba(255, 255, 255, 0.85)' : 'rgba(0, 0, 0, 0.85)'};
          "></div>
          <div style="
            position: absolute;
            right: -10px;
            bottom: -10px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: ${isLightMode ? 'rgba(255, 255, 255, 0.85)' : 'rgba(0, 0, 0, 0.85)'};
          "></div>
          
          <!-- 關閉按鈕 -->
          <button onclick="closeTransactionHistoryModal()" style="
            position: absolute;
            top: 16px;
            right: 16px;
            background: transparent;
            border: none;
            color: ${isLightMode ? '#536471' : '#71767b'};
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            transition: all 0.2s;
          " onmouseover="this.style.backgroundColor='${
            isLightMode ? 'rgba(0, 0, 0, 0.05)' : 'rgba(255, 255, 255, 0.05)'
          }';"
             onmouseout="this.style.backgroundColor='transparent'">
            <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: currentColor;">
              <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
            </svg>
          </button>

          <!-- 標題 -->
          <div style="
            color: ${isLightMode ? '#0f1419' : '#ffffff'};
            font-size: 20px;
            font-weight: 700;
            margin-bottom: 8px;
            letter-spacing: 0.5px;
          ">${title}</div>
          
          <div style="
            color: ${isLightMode ? '#666666' : '#999999'};
            font-size: 12px;
            font-weight: 600;
            font-family: monospace;
            letter-spacing: 1px;
            text-transform: uppercase;
          ">${transactions.length} Records</div>
        </div>

        <!-- 交易記錄清單 -->
        <div style="
          max-height: 50vh;
          overflow-y: auto;
          padding: 16px 24px;
        ">
          ${
            transactions.length > 0
              ? renderFullTransactionList(transactions, isLightMode)
              : renderNoRecords(isLightMode, title)
          }
        </div>
      </div>
    `;

    document.body.appendChild(modal);
    document.body.style.overflow = 'hidden';

    // 點擊背景關閉彈窗
    modal.addEventListener('click', e => {
      if (e.target === modal) {
        closeTransactionHistoryModal();
      }
    });

    // 添加入場動畫
    const historyCard = modal.querySelector('div');
    historyCard.style.transform = 'scale(0.8) translateY(20px)';
    historyCard.style.opacity = '0';

    requestAnimationFrame(() => {
      historyCard.style.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
      historyCard.style.transform = 'scale(1) translateY(0)';
      historyCard.style.opacity = '1';
    });
  }

  // 渲染完整交易記錄清單
  function renderFullTransactionList(transactions, isLightMode = false) {
    return transactions
      .map(
        transaction => `
      <div style="
        margin-bottom: 12px;
        background: linear-gradient(135deg, ${isLightMode ? 'rgba(0, 0, 0, 0.02)' : 'rgba(255, 255, 255, 0.03)'} 0%, ${
          isLightMode ? 'rgba(0, 0, 0, 0.01)' : 'rgba(255, 255, 255, 0.01)'
        } 100%);
        border: 1px solid ${isLightMode ? 'rgba(0, 0, 0, 0.08)' : 'rgba(255, 255, 255, 0.08)'};
        border-radius: 10px;
        padding: 14px;
        position: relative;
        overflow: hidden;
      ">
        <!-- 小票條紋浮水印 -->
        <div style="
          position: absolute;
          bottom: 0;
          left: 0;
          right: 0;
          height: 4px;
          background: repeating-linear-gradient(
            90deg,
            ${isLightMode ? 'rgba(0, 0, 0, 0.05)' : 'rgba(255, 255, 255, 0.05)'} 0px,
            ${isLightMode ? 'rgba(0, 0, 0, 0.05)' : 'rgba(255, 255, 255, 0.05)'} 4px,
            transparent 4px,
            transparent 8px
          );
        "></div>
        
        <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;">
          <div style="flex: 1; min-width: 0;">
            <div style="
              color: ${isLightMode ? '#0f1419' : '#ffffff'};
              font-size: 14px;
              font-weight: 600;
              margin-bottom: 6px;
              word-wrap: break-word;
            ">${transaction.description}</div>
            <div style="
              color: ${isLightMode ? '#6b7280' : '#9ca3af'};
              font-size: 11px;
              margin-bottom: 4px;
              font-family: monospace;
              letter-spacing: 0.3px;
            ">${new Date(transaction.timestamp).toLocaleDateString('zh-CN')} ${new Date(
          transaction.timestamp,
        ).toLocaleTimeString('zh-CN', { hour12: false })}</div>
          </div>
          <div style="
            color: ${
              transaction.amount > 0 ? (isLightMode ? '#0f1419' : '#ffffff') : isLightMode ? '#666666' : '#999999'
            };
            font-size: 16px;
            font-weight: 700;
            margin-left: 12px;
            flex-shrink: 0;
            font-family: monospace;
          ">${transaction.amount > 0 ? '+' : ''}$${Math.abs(transaction.amount).toFixed(2)}</div>
        </div>
        
        <!-- 類型標籤 -->
        <div style="
          display: inline-block;
          padding: 3px 8px;
          background: ${isLightMode ? 'rgba(0, 0, 0, 0.05)' : 'rgba(255, 255, 255, 0.08)'};
          border: 1px solid ${isLightMode ? 'rgba(0, 0, 0, 0.1)' : 'rgba(255, 255, 255, 0.12)'};
          border-radius: 6px;
          font-size: 10px;
          color: ${isLightMode ? '#666666' : '#999999'};
          font-weight: 600;
          letter-spacing: 0.5px;
        ">${getTransactionTypeText(transaction.type)}</div>
      </div>
    `,
      )
      .join('');
  }

  // 渲染無記錄狀態
  function renderNoRecords(isLightMode = false, title) {
    return `
      <div style="
        text-align: center;
        padding: 40px 20px;
        color: ${isLightMode ? '#6b7280' : '#9ca3af'};
        font-size: 15px;
      ">
        <svg viewBox="0 0 24 24" style="width: 48px; height: 48px; fill: currentColor; opacity: 0.3; margin: 0 auto 12px;">
          <g><path d="M21 18v1c0 1.1-.9 2-2 2H5c-1.11 0-2-.9-2-2V5c0-1.1.89-2 2-2h14c1.1 0 2 .9 2 2v1h-9c-1.11 0-2 .9-2 2v8c0 1.1.89 2 2 2h9zm-9-2h10V8H12v8zm4-2.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"/></g>
        </svg>
        <div style="font-weight: 600; margin-bottom: 8px;">暫無${title}</div>
        <div style="font-size: 13px; opacity: 0.8;">
          ${title.includes('收款') ? '收到的資金會顯示在這裡' : '轉出的資金會顯示在這裡'}
        </div>
      </div>
    `;
  }

  // 獲取交易類型文本
  function getTransactionTypeText(type) {
    const typeMap = {
      deposit: '充值',
      transfer_in: '收款',
      transfer_out: '轉帳',
      refund: '退款',
      init: '初始化',
      tip: '打賞',
      penalty: '違約費',
    };
    return typeMap[type] || type;
  }

  // 關閉交易歷史彈窗
  window.closeTransactionHistoryModal = function () {
    const modal = document.getElementById('transaction-history-modal');
    if (modal) {
      const historyCard = modal.querySelector('div');
      historyCard.style.transform = 'scale(0.9) translateY(20px)';
      historyCard.style.opacity = '0';

      setTimeout(() => {
        modal.remove();
        document.body.style.overflow = 'auto';
      }, 200);
    }
  };

  // 添加資金 (占位元函數，保持相容性)
  function addFunds() {
    showIncomeHistory();
  }

  // 發送金錢 (占位元函數，保持相容性)
  function sendMoney() {
    showExpenseHistory();
  }

  // 分享錢包 (占位元函數)
  function shareWallet() {
    showXToast('分享功能開發中...', 'info');
  }

  // 匯出錢包 (占位元函數)
  function exportWallet() {
    showXToast('匯出功能開發中...', 'info');
  }

  // 複製錢包資訊 (占位元函數)
  function copyWalletInfo() {
    const userName = window.userProfileData?.name || userProfileData.name || '用戶';
    const info = `${userName}的數字錢包\n餘額: $${walletData.balance.toFixed(2)}\n狀態: ${
      walletData.isActivated ? '已啟動' : '未啟動'
    }`;

    if (navigator.clipboard) {
      navigator.clipboard
        .writeText(info)
        .then(() => {
          showXToast('錢包資訊已複製', 'success');
        })
        .catch(() => {
          showXToast('複製失敗', 'error');
        });
    } else {
      showXToast('複製功能不支援', 'error');
    }
  }

  // 編輯個人資料彈窗相關功能

  // 打開編輯個人資料彈窗
  function openEditProfileModal() {
    const modal = document.getElementById('edit-profile-modal');
    modal.style.display = 'flex';

    // 禁止背景滾動
    document.body.style.overflow = 'hidden';

    // 載入當前資料到編輯表單
    loadDataToEditForm();
  }

  // 關閉編輯個人資料彈窗
  function closeEditProfileModal(event) {
    // 如果有事件參數，檢查是否點擊的是背景區域
    if (event && event.target !== event.currentTarget) {
      return;
    }

    const modal = document.getElementById('edit-profile-modal');
    modal.style.display = 'none';

    // 恢復背景滾動
    document.body.style.overflow = 'auto';
  }

  // 載入當前使用者資料到編輯表單
  function loadDataToEditForm() {
    // 使用window.userProfileData確保讀取最新資料
    const profile = window.userProfileData;

    // 載入基本資訊
    document.getElementById('edit-user-name').value = profile.name;
    document.getElementById('edit-user-handle').value = profile.handle.replace('@', '');
    document.getElementById('edit-user-bio').value = profile.bio;
    document.getElementById('edit-custom-tag1').value = profile.customTag1;
    document.getElementById('edit-custom-tag2').value = profile.customTag2;
    document.getElementById('edit-following-count').value = profile.following;
    document.getElementById('edit-followers-count').value = profile.followers;

    // 載入標籤圖示和顏色
    document.getElementById('edit-tag1-icon').value = profile.customTag1Icon || '✨';
    document.getElementById('edit-tag2-icon').value = profile.customTag2Icon || '📅';
    document.getElementById('edit-tag1-color').value = profile.customTag1Color || '#71767b';
    document.getElementById('edit-tag2-color').value = profile.customTag2Color || '#71767b';
    document.getElementById('edit-tag1-color-text').value = profile.customTag1Color || '#71767b';
    document.getElementById('edit-tag2-color-text').value = profile.customTag2Color || '#71767b';

    // 載入圖片
    document.getElementById('edit-cover-image').src = profile.coverImage;
    document.getElementById('edit-main-avatar').src = profile.avatar;

    // 載入公眾身份和真名設置
    document.getElementById('edit-public-identity').value = profile.publicIdentity || '';
    document.getElementById('edit-show-real-name').checked = profile.showRealName || false;
    document.getElementById('edit-real-name').value = profile.realName || '';

    // 根據核取方塊狀態顯示/隱藏真名輸入框
    toggleRealNameInput();

    // 更新字元計數
    updateCharacterCounts();

    // 載入認證類型設置
    loadVerificationTypeData();

    // 載入角色身份識別設置
    loadIdentityCharactersList();

    console.log('✅ 已載入使用者資料到編輯表單');
  }

  // 載入認證類型資料到編輯表單
  function loadVerificationTypeData() {
    // 使用window.userProfileData確保讀取最新資料
    const profile = window.userProfileData;

    // 設置認證類型選擇
    const verificationTypeSelect = document.getElementById('edit-verification-type');
    if (verificationTypeSelect) {
      verificationTypeSelect.value = profile.verificationType || 'none';
    }

    // 設置情侶綁定角色
    const coupleCharacterSelect = document.getElementById('edit-couple-character');
    if (coupleCharacterSelect) {
      coupleCharacterSelect.value = profile.coupleCharacterId || '';
    }

    // 載入可選擇的角色到情侶綁定下拉清單
    loadCoupleCharacterOptions();

    // 更新UI顯示
    updateVerificationTypeUI();
  }

  // 更新認證類型UI顯示
  function updateVerificationTypeUI() {
    const verificationTypeSelect = document.getElementById('edit-verification-type');
    const coupleBindingSection = document.getElementById('couple-binding-section');

    if (!verificationTypeSelect || !coupleBindingSection) return;

    const selectedType = verificationTypeSelect.value;

    // 根據選擇的認證類型顯示/隱藏情侶綁定選項
    if (selectedType === 'couple') {
      coupleBindingSection.style.display = 'block';
    } else {
      coupleBindingSection.style.display = 'none';
    }
  }

  // 載入可選擇的角色到情侶綁定下拉清單
  async function loadCoupleCharacterOptions() {
    try {
      const db = getDB(); // chats表在主要資料庫中
      const xDb = getXDB(); // X資料在X專用資料庫中

      // 獲取所有聊天角色
      const allChats = await db.chats.toArray();
      const characters = allChats.filter(chat => !chat.isGroup);

      const coupleCharacterSelect = document.getElementById('edit-couple-character');
      if (!coupleCharacterSelect) return;

      // 清空現有選項（保留預設選項）
      coupleCharacterSelect.innerHTML =
        '<option value="" style="background-color: #000; color: #fff;">未選擇角色</option>';

      // 獲取所有角色的X資料（從X專用資料庫）
      const characterProfiles = await xDb.xCharacterProfiles.toArray();
      const profileMap = new Map();
      characterProfiles.forEach(profile => {
        profileMap.set(profile.characterId, profile);
      });

      // 添加角色選項
      characters.forEach(character => {
        const option = document.createElement('option');
        option.value = character.id;

        // 優先使用X平臺名稱，如果沒有設置則使用角色名
        const xProfile = profileMap.get(character.id);
        const displayName = xProfile?.xName || character.name;

        option.textContent = displayName;
        option.style.backgroundColor = '#000';
        option.style.color = '#fff';
        coupleCharacterSelect.appendChild(option);
      });

      // 設置當前選中的角色
      if (userProfileData.coupleCharacterId) {
        coupleCharacterSelect.value = userProfileData.coupleCharacterId;
      }
    } catch (error) {
      console.error('載入情侶角色選項失敗:', error);
    }
  }

  // 更新字元計數顯示
  function updateCharacterCounts() {
    const nameInput = document.getElementById('edit-user-name');
    const handleInput = document.getElementById('edit-user-handle');
    const bioInput = document.getElementById('edit-user-bio');
    const tag1Input = document.getElementById('edit-custom-tag1');
    const tag2Input = document.getElementById('edit-custom-tag2');

    // 更新名稱計數
    if (nameInput) {
      const nameCount = nameInput.value.length;
      nameInput.parentNode.querySelector('div').textContent = `${nameCount} / 50`;
    }

    // 更新用戶名計數
    if (handleInput) {
      const handleCount = handleInput.value.length;
      handleInput.parentNode.querySelector('div').textContent = `${handleCount} / 15`;
    }

    // 更新簡介計數
    if (bioInput) {
      const bioCount = bioInput.value.length;
      bioInput.parentNode.querySelector('div').textContent = `${bioCount} / 160`;
    }

    // 更新標籤1計數
    if (tag1Input) {
      const tag1Count = tag1Input.value.length;
      const tag1Container = tag1Input.closest('.form-group');
      const countDiv = tag1Container.querySelector('div:last-child');
      countDiv.textContent = `${tag1Count} / 30`;
    }

    // 更新標籤2計數
    if (tag2Input) {
      const tag2Count = tag2Input.value.length;
      const tag2Container = tag2Input.closest('.form-group');
      const countDiv = tag2Container.querySelector('div:last-child');
      countDiv.textContent = `${tag2Count} / 30`;
    }

    // 公眾身份已移除字元限制，無需計數

    // 更新真實姓名計數
    const realNameInput = document.getElementById('edit-real-name');
    if (realNameInput) {
      const realNameCount = realNameInput.value.length;
      realNameInput.parentNode.querySelector('div').textContent = `${realNameCount} / 50`;
    }
  }

  // 切換真名輸入框顯示
  function toggleRealNameInput() {
    const checkbox = document.getElementById('edit-show-real-name');
    const container = document.getElementById('real-name-input-container');

    // 添加 null 檢查，防止元素不存在時報錯
    if (!checkbox || !container) {
      console.warn('使用者真名相關元素未找到');
      return;
    }

    if (checkbox.checked) {
      container.style.display = 'block';
    } else {
      container.style.display = 'none';
      // 清空真名輸入框
      const realNameInput = document.getElementById('edit-real-name');
      if (realNameInput) {
        realNameInput.value = '';
        updateCharacterCounts();
      }
    }
  }

  // 切換角色真名輸入框顯示
  function toggleCharacterRealNameInput() {
    const checkbox = document.getElementById('character-show-real-name');
    const container = document.getElementById('character-real-name-input-container');

    // 添加 null 檢查，防止元素不存在時報錯
    if (!checkbox || !container) {
      console.warn('角色真名相關元素未找到');
      return;
    }

    if (checkbox.checked) {
      container.style.display = 'block';
    } else {
      container.style.display = 'none';
      // 清空真名輸入框
      const realNameInput = document.getElementById('character-real-name');
      if (realNameInput) {
        realNameInput.value = '';
        updateCharacterXProfileCounts();
      }
    }
  }

  // 切換自動發消息設置顯示
  window.toggleAutoMessageSettings = function () {
    const checkbox = document.getElementById('character-auto-message-enabled');
    const settingsContainer = document.getElementById('auto-message-time-settings');

    if (!checkbox || !settingsContainer) {
      return;
    }

    if (checkbox.checked) {
      settingsContainer.style.display = 'block';
    } else {
      settingsContainer.style.display = 'none';
    }
  };

  // 標籤1顏色同步功能
  function updateTag1ColorFromText() {
    const colorText = document.getElementById('edit-tag1-color-text');
    const colorPicker = document.getElementById('edit-tag1-color');

    if (colorText && colorPicker) {
      const colorValue = colorText.value.trim();
      if (colorValue.match(/^#[0-9A-Fa-f]{6}$/)) {
        colorPicker.value = colorValue;
      }
    }
  }

  function updateTag1ColorFromPicker() {
    const colorText = document.getElementById('edit-tag1-color-text');
    const colorPicker = document.getElementById('edit-tag1-color');

    if (colorText && colorPicker) {
      colorText.value = colorPicker.value;
    }
  }

  // 標籤2顏色同步功能
  function updateTag2ColorFromText() {
    const colorText = document.getElementById('edit-tag2-color-text');
    const colorPicker = document.getElementById('edit-tag2-color');

    if (colorText && colorPicker) {
      const colorValue = colorText.value.trim();
      if (colorValue.match(/^#[0-9A-Fa-f]{6}$/)) {
        colorPicker.value = colorValue;
      }
    }
  }

  function updateTag2ColorFromPicker() {
    const colorText = document.getElementById('edit-tag2-color-text');
    const colorPicker = document.getElementById('edit-tag2-color');

    if (colorText && colorPicker) {
      colorText.value = colorPicker.value;
    }
  }

  // 簡化的關注數處理 - 直接使用字串
  function getFollowCountValue(input) {
    if (!input) return '';
    return input.toString().trim();
  }

  // 編輯封面圖
  // 編輯封面圖 - 使用連結上傳
  function editCoverImage() {
    const currentCover = document.getElementById('edit-cover-image').src;
    const coverUrl = prompt('請輸入封面圖片連結：', currentCover);

    if (coverUrl === null) return; // 用戶點擊取消

    if (!coverUrl.trim()) {
      showXToast('請輸入有效的圖片連結', 'error');
      return;
    }

    // 驗證是否為有效的URL
    try {
      new URL(coverUrl);
    } catch (e) {
      showXToast('請輸入有效的圖片連結', 'error');
      return;
    }

    // 測試圖片是否可以載入
    const testImg = new Image();
    testImg.onload = function () {
      document.getElementById('edit-cover-image').src = coverUrl;
      showXToast('封面圖已更新', 'success');
    };
    testImg.onerror = function () {
      showXToast('無法載入該圖片，請檢查連結是否正確', 'error');
    };
    testImg.src = coverUrl;
  }

  // 移除封面圖
  function removeCoverImage() {
    const defaultCover = 'https://i.postimg.cc/qRzMB6nQ/default-cover.jpg';
    document.getElementById('edit-cover-image').src = defaultCover;
    showXToast('已移除封面圖', 'success');
  }

  // 編輯頭像 - 使用連結上傳
  function editAvatarImage() {
    const currentAvatar = document.getElementById('edit-main-avatar').src;
    const avatarUrl = prompt('請輸入頭像圖片連結：', currentAvatar);

    if (avatarUrl === null) return; // 用戶點擊取消

    if (!avatarUrl.trim()) {
      showXToast('請輸入有效的圖片連結', 'error');
      return;
    }

    // 驗證是否為有效的URL
    try {
      new URL(avatarUrl);
    } catch (e) {
      showXToast('請輸入有效的圖片連結', 'error');
      return;
    }

    // 測試圖片是否可以載入
    const testImg = new Image();
    testImg.onload = function () {
      document.getElementById('edit-main-avatar').src = avatarUrl;
      showXToast('頭像已更新', 'success');
    };
    testImg.onerror = function () {
      showXToast('無法載入該圖片，請檢查連結是否正確', 'error');
    };
    testImg.src = avatarUrl;
  }

  // 角色身份識別管理函數

  // 載入已綁定X資料的角色清單
  async function loadIdentityCharactersList() {
    console.log(`🔄 [載入角色身份識別列表] 開始載入`);

    try {
      const db = getDB(); // 修正：chats表在全域資料庫中
      const xDb = getXDB(); // X專用資料庫用於其他資料

      // 獲取X設置中的綁定角色（使用當前帳號的設置）
      const settingsId = `xSettings_${currentAccountId || 'main'}`;
      const xSettings = await xDb.xSettings.get(settingsId);
      const boundCharacters = xSettings?.boundCharacters || [];

      console.log(`🔄 [載入角色身份識別列表] 綁定角色數: ${boundCharacters.length}`);

      if (boundCharacters.length === 0) {
        console.log(`⚠️ [載入角色身份識別列表] 無綁定角色`);
        renderIdentityCharactersList([]);
        return;
      }

      // 獲取所有聊天角色
      const allChats = await db.chats.toArray();
      const characters = allChats.filter(chat => !chat.isGroup && boundCharacters.includes(chat.id));

      console.log(`🔄 [載入角色身份識別列表] 過濾後角色數: ${characters.length}`);

      // 篩選出已綁定X資料的角色
      const charactersWithXProfile = [];
      for (const character of characters) {
        const xProfile = await xDb.xCharacterProfiles.get(character.id);
        if (xProfile) {
          const personaLength = (xProfile.userPersona || '').length;
          console.log(`🔄 [載入角色身份識別列表] 角色 ${character.name} (${character.id})`);
          console.log(`   - X名稱: ${xProfile.xName}`);
          console.log(`   - 用戶人設長度: ${personaLength} 字元`);
          console.log(
            `   - 人設預覽: "${(xProfile.userPersona || '').substring(0, 50)}${personaLength > 50 ? '...' : ''}"`,
          );

          charactersWithXProfile.push({
            id: character.id,
            name: character.name,
            originalName: character.originalName,
            xProfile: xProfile,
          });
        }
      }

      console.log(`✅ [載入角色身份識別列表] 最終角色數: ${charactersWithXProfile.length}`);
      renderIdentityCharactersList(charactersWithXProfile);
    } catch (error) {
      console.error('❌ [載入角色身份識別列表] 載入失敗:', error);
      console.error('❌ [載入角色身份識別清單] 錯誤詳情:', error.message, error.stack);
      renderIdentityCharactersList([]);
    }
  }

  // 渲染角色身份識別列表
  function renderIdentityCharactersList(characters) {
    const container = document.getElementById('identity-characters-list');

    if (characters.length === 0) {
      container.innerHTML = `
                <div style="text-align: center; color: #71767b; font-size: 13px; padding: 20px;">
                  暫無已綁定X資料的角色<br>
                  <span style="font-size: 12px; margin-top: 4px; display: block;">
                    請先在X設置中綁定角色並設置X資料
                  </span>
                </div>
              `;
      return;
    }

    // 確保knownIdentityCharacters陣列存在
    if (!userProfileData.knownIdentityCharacters) {
      userProfileData.knownIdentityCharacters = [];
    }

    container.innerHTML = characters
      .map(character => {
        const isSelected = userProfileData.knownIdentityCharacters.includes(character.id);
        return `
                <div style="display: flex; align-items: center; gap: 12px; padding: 8px; border-radius: 6px; margin-bottom: 6px; cursor: pointer; transition: background-color 0.2s;" 
                     onmouseover="this.style.backgroundColor='rgba(255,255,255,0.05)'" 
                     onmouseout="this.style.backgroundColor='transparent'"
                     onclick="toggleIdentityCharacter('${character.id}')">
                  
                  <!-- 核取方塊 -->
                  <div style="
                    width: 18px;
                    height: 18px;
                    border: 2px solid ${isSelected ? 'var(--x-accent)' : '#71767b'};
                    border-radius: 3px;
                    background-color: ${isSelected ? 'var(--x-accent)' : 'transparent'};
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    transition: all 0.2s;
                    flex-shrink: 0;
                  ">
                    ${
                      isSelected
                        ? '<svg viewBox="0 0 24 24" style="width: 12px; height: 12px; fill: #fff;"><path d="M9 16.17L5.53 12.7l-1.06 1.06L9 18.3l9.54-9.54-1.06-1.06L9 16.17z"/></svg>'
                        : ''
                    }
                  </div>

                                    <!-- 角色頭像 -->
                  <img src="${character.xProfile.xAvatar}" alt="${character.xProfile.xName}" 
                       style="width: 32px; height: 32px; border-radius: 50%; flex-shrink: 0;">

                  <!-- 角色信息 -->
                  <div style="flex: 1; min-width: 0;">
                    <div style="color: #fff; font-weight: 600; font-size: 14px;">
                      ${character.xProfile.xName}
                      ${
                        character.xProfile.xVerified
                          ? '<svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: var(--x-accent); margin-left: 4px; display: inline;"><path d="M22.5 12.5c0-1.58-.875-2.95-2.148-3.6.154-.435.238-.905.238-1.4 0-2.21-1.71-3.998-3.818-3.998-.47 0-.92.084-1.336.25C14.818 2.415 13.51 1.5 12 1.5s-2.816.917-3.437 2.25c-.415-.165-.866-.25-1.336-.25-2.11 0-3.818 1.79-3.818 4 0 .494.083.964.237 1.4-1.272.65-2.147 2.018-2.147 3.6 0 1.495.782 2.798 1.942 3.486-.02.17-.032.34-.032.514 0 2.21 1.708 4 3.818 4 .47 0 .92-.086 1.335-.25.62 1.334 1.926 2.25 3.437 2.25 1.512 0 2.818-.916 3.437-2.25.415.163.865.248 1.336.248 2.11 0 3.818-1.79 3.818-4 0-.174-.012-.344-.033-.513 1.158-.687 1.943-1.99 1.943-3.484zm-6.616-3.334l-4.334 6.5c-.145.217-.382.334-.625.334-.143 0-.288-.04-.416-.126l-2.5-1.668c-.326-.217-.413-.656-.196-.982.217-.326.656-.414.982-.196l1.875 1.25 3.75-5.625c.22-.33.66-.418.99-.196.33.22.418.66.196.99z"/></svg>'
                          : ''
                      }
                    </div>
                    <div style="color: #71767b; font-size: 12px;">
                      ${character.xProfile.xHandle} • ${character.name}
                                            ${
                                              character.xProfile &&
                                              character.xProfile.userPersona &&
                                              character.xProfile.userPersona.trim()
                                                ? '<span style="color: #10b981; font-size: 11px; margin-left: 8px;">✓ 已設置人設</span>'
                                                : '<span style="color: #f59e0b; font-size: 11px; margin-left: 8px;">⚠ 未設置人設</span>'
                                            }
                    </div>
                  </div>

                  <!-- 設置使用者人設按鈕 -->
                  <div class="persona-setting-btn" onclick="event.stopPropagation(); window.openUserPersonaEditor('${
                    character.id
                  }')" 
                       style="
                         width: 32px;
                         height: 32px;
                         border-radius: 50%;
                         background-color: ${
                           character.xProfile && character.xProfile.userPersona && character.xProfile.userPersona.trim()
                             ? '#10b981'
                             : '#1d9bf0'
                         };
                         color: #fff;
                         display: flex;
                         align-items: center;
                         justify-content: center;
                         cursor: pointer;
                         flex-shrink: 0;
                         transition: all 0.2s;
                         margin-left: 8px;
                       "
                       onmouseover="this.style.backgroundColor='${
                         character.xProfile && character.xProfile.userPersona && character.xProfile.userPersona.trim()
                           ? '#059669'
                           : '#1a8cd8'
                       }'; this.style.transform='scale(1.05)'"
                       onmouseout="this.style.backgroundColor='${
                         character.xProfile && character.xProfile.userPersona && character.xProfile.userPersona.trim()
                           ? '#10b981'
                           : '#1d9bf0'
                       }'; this.style.transform='scale(1)'"
                       title="${
                         character.xProfile && character.xProfile.userPersona && character.xProfile.userPersona.trim()
                           ? '編輯用戶人設'
                           : '設置用戶人設'
                       }">
                    ${
                      character.xProfile && character.xProfile.userPersona && character.xProfile.userPersona.trim()
                        ? '<svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: currentColor;"><g><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"></path></g></svg>'
                        : '<svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: currentColor;"><g><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"></path></g></svg>'
                    }
                  </div>
                </div>
              `;
      })
      .join('');
  }

  // 切換角色身份識別狀態
  function toggleIdentityCharacter(characterId) {
    // 確保knownIdentityCharacters陣列存在
    if (!userProfileData.knownIdentityCharacters) {
      userProfileData.knownIdentityCharacters = [];
    }

    const index = userProfileData.knownIdentityCharacters.indexOf(characterId);
    if (index === -1) {
      // 添加到已知身份列表
      userProfileData.knownIdentityCharacters.push(characterId);
    } else {
      // 從已知身份列表中移除
      userProfileData.knownIdentityCharacters.splice(index, 1);
    }

    // 重新渲染列表以更新UI
    loadIdentityCharactersList();
  }

  // 使用者人設編輯功能 - 使用+按鈕觸發

  // 打開使用者人設編輯器 - 全域函數
  window.openUserPersonaEditor = async function (characterId) {
    console.log(`📖 [打開用戶人設編輯器] 角色ID: ${characterId}`);

    try {
      const mainDB = getDB(); // 用於訪問 chats 表
      const xDB = getXDB(); // 用於訪問 xCharacterProfiles 表

      const chat = await mainDB.chats.get(characterId);
      const xProfile = await xDB.xCharacterProfiles.get(characterId);

      console.log(`📖 [打開用戶人設編輯器] 角色資料:`, chat ? '存在' : '不存在');
      console.log(`📖 [打開用戶人設編輯器] X資料資料:`, xProfile ? '存在' : '不存在');

      if (!chat || !xProfile) {
        console.error(`❌ [打開用戶人設編輯器] 無法獲取角色資訊`);
        showXToast('無法獲取角色資訊', 'error');
        return;
      }

      // 獲取現有的用戶人設（如果有的話）
      const existingPersona = xProfile.userPersona || '';
      console.log(`📖 [打開用戶人設編輯器] 現有人設長度: ${existingPersona.length} 字元`);
      console.log(
        `📖 [打開用戶人設編輯器] 人設內容預覽: "${existingPersona.substring(0, 100)}${
          existingPersona.length > 100 ? '...' : ''
        }"`,
      );

      // 顯示編輯彈窗
      window.showUserPersonaModal(characterId, chat.name, xProfile.xName, existingPersona);
    } catch (error) {
      console.error('❌ [打開用戶人設編輯器] 失敗:', error);
      console.error('❌ [打開用戶人設編輯器] 錯誤詳情:', error.message, error.stack);
      showXToast('打開編輯器失敗: ' + error.message, 'error');
    }
  };

  // 顯示使用者人設編輯彈窗 - 全域函數
  window.showUserPersonaModal = function (characterId, characterName, xName, existingPersona) {
    console.log(`🖼️ [顯示使用者人設彈窗] 角色: ${xName} (${characterName})`);
    console.log(`🖼️ [顯示使用者人設彈窗] 角色ID: ${characterId}`);
    console.log(`🖼️ [顯示使用者人設彈窗] 傳入的人設長度: ${existingPersona.length} 字元`);

    const modal = document.createElement('div');
    modal.id = 'user-persona-modal';
    modal.style.cssText = `
              position: fixed;
              top: 0;
              left: 0;
              width: 100%;
              height: 100%;
              background-color: rgba(0, 0, 0, 0.8);
              display: flex;
              align-items: center;
              justify-content: center;
              z-index: 10000;
              backdrop-filter: blur(4px);
            `;

    modal.innerHTML = `
              <div style="
                background-color: #1a1a1a;
                border-radius: 16px;
                width: 90%;
                max-width: 500px;
                max-height: 80vh;
                overflow-y: auto;
                position: relative;
                border: 1px solid #333;
              ">
                <!-- 彈窗頭部 -->
                <div style="
                  padding: 20px;
                  border-bottom: 1px solid #333;
                  display: flex;
                  align-items: center;
                  justify-content: space-between;
                ">
                  <div>
                    <h3 style="margin: 0; color: #fff; font-size: 18px; font-weight: 700;">
                      編輯用戶人設
                    </h3>
                    <p style="margin: 4px 0 0; color: #71767b; font-size: 14px;">
                      為 ${xName} (${characterName}) 設置你的身份資訊
                    </p>
                  </div>
                  <button onclick="window.closeUserPersonaModal()" style="
                    background: transparent;
                    border: none;
                    color: #71767b;
                    cursor: pointer;
                    padding: 8px;
                    border-radius: 50%;
                    transition: background-color 0.2s;
                  " onmouseover="this.style.backgroundColor='rgba(255,255,255,0.1)'" 
                     onmouseout="this.style.backgroundColor='transparent'">
                    <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: currentColor;">
                      <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
                    </svg>
                  </button>
                </div>

                <!-- 彈窗內容 -->
                <div style="padding: 20px;">
                  <!-- 說明文字 -->
                  <div style="
                    background-color: #003d82;
                    border: 1px solid var(--x-accent);
                    border-radius: 8px;
                    padding: 12px;
                    margin-bottom: 20px;
                  ">
                    <div style="color: var(--x-accent); font-size: 14px; font-weight: 600; margin-bottom: 4px;">
                      💡 如何設置用戶人設
                    </div>
                    <div style="color: #e1e8ed; font-size: 13px; line-height: 1.4;">
                      • 描述你希望這個角色瞭解的關於你的資訊<br>
                      • 例如：性格特點、興趣愛好、職業背景等<br>
                      • 這些資訊將説明角色更自然地與你互動
                    </div>
                  </div>

                  <!-- 用戶人設輸入 -->
                  <div style="margin-bottom: 20px;">
                    <label style="
                      display: block;
                      color: #fff;
                      font-size: 15px;
                      font-weight: 600;
                      margin-bottom: 8px;
                    ">用戶人設</label>
                    <textarea id="user-persona-input" placeholder="請描述你希望${xName}瞭解的關於你的資訊..." style="
                      width: 100%;
                      min-height: 120px;
                      max-height: 300px;
                      background-color: #0a0a0a;
                      border: 1px solid #333;
                      border-radius: 8px;
                      color: #fff;
                      font-size: 14px;
                      padding: 12px;
                      resize: vertical;
                      outline: none;
                      box-sizing: border-box;
                      font-family: inherit;
                      line-height: 1.4;
                    " oninput="window.updatePersonaCharCount()">${existingPersona}</textarea>
                    <div style="
                      display: flex;
                      justify-content: space-between;
                      align-items: center;
                      margin-top: 8px;
                    ">
                      <div style="color: #71767b; font-size: 12px;">
                        建議詳細描述，幫助角色更好地理解你
                      </div>
                      <div id="persona-char-count" style="color: #71767b; font-size: 12px;">
                        ${existingPersona.length} 字元
                      </div>
                    </div>
                  </div>

                  <!-- 操作按鈕 -->
                  <div style="display: flex; gap: 12px; justify-content: flex-end;">
                    <button onclick="window.closeUserPersonaModal()" style="
                      background: transparent;
                      color: #71767b;
                      border: 1px solid #333;
                      border-radius: 20px;
                      padding: 8px 20px;
                      font-size: 15px;
                      font-weight: 700;
                      cursor: pointer;
                      transition: all 0.2s;
                    " onmouseover="this.style.backgroundColor='rgba(255,255,255,0.05)'" 
                       onmouseout="this.style.backgroundColor='transparent'">
                      取消
                    </button>
                    <button onclick="window.saveUserPersona('${characterId}')" style="
                      background-color: var(--x-accent);
                      color: #fff;
                      border: none;
                      border-radius: 20px;
                      padding: 8px 20px;
                      font-size: 15px;
                      font-weight: 700;
                      cursor: pointer;
                      transition: all 0.2s;
                    " onmouseover="this.style.backgroundColor='#1a8cd8'" 
                       onmouseout="this.style.backgroundColor='var(--x-accent)'">
                      保存
                    </button>
                  </div>
                </div>
              </div>
            `;

    document.body.appendChild(modal);

    // 點擊背景關閉彈窗
    modal.addEventListener('click', e => {
      if (e.target === modal) {
        window.closeUserPersonaModal();
      }
    });
  };

  // 更新字元計數 - 全域函數
  window.updatePersonaCharCount = function () {
    const textarea = document.getElementById('user-persona-input');
    const countEl = document.getElementById('persona-char-count');
    if (textarea && countEl) {
      countEl.textContent = `${textarea.value.length} 字元`;
    }
  };

  // 關閉使用者人設編輯彈窗 - 全域函數
  window.closeUserPersonaModal = function () {
    console.log(`🚪 [關閉用戶人設彈窗] 關閉編輯彈窗`);

    const modal = document.getElementById('user-persona-modal');
    if (modal) {
      // 記錄關閉時的資料狀態
      const textarea = document.getElementById('user-persona-input');
      if (textarea) {
        console.log(`🚪 [關閉用戶人設彈窗] 彈窗中當前內容長度: ${textarea.value.length} 字元`);
      }

      modal.remove();
      console.log(`✅ [關閉用戶人設彈窗] 彈窗已移除`);
    }
  };

  // 保存使用者人設 - 全域函數
  window.saveUserPersona = async function (characterId) {
    const textarea = document.getElementById('user-persona-input');
    const persona = textarea.value.trim();

    console.log(`💾 [保存用戶人設] 開始保存角色 ${characterId} 的用戶人設`);
    console.log(`💾 [保存用戶人設] 人設內容長度: ${persona.length} 字元`);

    try {
      const db = getXDB();

      // 獲取現有的角色X資料
      let xProfile = await db.xCharacterProfiles.get(characterId);
      console.log(`💾 [保存用戶人設] 獲取到的角色資料:`, xProfile ? '存在' : '不存在');

      if (xProfile) {
        // 保存前記錄舊值
        const oldPersona = xProfile.userPersona || '';
        console.log(`💾 [保存用戶人設] 舊人設長度: ${oldPersona.length} 字元`);
        console.log(`💾 [保存用戶人設] 新人設長度: ${persona.length} 字元`);

        // 更新用戶人設
        xProfile.userPersona = persona;

        // 確保資料被正確保存
        await db.xCharacterProfiles.put(xProfile);

        // 驗證保存結果 - 重新讀取確認
        const verifyProfile = await db.xCharacterProfiles.get(characterId);
        const savedPersona = verifyProfile?.userPersona || '';
        console.log(`✅ [保存用戶人設] 驗證保存結果 - 實際保存長度: ${savedPersona.length} 字元`);

        if (savedPersona === persona) {
          console.log(`✅ [保存使用者人設] 資料驗證成功，保存一致`);
        } else {
          console.warn(`⚠️ [保存使用者人設] 資料驗證失敗！保存的內容與預期不一致`);
          console.warn(`⚠️ [保存用戶人設] 預期: "${persona.substring(0, 50)}..."`);
          console.warn(`⚠️ [保存用戶人設] 實際: "${savedPersona.substring(0, 50)}..."`);
        }

        showXToast(persona ? '用戶人設已保存' : '用戶人設已清空', 'success');
        window.closeUserPersonaModal();

        // 重新載入角色清單以更新UI顯示
        console.log(`🔄 [保存用戶人設] 重新載入角色身份識別列表`);
        await loadIdentityCharactersList();
      } else {
        console.error(`❌ [保存用戶人設] 無法找到角色資料，角色ID: ${characterId}`);
        showXToast('無法找到角色資料', 'error');
      }
    } catch (error) {
      console.error('❌ [保存用戶人設] 保存失敗:', error);
      console.error('❌ [保存使用者人設] 錯誤詳情:', error.message, error.stack);
      showXToast('保存失敗: ' + error.message, 'error');
    }
  };

  // 保存個人資料更改
  async function saveProfileChanges() {
    // 獲取表單數據
    const newName = document.getElementById('edit-user-name').value.trim();
    const newHandle = document.getElementById('edit-user-handle').value.trim();
    const newBio = document.getElementById('edit-user-bio').value.trim();
    const newTag1 = document.getElementById('edit-custom-tag1').value.trim();
    const newTag2 = document.getElementById('edit-custom-tag2').value.trim();
    const newTag1Icon = document.getElementById('edit-tag1-icon').value.trim() || '✨';
    const newTag2Icon = document.getElementById('edit-tag2-icon').value.trim() || '📅';
    const newTag1Color = document.getElementById('edit-tag1-color').value || '#71767b';
    const newTag2Color = document.getElementById('edit-tag2-color').value || '#71767b';
    const newFollowing = getFollowCountValue(document.getElementById('edit-following-count').value);
    const newFollowers = getFollowCountValue(document.getElementById('edit-followers-count').value);
    const newCover = document.getElementById('edit-cover-image').src;
    const newAvatar = document.getElementById('edit-main-avatar').src;

    // 獲取認證類型資料
    const newVerificationType = document.getElementById('edit-verification-type').value;
    const newCoupleCharacterId = document.getElementById('edit-couple-character').value;

    // 獲取情侶角色的X平臺身份資訊（如果有選擇）
    let newCoupleCharacterName = '';
    if (newCoupleCharacterId) {
      try {
        const db = getXDB();

        const coupleCharacterProfile = await db.xCharacterProfiles.get(newCoupleCharacterId);
        if (coupleCharacterProfile) {
          // 使用X平臺的handle和name組合
          newCoupleCharacterName = `@${coupleCharacterProfile.xHandle}（${coupleCharacterProfile.xName}）`;
        } else {
          // 如果沒有X資料，從選項中獲取，並生成默認格式
          const coupleOption = document.querySelector(`#edit-couple-character option[value="${newCoupleCharacterId}"]`);
          const displayName = coupleOption ? coupleOption.textContent : '';
          if (displayName) {
            const defaultHandle = displayName.toLowerCase().replace(/\s+/g, '_');
            newCoupleCharacterName = `@${defaultHandle}（${displayName}）`;
          }
        }
      } catch (error) {
        console.error('獲取情侶角色X資料失敗:', error);
        // 備用方案：從選項中獲取
        const coupleOption = document.querySelector(`#edit-couple-character option[value="${newCoupleCharacterId}"]`);
        const displayName = coupleOption ? coupleOption.textContent : '';
        if (displayName) {
          const defaultHandle = displayName.toLowerCase().replace(/\s+/g, '_');
          newCoupleCharacterName = `@${defaultHandle}（${displayName}）`;
        }
      }
    }

    // 獲取公眾身份和真名設置
    const newPublicIdentity = document.getElementById('edit-public-identity').value.trim();
    const newShowRealName = document.getElementById('edit-show-real-name').checked;
    const newRealName = document.getElementById('edit-real-name').value.trim();

    // 驗證資料
    if (!newName) {
      showXToast('名稱不能為空', 'error');
      return;
    }

    if (!newHandle) {
      showXToast('用戶名不能為空', 'error');
      return;
    }

    if (newName.length > 50) {
      showXToast('名稱不能超過50個字元', 'error');
      return;
    }

    if (newHandle.length > 15) {
      showXToast('用戶名不能超過15個字元', 'error');
      return;
    }

    if (newBio.length > 160) {
      showXToast('自我介紹不能超過160個字元', 'error');
      return;
    }

    if (newTag1.length > 30) {
      showXToast('自訂標籤1不能超過30個字元', 'error');
      return;
    }

    if (newTag2.length > 30) {
      showXToast('自訂標籤2不能超過30個字元', 'error');
      return;
    }

    if (newFollowing.length > 20) {
      showXToast('關注數量過長', 'error');
      return;
    }

    if (newFollowers.length > 20) {
      showXToast('關注者數量過長', 'error');
      return;
    }

    // 公眾身份已移除字元限制

    if (newShowRealName && newRealName.length > 50) {
      showXToast('真實姓名不能超過50個字元', 'error');
      return;
    }

    if (newShowRealName && !newRealName) {
      showXToast('選擇公開真名時必須填寫真實姓名', 'error');
      return;
    }

    // 更新使用者資料（使用window.userProfileData確保資料持久化）
    window.userProfileData.name = newName;
    window.userProfileData.handle = '@' + newHandle;
    window.userProfileData.bio = newBio;
    window.userProfileData.customTag1 = newTag1;
    window.userProfileData.customTag2 = newTag2;
    window.userProfileData.customTag1Icon = newTag1Icon;
    window.userProfileData.customTag2Icon = newTag2Icon;
    window.userProfileData.customTag1Color = newTag1Color;
    window.userProfileData.customTag2Color = newTag2Color;
    window.userProfileData.following = newFollowing;
    window.userProfileData.followers = newFollowers;
    window.userProfileData.coverImage = newCover;
    window.userProfileData.avatar = newAvatar;

    // 更新認證類型資料
    window.userProfileData.verificationType = newVerificationType;
    window.userProfileData.coupleCharacterId = newCoupleCharacterId;
    window.userProfileData.coupleCharacterName = newCoupleCharacterName;

    // 更新公眾身份和真名設置
    window.userProfileData.publicIdentity = newPublicIdentity;
    window.userProfileData.showRealName = newShowRealName;
    window.userProfileData.realName = newShowRealName ? newRealName : ''; // 只有選擇公開時才保存真名

    // 根據認證類型更新verified欄位
    window.userProfileData.verified = newVerificationType !== 'none';

    // ⚠️ 注意：knownIdentityCharacters已通過toggleIdentityCharacter函數即時更新到window.userProfileData
    // 這裡不需要重新收集，直接保存即可
    // 確保欄位存在
    if (!window.userProfileData.knownIdentityCharacters) {
      window.userProfileData.knownIdentityCharacters = [];
    }

    // 如果是情侶認證且綁定了角色，為該角色也設置情侶認證
    if (newVerificationType === 'couple' && newCoupleCharacterId) {
      setCoupleVerificationForCharacter(newCoupleCharacterId, window.userProfileData.name);
    }

    try {
      // 調試：保存前檢查
      console.log('📝 準備保存使用者資料...');
      console.log('👤 已知身份角色數:', window.userProfileData.knownIdentityCharacters?.length || 0);
      console.log('👤 已知身份角色列表:', window.userProfileData.knownIdentityCharacters || []);

      // 保存到資料庫
      await saveUserProfileToDB();

      // 更新UI顯示
      loadUserProfileToUI();

      // 更新認證徽章顯示
      updateVerificationBadge();

      // 同步頭像到所有位置
      syncUserAvatar(newAvatar);

      // 關閉彈窗
      closeEditProfileModal();

      let successMessage = '個人資料已更新';
      if (window.userProfileData.knownIdentityCharacters && window.userProfileData.knownIdentityCharacters.length > 0) {
        successMessage += `，已設置 ${window.userProfileData.knownIdentityCharacters.length} 個角色知道您的身份`;
      }
      showXToast(successMessage, 'success');

      // 調試：輸出身份識別設置
      if (window.userProfileData.knownIdentityCharacters && window.userProfileData.knownIdentityCharacters.length > 0) {
        console.log('✅ 已保存的用戶身份識別設置:', window.userProfileData.knownIdentityCharacters);
        console.log('✅ 這些角色現在知道您的身份，可以在X平臺上與您自然互動');
      }
    } catch (error) {
      console.error('保存個人資料失敗:', error);
      showXToast('保存失敗: ' + error.message, 'error');
    }
  }

  // 發帖彈窗相關功能

  // 隱私設置狀態：'public' = 所有人可見，'private' = 僅自己可見，'business' = 商業化推貼
  let tweetPrivacySetting = 'public';
  let selectedBusinessTransferId = null; // 選中的商業轉帳任務ID

  // 打開發帖彈窗
  function openComposeTweetModal() {
    const modal = document.getElementById('compose-tweet-modal');
    modal.style.display = 'flex';
    document.body.style.overflow = 'hidden';

    // 重置彈窗內容
    resetComposeModal();

    // 同步用戶頭像
    const avatar = document.querySelector('#compose-tweet-modal img[alt="用戶頭像"]');
    if (avatar) {
      avatar.src = userProfileData.avatar;
    }
  }

  // 關閉發帖彈窗
  function closeComposeTweetModal(event) {
    if (event && event.target !== event.currentTarget) {
      return;
    }

    const modal = document.getElementById('compose-tweet-modal');
    modal.style.display = 'none';
    document.body.style.overflow = 'auto';

    // 清理引用內容
    if (typeof removeQuoteContent === 'function') {
      removeQuoteContent();
    }
  }

  // 重置彈窗內容
  function resetComposeModal() {
    // 清空文本輸入
    document.getElementById('compose-text-input').value = '';
    updateComposeCharCount();
    updateComposeTweetButton();

    // 隱藏所有功能區域
    document.getElementById('compose-image-section').style.display = 'none';
    document.getElementById('compose-location-section').style.display = 'none';
    document.getElementById('compose-link-section').style.display = 'none';

    // 重置功能按鈕狀態
    resetFunctionButtonStates();

    // 清空各功能區域的內容
    clearImageSection();
    clearLocationSection();
    clearLinkSection();

    // 重置隱私設置為預設值
    tweetPrivacySetting = 'public';
    selectedBusinessTransferId = null;
    const iconPath = document.getElementById('privacy-icon-path');
    const textElement = document.getElementById('privacy-text');
    iconPath.setAttribute(
      'd',
      'M12 1.75C6.34 1.75 1.75 6.34 1.75 12S6.34 22.25 12 22.25 22.25 17.66 22.25 12 17.66 1.75 12 1.75zm-.81 14.68l-4.1-3.27 1.25-1.57 2.47 1.98 3.97-5.47 1.62 1.18-5.21 7.15z',
    );
    textElement.textContent = '所有人可以回復';
    textElement.style.color = 'var(--x-accent)';

    // 隱藏商業任務選擇區域
    const businessSection = document.getElementById('business-task-selection');
    if (businessSection) businessSection.style.display = 'none';

    // 清理引用內容
    if (typeof removeQuoteContent === 'function') {
      removeQuoteContent();
    }
  }

  // 處理文本輸入
  function handleComposeInput() {
    updateComposeCharCount();
    updateComposeTweetButton();
    processHashtagsAndMentions();
  }

  // 更新字元計數
  function updateComposeCharCount() {
    const textInput = document.getElementById('compose-text-input');
    const charCount = document.getElementById('compose-char-count');
    const length = textInput.value.length;

    charCount.textContent = `${length} / 280`;

    // 根據字元數更改顏色
    if (length > 260) {
      charCount.style.color = '#f4212e';
    } else if (length > 240) {
      charCount.style.color = '#ffad1f';
    } else {
      charCount.style.color = '#71767b';
    }
  }

  // 更新發帖按鈕狀態
  function updateComposeTweetButton() {
    const textInput = document.getElementById('compose-text-input');
    const tweetBtn = document.getElementById('compose-tweet-btn');
    const hasContent = textInput.value.trim().length > 0;

    if (hasContent) {
      tweetBtn.disabled = false;
      tweetBtn.style.opacity = '1';
      tweetBtn.style.cursor = 'pointer';
    } else {
      tweetBtn.disabled = true;
      tweetBtn.style.opacity = '0.5';
      tweetBtn.style.cursor = 'not-allowed';
    }
  }

  // 處理話題標籤和提及
  function processHashtagsAndMentions() {
    const textInput = document.getElementById('compose-text-input');
    const text = textInput.value;

    // 這裡可以添加即時高亮#和@的邏輯
    // 由於textarea的限制，我們暫時不實現即時高亮
    // 在實際發佈時會處理這些標籤
  }

  // 切換圖片區域
  function toggleImageSection() {
    const section = document.getElementById('compose-image-section');
    const btn = document.getElementById('image-btn');

    if (section.style.display === 'none') {
      section.style.display = 'block';
      btn.style.backgroundColor = 'rgba(29,155,240,0.1)';
    } else {
      section.style.display = 'none';
      btn.style.backgroundColor = 'transparent';
      clearImageSection();
    }
  }

  // 選擇圖片添加方式
  function selectImageMethod(method) {
    const descBtn = document.getElementById('img-desc-btn');
    const uploadBtn = document.getElementById('img-upload-btn');
    const descInput = document.getElementById('image-description-input');
    const uploadArea = document.getElementById('image-upload-area');

    // 重新開機按鈕樣式
    descBtn.style.backgroundColor = '#333';
    descBtn.style.borderColor = '#536471';
    uploadBtn.style.backgroundColor = '#333';
    uploadBtn.style.borderColor = '#536471';

    // 隱藏所有區域
    descInput.style.display = 'none';
    uploadArea.style.display = 'none';

    if (method === 'description') {
      descBtn.style.backgroundColor = 'var(--x-accent)';
      descBtn.style.borderColor = 'var(--x-accent)';
      descInput.style.display = 'block';
    } else if (method === 'upload') {
      uploadBtn.style.backgroundColor = 'var(--x-accent)';
      uploadBtn.style.borderColor = 'var(--x-accent)';
      uploadArea.style.display = 'block';
    }
  }

  // 觸發圖片上傳
  function triggerImageUpload() {
    document.getElementById('image-file-input').click();
  }

  // 存儲上傳的圖片資料（支援多圖）
  let uploadedImagesData = [];

  // 處理圖片上傳（支援多圖）
  function handleImageUpload(event) {
    const files = event.target.files;
    if (!files || files.length === 0) return;

    // 驗證圖片數量（最多4張）
    if (uploadedImagesData.length + files.length > 4) {
      showXToast('最多只能上傳4張圖片', 'error');
      return;
    }

    const previewContainer = document.getElementById('preview-images-container');
    const previewArea = document.getElementById('uploaded-image-preview');

    let loadedCount = 0;
    const totalFiles = files.length;

    for (let i = 0; i < files.length; i++) {
      const file = files[i];

      // 驗證檔案類型
      if (!file.type.startsWith('image/')) {
        showXToast('請選擇圖片檔', 'error');
        continue;
      }

      // 驗證文件大小
      if (file.size > 5 * 1024 * 1024) {
        showXToast('圖片檔不能超過5MB', 'error');
        continue;
      }

      const reader = new FileReader();
      reader.onload = function (e) {
        const imageData = e.target.result;
        uploadedImagesData.push(imageData);

        // 創建預覽元素
        const previewItem = document.createElement('div');
        previewItem.style.cssText = 'position: relative; border-radius: 8px; overflow: hidden;';
        previewItem.innerHTML = `
          <img src="${imageData}" style="width: 100%; height: 150px; object-fit: cover; display: block;" alt="預覽圖片">
          <div onclick="removeUploadedImage(${uploadedImagesData.length - 1})" style="
            position: absolute;
            top: 4px;
            right: 4px;
            background-color: rgba(0,0,0,0.7);
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background-color 0.2s;
          " onmouseover="this.style.backgroundColor='rgba(0,0,0,0.9)'" onmouseout="this.style.backgroundColor='rgba(0,0,0,0.7)'">
            <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: #fff;">
              <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
            </svg>
          </div>
        `;
        previewContainer.appendChild(previewItem);
        previewArea.style.display = 'block';

        loadedCount++;
        if (loadedCount === totalFiles) {
          showXToast(`成功上傳${totalFiles}張圖片`, 'success');
        }
      };
      reader.readAsDataURL(file);
    }
  }

  // 移除單張上傳的圖片
  window.removeUploadedImage = function (index) {
    uploadedImagesData.splice(index, 1);

    // 重新渲染預覽
    const previewContainer = document.getElementById('preview-images-container');
    const previewArea = document.getElementById('uploaded-image-preview');
    previewContainer.innerHTML = '';

    if (uploadedImagesData.length === 0) {
      previewArea.style.display = 'none';
    } else {
      uploadedImagesData.forEach((imageData, idx) => {
        const previewItem = document.createElement('div');
        previewItem.style.cssText = 'position: relative; border-radius: 8px; overflow: hidden;';
        previewItem.innerHTML = `
          <img src="${imageData}" style="width: 100%; height: 150px; object-fit: cover; display: block;" alt="預覽圖片">
          <div onclick="removeUploadedImage(${idx})" style="
            position: absolute;
            top: 4px;
            right: 4px;
            background-color: rgba(0,0,0,0.7);
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background-color 0.2s;
          " onmouseover="this.style.backgroundColor='rgba(0,0,0,0.9)'" onmouseout="this.style.backgroundColor='rgba(0,0,0,0.7)'">
            <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: #fff;">
              <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
            </svg>
          </div>
        `;
        previewContainer.appendChild(previewItem);
      });
    }

    showXToast('已移除圖片', 'info');
  };

  // 移除圖片
  function removeImage() {
    clearImageSection();
    toggleImageSection(); // 關閉圖片區域
  }

  // 清空圖片區域
  function clearImageSection() {
    // 重置檔輸入
    document.getElementById('image-file-input').value = '';

    // 清空上傳的圖片資料
    uploadedImagesData = [];

    // 隱藏預覽
    document.getElementById('uploaded-image-preview').style.display = 'none';

    // 清空預覽容器
    const previewContainer = document.getElementById('preview-images-container');
    if (previewContainer) {
      previewContainer.innerHTML = '';
    }

    // 清空描述文本
    const descTextarea = document.querySelector('#image-description-input textarea');
    if (descTextarea) {
      descTextarea.value = '';
    }

    // 重新開機按鈕狀態
    const descBtn = document.getElementById('img-desc-btn');
    const uploadBtn = document.getElementById('img-upload-btn');
    descBtn.style.backgroundColor = '#333';
    descBtn.style.borderColor = '#536471';
    uploadBtn.style.backgroundColor = '#333';
    uploadBtn.style.borderColor = '#536471';

    // 隱藏輸入區域
    document.getElementById('image-description-input').style.display = 'none';
    document.getElementById('image-upload-area').style.display = 'none';
  }

  // 切換位置區域
  function toggleLocationSection() {
    const section = document.getElementById('compose-location-section');
    const btn = document.getElementById('location-btn');

    if (section.style.display === 'none') {
      section.style.display = 'block';
      btn.style.backgroundColor = 'rgba(29,155,240,0.1)';
    } else {
      section.style.display = 'none';
      btn.style.backgroundColor = 'transparent';
      clearLocationSection();
    }
  }

  // 移除位置
  function removeLocation() {
    clearLocationSection();
    toggleLocationSection(); // 關閉位置區域
  }

  // 清空位置區域
  function clearLocationSection() {
    document.getElementById('location-input').value = '';
  }

  // 切換連結區域
  function toggleLinkSection() {
    const section = document.getElementById('compose-link-section');
    const btn = document.getElementById('attach-btn');

    if (section.style.display === 'none') {
      section.style.display = 'block';
      btn.style.backgroundColor = 'rgba(29,155,240,0.1)';
    } else {
      section.style.display = 'none';
      btn.style.backgroundColor = 'transparent';
      clearLinkSection();
    }
  }

  // 移除連結
  function removeLink() {
    clearLinkSection();
    toggleLinkSection(); // 關閉連結區域
  }

  // 清空連結區域
  function clearLinkSection() {
    document.getElementById('link-title-input').value = '';
    document.getElementById('link-url-input').value = '';
    document.getElementById('link-description-input').value = '';
  }

  // 重置功能按鈕狀態
  function resetFunctionButtonStates() {
    const buttons = ['image-btn', 'location-btn', 'attach-btn'];
    buttons.forEach(btnId => {
      const btn = document.getElementById(btnId);
      btn.style.backgroundColor = 'transparent';
    });
  }

  // 切換隱私設置
  async function togglePrivacySettings() {
    // 三種模式迴圈切換：public → private → business → public
    if (tweetPrivacySetting === 'public') {
      tweetPrivacySetting = 'private';
    } else if (tweetPrivacySetting === 'private') {
      // 檢查是否有待完成的商業轉帳任務
      const hasBusinessTasks = await checkPendingBusinessTasks();
      if (hasBusinessTasks) {
        tweetPrivacySetting = 'business';
      } else {
        tweetPrivacySetting = 'public';
        showXToast('當前沒有待完成的商業轉帳任務', 'info');
      }
    } else {
      tweetPrivacySetting = 'public';
    }

    updatePrivacySettingUI();
  }

  // 更新隱私設置UI
  function updatePrivacySettingUI() {
    const iconPath = document.getElementById('privacy-icon-path');
    const textElement = document.getElementById('privacy-text');

    if (tweetPrivacySetting === 'public') {
      // 所有人可見
      iconPath.setAttribute(
        'd',
        'M12 1.75C6.34 1.75 1.75 6.34 1.75 12S6.34 22.25 12 22.25 22.25 17.66 22.25 12 17.66 1.75 12 1.75zm-.81 14.68l-4.1-3.27 1.25-1.57 2.47 1.98 3.97-5.47 1.62 1.18-5.21 7.15z',
      );
      textElement.textContent = '所有人可以回復';
      textElement.style.color = 'var(--x-accent)';

      // 隱藏商業任務選擇區域
      const businessSection = document.getElementById('business-task-selection');
      if (businessSection) businessSection.style.display = 'none';

      showXToast('已切換為所有人可見', 'success');
    } else if (tweetPrivacySetting === 'private') {
      // 僅自己可見
      iconPath.setAttribute(
        'd',
        'M17.863 13.44c1.477 1.58 2.366 3.8 2.632 6.46l.11 1.1H3.395l.11-1.1c.266-2.66 1.155-4.88 2.632-6.46C7.627 11.85 9.648 11 12 11s4.373.85 5.863 2.44zM12 2C9.791 2 8 3.79 8 6s1.791 4 4 4 4-1.79 4-4-1.791-4-4-4z',
      );
      textElement.textContent = '僅自己可見';
      textElement.style.color = 'var(--x-accent)';

      // 隱藏商業任務選擇區域
      const businessSection = document.getElementById('business-task-selection');
      if (businessSection) businessSection.style.display = 'none';

      showXToast('已切換為僅自己可見', 'success');
    } else {
      // 商業化推貼
      iconPath.setAttribute(
        'd',
        'M20 6h-3V4c0-1.1-.9-2-2-2H9c-1.1 0-2 .9-2 2v2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zM9 4h6v2H9V4zm11 16H4V8h16v12z',
      );
      textElement.textContent = '商業化推貼';
      textElement.style.color = 'var(--x-accent)';

      // 顯示商業任務選擇區域
      showBusinessTaskSelection();

      showXToast('已切換為商業化推貼', 'success');
    }
  }

  // 檢查是否有待完成的商業轉帳任務
  async function checkPendingBusinessTasks() {
    try {
      const xDb = getXDB();
      const businessTransfersId = `businessTransfers_${currentAccountId || 'main'}`;
      const savedData = await xDb.xAccountProfiles.get(businessTransfersId);

      console.log('🔍 [檢查商業任務] 資料:', savedData);

      if (!savedData || !savedData.data) {
        console.log('🔍 [檢查商業任務] 沒有保存的資料');
        return false;
      }

      console.log('🔍 [檢查商業任務] 總任務數:', savedData.data.length);

      // 篩選接收的、進行中且未過期的商業轉帳
      const now = new Date();
      const pendingTasks = savedData.data.filter(t => {
        console.log('🔍 [檢查任務]', {
          direction: t.direction,
          taskStatus: t.taskStatus,
          taskDeadline: t.taskDeadline,
          acceptedAt: t.acceptedAt,
          taskDeadlineHours: t.taskDeadlineHours,
        });

        if (t.direction !== 'received' || t.taskStatus !== 'in_progress') return false;

        // 檢查是否有 taskDeadline 欄位，如果沒有則嘗試動態計算
        let deadline;
        if (!t.taskDeadline) {
          if (t.acceptedAt && t.taskDeadlineHours) {
            // 動態計算截止時間
            const acceptedTime = new Date(t.acceptedAt);
            const deadlineHours = parseFloat(t.taskDeadlineHours) || 24;
            deadline = new Date(acceptedTime.getTime() + deadlineHours * 60 * 60 * 1000);
            console.log('⚠️ [檢查任務] 動態計算截止時間:', deadline.toISOString());
          } else {
            console.warn('⚠️ [檢查任務] 任務沒有足夠資訊計算截止時間，仍然認為有效', t);
            return true; // 如果沒有截止時間，認為任務有效
          }
        } else {
          deadline = new Date(t.taskDeadline);
        }

        const isValid = deadline.getTime() > now.getTime();
        console.log('🔍 [檢查任務] 是否有效:', isValid, '截止時間:', deadline, '現在:', now);
        return isValid; // 只保留未過期的任務
      });

      console.log('🔍 [檢查商業任務] 有效任務數:', pendingTasks.length);
      return pendingTasks.length > 0;
    } catch (error) {
      console.error('檢查商業任務失敗:', error);
      return false;
    }
  }

  // 顯示商業任務選擇區域
  async function showBusinessTaskSelection() {
    try {
      const xDb = getXDB();
      const businessTransfersId = `businessTransfers_${currentAccountId || 'main'}`;
      const savedData = await xDb.xAccountProfiles.get(businessTransfersId);

      const businessSection = document.getElementById('business-task-selection');
      const tasksList = document.getElementById('business-tasks-list');

      if (!businessSection || !tasksList) return;

      businessSection.style.display = 'block';
      tasksList.innerHTML = '';

      if (!savedData || !savedData.data) {
        tasksList.innerHTML = `
          <div style="
            text-align: center;
            padding: 24px 12px;
            color: #71767b;
            font-size: 13px;
          ">
            <svg viewBox="0 0 24 24" style="width: 40px; height: 40px; fill: currentColor; opacity: 0.3; margin: 0 auto 8px;">
              <g><path d="M20 6h-3V4c0-1.1-.9-2-2-2H9c-1.1 0-2 .9-2 2v2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zM9 4h6v2H9V4zm11 16H4V8h16v12z"></path></g>
            </svg>
            <div>沒有待完成的任務</div>
          </div>
        `;
        return;
      }

      // 篩選接收的、進行中的商業轉帳，並排除已過期的任務
      const now = new Date();
      console.log('📋 [顯示任務清單] 開始篩選，總數:', savedData.data.length);

      const pendingTasks = savedData.data.filter(t => {
        console.log('📋 [篩選任務]', {
          direction: t.direction,
          taskStatus: t.taskStatus,
          taskDeadline: t.taskDeadline,
          acceptedAt: t.acceptedAt,
          taskDeadlineHours: t.taskDeadlineHours,
        });

        if (t.direction !== 'received' || t.taskStatus !== 'in_progress') return false;

        // 如果沒有截止時間，嘗試動態計算
        let deadline;
        if (!t.taskDeadline) {
          if (t.acceptedAt && t.taskDeadlineHours) {
            // 動態計算截止時間
            const acceptedTime = new Date(t.acceptedAt);
            const deadlineHours = parseFloat(t.taskDeadlineHours) || 24;
            deadline = new Date(acceptedTime.getTime() + deadlineHours * 60 * 60 * 1000);
            console.log('⚠️ [篩選任務] 動態計算截止時間:', deadline.toISOString());
          } else {
            console.warn('⚠️ [篩選任務] 任務沒有足夠資訊計算截止時間，仍然顯示', t.transferId);
            return true;
          }
        } else {
          deadline = new Date(t.taskDeadline);
        }

        const isValid = deadline.getTime() > now.getTime();
        console.log('📋 [篩選任務] 是否有效:', isValid);
        return isValid; // 只保留未過期的任務
      });

      console.log('📋 [顯示任務清單] 篩選後:', pendingTasks.length);

      if (pendingTasks.length === 0) {
        tasksList.innerHTML = `
          <div style="
            text-align: center;
            padding: 24px 12px;
            color: #71767b;
            font-size: 13px;
          ">
            <svg viewBox="0 0 24 24" style="width: 40px; height: 40px; fill: currentColor; opacity: 0.3; margin: 0 auto 8px;">
              <g><path d="M20 6h-3V4c0-1.1-.9-2-2-2H9c-1.1 0-2 .9-2 2v2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zM9 4h6v2H9V4zm11 16H4V8h16v12z"></path></g>
            </svg>
            <div>沒有待完成的任務</div>
          </div>
        `;
        return;
      }

      // 渲染任務列表
      pendingTasks.forEach(task => {
        // 獲取或計算截止時間
        let deadline;
        if (task.taskDeadline) {
          deadline = new Date(task.taskDeadline);
        } else if (task.acceptedAt && task.taskDeadlineHours) {
          const acceptedTime = new Date(task.acceptedAt);
          const deadlineHours = parseFloat(task.taskDeadlineHours) || 24;
          deadline = new Date(acceptedTime.getTime() + deadlineHours * 60 * 60 * 1000);
        } else {
          // 無法計算截止時間，使用默認24小時
          deadline = new Date(now.getTime() + 24 * 60 * 60 * 1000);
        }

        const remainingMs = deadline.getTime() - now.getTime();

        // 計算剩餘時間
        const hours = Math.floor(remainingMs / (1000 * 60 * 60));
        const minutes = Math.floor((remainingMs % (1000 * 60 * 60)) / (1000 * 60));
        const deadlineText = hours > 0 ? `剩餘 ${hours}小時${minutes}分鐘` : `剩餘 ${minutes}分鐘`;

        const isSelected = selectedBusinessTransferId === task.transferId;

        const taskCard = document.createElement('div');
        taskCard.style.cssText = `
          padding: 14px;
          margin-bottom: 10px;
          background: linear-gradient(135deg, ${
            isSelected ? 'rgba(255, 255, 255, 0.08)' : 'rgba(255, 255, 255, 0.03)'
          } 0%, ${isSelected ? 'rgba(255, 255, 255, 0.04)' : 'rgba(255, 255, 255, 0.01)'} 100%);
          border: 1px solid ${isSelected ? 'rgba(255, 255, 255, 0.25)' : 'rgba(255, 255, 255, 0.1)'};
          border-radius: 10px;
          cursor: pointer;
          transition: all 0.2s;
          position: relative;
          overflow: hidden;
        `;

        taskCard.innerHTML = `
          <!-- 票券浮水印 -->
          <div style="
            position: absolute;
            top: 50%;
            right: -25px;
            transform: translateY(-50%) rotate(15deg);
            font-size: 28px;
            color: rgba(255, 255, 255, 0.02);
            font-weight: 700;
            pointer-events: none;
          ">TASK</div>
          
          <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;">
            <div style="flex: 1;">
              <div style="color: #fff; font-size: 14px; font-weight: 600; margin-bottom: 4px;">
                來自 ${task.senderName}
              </div>
              <div style="color: #71767b; font-size: 11px; font-family: monospace; letter-spacing: 0.3px;">${
                task.senderHandle
              }</div>
            </div>
            <div style="
              padding: 4px 10px;
              background: linear-gradient(135deg, rgba(255, 255, 255, 0.12) 0%, rgba(255, 255, 255, 0.06) 100%);
              color: #e5e5e5;
              font-size: 10px;
              font-weight: 600;
              border-radius: 8px;
              border: 1px solid rgba(255, 255, 255, 0.15);
              letter-spacing: 0.5px;
              display: flex;
              align-items: center;
              gap: 4px;
            ">
              <svg viewBox="0 0 24 24" style="width: 10px; height: 10px; fill: currentColor;">
                <g><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm.5-13H11v6l5.2 3.2.8-1.3-4.5-2.7V7z"></path></g>
              </svg>
              ${deadlineText}
            </div>
          </div>
          
          <!-- 任務描述 -->
          <div style="
            color: #e5e5e5;
            font-size: 13px;
            line-height: 1.4;
            margin-bottom: 12px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.02);
            border-left: 2px solid rgba(255, 255, 255, 0.15);
            border-radius: 4px;
          ">${task.taskDescription}</div>
          
          <!-- 底部資訊 -->
          <div style="
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-top: 10px;
            border-top: 1px dashed rgba(255, 255, 255, 0.1);
          ">
            <div style="
              color: #71767b;
              font-size: 11px;
              font-family: monospace;
            ">$${task.amount} <span style="opacity: 0.6;">(定金 $${task.depositAmount})</span></div>
            ${
              isSelected
                ? `<div style="
              display: inline-flex;
              align-items: center;
              gap: 4px;
              padding: 3px 8px;
              background: linear-gradient(135deg, rgba(255, 255, 255, 0.12) 0%, rgba(255, 255, 255, 0.06) 100%);
              border: 1px solid rgba(255, 255, 255, 0.2);
              border-radius: 8px;
              font-size: 10px;
              font-weight: 600;
              color: #fff;
              letter-spacing: 0.5px;
            ">
              <svg viewBox="0 0 24 24" style="width: 10px; height: 10px; fill: currentColor;">
                <g><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"></path></g>
              </svg>
              已選擇
            </div>`
                : ''
            }
          </div>
        `;

        taskCard.onclick = () => {
          selectedBusinessTransferId = task.transferId;
          showBusinessTaskSelection(); // 重新渲染以更新選中狀態
        };

        taskCard.onmouseover = function () {
          if (!isSelected) {
            this.style.borderColor = 'rgba(255, 255, 255, 0.2)';
            this.style.background =
              'linear-gradient(135deg, rgba(255, 255, 255, 0.05) 0%, rgba(255, 255, 255, 0.02) 100%)';
          }
        };

        taskCard.onmouseout = function () {
          if (!isSelected) {
            this.style.borderColor = 'rgba(255, 255, 255, 0.1)';
            this.style.background =
              'linear-gradient(135deg, rgba(255, 255, 255, 0.03) 0%, rgba(255, 255, 255, 0.01) 100%)';
          }
        };

        tasksList.appendChild(taskCard);
      });
    } catch (error) {
      console.error('顯示商業任務失敗:', error);
    }
  }

  // 發佈推文
  async function publishTweet() {
    const textInput = document.getElementById('compose-text-input');
    const content = textInput.value.trim();

    if (!content) {
      showXToast('請輸入推文內容', 'error');
      return;
    }

    // 驗證商業化推貼的必填項
    if (tweetPrivacySetting === 'business') {
      if (!selectedBusinessTransferId) {
        showXToast('請選擇要完成的商業任務', 'error');
        return;
      }
    }

    // 獲取附加內容（使用window.userProfileData確保獲取最新帳號資料）
    const tweetData = {
      id: 'user_' + Date.now(),
      content: content,
      image: getImageData(),
      location: getLocationData(),
      link: getLinkData(),
      timestamp: new Date(),
      user: {
        name: window.userProfileData.name,
        handle: window.userProfileData.handle,
        avatar: window.userProfileData.avatar,
        verified: window.userProfileData.verified,
      },
      stats: {
        comments: 0,
        retweets: 0,
        likes: 0,
        views: 0,
      },
      comments: [],
      privacy: tweetPrivacySetting,
    };

    // 如果是商業化推貼，添加商業轉帳資訊
    if (tweetPrivacySetting === 'business') {
      tweetData.businessTransferId = selectedBusinessTransferId;
      tweetData.isBusinessPost = true;
    }

    // 如果有引用內容，添加到推文中
    if (typeof currentQuoteData !== 'undefined' && currentQuoteData) {
      tweetData.quotedTweet = {
        type: currentQuoteData.type,
        user: {
          name: currentQuoteData.user.name,
          handle: currentQuoteData.user.handle,
          avatar: currentQuoteData.user.avatar,
          verified: currentQuoteData.user.verified,
        },
        content: currentQuoteData.content,
        time: currentQuoteData.time,
        image: currentQuoteData.image || null, // 保存圖片資料
        link: currentQuoteData.link || null, // 保存連結資料
        location: currentQuoteData.location || null, // 保存位置資料
      };
    }

    console.log('推文數據:', tweetData);

    // 關閉彈窗
    closeComposeTweetModal();

    // 保存使用者發佈的帖子到個人頁面
    await saveUserTweet(tweetData);

    // 如果當前在個人主頁，刷新推文顯示
    if (document.getElementById('x-profile-page').style.display !== 'none') {
      loadUserProfileTweets();
    }

    // 顯示推文詳情頁面
    showTweetDetail(tweetData);

    showXToast(currentQuoteData ? '引用轉發已發佈！' : '發帖成功！', 'success');

    // 如果是商業化推貼，觸發AI任務評估
    if (tweetPrivacySetting === 'business') {
      showXToast('正在提交任務成果...', 'info');
      await handleBusinessPostSubmission(tweetData, selectedBusinessTransferId);
    }
    // 如果設置為所有人可見，觸發AI回復
    else if (tweetPrivacySetting === 'public') {
      showXToast('正在等待回復...', 'info');
      await generateAIResponseForTweet(tweetData);
    }
  }

  // 獲取圖片資料（支援多圖）
  function getImageData() {
    const imageSection = document.getElementById('compose-image-section');
    if (imageSection.style.display === 'none') return null;

    const descTextarea = document.querySelector('#image-description-input textarea');

    // 文字描述類型（單圖）
    if (descTextarea && descTextarea.style.display !== 'none' && descTextarea.value.trim()) {
      return {
        type: 'description',
        content: descTextarea.value.trim(),
      };
    }
    // 本地上傳類型（多圖）
    else if (uploadedImagesData && uploadedImagesData.length > 0) {
      return {
        type: 'uploads', // 注意：複數形式表示多圖
        images: uploadedImagesData.map(data => ({ content: data })),
      };
    }

    return null;
  }

  // 獲取位置資料
  function getLocationData() {
    const locationSection = document.getElementById('compose-location-section');
    if (locationSection.style.display === 'none') return null;

    const locationInput = document.getElementById('location-input');
    const location = locationInput.value.trim();

    return location ? location : null;
  }

  // 保存功能相關函數
  function saveImageData() {
    showXToast('圖片資料已保存', 'success');
  }

  function saveLocationData() {
    const locationInput = document.getElementById('location-input');
    if (locationInput.value.trim()) {
      showXToast('位置資訊已保存', 'success');
    } else {
      showXToast('請先輸入位置資訊', 'error');
    }
  }

  function saveLinkData() {
    const title = document.getElementById('link-title-input').value.trim();
    const url = document.getElementById('link-url-input').value.trim();
    const description = document.getElementById('link-description-input').value.trim();

    if (title || url || description) {
      showXToast('連結資訊已保存', 'success');
    } else {
      showXToast('請先填寫連結資訊', 'error');
    }
  }

  // 處理連結首圖上傳
  function triggerLinkImageUpload() {
    document.getElementById('link-image-input').click();
  }

  function handleLinkImageUpload(event) {
    const file = event.target.files[0];
    if (!file) return;

    // 驗證檔案類型
    if (!file.type.startsWith('image/')) {
      showXToast('請選擇圖片檔', 'error');
      return;
    }

    // 驗證文件大小
    if (file.size > 5 * 1024 * 1024) {
      showXToast('圖片檔不能超過5MB', 'error');
      return;
    }

    const reader = new FileReader();
    reader.onload = function (e) {
      const previewArea = document.getElementById('link-image-preview');
      const previewImg = document.getElementById('link-preview-image');

      previewImg.src = e.target.result;
      previewArea.style.display = 'block';

      showXToast('連結首圖上傳成功', 'success');
    };
    reader.readAsDataURL(file);
  }

  // 更新獲取連結資料函數
  function getLinkData() {
    const linkSection = document.getElementById('compose-link-section');
    if (linkSection.style.display === 'none') return null;

    const title = document.getElementById('link-title-input').value.trim();
    const url = document.getElementById('link-url-input').value.trim();
    const description = document.getElementById('link-description-input').value.trim();
    const previewImg = document.getElementById('link-preview-image');
    const thumbnail = previewImg && previewImg.src.startsWith('data:') ? previewImg.src : null;

    if (title || url || description || thumbnail) {
      return {
        title: title,
        url: url,
        description: description,
        thumbnail: thumbnail,
      };
    }

    return null;
  }

  // 清空連結區域
  function clearLinkSection() {
    document.getElementById('link-title-input').value = '';
    document.getElementById('link-url-input').value = '';
    document.getElementById('link-description-input').value = '';
    document.getElementById('link-image-input').value = '';
    document.getElementById('link-image-preview').style.display = 'none';
  }

  // 從推文詳情返回
  window.goBackFromTweetDetail = function () {
    const currentTweetData = sessionStorage.getItem('currentTweetData');
    if (currentTweetData) {
      try {
        const tweet = JSON.parse(currentTweetData);
        // 根據推文來源返回到正確的頁面
        if (tweet._source === 'account') {
          // 返回帳戶主頁時，重置推進模式
          if (isTweetProgressMode) {
            isTweetProgressMode = false;
            updateTweetRerollButtonUI();
            console.log('📖 [返回] 已重置推進模式');
          }
          document.getElementById('x-tweet-detail-page').style.display = 'none';
          document.getElementById('account-profile-page').style.display = 'flex';
          return;
        } else if (tweet._source === 'search') {
          // 返回搜尋網頁面時，重置推進模式
          if (isTweetProgressMode) {
            isTweetProgressMode = false;
            updateTweetRerollButtonUI();
            console.log('📖 [返回] 已重置推進模式');
          }
          document.getElementById('x-tweet-detail-page').style.display = 'none';

          // 恢復搜索結果視圖
          if (isInSearchResults && currentSearchQuery) {
            document.getElementById('trending-view').style.display = 'none';
            document.getElementById('search-results-view').style.display = 'flex';

            // 顯示返回按鈕，隱藏刷新按鈕
            const backBtn = document.getElementById('search-back-btn');
            if (backBtn) backBtn.style.display = 'flex';
            const refreshBtn = document.querySelector('.refresh-trends-btn');
            if (refreshBtn) refreshBtn.style.display = 'none';
          }

          switchXPage('search');
          return;
        }
      } catch (e) {
        console.warn('解析推文數據失敗:', e);
      }
    }
    // 默認返回主頁
    switchXPage('home');
  };

  // 顯示推文詳情頁面
  async function showTweetDetail(tweetData) {
    console.log('📖 [顯示詳情] 開始顯示推文詳情，推文ID:', tweetData.id);

    // 從資料庫載入最新的推文資料（包括所有評論）
    let latestTweetData = tweetData;
    try {
      const xDb = getXDB();
      const isUserTweet = tweetData.id.startsWith('user_');

      if (isUserTweet) {
        console.log('📖 [顯示詳情] 從使用者推文資料庫載入');
        const userTweetsId = `userTweets_${currentAccountId || 'main'}`;
        const userTweetsData = await xDb.xUserTweets.get(userTweetsId);

        if (userTweetsData && userTweetsData.tweets) {
          const dbTweet = userTweetsData.tweets.find(t => t.id === tweetData.id);
          if (dbTweet) {
            latestTweetData = dbTweet;
            console.log('✅ [顯示詳情] 已載入最新使用者推文資料，評論數:', dbTweet.comments?.length || 0);
          } else {
            console.warn('⚠️ [顯示詳情] 資料庫中未找到該使用者推文');
          }
        }
      } else {
        console.log('📖 [顯示詳情] 從主頁推文資料庫載入');
        const tweetsData = await xDb.xTweetsData.get('tweets');
        if (tweetsData) {
          let dbTweet = null;

          if (tweetsData.forYouTweets) {
            dbTweet = tweetsData.forYouTweets.find(t => t.id === tweetData.id);
          }

          if (!dbTweet && tweetsData.followingTweets) {
            dbTweet = tweetsData.followingTweets.find(t => t.id === tweetData.id);
          }

          if (dbTweet) {
            latestTweetData = dbTweet;
            console.log('✅ [顯示詳情] 已載入最新主頁推文資料，評論數:', dbTweet.comments?.length || 0);
          } else {
            console.warn('⚠️ [顯示詳情] 資料庫中未找到該主頁推文');
          }
        }
      }
    } catch (loadError) {
      console.error('❌ [顯示詳情] 從資料庫載入推文失敗:', loadError);
    }

    // 保存最新推文資料到sessionStorage，供重回功能使用
    sessionStorage.setItem('currentTweetData', JSON.stringify(latestTweetData));
    console.log('📖 [顯示詳情] sessionStorage 已更新');

    // 隱藏所有頁面
    document.querySelectorAll('.x-page').forEach(page => {
      page.style.display = 'none';
    });

    // 顯示推文詳情頁面
    const detailPage = document.getElementById('x-tweet-detail-page');
    detailPage.style.display = 'flex';

    // 判斷是否為帳戶推文或搜索結果推文，如果是則強制進入推進模式
    const isAccountTweet = latestTweetData._source === 'account';
    const isSearchTweet = latestTweetData._source === 'search';
    const isUserTweet = latestTweetData.id && latestTweetData.id.startsWith('user_');

    if (isAccountTweet || isSearchTweet) {
      const sourceType = isAccountTweet ? '帳戶推文' : '搜索結果推文';
      console.log(`📖 [顯示詳情] 檢測到${sourceType}，強制啟用推進模式（該類型推文僅支持推進）`);
      // 強制設置為推進模式（帳戶推文/搜索推文只能推進，不能重回）
      if (!isTweetProgressMode) {
        isTweetProgressMode = true;
        updateTweetRerollButtonUI();
      }
    } else if (isUserTweet) {
      console.log(`📖 [顯示詳情] 檢測到用戶推文，支援重回+推進模式`);
      // 用戶推文：保持當前模式設置，支援切換
      updateTweetRerollButtonUI();
    }

    // 渲染推文詳情
    renderTweetDetail(latestTweetData);

    console.log('✅ [顯示詳情] 推文詳情頁面已顯示');

    // 確保使用者資料頭像正確顯示
    setTimeout(() => {
      const detailCommentUserAvatar = document.getElementById('detail-comment-user-avatar');
      if (detailCommentUserAvatar) {
        detailCommentUserAvatar.src = userProfileData.avatar;
      }

      // 更新所有回復輸入框頭像
      const replyUserAvatars = document.querySelectorAll('.reply-user-avatar');
      replyUserAvatars.forEach(avatar => {
        avatar.src = userProfileData.avatar;
      });
    }, 100);
  }

  // 渲染推文詳情
  function renderTweetDetail(tweet) {
    const container = document.getElementById('tweet-detail-container');
    container.setAttribute('data-tweet-id', tweet.id);

    // 創建詳情HTML
    const detailHTML = `
              <div class="tweet-detail-item" style="padding: 16px 16px 4px 16px;">
                <!-- 使用者資訊 -->
                <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 16px;">
                  <img src="${tweet.user.avatar}" alt="${tweet.user.name}" 
                    onclick="openAccountProfile('${tweet.user.name.replace(/'/g, "\\'")}', '${tweet.user.handle}', '${
      tweet.user.avatar
    }', {source: 'tweetDetail'});event.stopPropagation();"
                    style="width: 48px; height: 48px; border-radius: 50%; cursor: pointer; transition: opacity 0.2s;"
                    onmouseover="this.style.opacity='0.8'" 
                    onmouseout="this.style.opacity='1'">
                  <div>
                    <div style="display: flex; align-items: center; gap: 4px;">
                      <span onclick="openAccountProfile('${tweet.user.name.replace(/'/g, "\\'")}', '${
      tweet.user.handle
    }', '${
      tweet.user.avatar
    }', {source: 'tweetDetail'});event.stopPropagation();" style="color: #fff; font-weight: 700; font-size: 17px; cursor: pointer;">${
      tweet.user.name
    }</span>
                      ${
                        tweet.user.verified
                          ? '<svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-accent);"><g><path d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.27 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.46 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z"></path></g></svg>'
                          : ''
                      }
                    </div>
                    <div style="color: #71767b; font-size: 15px;">${
                      tweet.user.handle.startsWith('@') ? tweet.user.handle : '@' + tweet.user.handle
                    }</div>
                  </div>
                </div>

                <!-- 推文內容 -->
                <div style="color: #fff; font-size: 16px; line-height: 1.3; margin-bottom: 16px; word-wrap: break-word;">
                  ${processContent(tweet.content)}
                </div>

                ${renderTweetMedia(tweet)}
                ${renderTweetLink(tweet)}
                ${renderQuotedTweet(tweet)}

                <!-- 時間和位置資訊 -->
                <div style="display: flex; align-items: center; justify-content: space-between; margin: 12px 0 16px 0;">
                  <div style="display: flex; align-items: center; gap: 16px;">
                    <span style="color: #71767b; font-size: 15px;">${formatDetailTime(
                      tweet.timestamp || tweet.createdAt,
                    )}</span>
                    <span style="color: #71767b; font-size: 15px;">·</span>
                    <span id="tweet-detail-views" style="color: #fff; font-weight: 700; font-size: 15px;">${formatNumber(
                      tweet.stats.views,
                    )}</span>
                    <span id="tweet-detail-views-label" style="color: #71767b; font-size: 15px;">${getI18nText(
                      'tweetDetailViews',
                    )}</span>
                  </div>
                  ${
                    tweet.location
                      ? `
                    <div style="display: flex; align-items: center; gap: 4px; color: var(--x-accent); font-size: 15px;">
                      <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: currentColor;">
                        <g>
                          <path d="M12 7c-1.93 0-3.5 1.57-3.5 3.5S10.07 14 12 14s3.5-1.57 3.5-3.5S13.93 7 12 7zm0 5c-.827 0-1.5-.673-1.5-1.5S11.173 9 12 9s1.5.673 1.5 1.5S12.827 12 12 12zm0-10c-4.687 0-8.5 3.813-8.5 8.5 0 5.967 7.621 11.116 7.945 11.332l.555.37.555-.37C12.879 21.616 20.5 16.467 20.5 10.5 20.5 5.813 16.687 2 12 2zm0 17.77c-1.665-1.241-6.5-5.196-6.5-9.27C5.5 6.916 8.416 4 12 4s6.5 2.916 6.5 6.5c0 4.073-4.835 8.028-6.5 9.27z"></path>
                        </g>
                      </svg>
                      <span>${tweet.location}</span>
                    </div>
                  `
                      : ''
                  }
                </div>

                <!-- 互動數據 -->
                <div id="tweet-detail-stats" style="display: flex; align-items: center; gap: 32px; padding: 16px 0; border-top: 1px solid #2f3336; border-bottom: 1px solid #2f3336;">
                  <div style="display: flex; align-items: center; gap: 4px;">
                    <span style="color: #fff; font-weight: 700; font-size: 15px;">${formatNumber(
                      tweet.stats.retweets,
                    )}</span>
                    <span style="color: #71767b; font-size: 15px;">${getI18nText('tweetDetailRetweets')}</span>
                  </div>
                  <div style="display: flex; align-items: center; gap: 4px;">
                    <span style="color: #fff; font-weight: 700; font-size: 15px;">${formatNumber(
                      tweet.stats.likes,
                    )}</span>
                    <span style="color: #71767b; font-size: 15px;">${getI18nText('tweetDetailLikes')}</span>
                  </div>
                  <div style="display: flex; align-items: center; gap: 4px;">
                    <span style="color: #fff; font-weight: 700; font-size: 15px;">${formatNumber(
                      tweet.stats.comments,
                    )}</span>
                    <span style="color: #71767b; font-size: 15px;">${getI18nText('tweetDetailBookmarks')}</span>
                  </div>
                </div>

                <!-- 互動按鈕 -->
                <div style="display: flex; justify-content: space-between; padding: 12px 0 0 0;">
                  <div class="tweet-action comment" style="display: flex; align-items: center; gap: 8px; padding: 8px; border-radius: 50%; cursor: pointer; color: #71767b; transition: all 0.2s;" onmouseover="this.style.backgroundColor='rgba(29,155,240,0.1)'; this.style.color='#1d9bf0';" onmouseout="this.style.backgroundColor='transparent'; this.style.color='#71767b';">
                    <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor" style="width: 20px; height: 20px;">
                      <g><path d="M1.751 10c0-4.42 3.584-8.005 8.005-8.005h4.366c4.49 0 8.129 3.64 8.129 8.13 0 2.96-1.607 5.68-4.196 7.11l-8.054 4.46v-3.69h-.067c-4.49.1-8.183-3.51-8.183-8.005zm8.005-6.005c-3.317 0-6.005 2.69-6.005 6.005 0 3.37 2.77 6.08 6.138 6.01l.351-.01h1.761v2.3l5.087-2.81c1.951-1.08 3.163-3.13 3.163-5.36 0-3.39-2.744-6.13-6.129-6.13H9.756z"></path></g>
                    </svg>
                  </div>
                  <div class="tweet-action retweet" style="display: flex; align-items: center; gap: 8px; padding: 8px; border-radius: 50%; cursor: pointer; color: #71767b; transition: all 0.2s;" onmouseover="this.style.backgroundColor='rgba(0,186,124,0.1)'; this.style.color='#00ba7c';" onmouseout="this.style.backgroundColor='transparent'; this.style.color='#71767b';">
                    <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor" style="width: 20px; height: 20px;">
                      <g><path d="M4.5 3.88l4.432 4.14-1.364 1.46L5.5 7.55V16c0 1.1.896 2 2 2H13v2H7.5c-2.209 0-4-1.791-4-4V7.55L1.432 9.48.068 8.02 4.5 3.88zM16.5 6H11V4h5.5c2.209 0 4 1.791 4 4v8.45l2.068-1.93 1.364 1.46-4.432 4.14-4.432-4.14 1.364-1.46 2.068 1.93V8c0-1.1-.896-2-2-2z"></path></g>
                    </svg>
                  </div>
                  <div class="tweet-action like" onclick="toggleDetailLike('${
                    tweet.id
                  }', this)" data-liked="false" data-likes="${
      tweet.stats.likes
    }" style="display: flex; align-items: center; gap: 8px; padding: 8px; border-radius: 50%; cursor: pointer; color: #71767b; transition: all 0.2s;" onmouseover="this.style.backgroundColor='rgba(249,24,128,0.1)'; this.style.color='#f91880';" onmouseout="this.style.backgroundColor='transparent'; this.style.color='#71767b';">
                    <svg class="action-icon like-icon" viewBox="0 0 24 24" fill="currentColor" style="width: 20px; height: 20px;">
                      <g><path d="M16.697 5.5c-1.222-.06-2.679.51-3.89 2.16l-.805 1.09-.806-1.09C9.984 6.01 8.526 5.44 7.304 5.5c-1.243.07-2.349.78-2.91 1.91-.552 1.12-.633 2.78.479 4.82 1.074 1.97 3.257 4.27 7.129 6.61 3.87-2.34 6.052-4.64 7.126-6.61 1.111-2.04 1.03-3.7.477-4.82-.561-1.13-1.666-1.84-2.908-1.91zm4.187 7.69c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g>
                    </svg>
                  </div>
                  <div class="tweet-action bookmark" style="display: flex; align-items: center; gap: 8px; padding: 8px; border-radius: 50%; cursor: pointer; color: #71767b; transition: all 0.2s;" onmouseover="this.style.backgroundColor='rgba(29,155,240,0.1)'; this.style.color='#1d9bf0';" onmouseout="this.style.backgroundColor='transparent'; this.style.color='#71767b';">
                    <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor" style="width: 20px; height: 20px;">
                      <g><path d="M4 4.5C4 3.12 5.119 2 6.5 2h11C18.881 2 20 3.12 20 4.5v18.44l-8-5.71-8 5.71V4.5zM6.5 4c-.276 0-.5.22-.5.5v14.56l6-4.29 6 4.29V4.5c0-.28-.224-.5-.5-.5h-11z"></path></g>
                    </svg>
                  </div>
                  <div class="tweet-action share" id="tweet-detail-share-btn" style="display: flex; align-items: center; gap: 8px; padding: 8px; border-radius: 50%; cursor: pointer; color: #71767b; transition: all 0.2s;" onmouseover="this.style.backgroundColor='rgba(29,155,240,0.1)'; this.style.color='#1d9bf0';" onmouseout="this.style.backgroundColor='transparent'; this.style.color='#71767b';">
                    <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor" style="width: 20px; height: 20px;">
                      <g><path d="M12 2.59l5.7 5.7-1.41 1.42L13 6.41V16h-2V6.41l-3.29 3.3-1.42-1.42L12 2.59zM21 15l-.02 3.51c0 1.38-1.12 2.49-2.5 2.49H5.5C4.11 21 3 19.88 3 18.5V15h2v3.5c0 .28.22.5.5.5h12.98c.28 0 .5-.22.5-.5L19 15h2z"></path></g>
                    </svg>
                  </div>
                </div>
              </div>
            `;

    container.innerHTML = detailHTML;

    // 同步用戶頭像
    const commentInputAvatar = document.querySelector('#x-tweet-detail-page .detail-comment-input-area img');
    if (commentInputAvatar) {
      commentInputAvatar.src = userProfileData.avatar;
    }

    // 添加分享按鈕點擊事件
    const shareBtn = document.getElementById('tweet-detail-share-btn');
    if (shareBtn) {
      shareBtn.onclick = () => {
        showShareContentModal(
          {
            user: tweet.user,
            content: tweet.content,
            time: tweet.time || formatDetailTime(tweet.timestamp),
            image: tweet.image,
            // 包含完整推文和評論區資料
            fullTweet: tweet,
            comments: tweet.comments || [],
          },
          'tweet',
        );
      };
    }

    // 渲染評論（如果有）
    renderDetailComments(tweet.comments);
  }

  // 渲染推文媒體內容（支援多圖）
  function renderTweetMedia(tweet) {
    // 支援兩種格式：tweet.image（舊格式）和 tweet.media（帳戶推文格式）

    // 1. 處理帳戶推文的 media 陣列格式
    if (tweet.media && Array.isArray(tweet.media) && tweet.media.length > 0) {
      const media = tweet.media[0];
      if (media.type === 'description' && media.description) {
        return `
                <div style="margin-bottom: 16px; background-color: var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 16px; padding: 16px;">
                  <div style="color: var(--x-text-primary); font-size: 15px; line-height: 20px;">${media.description}</div>
                </div>
              `;
      } else if (media.type === 'upload' && media.url) {
        return `
                <div style="margin-bottom: 16px; border-radius: 16px; overflow: hidden;">
                  <img src="${media.url}" style="width: 100%; max-height: 400px; object-fit: cover; display: block;" alt="推文圖片">
                </div>
              `;
      }
    }

    // 2. 處理舊的 image 格式（相容性）
    if (!tweet.image) return '';

    // 文字描述類型
    if (tweet.image.type === 'description') {
      return `
                <div style="margin-bottom: 16px; background-color: var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 12px; padding: 16px; box-sizing: border-box;">
                  <div style="color: var(--x-text-primary); font-size: 15px; line-height: 1.4; white-space: pre-wrap; word-wrap: break-word; overflow-wrap: break-word; width: 100%; box-sizing: border-box;">${tweet.image.content}</div>
                </div>
              `;
    }
    // 單圖上傳
    else if (tweet.image.type === 'upload') {
      return `
                <div style="margin-bottom: 16px; border-radius: 16px; overflow: hidden;">
                  <img src="${tweet.image.content}" style="width: 100%; max-height: 400px; object-fit: cover; display: block;" alt="推文圖片">
                </div>
              `;
    }
    // 多圖上傳
    else if (tweet.image.type === 'uploads' && tweet.image.images && tweet.image.images.length > 0) {
      const imageCount = tweet.image.images.length;
      let gridTemplate = '';

      if (imageCount === 1) {
        gridTemplate = 'grid-template-columns: 1fr;';
      } else if (imageCount === 2) {
        gridTemplate = 'grid-template-columns: repeat(2, 1fr);';
      } else if (imageCount === 3) {
        gridTemplate = 'grid-template-columns: repeat(2, 1fr);';
      } else {
        gridTemplate = 'grid-template-columns: repeat(2, 1fr);';
      }

      const imagesHtml = tweet.image.images
        .map((img, index) => {
          const spanStyle = imageCount === 3 && index === 0 ? 'grid-column: span 2;' : '';
          return `
          <div style="${spanStyle}border-radius: 12px; overflow: hidden;">
            <img src="${img.content}" style="width: 100%; height: ${
            imageCount === 1 ? '400px' : '280px'
          }; object-fit: cover; display: block;" alt="推文圖片${index + 1}">
          </div>
        `;
        })
        .join('');

      return `
                <div style="margin-bottom: 16px; display: grid; ${gridTemplate} gap: 4px;">
                  ${imagesHtml}
                </div>
              `;
    }

    return '';
  }

  // 渲染推文連結
  function renderTweetLink(tweet) {
    if (!tweet.link) return '';

    return `
              <div style="margin-bottom: 16px; border: 1px solid #333; border-radius: 12px; overflow: hidden; transition: background-color 0.2s;" onmouseover="this.style.backgroundColor='rgba(255,255,255,0.03)'" onmouseout="this.style.backgroundColor='transparent'">
                ${
                  tweet.link.thumbnail
                    ? `
                  <div style="width: 100%; height: 200px; background-color: #333;">
                    <img src="${tweet.link.thumbnail}" style="width: 100%; height: 100%; object-fit: cover;" alt="連結預覽圖">
                  </div>
                `
                    : ''
                }
                <div style="padding: 12px;">
                  <div style="color: #71767b; font-size: 13px; margin-bottom: 4px;">${tweet.link.url || '連結'}</div>
                  ${
                    tweet.link.title
                      ? `<div style="color: #fff; font-size: 15px; font-weight: 600; margin-bottom: 4px; line-height: 1.3;">${tweet.link.title}</div>`
                      : ''
                  }
                  ${
                    tweet.link.description
                      ? `<div style="color: #71767b; font-size: 14px; line-height: 1.4;">${tweet.link.description}</div>`
                      : ''
                  }
                </div>
              </div>
            `;
  }

  // 渲染引用推文內容（詳情頁版本）
  function renderQuotedTweet(tweet) {
    if (!tweet.quotedTweet) return '';

    const quoted = tweet.quotedTweet;
    const typeText = quoted.type === 'tweet' ? '推文' : '評論';

    return `
              <div style="margin-bottom: 16px; border: 1px solid var(--x-border-color); border-radius: 16px; padding: 16px; background-color: var(--x-bg-hover); transition: background-color 0.2s;">
                <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
                  <img src="${quoted.user.avatar}" 
                    onclick="openAccountProfile('${quoted.user.name.replace(/'/g, "\\'")}', '${quoted.user.handle}', '${
      quoted.user.avatar
    }', {source: 'quotedTweet'});event.stopPropagation();"
                    style="width: 24px; height: 24px; border-radius: 50%; cursor: pointer; transition: opacity 0.2s;" 
                    onmouseover="this.style.opacity='0.8'" 
                    onmouseout="this.style.opacity='1'"
                    alt="${quoted.user.name}">
                  <div style="display: flex; align-items: center; gap: 4px;">
                    <span onclick="openAccountProfile('${quoted.user.name.replace(/'/g, "\\'")}', '${
      quoted.user.handle
    }', '${
      quoted.user.avatar
    }', {source: 'quotedTweet'});event.stopPropagation();" style="color: var(--x-text-primary); font-size: 15px; font-weight: 700; cursor: pointer;">${
      quoted.user.name
    }</span>
                    ${
                      quoted.user.verified
                        ? '<svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-accent);"><g><path d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.27 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.46 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z"></path></g></svg>'
                        : ''
                    }
                    <span style="color: var(--x-text-secondary); font-size: 15px;">${quoted.user.handle}</span>
                    <span style="color: var(--x-text-secondary); font-size: 15px;">·${quoted.time}</span>
                  </div>
                </div>
                <div style="color: var(--x-text-primary); font-size: 17px; line-height: 1.3; word-wrap: break-word;">${
                  quoted.content
                }</div>
                ${renderQuotedTweetMedia(quoted)}
                <div style="color: var(--x-text-secondary); font-size: 13px; margin-top: 12px; font-style: italic;">引用${typeText}</div>
              </div>
            `;
  }

  // 渲染引用內容的媒體（圖片）
  function renderQuotedTweetMedia(quoted) {
    if (!quoted.image) return '';

    if (quoted.image.type === 'description') {
      return `
                <div style="margin-top: 8px; background-color: var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 8px; padding: 8px; box-sizing: border-box;">
                  <div style="color: var(--x-text-primary); font-size: 13px; line-height: 1.4; white-space: pre-wrap; word-wrap: break-word; overflow-wrap: break-word; width: 100%; box-sizing: border-box;">${quoted.image.content}</div>
                </div>
              `;
    } else if (quoted.image.type === 'upload') {
      return `
                <div style="margin-top: 8px; border-radius: 8px; overflow: hidden;">
                  <img src="${quoted.image.content}" style="width: 100%; max-height: 120px; object-fit: cover; display: block;" alt="引用圖片">
                </div>
              `;
    }

    return '';
  }

  // 格式化詳情頁時間
  function formatDetailTime(timestamp) {
    // 如果沒有timestamp，返回預設值
    if (!timestamp) {
      return '未知時間';
    }

    const date = new Date(timestamp);

    // 檢查日期是否有效
    if (isNaN(date.getTime())) {
      return '未知時間';
    }

    const formatter = new Intl.DateTimeFormat('zh-CN', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    });

    return formatter.format(date);
  }

  // 詳情頁點贊功能
  function toggleDetailLike(tweetId, element) {
    const isLiked = element.dataset.liked === 'true';
    const currentLikes = parseInt(element.dataset.likes);

    if (isLiked) {
      element.dataset.liked = 'false';
      element.dataset.likes = (currentLikes - 1).toString();
      element.style.color = '#71767b';
    } else {
      element.dataset.liked = 'true';
      element.dataset.likes = (currentLikes + 1).toString();
      element.style.color = '#f91880';
    }
  }

  // 詳情頁評論相關功能
  function handleDetailCommentInput(event) {
    const textarea = event.target;
    const replyBtn = document.getElementById('detail-reply-btn');

    // 更新按鈕狀態
    if (textarea.value.trim().length > 0) {
      replyBtn.style.opacity = '1';
      replyBtn.disabled = false;
    } else {
      replyBtn.style.opacity = '0.5';
      replyBtn.disabled = true;
    }

    // 回車發送評論
    if (event.key === 'Enter' && !event.shiftKey) {
      event.preventDefault();
      if (textarea.value.trim().length > 0) {
        submitDetailComment();
      }
    }
  }

  function autoResizeDetail(textarea) {
    textarea.style.height = '20px';
    textarea.style.height = Math.min(textarea.scrollHeight, 120) + 'px';

    const replyBtn = document.getElementById('detail-reply-btn');
    if (textarea.value.trim().length > 0) {
      replyBtn.style.opacity = '1';
      replyBtn.disabled = false;
    } else {
      replyBtn.style.opacity = '0.5';
      replyBtn.disabled = true;
    }
  }

  async function submitDetailComment() {
    const textarea = document.getElementById('detail-comment-input');
    const content = textarea.value.trim();

    if (content.length === 0) return;

    // 獲取當前推文資料
    const currentTweetData = sessionStorage.getItem('currentTweetData');
    if (!currentTweetData) {
      showXToast('無法獲取推文資訊', 'error');
      return;
    }

    let tweetData;
    try {
      tweetData = JSON.parse(currentTweetData);
    } catch (e) {
      showXToast('推文數據解析失敗', 'error');
      return;
    }

    console.log('📝 [提交評論] 開始處理評論提交');
    console.log('📝 [提交評論] 推文ID:', tweetData.id);
    console.log('📝 [提交評論] 推文作者:', tweetData.user.handle);
    console.log('📝 [提交評論] 當前用戶:', window.userProfileData.handle);
    console.log('📝 [提交評論] 是否為用戶推文:', tweetData.id.startsWith('user_'));

    // 檢查是否為僅自己可見的帖子
    if (tweetData.privacy === 'private') {
      showXToast('私有帖子不支援回復功能', 'error');
      return;
    }

    const newComment = {
      id: 'detail_' + Date.now(),
      user: {
        name: window.userProfileData.name,
        handle: window.userProfileData.handle,
        avatar: window.userProfileData.avatar,
        verified: window.userProfileData.verified,
      },
      content: content,
      time: '剛剛',
      replies: [],
    };

    // 如果有圖片，添加圖片資料
    if (detailCommentImageData) {
      newComment.image = {
        type: 'upload',
        content: detailCommentImageData,
      };
    }

    console.log('📝 [提交評論] 新評論資料:', {
      id: newComment.id,
      content: newComment.content.substring(0, 50) + '...',
      hasImage: !!newComment.image,
    });

    // 將評論添加到推文數據中
    if (!tweetData.comments) {
      tweetData.comments = [];
    }
    tweetData.comments.push(newComment);

    // 更新評論數量統計
    if (!tweetData.stats) {
      tweetData.stats = { comments: 0, retweets: 0, likes: 0, views: 0 };
    }
    tweetData.stats.comments = tweetData.comments.length;

    console.log('📝 [提交評論] 評論已添加到推文資料，當前評論總數:', tweetData.stats.comments);

    // 保存到資料庫
    try {
      const xDb = getXDB();

      // 判斷推文類型
      const isUserTweet = tweetData.id.startsWith('user_');
      const isRetweetMention = tweetData._source === 'retweet_mention';
      const isNewTweetMention = tweetData._source === 'newtweet_mention';

      if (isRetweetMention) {
        console.log('📝 [提交評論] 這是 Mentions 轉帖，保存到 Mentions 資料');

        const mentionsId = `mentions_${currentAccountId || 'main'}`;
        const mentionsData = await xDb.xAccountProfiles.get(mentionsId);

        if (mentionsData && mentionsData.data) {
          const retweetIndex = mentionsData.data.findIndex(m => m.id === tweetData.id && m.type === 'retweet');
          if (retweetIndex !== -1) {
            // 更新評論資料
            mentionsData.data[retweetIndex].comments = tweetData.comments;
            // 同步更新 stats
            if (!mentionsData.data[retweetIndex].stats) {
              mentionsData.data[retweetIndex].stats = tweetData.stats;
            } else {
              mentionsData.data[retweetIndex].stats.comments = tweetData.stats.comments;
            }

            await xDb.xAccountProfiles.put(mentionsData);
            console.log('✅ [提交評論] Mentions 轉帖通知已更新，評論總數:', tweetData.comments.length);
          } else {
            console.warn('⚠️ [提交評論] 未在 Mentions 資料中找到對應的轉帖通知:', tweetData.id);
          }
        } else {
          console.warn('⚠️ [提交評論] 未找到 Mentions 資料:', mentionsId);
        }
      } else if (isNewTweetMention) {
        console.log('📝 [提交評論] 這是 Mentions New Tweet，保存到 Mentions 資料');

        const mentionsId = `mentions_${currentAccountId || 'main'}`;
        const mentionsData = await xDb.xAccountProfiles.get(mentionsId);

        if (mentionsData && mentionsData.data) {
          const newTweetIndex = mentionsData.data.findIndex(
            m => m.id === tweetData._mentionId && m.type === 'newTweet',
          );
          if (newTweetIndex !== -1) {
            // 更新推文的評論資料
            if (!mentionsData.data[newTweetIndex].tweet) {
              mentionsData.data[newTweetIndex].tweet = {};
            }
            mentionsData.data[newTweetIndex].tweet.comments = tweetData.comments;
            // 同步更新 stats
            if (!mentionsData.data[newTweetIndex].tweet.stats) {
              mentionsData.data[newTweetIndex].tweet.stats = tweetData.stats;
            } else {
              mentionsData.data[newTweetIndex].tweet.stats.comments = tweetData.stats.comments;
            }

            await xDb.xAccountProfiles.put(mentionsData);
            console.log('✅ [提交評論] Mentions New Tweet 通知已更新，評論總數:', tweetData.comments.length);
          } else {
            console.warn('⚠️ [提交評論] 未在 Mentions 資料中找到對應的 New Tweet 通知:', tweetData._mentionId);
          }
        } else {
          console.warn('⚠️ [提交評論] 未找到 Mentions 資料:', mentionsId);
        }
      } else if (isUserTweet) {
        console.log('📝 [提交評論] 這是用戶自己的推文，保存到 xUserTweets');

        // 獲取使用者推文資料ID（按帳號隔離）
        const userTweetsId = `userTweets_${currentAccountId || 'main'}`;
        const userTweetsData = await xDb.xUserTweets.get(userTweetsId);

        if (userTweetsData && userTweetsData.tweets) {
          console.log('📝 [提交評論] 找到使用者推文資料，推文總數:', userTweetsData.tweets.length);

          const tweetIndex = userTweetsData.tweets.findIndex(t => t.id === tweetData.id);
          if (tweetIndex !== -1) {
            console.log('📝 [提交評論] 找到目標推文，索引:', tweetIndex);

            // 更新推文資料
            userTweetsData.tweets[tweetIndex] = tweetData;

            // 保存到資料庫
            await xDb.xUserTweets.put(userTweetsData);
            console.log('✅ [提交評論] 使用者推文資料已保存到資料庫');
          } else {
            console.warn('⚠️ [提交評論] 未找到目標推文，推文ID:', tweetData.id);
          }
        } else {
          console.warn('⚠️ [提交評論] 未找到使用者推文資料');
        }
      } else {
        console.log('📝 [提交評論] 這是主頁推文，保存到 xTweetsData');

        // 這是主頁推文，更新到主頁數據
        const tweetsData = await xDb.xTweetsData.get('tweets');
        if (tweetsData) {
          let updated = false;

          // 更新 forYouTweets
          if (tweetsData.forYouTweets) {
            const index = tweetsData.forYouTweets.findIndex(t => t.id === tweetData.id);
            if (index !== -1) {
              tweetsData.forYouTweets[index] = tweetData;
              updated = true;
              console.log('📝 [提交評論] 已更新 forYouTweets');
            }
          }

          // 更新 followingTweets
          if (tweetsData.followingTweets && !updated) {
            const index = tweetsData.followingTweets.findIndex(t => t.id === tweetData.id);
            if (index !== -1) {
              tweetsData.followingTweets[index] = tweetData;
              updated = true;
              console.log('📝 [提交評論] 已更新 followingTweets');
            }
          }

          if (updated) {
            await xDb.xTweetsData.put(tweetsData);
            console.log('✅ [提交評論] 主頁推文資料已保存到資料庫');
          } else {
            console.warn('⚠️ [提交評論] 未在主頁數據中找到目標推文');
          }
        }
      }

      // 更新 sessionStorage 中的資料
      sessionStorage.setItem('currentTweetData', JSON.stringify(tweetData));
      console.log('✅ [提交評論] sessionStorage 已更新');
    } catch (saveError) {
      console.error('❌ [提交評論] 保存評論到資料庫失敗:', saveError);
      showXToast('評論保存失敗: ' + saveError.message, 'error');
    }

    // 渲染新評論
    const commentsContainer = document.getElementById('detail-comments-container');
    const commentElement = createCommentElement(newComment);
    commentsContainer.appendChild(commentElement);

    console.log('📝 [提交評論] 評論已渲染到頁面');

    // 更新新添加的回復輸入框頭像（使用window.userProfileData確保獲取最新帳號資料）
    const replyUserAvatars = document.querySelectorAll('.reply-user-avatar');
    replyUserAvatars.forEach(avatar => {
      avatar.src = window.userProfileData.avatar;
    });

    // 清空輸入框
    textarea.value = '';
    textarea.style.height = '20px';

    // 清除圖片
    if (detailCommentImageData) {
      removeDetailCommentImage();
    }

    const replyBtn = document.getElementById('detail-reply-btn');
    replyBtn.style.opacity = '0.5';
    replyBtn.disabled = true;

    showXToast('你的評論等待回復中', 'info');

    // 觸發AI回復 - 判斷是否為用戶自己的帖子
    const isOwnPost =
      tweetData.user && (tweetData.user.handle === userProfileData.handle || tweetData.id.startsWith('user_'));
    console.log('📝 [提交評論] 準備觸發AI回復，isOwnPost:', isOwnPost);

    // 🔧 使用非同步非阻塞方式觸發AI回復，避免使用者離開頁面時中斷導致的問題
    setTimeout(async () => {
      try {
        await generateUnifiedAIResponse(tweetData, newComment, {
          isOwnPost,
          commentType: 'main_comment',
          pageType: 'detail',
          parentComment: null,
        });
        console.log('✅ [提交評論] AI回復生成完成');
      } catch (error) {
        console.error('❌ [提交評論] AI回復生成失敗:', error);
      }
    }, 100);

    console.log('✅ [提交評論] 評論提交流程完成（AI回復已非同步觸發）');
  }

  function renderDetailComments(comments) {
    const container = document.getElementById('detail-comments-container');
    container.innerHTML = '';

    if (!comments || comments.length === 0) return;

    console.log('📋 [渲染評論] 開始渲染評論，主評論數:', comments.length);

    comments.forEach(comment => {
      // 渲染主評論
      const commentElement = createCommentElement(comment);
      container.appendChild(commentElement);

      // 如果有樓中樓回復，也渲染它們
      if (comment.replies && comment.replies.length > 0) {
        console.log('📋 [渲染評論] 評論', comment.id, '有', comment.replies.length, '條樓中樓回復');

        comment.replies.forEach(reply => {
          const replyElement = createCommentElement(reply, true);
          container.appendChild(replyElement);
        });
      }
    });

    console.log('✅ [渲染評論] 評論渲染完成');

    // 更新所有回復輸入框頭像
    const replyUserAvatars = document.querySelectorAll('.reply-user-avatar');
    replyUserAvatars.forEach(avatar => {
      avatar.src = userProfileData.avatar;
    });
  }

  // ============================================
  // 商業推貼提交處理
  // ============================================

  // 處理商業推貼提交
  async function handleBusinessPostSubmission(tweetData, businessTransferId) {
    try {
      console.log('💼 [商業推貼] 開始處理任務提交');

      // 獲取商業轉帳資訊
      const xDb = getXDB();
      const businessTransfersId = `businessTransfers_${currentAccountId || 'main'}`;
      const savedData = await xDb.xAccountProfiles.get(businessTransfersId);

      if (!savedData || !savedData.data) {
        console.error('❌ 未找到商業轉帳資料');
        return;
      }

      const businessTransfer = savedData.data.find(t => t.transferId === businessTransferId);
      if (!businessTransfer) {
        console.error('❌ 未找到對應的商業轉帳');
        return;
      }

      console.log('✅ [商業推貼] 找到商業轉帳:', businessTransfer);

      // 查找對應的AI對話
      const conversationId = `messageConversation_${currentAccountId || 'main'}_${businessTransfer.conversationId}`;
      const conversation = await xDb.xAccountProfiles.get(conversationId);

      if (!conversation) {
        console.error('❌ 未找到對話資訊');
        showXToast('無法找到對應的對話，請手動聯繫對方', 'error');
        return;
      }

      console.log('✅ [商業推貼] 找到對話:', conversation);

      // 構建正確的對話資料結構
      const conversationData = {
        id: businessTransfer.conversationId,
        user: {
          name: businessTransfer.senderName,
          handle: businessTransfer.senderHandle,
          avatar: businessTransfer.senderAvatar,
          verified: false,
        },
      };

      // 觸發AI評估並發送私信
      await triggerBusinessTaskEvaluation(tweetData, businessTransfer, conversationData);
    } catch (error) {
      console.error('❌ [商業推貼] 處理失敗:', error);
      showXToast('提交失敗: ' + error.message, 'error');
    }
  }

  // 觸發商業任務評估（AI自動發送私信）
  async function triggerBusinessTaskEvaluation(tweetData, businessTransfer, conversationData) {
    try {
      console.log('🤖 [商業任務評估] 開始AI評估流程');

      // 第一步：先觸發AI評論生成（第二個情景）
      console.log('📝 [商業任務評估] 步驟1：生成AI評論...');

      // 標記這是商業化推貼
      const businessTweetData = {
        ...tweetData,
        _isBusinessPost: true,
        _businessTransferId: businessTransfer.transferId,
        _taskDescription: businessTransfer.taskDescription,
      };

      // 調用發帖生成器
      await generateAIResponseForTweet(businessTweetData);

      // 第二步：等待評論生成完成後，延遲3秒再發送評估私信
      setTimeout(async () => {
        console.log('💬 [商業任務評估] 步驟2：發送AI評估私信...');

        showPhoneNotification({
          title: 'X',
          message: `${conversationData.user.name} 正在評估你的任務完成情況...`,
          avatar: conversationData.user.avatar,
          leftIcon: 'x',
        });

        // 調用第九個情景的AI私信評估
        await generateBusinessTaskEvaluationMessage(tweetData, businessTransfer, conversationData);
      }, 3000); // 等待3秒讓用戶看到評論
    } catch (error) {
      console.error('❌ [商業任務評估] 失敗:', error);
      showXToast('任務評估失敗: ' + error.message, 'error');
    }
  }

  // 生成商業任務評估私信（調用第九個情景）
  async function generateBusinessTaskEvaluationMessage(tweetData, businessTransfer, conversationData) {
    try {
      console.log('💼 [AI評估] 開始生成評估私信');

      // 構建評估上下文
      const evaluationContext = {
        isBusinessTaskEvaluation: true,
        tweetData: tweetData,
        businessTransfer: businessTransfer,
      };

      // 調用第九個情景的私信生成器（續寫模式）
      const messageData = {
        id: conversationData.id,
        user: conversationData.user,
      };

      const aiMessages = await generateMessageConversation(messageData, true, {
        isAutoMessage: true,
        businessTaskEvaluation: evaluationContext,
      });

      if (!aiMessages || aiMessages.length === 0) {
        console.error('❌ [AI評估] 未生成評估消息');
        return;
      }

      console.log('✅ [AI評估] 生成了評估消息:', aiMessages);

      // 保存AI評估消息到私信資料庫
      const xDb = getXDB();
      const conversationId = `messageConversation_${currentAccountId || 'main'}_${conversationData.id}`;
      const savedConversation = await xDb.xAccountProfiles.get(conversationId);

      if (savedConversation && savedConversation.data) {
        // 添加AI消息到對話記錄
        aiMessages.forEach(msg => {
          savedConversation.data.messages.push({
            ...msg,
            isOwn: false,
            timestamp: new Date().toISOString(),
          });
        });

        await xDb.xAccountProfiles.put(savedConversation);
        console.log('✅ [AI評估] 評估消息已保存到資料庫');

        // 檢查是否有轉帳消息（支付尾款、扣款或額外獎勵）
        const transferMessages = aiMessages.filter(msg => msg.type === 'transfer');
        if (transferMessages.length > 0) {
          // 處理AI發起的轉帳（尾款支付）
          for (const transferMsg of transferMessages) {
            await handleAIBusinessPayment(transferMsg, businessTransfer, conversationData);
          }
        }

        // 顯示通知
        setTimeout(() => {
          showPhoneNotification({
            title: 'X',
            message: `${conversationData.user.name} 已完成任務評估`,
            avatar: conversationData.user.avatar,
            leftIcon: 'x',
          });
        }, 1000);
      }
    } catch (error) {
      console.error('❌ [AI評估] 生成評估私信失敗:', error);
    }
  }

  // 處理AI商業任務付款
  async function handleAIBusinessPayment(transferMessage, businessTransfer, conversationData) {
    try {
      console.log('💰 [AI付款] 處理商業任務付款:', transferMessage);

      const amount = parseFloat(transferMessage.amount || 0);
      if (amount <= 0) return;

      // 更新錢包餘額
      await loadWalletData();
      const currentBalance = parseFloat(walletData.balance) || 0;
      walletData.balance = currentBalance + amount;

      // 添加交易記錄
      const senderName = conversationData.user?.name || '對方';
      let transactionDesc = '';

      if (transferMessage.note) {
        transactionDesc = `${senderName} - ${transferMessage.note}`;
      } else {
        transactionDesc = `商業轉帳尾款 - ${senderName}`;
      }

      const transaction = {
        id: 'business_payment_' + Date.now(),
        description: transactionDesc,
        amount: amount,
        timestamp: new Date().toISOString(),
        type: 'business_transfer_remaining_in',
      };

      walletData.transactions.unshift(transaction);
      await saveWalletData();

      // 更新商業轉帳狀態
      const xDb = getXDB();
      const businessTransfersId = `businessTransfers_${currentAccountId || 'main'}`;
      const savedData = await xDb.xAccountProfiles.get(businessTransfersId);

      if (savedData && savedData.data) {
        const transfer = savedData.data.find(t => t.transferId === businessTransfer.transferId);
        if (transfer) {
          transfer.taskStatus = 'completed';
          transfer.completedAt = new Date().toISOString();
          await xDb.xAccountProfiles.put(savedData);
          console.log('✅ [AI付款] 商業轉帳狀態已更新為已完成');
        }
      }

      console.log('✅ [AI付款] 付款完成，金額:', amount, '新餘額:', walletData.balance);

      // 顯示收款通知
      setTimeout(() => {
        showPhoneNotification({
          title: 'X Wallet',
          message: `已收款 $${amount.toFixed(2)}, 當前餘額 $${walletData.balance.toFixed(2)}`,
          avatar: window.userProfileData?.avatar,
          leftIcon: 'x',
        });
      }, 2000);
    } catch (error) {
      console.error('❌ [AI付款] 處理付款失敗:', error);
    }
  }

  // ▼▼▼ 【主要！！！】第二個情景：發帖生成器▼▼▼
  // 推進模式狀態（發帖生成器專用）
  let isTweetProgressMode = false;
  let tweetProgressLongPressTimer = null;

  // 計算兩個字串的相似度（0-1之間，1表示完全相同）
  function calculateSimilarity(str1, str2) {
    if (str1 === str2) return 1;
    if (str1.length === 0 || str2.length === 0) return 0;

    // 使用最長公共子序列（LCS）演算法的簡化版本
    const longer = str1.length > str2.length ? str1 : str2;
    const shorter = str1.length > str2.length ? str2 : str1;

    // 計算字元匹配度
    let matches = 0;
    const shorterChars = shorter.split('');
    const longerChars = longer.split('');

    shorterChars.forEach(char => {
      const index = longerChars.indexOf(char);
      if (index !== -1) {
        matches++;
        longerChars.splice(index, 1); // 移除已匹配的字元，避免重複計數
      }
    });

    // 相似度 = 匹配字元數 / 較長字串長度
    const similarity = matches / longer.length;

    // 額外檢測：如果較短字串完全包含在較長字串中，提高相似度
    if (longer.includes(shorter)) {
      return Math.max(similarity, shorter.length / longer.length);
    }

    return similarity;
  }

  async function generateAIResponseForTweet(tweetData, isReroll = false, isProgressMode = false) {
    try {
      // 從資料庫讀取API配置
      const db = getDB(); // 用於訪問API配置
      const xDb = getXDB(); // 用於訪問X專用設置

      const apiConfig = await db.apiConfig.get('main');
      if (!apiConfig || !apiConfig.proxyUrl || !apiConfig.apiKey || !apiConfig.model) {
        showXToast('請先配置API設置', 'error');
        return;
      }

      const { proxyUrl, apiKey, model } = apiConfig;

      // 從X設置中讀取配置（按帳號讀取）
      const settingsId = `xSettings_${currentAccountId || 'main'}`;
      const xSettings = await xDb.xSettings.get(settingsId);
      const userPrompt = xSettings?.systemPrompt || '';
      const worldSetting = xSettings?.worldSetting || '';
      const boundCharacters = xSettings?.boundCharacters || [];

      // 檢測推文類型
      const isAccountTweet = tweetData._source === 'account';
      const isUserTweet = tweetData.id && tweetData.id.startsWith('user_');
      const isBusinessPost = tweetData.isBusinessPost === true;

      let targetProfileInfo;
      let isBoundCharacterAccount = false; // 是否為綁定角色的帳戶
      let boundCharacterIdForAccount = null; // 綁定角色的ID
      let isUserOwnTweet = isUserTweet; // 是否為用戶自己的推文

      console.log('🔍 [發帖生成器] 推文類型檢測:', {
        isAccountTweet,
        isUserTweet,
        isBusinessPost,
        tweetId: tweetData.id,
      });

      if (isAccountTweet) {
        // 帳戶推文：構建帳戶資料資訊
        console.log('🔍 [AI生成] 檢測到帳戶推文，載入帳戶資料');

        // 嘗試從當前查看的帳戶獲取資料
        let accountData = currentViewingAccount;

        // 如果沒有，嘗試從資料庫載入
        if (!accountData && tweetData._accountHandle) {
          const cleanHandle = tweetData._accountHandle.replace('@', '');
          accountData = await xDb.xAccountProfiles.get(cleanHandle);
        }

        if (accountData) {
          const accountInfo = accountData.accountInfo || accountData;
          targetProfileInfo = {
            name: accountInfo.name,
            handle: accountInfo.handle,
            avatar: accountInfo.avatar,
            verified: accountInfo.verified || false,
            verificationType: accountInfo.verificationType || 'none',
            publicIdentity: accountInfo.publicIdentity || '',
            bio: accountInfo.bio || '',
            knownIdentityCharacters: [], // 帳戶沒有已知身份角色概念
          };
          console.log('✅ [AI生成] 已載入帳戶資料:', targetProfileInfo.name);

          // 檢查該帳戶是否為綁定角色
          if (boundCharacters && boundCharacters.length > 0) {
            const allXProfiles = await xDb.xCharacterProfiles.toArray();
            const cleanHandle = accountInfo.handle.replace('@', '');

            for (const charId of boundCharacters) {
              const xProfile = allXProfiles.find(p => p.characterId === charId);
              if (xProfile && xProfile.xHandle === cleanHandle) {
                isBoundCharacterAccount = true;
                boundCharacterIdForAccount = charId;
                console.log('🎭 [AI生成] 識別到綁定角色帳戶:', accountInfo.name, '(', charId, ')');
                break;
              }
            }
          }
        } else {
          // 如果找不到帳戶資料，使用推文中的使用者資訊
          console.warn('⚠️ [AI生成] 未找到帳戶資料，使用推文使用者資訊');
          targetProfileInfo = {
            name: tweetData.user.name,
            handle: tweetData.user.handle,
            avatar: tweetData.user.avatar,
            verified: tweetData.user.verified || false,
            verificationType: tweetData.user.verificationType || 'none',
            publicIdentity: '',
            bio: '',
            knownIdentityCharacters: [],
          };
        }
      } else if (isUserTweet) {
        // 用戶自己的推文：使用使用者X個人資料資訊
        console.log('✅ [發帖生成器] 檢測到用戶推文，使用使用者資料');
        targetProfileInfo = StringBuilders.buildUserXProfileInfo(window.userProfileData);
      } else {
        // 主頁推文（其他人發的）：使用統一資料獲取系統獲取發帖人資料
        console.log('🔍 [發帖生成器] 檢測到主頁推文，查詢發帖人資料:', tweetData.user.handle);

        try {
          const posterProfile = await StringBuilders.getUnifiedProfile(tweetData.user.handle, {
            userProfileInfo: window.userProfileData,
          });

          if (posterProfile) {
            console.log('✅ [發帖生成器] 已獲取發帖人資料:', posterProfile.name);

            // 檢查發帖人是否為綁定角色
            if (posterProfile.type === 'character' && boundCharacters.includes(posterProfile.characterId)) {
              isBoundCharacterAccount = true;
              boundCharacterIdForAccount = posterProfile.characterId;
              console.log('🎭 [發帖生成器] 發帖人是綁定角色:', posterProfile.name);
            }

            targetProfileInfo = {
              name: posterProfile.name,
              handle: posterProfile.handle,
              avatar: posterProfile.avatar,
              verified: posterProfile.verified || false,
              verificationType: posterProfile.xProfile?.xVerified ? 'verified' : 'none',
              publicIdentity: posterProfile.publicIdentity || '',
              bio: posterProfile.bio || '',
              knownIdentityCharacters: [], // 其他人的推文，不使用用戶的已知身份角色
            };

            isUserOwnTweet = false; // 明確標記這不是使用者自己的推文
          } else {
            console.warn('⚠️ [發帖生成器] 未找到發帖人資料，使用推文使用者資訊');
            targetProfileInfo = {
              name: tweetData.user.name,
              handle: tweetData.user.handle,
              avatar: tweetData.user.avatar,
              verified: tweetData.user.verified || false,
              verificationType: tweetData.user.verificationType || 'none',
              publicIdentity: '',
              bio: '',
              knownIdentityCharacters: [],
            };
            isUserOwnTweet = false;
          }
        } catch (error) {
          console.error('❌ [發帖生成器] 獲取發帖人資料失敗:', error);
          // 回退到使用推文中的使用者資訊
          targetProfileInfo = {
            name: tweetData.user.name,
            handle: tweetData.user.handle,
            avatar: tweetData.user.avatar,
            verified: tweetData.user.verified || false,
            verificationType: tweetData.user.verificationType || 'none',
            publicIdentity: '',
            bio: '',
            knownIdentityCharacters: [],
          };
          isUserOwnTweet = false;
        }
      }

      const userXProfileInfo = targetProfileInfo;

      console.log('📋 [發帖生成器] 最終資料資訊:', {
        name: userXProfileInfo.name,
        handle: userXProfileInfo.handle,
        isUserOwnTweet,
        isBoundCharacterAccount,
        boundCharacterIdForAccount,
      });

      // 獲取知道使用者身份的角色資訊（僅用於使用者自己的推文）
      let knownIdentityCharactersInfo = '';
      if (isUserOwnTweet && userXProfileInfo.knownIdentityCharacters.length > 0 && boundCharacters.length > 0) {
        const allChats = await db.chats.toArray();
        const knownCharacters = allChats.filter(
          chat => !chat.isGroup && userXProfileInfo.knownIdentityCharacters.includes(chat.id),
        );

        if (knownCharacters.length > 0) {
          knownIdentityCharactersInfo = '\n\n【知道用戶身份的角色】：';
          for (const char of knownCharacters) {
            let xProfile = await xDb.xCharacterProfiles.get(char.id);
            if (xProfile) {
              knownIdentityCharactersInfo += `\n- ${xProfile.xName} (${xProfile.xHandle}): 知道用戶身份，可能會對用戶的帖子進行互動`;
              if (char.history && char.history.length > 0) {
                const recentHistory = char.history.slice(-5);
                knownIdentityCharactersInfo += '\n  最近互動記憶：';
                recentHistory.forEach(msg => {
                  if (msg.role === 'assistant' && msg.content) {
                    knownIdentityCharactersInfo += `\n  - ${msg.content.substring(0, 80)}...`;
                  }
                });
              }
            }
          }
          knownIdentityCharactersInfo += '\n\n注意：這些角色可能會對用戶的帖子進行評論，但概率不要太高，要自然。';
        }
      }

      // Token計數器
      let tokenCount = 0;

      // 1. 提示詞 + 世界書
      let systemPrompt = StringBuilders.buildBaseSystemPrompt({
        userPrompt,
        worldSetting,
      });
      tokenCount = TokenUtils.logTokenUsage('發帖生成器', '基礎系統提示詞', systemPrompt, tokenCount);

      // 1.5. 獲取適用的世界書內容
      const worldBooksOptions = { boundCharacters: [] };
      if (isBoundCharacterAccount && boundCharacterIdForAccount) {
        // 如果發帖人是綁定角色，只傳入該角色ID
        worldBooksOptions.boundCharacters = [boundCharacterIdForAccount];
        console.log('📚 [發帖生成器] 載入綁定角色的世界書');
      } else if (isUserOwnTweet) {
        // 用戶自己的推文：傳入所有綁定角色
        worldBooksOptions.boundCharacters = boundCharacters;
        console.log('📚 [發帖生成器] 載入用戶所有綁定角色的世界書');
      } else {
        // 其他人的推文：不載入世界書
        worldBooksOptions.boundCharacters = [];
        console.log('📚 [發帖生成器] 跳過世界書（非用戶推文）');
      }

      const worldBooksContent = await StringBuilders.getApplicableWorldBooks('tweetDetail', worldBooksOptions);
      if (worldBooksContent) {
        systemPrompt += worldBooksContent;
        tokenCount = TokenUtils.logTokenUsage('發帖生成器', '世界書內容', worldBooksContent, tokenCount);
      }

      // 2. 核心任務說明（根據模式不同調整）
      const tweetAuthor = isUserOwnTweet ? '用戶' : `${userXProfileInfo.name} (${userXProfileInfo.handle})`;

      if (isProgressMode) {
        // 計算時間流逝
        const tweetTimestamp = tweetData.timestamp || Date.now();
        const now = Date.now();
        const minutesPassed = Math.floor((now - tweetTimestamp) / (1000 * 60));
        const hoursPassed = Math.floor(minutesPassed / 60);
        const daysPassed = Math.floor(hoursPassed / 24);

        let timePassedDesc;
        if (daysPassed > 0) {
          timePassedDesc = `${daysPassed}天${hoursPassed % 24}小時`;
        } else if (hoursPassed > 0) {
          timePassedDesc = `${hoursPassed}小時${minutesPassed % 60}分鐘`;
        } else {
          timePassedDesc = `${minutesPassed}分鐘`;
        }

        systemPrompt += `

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 核心任務：推進帖子互動 🎯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
你是X社交平臺的互動生成器。${tweetAuthor}的帖子已發佈一段時間，你的任務是：
✅ 生成**新的**評論和互動（在已有評論基礎上繼續）
✅ 更新互動資料（點贊、轉發、流覽量應該增加）
❌ 絕對不能生成${tweetAuthor}本人發表的任何內容
❌ 絕對不能重複已有評論的內容或觀點

**時間資訊**：
- 帖子發佈已過去：${timePassedDesc}
- 已有評論數量：${tweetData.comments?.length || 0} 條

**推進模式生成策略**：
1. **優先生成樓中樓回復**（70%）：
   - 對已有評論進行回復、補充或討論
   - 使用 replyTo 欄位指定回復物件
   - 可以贊同、質疑、或提出新角度

2. **次要生成新頂層評論**（30%）：
   - 必須帶有明顯的時間感（"剛看到"、"終於找到"、"現在才發現"等）
   - 角度必須與所有已有評論完全不同
   - 可以是遲到者的獨特視角或冷靜分析

3. **內容創新要求**：
   - 不要重複任何已有的觀點、表達或句式
   - 提供新的資訊、角度或情緒
   - 互動資料應反映熱度持續（點贊、轉發、流覽量增加）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━`;
      } else {
        systemPrompt += `

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🚫 核心任務說明 🚫
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
你是X社交平臺的互動生成器。${tweetAuthor}剛發佈了一條新帖子，你的任務是：
✅ 生成其他X平臺用戶對這條帖子的評論和反應
❌ 絕對不能生成${tweetAuthor}本人發表的任何內容

**明確：${tweetAuthor}已經發佈了推文，你只負責生成別人的回應！**

${
  !isUserOwnTweet && !isBoundCharacterAccount
    ? `⚠️ **特別注意**：這是${tweetAuthor}發佈的推文，與當前用戶無關。
- 應該生成普通路人用戶的評論
- 評論者是看到這條推文的陌生網友
- 不要假設評論者與${tweetAuthor}有任何私人關係`
    : ''
}
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━`;
      }

      const coreTaskSection = systemPrompt.substring(systemPrompt.lastIndexOf('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━'));
      tokenCount = TokenUtils.logTokenUsage('發帖生成器', '核心任務說明', coreTaskSection, tokenCount);

      // 3. 角色資料（互動反應場景）
      let charactersInfo = '';

      // 🔧 確定傳遞給角色資料的使用者資訊
      // 如果是綁定角色的推文，需要傳遞真實的使用者資料（用於判斷身份識別）
      // 如果是用戶自己的推文，傳遞使用者資料
      // 如果是其他人的推文，不載入角色資料
      const userInfoForCharacter =
        isBoundCharacterAccount || isUserOwnTweet ? StringBuilders.buildUserXProfileInfo(window.userProfileData) : null;

      if (isBoundCharacterAccount && boundCharacterIdForAccount) {
        // 如果發帖人是綁定角色，只載入該角色的信息
        console.log('📋 [發帖生成器] 發帖人是綁定角色，只載入該角色資訊（傳遞真實使用者資料以判斷身份識別）');
        charactersInfo = await StringBuilders.buildCompleteCharacterInfo(
          [boundCharacterIdForAccount],
          userInfoForCharacter, // 傳遞真實使用者資料
          'reaction',
        );
      } else if (isUserOwnTweet) {
        // 用戶自己的推文：載入所有綁定角色資訊（這些角色可能會評論）
        console.log('📋 [發帖生成器] 用戶推文，載入所有綁定角色資訊');
        charactersInfo = await StringBuilders.buildCompleteCharacterInfo(
          boundCharacters,
          userInfoForCharacter,
          'reaction',
        );
      } else {
        // 其他人的推文（非綁定角色）：不載入任何角色資訊，讓AI生成路人評論
        console.log('📋 [發帖生成器] 其他人的推文，不載入用戶角色（將生成路人評論）');
        charactersInfo = '';
      }

      if (charactersInfo) {
        systemPrompt += charactersInfo;
        tokenCount = TokenUtils.logTokenUsage('發帖生成器', '角色資料資訊', charactersInfo, tokenCount);
      } else {
        console.log('ℹ️ [發帖生成器] 跳過角色資料（非使用者推文或無綁定角色）');
      }

      // 添加角色關係冊（僅在用戶推文或綁定角色推文時）
      if ((isUserOwnTweet || isBoundCharacterAccount) && boundCharacters && boundCharacters.length > 0) {
        const relationshipsInfo = await StringBuilders.buildCharacterRelationships(boundCharacters, currentAccountId);
        if (relationshipsInfo) {
          systemPrompt += relationshipsInfo;
          tokenCount = TokenUtils.logTokenUsage('發帖生成器', '角色關係網絡', relationshipsInfo, tokenCount);
        }
      }

      if (knownIdentityCharactersInfo) {
        systemPrompt += knownIdentityCharactersInfo;
        tokenCount = TokenUtils.logTokenUsage('發帖生成器', '已知身份角色', knownIdentityCharactersInfo, tokenCount);
      }

      // 3.5. 檢測推文中的@提及，讀取被提及帳戶的資料
      let mentionedAccountsInfo = '';
      const mentionRegex = /@(\w+)/g;
      const mentions = [...tweetData.content.matchAll(mentionRegex)];

      if (mentions.length > 0) {
        console.log(`📢 [發帖生成器] 檢測到${mentions.length}個@提及`);
        const mentionHandles = [...new Set(mentions.map(m => m[1]))]; // 去重

        for (const handle of mentionHandles) {
          try {
            // 使用統一資料獲取系統
            // 如果是用戶自己的推文，傳遞使用者資料；否則傳遞發帖人資料
            const mentionedProfile = await StringBuilders.getUnifiedProfile(`@${handle}`, {
              userProfileInfo: isUserOwnTweet ? window.userProfileData : null,
            });

            if (mentionedProfile) {
              const mentionStart = systemPrompt.length;
              systemPrompt += `

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📢 被@提及的帳戶資料 📢
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
推文中提到了 ${mentionedProfile.handle}，以下是該帳戶的詳細資訊：
`;

              // 格式化資料
              systemPrompt += StringBuilders.formatProfileForPrompt(mentionedProfile, {
                includeType: true,
                includeTweets: true,
                includeRelationships: true,
              });

              systemPrompt += `
⚠️ 被@提及的影響：
- 該帳戶看到自己被@提及後，可能會來評論區互動
- 出現概率根據以下因素決定：
  * 與發帖者的關係（認識/陌生）
  * 推文內容的相關性
  * 該帳戶的活躍度和性格
- 如果該帳戶來評論，必須嚴格使用上述資料資訊
- 評論內容要符合被@的情境（如被請教、被吐槽、被感謝等）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;

              const mentionSection = systemPrompt.substring(mentionStart);
              tokenCount = TokenUtils.logTokenUsage(
                '發帖生成器',
                `@提及帳戶 ${mentionedProfile.handle}`,
                mentionSection,
                tokenCount,
              );
            }
          } catch (error) {
            console.error(`❌ [發帖生成器] 讀取@${handle}資料失敗:`, error);
          }
        }
      }

      // 4. 使用者資料
      const userConstraintsStart = systemPrompt.length;
      systemPrompt += StringBuilders.buildUniversalConstraints(userXProfileInfo);
      const userConstraints = systemPrompt.substring(userConstraintsStart);
      tokenCount = TokenUtils.logTokenUsage('發帖生成器', '使用者資料約束', userConstraints, tokenCount);

      // 4.5. 如果是推進模式，添加現有評論上下文
      if (isProgressMode && tweetData.comments && tweetData.comments.length > 0) {
        const existingCommentsStart = systemPrompt.length;
        systemPrompt += `

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
⚠️ 【已有評論上下文 - 嚴禁重複】⚠️
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
以下是該帖子**已存在**的所有評論（共${tweetData.comments.length}條），**絕對不能**生成與這些內容相似或重複的評論：

`;
        tweetData.comments.forEach((comment, index) => {
          systemPrompt += `${index + 1}. ${comment.user.name} (${comment.user.handle}): "${comment.content}"`;
          if (comment.image) {
            systemPrompt += ` [含圖片]`;
          }
          systemPrompt += `\n`;

          if (comment.replies && comment.replies.length > 0) {
            comment.replies.forEach(reply => {
              systemPrompt += `   └─ ${reply.user.name} (${reply.user.handle}): "${reply.content}"`;
              if (reply.image) {
                systemPrompt += ` [含圖片]`;
              }
              systemPrompt += `\n`;
            });
          }
        });

        systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🚫 【嚴格要求 - 必須遵守】🚫
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
1. **絕對禁止**重複上述任何評論的觀點、內容或表達方式
2. **絕對禁止**使用與上述評論相似的句式或措辭
3. **必須生成**全新的、不同角度的評論
4. 新評論應該：
   - 提出完全不同的觀點或看法
   - 使用不同的表達方式和語氣
   - 可以是對已有評論的**補充回復**（樓中樓，使用replyTo欄位）
   - 可以從時間角度切入（如"剛看到"、"終於找到這個帖子"等）
   - 可以是新角度的提問、質疑或討論
5. 如果實在找不到新角度，優先生成樓中樓回復而非新評論
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;

        const existingComments = systemPrompt.substring(existingCommentsStart);
        tokenCount = TokenUtils.logTokenUsage('發帖生成器', '已有評論上下文', existingComments, tokenCount);
      }

      systemPrompt += `

【生成要求】：
- 生成${isProgressMode ? '3-8' : '3-15'}條評論，內容多樣化（簡短/深度/表情符號），支援樓中樓回復，全年齡適宜
${
  isProgressMode
    ? `- ⚠️ **推進模式特殊要求**：
  * 優先生成樓中樓回復（對已有評論的回復）而非新的頂層評論
  * 新頂層評論必須有明顯的時間感（如"剛看到"、"現在才發現"等）
  * 新評論角度要與已有評論**完全不同**，不要重複任何觀點
  * 可以是後來者的補充、質疑、或從全新角度的討論`
    : ''
}
${
  isBusinessPost
    ? `- 💼 **商業推文特殊要求**：
  * 這是一條商業化推文（廣告/推廣性質），資料應該更高
  * 互動資料（點贊、轉發、流覽量）應該是普通推文的1.5-3倍
  * 評論區應該有30-50%是正面支持性評論（"支持！"、"好棒"、"已下單"等）
  * 20-30%是詢問相關資訊的評論（"在哪買"、"多少錢"、"怎麼聯繫"等）
  * 10-20%可以是中性或輕微質疑的評論（保持真實感）
  * 評論風格應該更像粉絲/潛在客戶，而非批評者
  * 如果用戶有較高知名度，應該體現出粉絲經濟效應`
    : ''
}
- 引用轉發處理：如帖子含引用內容，評論可涉及使用者觀點和被引用原內容
- 公眾身份影響：知名度越高，討論熱度和互動資料越多
- 除了綁定角色外，其他用戶頭像統一：https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg
- 圖片支援：評論可以包含文字圖片（10-20%的評論帶圖），用於展示圖片視頻等媒體，圖片描述應詳細具體

【🔒 隱私保護規則 - 路人評論限制】：
🚨 路人評論者（非綁定角色/關係NPC的普通用戶）只能基於X平臺公開信息：
  ✅ 可以使用：X姓名、X控制碼、X簡介、公開身份
  ❌ 禁止提及：真實姓名、真實職業、私人關係、未公開的身份資訊
  ❌ 禁止使用：只有親密關係才知道的稱呼（如"老師"、"同學"、"同事"等，除非是公開身份）
  ❌ 禁止提及：角色人設描述中的私密細節
  
示例說明：
- ✅ 正確："@handle 姐姐太美了"（基於公開身份"網紅"）
- ❌ 錯誤："@handle 張老師這節課講得真好"（洩露了真實職業"老師"和真實姓氏）
- ❌ 錯誤："@handle 李老師今天也這麼漂亮"（洩露了真實姓名）
  
⚠️ 只有已綁定的關係NPC才能提及私密資訊（因為他們是角色的私人關係）
【情侶角色回復規則】：
${
  userXProfileInfo.verificationType === 'couple' && userXProfileInfo.coupleCharacterName
    ? `- 用戶的情侶是 ${userXProfileInfo.coupleCharacterName}（公開關係）
- 出現概率應很低（10-20%，與帖子無關時更低）
- 評論圍繞帖子主題，自然體現親密關係但不過分強調
- 粉絲群體限制：僅當雙方為明星/網紅/公眾人物時才可能生成1-2條CP粉絲評論，普通情侶嚴禁生成"磕CP""嗑糖"等粉絲向評論`
    : ''
}

【JSON返回格式】：
\`\`\`json
{
  "stats": {retweets, likes, views, comments},
  "comments": [評論陣列]
}
\`\`\`

評論物件結構：
- user: {name, handle, avatar, verified}
- content: 評論文本
- timeOffset: 相對推文發佈的分鐘數（負數，如-5表示推文發佈後5分鐘的評論）
- image: {type: "description", content: "圖片文字描述"} (可選，10-20%的評論帶圖)
- replies: [回復陣列] (可選，樓中樓回復，不超過3層)
- replyTo: "@被回復者控制碼" (樓中樓回復時必填)

關鍵規則：
1. verified欄位必須是布林值(true/false)
2. stats中所有數位必須是純數位
3. timeOffset必須是負數，表示評論發佈在推文之後多少分鐘（如-5, -10, -30等）
4. 支援多層對話鏈：A評論 → B回復A(replyTo:"@A") → C回復B(replyTo:"@B")`;

      const formatSection = systemPrompt.substring(systemPrompt.lastIndexOf('【JSON返回格式】'));
      tokenCount = TokenUtils.logTokenUsage('發帖生成器', 'JSON格式要求', formatSection, tokenCount);

      // 構建消息內容，支援圖片識別
      const messageContent = [];

      // 添加基礎文本內容
      let contentText = `請為這條推文生成社交互動資料：

推文內容："${tweetData.content}"
${tweetData.location ? `位置：${tweetData.location}` : ''}`;

      // 如果有附帶連結，添加完整連結資訊
      if (tweetData.link) {
        contentText += '\n\n【附帶連結】：';
        if (tweetData.link.title) contentText += `\n標題：${tweetData.link.title}`;
        if (tweetData.link.url) contentText += `\n地址：${tweetData.link.url}`;
        if (tweetData.link.description) contentText += `\n描述：${tweetData.link.description}`;
        if (tweetData.link.thumbnail) contentText += '\n[含連結首圖]';
      }

      // 如果有引用內容，添加引用資訊
      if (tweetData.quotedTweet) {
        const quoted = tweetData.quotedTweet;
        const quotedType = quoted.type === 'tweet' ? '推文' : '評論';
        contentText += `

【引用${quotedType}】：
原作者：${quoted.user.name} (${quoted.user.handle})${quoted.user.verified ? ' ✓已認證' : ''}
發佈時間：${quoted.time}
原內容："${quoted.content}"`;

        // 如果引用內容包含圖片，添加圖片資訊
        if (quoted.image) {
          if (quoted.image.type === 'description') {
            contentText += `
原圖片描述：${quoted.image.content}`;
          } else if (quoted.image.type === 'upload') {
            contentText += `
原圖片：包含上傳的圖片內容`;
          }
        }

        // 如果引用內容包含位置資訊
        if (quoted.location) {
          contentText += `
原位置：${quoted.location}`;
        }

        contentText += `

注意：這是一條引用轉發，用戶對原${quotedType}進行了評論並轉發。AI回復應該考慮到這個引用關係和上下文，生成的評論可能會同時涉及用戶的評論和被引用的原內容。`;
      }

      messageContent.push({ type: 'text', text: contentText });

      // 如果有上傳的圖片，添加圖片內容
      if (tweetData.image) {
        if (tweetData.image.type === 'upload' && tweetData.image.content) {
          // 單圖上傳
          messageContent.push({
            type: 'image_url',
            image_url: { url: tweetData.image.content },
          });
        } else if (tweetData.image.type === 'uploads' && tweetData.image.images && tweetData.image.images.length > 0) {
          // 多圖上傳
          tweetData.image.images.forEach((img, index) => {
            if (img.content) {
              messageContent.push({
                type: 'image_url',
                image_url: { url: img.content },
              });
            }
          });
        } else if (tweetData.image.type === 'description') {
          // 文字描述
          messageContent.push({
            type: 'text',
            text: `圖片描述：${tweetData.image.content}`,
          });
        }
      }

      const messages = [{ role: 'user', content: messageContent }];

      // 記錄上下文資訊token
      const contextText = messageContent.map(c => c.text || '[圖片]').join(' ');
      tokenCount = TokenUtils.logTokenUsage('發帖生成器', '上下文信息', contextText, tokenCount);

      // 最終統計
      TokenUtils.logFinalPrompt('發帖生成器', systemPrompt, contextText);

      // 判斷API類型並發送請求
      let isGemini = proxyUrl.includes('generativelanguage');
      let response;

      if (isGemini) {
        // 為X社交頁面創建正確的Gemini請求配置
        const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models';
        const geminiConfig = {
          url: `${GEMINI_API_URL}/${model}:generateContent?key=${getRandomValue(apiKey)}`,
          data: {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              contents: [
                {
                  parts: [
                    {
                      text:
                        systemPrompt +
                        '\n\n' +
                        messages
                          .map(m =>
                            Array.isArray(m.content) ? m.content.map(c => c.text || '[圖片]').join(' ') : m.content,
                          )
                          .join('\n'),
                    },
                  ],
                },
              ],
              generationConfig: {
                temperature: 0.8,
              },
            }),
          },
        };
        response = await fetch(geminiConfig.url, geminiConfig.data);
      } else {
        const openAiPayload = {
          model: model,
          messages: [{ role: 'system', content: systemPrompt }, ...messages],
          temperature: 0.8,
          stream: false,
        };
        response = await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${apiKey}`,
          },
          body: JSON.stringify(openAiPayload),
        });
      }

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(`API錯誤: ${response.status} - ${errorData.error?.message || response.statusText}`);
      }

      const data = await response.json();
      let aiResponseContent;

      if (isGemini) {
        aiResponseContent = getGeminiResponseText(data);
      } else {
        // OpenAI格式
        aiResponseContent = data.choices?.[0]?.message?.content || '';
      }

      console.log('AI原始回應:', aiResponseContent);

      // 調試使用者身份識別資訊
      console.log('使用者身份識別調試資訊（發帖AI回復）:');
      console.log('- 使用者X資料:', userXProfileInfo);
      console.log('- 知道用戶身份的角色數量:', userXProfileInfo.knownIdentityCharacters.length);
      if (knownIdentityCharactersInfo) {
        console.log('- 知道使用者身份的角色資訊已添加到AI上下文');
      }

      // 解析AI返回的JSON資料
      const cleanedResponse = aiResponseContent
        .replace(/```json\s*/, '')
        .replace(/```\s*$/, '')
        .trim();

      if (!cleanedResponse) {
        throw new Error('AI返回了空的回應內容');
      }

      let interactionData;
      try {
        interactionData = JSON.parse(cleanedResponse);
      } catch (parseError) {
        console.error('JSON解析失敗:', parseError);
        console.error('嘗試解析的內容:', cleanedResponse);
        throw new Error(`AI返回的資料不是有效的JSON格式: ${parseError.message}`);
      }

      // 🚫 篩選用戶身份冒用（最優先）
      interactionData = StringBuilders.filterUserImpersonation(
        interactionData,
        userXProfileInfo.handle,
        userXProfileInfo.name,
      );

      // 🔧 強制修正所有頭像
      await StringBuilders.enforceAvatarRules(interactionData, userXProfileInfo.handle);

      // 驗證資料格式
      if (!interactionData.stats || !interactionData.comments) {
        throw new Error('AI返回的資料格式不正確');
      }

      // 如果是推進模式，檢測並過濾重複評論
      if (isProgressMode && tweetData.comments && tweetData.comments.length > 0) {
        const existingComments = tweetData.comments;
        const newComments = interactionData.comments || [];

        // 過濾重複評論
        const filteredComments = newComments.filter(newComment => {
          const newContent = newComment.content.toLowerCase().trim();

          // 檢查是否與現有評論重複
          const isDuplicate = existingComments.some(existingComment => {
            const existingContent = existingComment.content.toLowerCase().trim();

            // 相似度檢測：完全相同或高度相似（超過70%相同）
            if (existingContent === newContent) return true;

            // 計算簡單的相似度（基於公共子串）
            const similarity = calculateSimilarity(newContent, existingContent);
            if (similarity > 0.7) {
              console.log(`🔍 [重複檢測] 發現相似評論 (${(similarity * 100).toFixed(0)}%):`, {
                existing: existingComment.content,
                new: newComment.content,
              });
              return true;
            }

            // 檢查樓中樓回復是否重複
            if (existingComment.replies && existingComment.replies.length > 0) {
              return existingComment.replies.some(reply => {
                const replyContent = reply.content.toLowerCase().trim();
                if (replyContent === newContent) return true;
                const replySimilarity = calculateSimilarity(newContent, replyContent);
                if (replySimilarity > 0.7) {
                  console.log(`🔍 [重複檢測] 發現與樓中樓回復相似的評論 (${(replySimilarity * 100).toFixed(0)}%)`);
                  return true;
                }
                return false;
              });
            }

            return false;
          });

          return !isDuplicate;
        });

        const removedCount = newComments.length - filteredComments.length;
        if (removedCount > 0) {
          console.log(`✅ [去重] 移除了 ${removedCount} 條重複評論，保留 ${filteredComments.length} 條新評論`);
          interactionData.comments = filteredComments;
        }

        // 如果所有新評論都被過濾掉了，提示用戶
        if (filteredComments.length === 0) {
          showXToast('AI生成的評論與已有內容重複，已自動過濾', 'warning');
          return; // 不保存重複內容
        }
      }

      // 為評論分配ID和時間戳記
      const timestamp = Date.now();
      let tweetTimestamp = tweetData.timestamp || timestamp;

      // 確保 tweetTimestamp 是數位格式（處理可能的Date物件或ISO字串）
      if (typeof tweetTimestamp !== 'number') {
        if (tweetTimestamp instanceof Date) {
          tweetTimestamp = tweetTimestamp.getTime();
        } else if (typeof tweetTimestamp === 'string') {
          tweetTimestamp = new Date(tweetTimestamp).getTime();
        } else {
          tweetTimestamp = timestamp;
        }
      }

      // 驗證轉換後的時間戳記有效性
      if (isNaN(tweetTimestamp) || tweetTimestamp <= 0) {
        console.warn('⚠️ [發帖生成器] 推文時間戳記無效，使用當前時間');
        tweetTimestamp = timestamp;
      }

      interactionData.comments.forEach((comment, index) => {
        comment.id = `ai_${timestamp}_${index}`;

        // 將timeOffset轉換為實際時間戳記
        if (isProgressMode) {
          // 推進模式：新評論應該是最近發佈的，使用當前時間附近
          // 忽略AI生成的timeOffset，因為它是相對于推文發佈時間的
          const minutesAgo = Math.floor(Math.random() * 60); // 0-60分鐘前
          comment.timestamp = timestamp - minutesAgo * 60 * 1000;
          delete comment.timeOffset;
        } else {
          // 正常模式：基於推文發佈時間計算
          if (comment.timeOffset !== undefined) {
            // timeOffset是負數，表示推文發佈後多少分鐘
            comment.timestamp = tweetTimestamp + Math.abs(comment.timeOffset) * 60 * 1000;
            delete comment.timeOffset; // 刪除臨時欄位
          } else if (!comment.timestamp) {
            // 如果沒有timeOffset，隨機生成一個時間戳記
            comment.timestamp = tweetTimestamp + (5 + Math.random() * 30) * 60 * 1000;
          }
        }

        // 為回復分配ID和時間戳記
        if (comment.replies && comment.replies.length > 0) {
          comment.replies.forEach((reply, replyIndex) => {
            reply.id = `ai_${timestamp}_${index}_${replyIndex}`;

            if (isProgressMode) {
              // 推進模式：回復時間應該在評論之後幾分鐘
              reply.timestamp = comment.timestamp + (1 + Math.random() * 10) * 60 * 1000;
              delete reply.timeOffset;
            } else {
              // 正常模式：基於推文發佈時間計算
              if (reply.timeOffset !== undefined) {
                reply.timestamp = tweetTimestamp + Math.abs(reply.timeOffset) * 60 * 1000;
                delete reply.timeOffset;
              } else if (!reply.timestamp) {
                // 回復時間晚於評論
                reply.timestamp = comment.timestamp + (1 + Math.random() * 10) * 60 * 1000;
              }
            }
          });
        }
      });

      // 更新推文詳情頁面的資料
      await updateTweetDetailWithAI(tweetData.id, interactionData, isReroll, isProgressMode);

      // 如果當前顯示的是這條推文的詳情頁，重新載入完整資料並顯示
      const detailPage = document.getElementById('x-tweet-detail-page');
      if (detailPage && detailPage.style.display === 'flex') {
        const currentTweetData = sessionStorage.getItem('currentTweetData');
        if (currentTweetData) {
          const currentTweet = JSON.parse(currentTweetData);
          if (currentTweet.id === tweetData.id) {
            // 從資料庫重新載入最新的推文資料（包含AI反應）
            const db = getXDB();
            const accountTweetsId = `userTweets_${currentAccountId || 'main'}`;
            const userTweets = await db.xUserTweets.get(accountTweetsId);
            if (userTweets) {
              const updatedTweet = userTweets.tweets.find(t => t.id === tweetData.id);
              if (updatedTweet) {
                await showTweetDetail(updatedTweet);
                console.log('✅ 詳情頁已刷新，顯示最新AI反應');
              }
            }
          }
        }
      }

      // 顯示手機樣式通知
      const isEnglish = currentLanguage === 'en';
      const userAvatar = window.userProfileData?.avatar || 'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg';
      showPhoneNotification({
        title: 'X',
        message: isProgressMode
          ? isEnglish
            ? 'Your post interaction has been progressed!'
            : '帖子互動已推進！'
          : isEnglish
          ? 'Someone replied to your post!'
          : '你的帖子有人回復了哦！',
        avatar: userAvatar,
        leftIcon: 'x',
      });

      // 🎁 如果是商業推文且不是重新生成/推進模式，觸發打賞生成器
      if (isBusinessPost && !isReroll && !isProgressMode) {
        console.log('🎁 [打賞生成器] 檢測到商業推文，開始生成打賞資料');
        // 非同步執行，不阻塞主流程
        generateTipsForBusinessPost(tweetData, interactionData).catch(err => {
          console.error('生成打賞失敗（靜默）:', err);
        });
      }

      // 🔓 檢測拉黑解除觸發（如果推文中@了某人）
      if (!isReroll && !isProgressMode) {
        const mentionRegex = /@(\w+)/g;
        const mentions = [...tweetData.content.matchAll(mentionRegex)];

        if (mentions.length > 0 && userXProfileInfo && userXProfileInfo.handle) {
          const userHandle = userXProfileInfo.handle;

          // 非同步檢測每個@提及
          mentions.forEach(match => {
            const targetHandle = `@${match[1]}`;
            checkUnblockTrigger(userHandle, targetHandle, 'mention', tweetData.content).catch(err => {
              console.error('拉黑解除檢測失敗（靜默）:', err);
            });
          });
        }
      }
    } catch (error) {
      console.error('生成AI回復失敗:', error);
      showXToast(`回復生成失敗: ${error.message}`, 'error');
    }
  }

  // 切換推進模式（發帖生成器專用）
  window.toggleTweetProgressMode = function () {
    // 檢查當前推文類型
    const currentTweetData = sessionStorage.getItem('currentTweetData');
    if (currentTweetData) {
      try {
        const tweet = JSON.parse(currentTweetData);
        const isAccountTweet = tweet._source === 'account';
        const isSearchTweet = tweet._source === 'search';

        // 帳戶推文和搜索推文只能使用推進模式，不允許切換到重回
        if ((isAccountTweet || isSearchTweet) && isTweetProgressMode) {
          showXToast('該推文只支援推進模式', 'warning');
          return;
        }
      } catch (e) {
        console.warn('解析推文數據失敗:', e);
      }
    }

    isTweetProgressMode = !isTweetProgressMode;
    updateTweetRerollButtonUI();

    if (isTweetProgressMode) {
      showXToast('已切換到推進模式 - 將追加新評論', 'success');
    } else {
      showXToast('已切換到重新生成模式 - 將覆蓋現有評論', 'info');
    }
  };

  // 更新重回按鈕UI（發帖生成器專用）
  function updateTweetRerollButtonUI() {
    const rerollBtn = document.getElementById('reroll-replies-btn');
    if (!rerollBtn) return;

    // 獲取當前主題的文本顏色
    const textColor =
      getComputedStyle(document.getElementById('x-social-screen')).getPropertyValue('--x-text-primary').trim() ||
      '#fff';

    // 檢查當前推文類型
    let isAccountOrSearchTweet = false;
    const currentTweetData = sessionStorage.getItem('currentTweetData');
    if (currentTweetData) {
      try {
        const tweet = JSON.parse(currentTweetData);
        isAccountOrSearchTweet = tweet._source === 'account' || tweet._source === 'search';
      } catch (e) {
        console.warn('解析推文數據失敗:', e);
      }
    }

    if (isTweetProgressMode) {
      // 推進模式 - 心電圖圖示
      rerollBtn.innerHTML = `
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="${textColor}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M3 12h4l3 8l4 -16l3 8h4" />
        </svg>
      `;
      rerollBtn.setAttribute(
        'title',
        isAccountOrSearchTweet ? '推進帖子互動（追加新評論）' : '推進帖子互動（追加新評論）\n長按切換到重新生成模式',
      );
    } else {
      // 重新生成模式 - 星形圖示（僅使用者推文可用）
      rerollBtn.innerHTML = `
        <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: ${textColor};">
          <g>
            <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z" />
          </g>
        </svg>
      `;
      rerollBtn.setAttribute('title', '重新生成回復\n長按切換到推進模式');
    }
  }

  // 長按事件處理（發帖生成器專用）
  window.handleTweetRerollButtonMouseDown = function () {
    tweetProgressLongPressTimer = setTimeout(() => {
      toggleTweetProgressMode();
    }, 800);
  };

  window.handleTweetRerollButtonMouseUp = function () {
    if (tweetProgressLongPressTimer) {
      clearTimeout(tweetProgressLongPressTimer);
      tweetProgressLongPressTimer = null;
    }
  };

  // 重新生成AI回復或推進評論
  async function rerollAIReplies() {
    // 清除長按計時器
    if (tweetProgressLongPressTimer) {
      clearTimeout(tweetProgressLongPressTimer);
      tweetProgressLongPressTimer = null;
    }

    try {
      // 獲取當前推文ID
      const currentTweetId = getCurrentTweetId();
      if (!currentTweetId) {
        showXToast('無法獲取當前推文資訊', 'error');
        return;
      }

      // 獲取推文資料
      const xTweetsData = await getXTweetsData();
      const currentTweet = xTweetsData.find(tweet => tweet.id === currentTweetId);
      if (!currentTweet) {
        showXToast('未找到推文數據', 'error');
        return;
      }

      // 檢查推文類型並記錄日誌
      const isAccountTweet = currentTweet._source === 'account';
      const isSearchTweet = currentTweet._source === 'search';
      const isUserTweet = currentTweet.id && currentTweet.id.startsWith('user_');

      console.log(`🔄 [重回/推進] 推文類型:`, {
        isAccountTweet,
        isSearchTweet,
        isUserTweet,
        currentMode: isTweetProgressMode ? '推進模式' : '重回模式',
        tweetId: currentTweetId,
      });

      // 安全檢查：帳戶推文和搜索推文只能使用推進模式
      if ((isAccountTweet || isSearchTweet) && !isTweetProgressMode) {
        console.warn('⚠️ [重回/推進] 帳戶/搜索推文不支援重回模式，自動切換到推進模式');
        isTweetProgressMode = true;
        updateTweetRerollButtonUI();
      }

      // 顯示載入狀態
      const rerollBtn = document.getElementById('reroll-replies-btn');
      const originalHTML = rerollBtn.innerHTML;
      const textColor =
        getComputedStyle(document.getElementById('x-social-screen')).getPropertyValue('--x-text-primary').trim() ||
        '#fff';
      rerollBtn.innerHTML = `
                 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: ${textColor}; animation: spin 1s linear infinite;">
                   <g>
                  <path d="M12 4V2A10 10 0 0 0 2 12h2a8 8 0 0 1 8-8z" />
                   </g>
                 </svg>
               `;
      rerollBtn.style.pointerEvents = 'none';

      // 根據模式和推文類型顯示不同提示
      let toastMessage = '正在推進帖子互動...';
      if (!isTweetProgressMode && isUserTweet) {
        toastMessage = '正在重新生成回復...';
      } else if (isAccountTweet) {
        toastMessage = '正在推進帳戶推文互動...';
      } else if (isSearchTweet) {
        toastMessage = '正在推進搜索推文互動...';
      }
      showXToast(toastMessage, 'info');

      // 調用AI生成（傳遞推進模式參數）
      await generateAIResponseForTweet(currentTweet, !isTweetProgressMode, isTweetProgressMode);

      // 恢復按鈕狀態
      rerollBtn.innerHTML = originalHTML;
      rerollBtn.style.pointerEvents = 'auto';
    } catch (error) {
      console.error('AI回復操作失敗:', error);
      showXToast(isTweetProgressMode ? '推進失敗，請檢查網路連接' : '重新生成失敗，請檢查網路連接', 'error');

      // 恢復按鈕狀態
      const rerollBtn = document.getElementById('reroll-replies-btn');
      updateTweetRerollButtonUI();
      rerollBtn.style.pointerEvents = 'auto';
    }
  }

  // 獲取當前顯示的推文ID
  function getCurrentTweetId() {
    const tweetDetailContainer = document.getElementById('tweet-detail-container');
    return tweetDetailContainer ? tweetDetailContainer.getAttribute('data-tweet-id') : null;
  }

  // 獲取推文資料 - 簡化版本，直接返回當前推文資料
  async function getXTweetsData() {
    // 因為推文詳情頁面只顯示單個推文，我們可以從DOM中重構資料
    const currentTweetId = getCurrentTweetId();
    if (!currentTweetId) return [];

    // 從sessionStorage獲取推文資料（如果有）
    const tweetData = sessionStorage.getItem('currentTweetData');
    if (tweetData) {
      try {
        return [JSON.parse(tweetData)];
      } catch (e) {
        console.warn('無法解析推文資料:', e);
      }
    }

    return [];
  }

  // ▼▼▼ 【次要】打賞生成器：為商業推文生成隨機打賞 ▼▼▼
  /**
   * 為商業推文生成打賞資料
   * @param {Object} tweetData - 推文數據
   * @param {Object} interactionData - AI生成的互動資料
   */
  async function generateTipsForBusinessPost(tweetData, interactionData) {
    try {
      console.log('🎁 [打賞生成器] 開始為商業推文生成打賞');

      // 從資料庫讀取API配置
      const db = getDB();
      const xDb = getXDB();

      const apiConfig = await db.apiConfig.get('main');
      if (!apiConfig || !apiConfig.proxyUrl || !apiConfig.apiKey || !apiConfig.model) {
        console.error('🎁 [打賞生成器] API配置不完整，跳過打賞生成');
        return;
      }

      const { proxyUrl, apiKey, model } = apiConfig;

      // 獲取使用者X資料
      const userXProfileInfo = StringBuilders.buildUserXProfileInfo(window.userProfileData);

      // 構建AI提示詞
      let systemPrompt = `你是X社交平臺的打賞生成器。用戶剛發佈了一條商業推文（廣告/推廣性質），現在需要生成粉絲/支持者的打賞記錄。

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 核心任務：生成打賞記錄 🎯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

**使用者資訊**：
- 用戶名：${userXProfileInfo.name}
- 用戶控制碼：${userXProfileInfo.handle}
- 認證狀態：${userXProfileInfo.verified ? '已認證' : '未認證'}
${userXProfileInfo.publicIdentity ? `- 公眾身份：${userXProfileInfo.publicIdentity}` : ''}
- 粉絲影響力：${userXProfileInfo.publicIdentity ? '有一定影響力' : '普通用戶'}

**商業推文內容**：
"${tweetData.content}"

**推文資料表現**：
- 👍 喜歡數：${interactionData.stats.likes}
- 🔄 轉發數：${interactionData.stats.retweets}
- 💬 評論數：${interactionData.stats.comments}
- 👀 流覽量：${interactionData.stats.views}

**評論區回饋**（前5條）：
${
  interactionData.comments && interactionData.comments.length > 0
    ? interactionData.comments
        .slice(0, 5)
        .map((c, i) => `${i + 1}. ${c.user.name}: "${c.content}"`)
        .join('\n')
    : '暫無評論'
}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
💰 打賞生成規則 💰
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

**數量規則**：
根據推文資料表現和用戶影響力生成3-8條打賞記錄：
- 流覽量 < 1000：生成3-4條
- 流覽量 1000-5000：生成4-6條
- 流覽量 > 5000：生成6-8條
- 如果用戶有公眾身份，+1條

**金額規則**：
根據使用者影響力和資料表現：
- 普通用戶：每條 $5-$30
- 有公眾身份：每條 $10-$50
- 認證用戶：每條 $15-$80
- 如果推文資料特別好（點贊>500），可能出現1-2條大額打賞（$50-$150）

**打賞者信息**：
- name: 粉絲/支持者的名字（真實感，不要太誇張）
- handle: X平臺控制碼（格式：@username）
- note: 打賞備註（簡短、真誠、與推文內容相關）

**備註示例**：
- "支持！"
- "很棒的產品！"
- "已下單~"
- "期待後續"
- "感謝分享"
- "繼續加油！"
- "值得推薦"

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📋 JSON返回格式 📋
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

\`\`\`json
{
  "tips": [
    {
      "name": "打賞者姓名",
      "handle": "@username",
      "amount": 25.00,
      "note": "打賞備註"
    }
  ]
}
\`\`\`

**重要規則**：
1. amount必須是數位類型，保留兩位元小數
2. handle必須以@開頭
3. note要簡短（不超過20字）、真誠、與推文內容相關
4. 打賞者不能是用戶本人
5. 每條打賞記錄獨立，不要重複`;

      const messages = [
        {
          role: 'user',
          content: '請根據以上資訊生成打賞記錄。',
        },
      ];

      // 判斷API類型並發送請求
      let isGemini = proxyUrl.includes('generativelanguage');
      let response;

      if (isGemini) {
        const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models';
        const geminiConfig = {
          url: `${GEMINI_API_URL}/${model}:generateContent?key=${getRandomValue(apiKey)}`,
          data: {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              contents: [
                {
                  parts: [{ text: systemPrompt + '\n\n' + messages[0].content }],
                },
              ],
              generationConfig: {
                temperature: 0.8,
              },
            }),
          },
        };
        response = await fetch(geminiConfig.url, geminiConfig.data);
      } else {
        const openAiPayload = {
          model: model,
          messages: [{ role: 'system', content: systemPrompt }, ...messages],
          temperature: 0.8,
          stream: false,
        };
        response = await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${apiKey}`,
          },
          body: JSON.stringify(openAiPayload),
        });
      }

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(`API錯誤: ${response.status} - ${errorData.error?.message || response.statusText}`);
      }

      const data = await response.json();
      let aiResponseContent;

      if (isGemini) {
        aiResponseContent = getGeminiResponseText(data);
      } else {
        aiResponseContent = data.choices?.[0]?.message?.content || '';
      }

      console.log('🎁 [打賞生成器] AI原始回應:', aiResponseContent);

      // 解析AI返回的JSON資料
      const cleanedResponse = aiResponseContent
        .replace(/```json\s*/, '')
        .replace(/```\s*$/, '')
        .trim();

      let tipsData;
      try {
        tipsData = JSON.parse(cleanedResponse);
      } catch (parseError) {
        console.error('🎁 [打賞生成器] JSON解析失敗:', parseError);
        throw new Error(`AI返回的資料不是有效的JSON格式: ${parseError.message}`);
      }

      if (!tipsData.tips || !Array.isArray(tipsData.tips)) {
        throw new Error('AI返回的資料格式不正確');
      }

      console.log(`🎁 [打賞生成器] 成功生成${tipsData.tips.length}條打賞記錄`);

      // 調度打賞通知（在5小時內隨機時間觸發）
      scheduleTipNotifications(tweetData.id, tipsData.tips);
    } catch (error) {
      console.error('🎁 [打賞生成器] 生成打賞失敗:', error);
      throw error;
    }
  }

  /**
   * 調度打賞通知，在5小時內隨機時間觸發
   * @param {string} tweetId - 推文ID
   * @param {Array} tips - 打賞記錄陣列
   */
  function scheduleTipNotifications(tweetId, tips) {
    console.log(`🎁 [打賞調度] 開始調度${tips.length}條打賞通知`);

    const FIVE_HOURS_MS = 5 * 60 * 60 * 1000; // 5小時的毫秒數
    const now = Date.now();

    tips.forEach((tip, index) => {
      // 在5小時內隨機生成一個觸發時間
      const randomDelay = Math.random() * FIVE_HOURS_MS;

      console.log(`🎁 [打賞調度] 打賞 #${index + 1} 將在 ${Math.round(randomDelay / 1000 / 60)} 分鐘後觸發`);

      // 設置計時器
      setTimeout(() => {
        processTipNotification(tweetId, tip);
      }, randomDelay);
    });
  }

  /**
   * 處理單個打賞通知
   * @param {string} tweetId - 推文ID
   * @param {Object} tip - 打賞數據
   */
  async function processTipNotification(tweetId, tip) {
    try {
      console.log('🎁 [打賞通知] 觸發打賞:', tip);

      // 1. 更新錢包餘額
      await loadWalletData();

      if (!walletData.isActivated) {
        console.warn('🎁 [打賞通知] 錢包未啟動，跳過打賞');
        return;
      }

      const amount = parseFloat(tip.amount);
      walletData.balance += amount;

      // 2. 添加交易記錄
      const transaction = {
        id: 'tip_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
        description: `來自 ${tip.name} 的打賞`,
        amount: amount,
        timestamp: new Date().toISOString(),
        type: 'tip',
        note: tip.note,
        tipper: {
          name: tip.name,
          handle: tip.handle,
        },
        tweetId: tweetId,
      };

      walletData.transactions.unshift(transaction);

      // 3. 保存錢包資料
      await saveWalletData();

      console.log(`🎁 [打賞通知] 打賞已入帳: +$${amount.toFixed(2)}`);

      // 4. 顯示手機樣式通知
      showPhoneNotification({
        title: `收到來自 ${tip.name} 的贈金`,
        message: `+$${amount.toFixed(2)} - ${tip.note}`,
        avatar: window.userProfileData?.avatar,
        leftIcon: 'custom',
        leftIconHtml: `
          <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: #22c55e;">
            <g><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm.31-8.86c-1.77-.45-2.34-.94-2.34-1.67 0-.84.79-1.43 2.1-1.43 1.38 0 1.9.66 1.94 1.64h1.71c-.05-1.34-.87-2.57-2.49-2.97V5H10.9v1.69c-1.51.32-2.72 1.3-2.72 2.81 0 1.79 1.49 2.69 3.66 3.21 1.95.46 2.34 1.15 2.34 1.87 0 .53-.39 1.39-2.1 1.39-1.6 0-2.23-.72-2.32-1.64H8.04c.1 1.7 1.36 2.66 2.86 2.97V19h2.34v-1.67c1.52-.29 2.72-1.16 2.73-2.77-.01-2.2-1.9-2.96-3.66-3.42z"></path></g>
          </svg>
        `,
        duration: 4000,
      });

      // 5. 顯示toast提示
      showXToast(`收到打賞 +$${amount.toFixed(2)}`, 'success');
    } catch (error) {
      console.error('🎁 [打賞通知] 處理打賞失敗:', error);
    }
  }
  // ▲▲▲ 【次要】打賞生成器 ▲▲▲

  // ▲▲▲ 【主要！！！】第二個情景：發帖生成器 ▲▲▲

  // 保存用戶發佈的帖子
  async function saveUserTweet(tweetData) {
    try {
      const db = getXDB();
      const accountTweetsId = `userTweets_${currentAccountId || 'main'}`;

      // 獲取當前帳戶的推文資料
      let userTweets = await db.xUserTweets.get(accountTweetsId);
      if (!userTweets) {
        userTweets = { id: accountTweetsId, tweets: [] };
      }

      // 為推文添加帳戶ID標識
      tweetData.accountId = currentAccountId || 'main';

      // 添加新推文到開頭（最新的在前面）
      userTweets.tweets.unshift(tweetData);

      // 保存更新後的資料
      await db.xUserTweets.put(userTweets);

      console.log('用戶推文已保存到帳戶:', currentAccountId, tweetData);

      // 🔔 自動觸發第十個情景：為最新推文生成 Mentions 通知
      // 非同步執行，不阻塞主流程
      generateMentionsForLatestTweet(tweetData).catch(err => {
        console.error('生成Mentions通知失敗（靜默）:', err);
      });
    } catch (error) {
      console.error('保存用戶推文失敗:', error);
    }
  }

  // 獲取當前帳戶發佈的所有帖子
  async function getUserTweets() {
    try {
      const db = getXDB();
      const accountTweetsId = `userTweets_${currentAccountId || 'main'}`;

      const userTweets = await db.xUserTweets.get(accountTweetsId);
      return userTweets ? userTweets.tweets : [];
    } catch (error) {
      console.error('獲取用戶推文失敗:', error);
      return [];
    }
  }

  // 多選刪除相關變數
  let isMultiSelectMode = false;
  let selectedTweets = new Set();

  // 顯示推文操作功能表（置頂/刪除）
  function showTweetActionMenu(tweetId, event) {
    // 阻止事件冒泡
    if (event) {
      event.preventDefault();
      event.stopPropagation();
    }

    // 移除已存在的菜單
    const existingMenu = document.getElementById('tweet-action-menu');
    if (existingMenu) {
      existingMenu.remove();
    }

    // 獲取推文資料
    getUserTweets().then(userTweets => {
      const tweet = userTweets.find(t => t.id === tweetId);
      if (!tweet) return;

      const isPinned = tweet.pinned || false;

      // 創建菜單
      const menu = document.createElement('div');
      menu.id = 'tweet-action-menu';
      menu.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: #000;
        border: 1px solid #2f3336;
        border-radius: 16px;
        min-width: 280px;
        z-index: 10000;
        box-shadow: 0 8px 24px rgba(0,0,0,0.5);
      `;

      menu.innerHTML = `
        <div style="padding: 12px 0;">
          <div onclick="toggleTweetPin('${tweetId}')" style="
            padding: 12px 16px;
            color: #fff;
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 12px;
            transition: background-color 0.2s;
          " onmouseover="this.style.backgroundColor='rgba(255,255,255,0.03)'" onmouseout="this.style.backgroundColor='transparent'">
            <svg viewBox="0 0 32 32" style="width: 18px; height: 18px; fill: currentColor;">
              <path d="M20.743 14.815l-0.933-12.065h5.191c0.414 0 0.75-0.336 0.75-0.75s-0.336-0.75-0.75-0.75v0h-18c-0.414 0-0.75 0.336-0.75 0.75s0.336 0.75 0.75 0.75v0h5.432l-1.275 12.103c-3.213 0.959-5.574 3.738-5.904 7.113l-0.003 0.034c0 0.414 0.336 0.75 0.75 0.75h9.25v7.25c0 0.414 0.336 0.75 0.75 0.75s0.75-0.336 0.75-0.75v0-7.25h9.25c0.414-0 0.75-0.336 0.75-0.75v0c0-3.017-2.35-5.787-6.007-7.185zM12.104 16.081c0.096-0.035 0.179-0.085 0.249-0.148l-0.001 0.001 0.005-0.003c0.126-0.117 0.211-0.275 0.233-0.453l0-0.004 0.011-0.022 1.337-12.701h4.367l0.979 12.681c0.033 0.35 0.303 0.627 0.647 0.67l0.004 0c2.542 0.682 4.512 2.623 5.222 5.096l0.013 0.052h-18.341c0.729-2.54 2.714-4.49 5.222-5.157l0.052-0.012z"></path>
            </svg>
            <span>${isPinned ? '取消置頂' : '置頂到個人資料'}</span>
          </div>
          <div onclick="enterMultiSelectModeFromMenu('${tweetId}')" style="
            padding: 12px 16px;
            color: #fff;
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 12px;
            transition: background-color 0.2s;
          " onmouseover="this.style.backgroundColor='rgba(255,255,255,0.03)'" onmouseout="this.style.backgroundColor='transparent'">
            <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;">
              <g><path d="M9 2C6.243 2 4 4.243 4 7v10c0 2.757 2.243 5 5 5h6c2.757 0 5-2.243 5-5V7c0-2.757-2.243-5-5-5H9zm0 2h6c1.654 0 3 1.346 3 3v10c0 1.654-1.346 3-3 3H9c-1.654 0-3-1.346-3-3V7c0-1.654 1.346-3 3-3zm6.207 3.793l-5.5 5.5-2.414-2.414-1.414 1.414 3.121 3.121.707.707.707-.707 6.207-6.207-1.414-1.414z"></path></g>
            </svg>
            <span>選擇多條推文</span>
          </div>
          <div onclick="deleteSingleTweet('${tweetId}')" style="
            padding: 12px 16px;
            color: #f4212e;
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 12px;
            transition: background-color 0.2s;
          " onmouseover="this.style.backgroundColor='rgba(244,33,46,0.1)'" onmouseout="this.style.backgroundColor='transparent'">
            <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;">
              <g><path d="M16 6V4.5C16 3.12 14.88 2 13.5 2h-3C9.11 2 8 3.12 8 4.5V6H3v2h1.06l.81 11.21C4.98 20.78 6.28 22 7.86 22h8.27c1.58 0 2.88-1.22 3-2.79L19.93 8H21V6h-5zm-6-1.5c0-.28.22-.5.5-.5h3c.27 0 .5.22.5.5V6h-4V4.5zm7.13 14.57c-.04.52-.47.93-1 .93H7.86c-.53 0-.96-.41-1-.93L6.07 8h11.85l-.79 11.07zM9 17v-6h2v6H9zm4 0v-6h2v6h-2z"></path></g>
            </svg>
            <span>刪除</span>
          </div>
        </div>
        <div onclick="closeTweetActionMenu()" style="
          padding: 12px 16px;
          color: #71767b;
          font-size: 15px;
          font-weight: 500;
          cursor: pointer;
          text-align: center;
          border-top: 1px solid #2f3336;
          transition: background-color 0.2s;
        " onmouseover="this.style.backgroundColor='rgba(255,255,255,0.03)'" onmouseout="this.style.backgroundColor='transparent'">
          取消
        </div>
      `;

      document.body.appendChild(menu);

      // 點擊菜單外部關閉
      setTimeout(() => {
        document.addEventListener('click', function closeMenuOnClickOutside(e) {
          if (!menu.contains(e.target)) {
            menu.remove();
            document.removeEventListener('click', closeMenuOnClickOutside);
          }
        });
      }, 100);
    });
  }

  // 關閉操作功能表
  window.closeTweetActionMenu = function () {
    const menu = document.getElementById('tweet-action-menu');
    if (menu) {
      menu.remove();
    }
  };

  // 切換推文置頂狀態
  window.toggleTweetPin = async function (tweetId) {
    try {
      const db = getXDB();
      const accountTweetsId = `userTweets_${currentAccountId || 'main'}`;
      const userTweets = await db.xUserTweets.get(accountTweetsId);

      if (userTweets && userTweets.tweets) {
        const tweet = userTweets.tweets.find(t => t.id === tweetId);
        if (tweet) {
          const wasPinned = tweet.pinned || false;

          // 如果要置頂，先取消其他推文的置頂
          if (!wasPinned) {
            userTweets.tweets.forEach(t => {
              if (t.pinned) {
                t.pinned = false;
              }
            });
          }

          // 切換當前推文的置頂狀態
          tweet.pinned = !wasPinned;

          // 保存到資料庫
          await db.xUserTweets.put(userTweets);

          showXToast(wasPinned ? '已取消置頂' : '推文已置頂', 'success');

          // 關閉功能表並刷新顯示
          closeTweetActionMenu();
          loadUserProfileTweets();
        }
      }
    } catch (error) {
      console.error('切換置頂狀態失敗:', error);
      showXToast('操作失敗', 'error');
    }
  };

  // 刪除單條推文
  window.deleteSingleTweet = async function (tweetId) {
    const confirmDelete = confirm('確定要刪除這條推文嗎？刪除後無法恢復。');
    if (!confirmDelete) return;

    try {
      const db = getXDB();
      const accountTweetsId = `userTweets_${currentAccountId || 'main'}`;
      const userTweets = await db.xUserTweets.get(accountTweetsId);

      if (userTweets && userTweets.tweets) {
        userTweets.tweets = userTweets.tweets.filter(tweet => tweet.id !== tweetId);
        await db.xUserTweets.put(userTweets);

        // 同時從主推文資料中刪除
        const tweetsData = await db.xTweetsData.get('tweets');
        if (tweetsData) {
          let updated = false;

          if (tweetsData.forYouTweets) {
            const originalLength = tweetsData.forYouTweets.length;
            tweetsData.forYouTweets = tweetsData.forYouTweets.filter(tweet => tweet.id !== tweetId);
            if (tweetsData.forYouTweets.length !== originalLength) updated = true;
          }

          if (tweetsData.followingTweets) {
            const originalLength = tweetsData.followingTweets.length;
            tweetsData.followingTweets = tweetsData.followingTweets.filter(tweet => tweet.id !== tweetId);
            if (tweetsData.followingTweets.length !== originalLength) updated = true;
          }

          if (updated) {
            await db.xTweetsData.put(tweetsData);
          }
        }

        showXToast('推文已刪除', 'success');
        closeTweetActionMenu();
        loadUserProfileTweets();
      }
    } catch (error) {
      console.error('刪除推文失敗:', error);
      showXToast('刪除失敗', 'error');
    }
  };

  // 切換推文選擇狀態（用於多選模式）
  function toggleTweetSelection(tweetId) {
    if (!isMultiSelectMode) {
      enterMultiSelectMode();
    }

    const tweetEl = document.querySelector(`[data-tweet-id="${tweetId}"]`);
    if (!tweetEl) return;

    if (selectedTweets.has(tweetId)) {
      selectedTweets.delete(tweetId);
      tweetEl.classList.remove('selected');
      tweetEl.style.backgroundColor = '';
    } else {
      selectedTweets.add(tweetId);
      tweetEl.classList.add('selected');
      tweetEl.style.backgroundColor = 'color-mix(in srgb, var(--x-accent) , 0.1)';
    }

    updateDeleteUI();
  }

  // 從功能表進入多選模式並選中當前推文
  window.enterMultiSelectModeFromMenu = function (tweetId) {
    closeTweetActionMenu();
    enterMultiSelectMode();
    // 自動選中觸發功能表的推文
    if (tweetId) {
      toggleTweetSelection(tweetId);
    }
  };

  // 進入多選模式
  function enterMultiSelectMode() {
    isMultiSelectMode = true;

    // 顯示刪除工具列
    showDeleteToolbar();

    // 改變所有推文的樣式
    document.querySelectorAll('.user-tweet-item').forEach(item => {
      item.style.borderLeft = '3px solid var(--x-accent)';
    });
  }

  // 退出多選模式
  window.exitMultiSelectMode = function () {
    isMultiSelectMode = false;
    selectedTweets.clear();

    // 隱藏刪除工具列
    hideDeleteToolbar();

    // 恢復所有推文的樣式
    document.querySelectorAll('.user-tweet-item').forEach(item => {
      item.classList.remove('selected');
      item.style.backgroundColor = '';
      item.style.borderLeft = '';
    });
  };

  // 顯示刪除工具列
  function showDeleteToolbar() {
    let toolbar = document.getElementById('delete-toolbar');
    if (!toolbar) {
      toolbar = document.createElement('div');
      toolbar.id = 'delete-toolbar';
      toolbar.style.cssText = `
                position: fixed;
                bottom: 80px;
                left: 50%;
                transform: translateX(-50%);
                background-color: #000;
                border: 1px solid #333;
                border-radius: 20px;
                padding: 8px 16px;
                display: flex;
                align-items: center;
                gap: 12px;
                z-index: 1000;
                box-shadow: 0 4px 12px rgba(0,0,0,0.5);
              `;

      toolbar.innerHTML = `
                <button onclick="selectAllTweets()" style="background-color: var(--x-accent); color: #fff; border: none; border-radius: 16px; padding: 6px 12px; font-size: 13px; cursor: pointer;">
                  全選
                </button>
                <span id="selected-count" style="color: #fff; font-size: 14px;">已選擇 0 條</span>
                <button onclick="deleteSelectedTweets()" style="background-color: #f91880; color: #fff; border: none; border-radius: 16px; padding: 6px 12px; font-size: 13px; cursor: pointer;">
                  刪除
                </button>
                <button onclick="exitMultiSelectMode()" style="background-color: #333; color: #fff; border: none; border-radius: 16px; padding: 6px 12px; font-size: 13px; cursor: pointer;">
                  取消
                </button>
              `;

      document.body.appendChild(toolbar);
    }
    toolbar.style.display = 'flex';
  }

  // 隱藏刪除工具列
  function hideDeleteToolbar() {
    const toolbar = document.getElementById('delete-toolbar');
    if (toolbar) {
      toolbar.style.display = 'none';
    }
  }

  // 更新刪除UI
  function updateDeleteUI() {
    const countEl = document.getElementById('selected-count');
    if (countEl) {
      countEl.textContent = `已選擇 ${selectedTweets.size} 條`;
    }
  }

  // 全選推文
  window.selectAllTweets = function () {
    document.querySelectorAll('.user-tweet-item').forEach(item => {
      const tweetId = item.dataset.tweetId;
      if (!selectedTweets.has(tweetId)) {
        selectedTweets.add(tweetId);
        item.classList.add('selected');
        item.style.backgroundColor = 'color-mix(in srgb, var(--x-accent) , 0.1)';
      }
    });
    updateDeleteUI();
  };

  // 刪除選中的推文
  window.deleteSelectedTweets = async function () {
    if (selectedTweets.size === 0) return;

    const confirmDelete = confirm(`確定要刪除選中的 ${selectedTweets.size} 條推文嗎？刪除後無法恢復。`);
    if (!confirmDelete) return;

    try {
      const db = getXDB();

      // 獲取當前帳戶的推文資料
      const accountTweetsId = `userTweets_${currentAccountId || 'main'}`;
      const userTweets = await db.xUserTweets.get(accountTweetsId);
      if (userTweets && userTweets.tweets) {
        // 過濾掉選中的推文
        userTweets.tweets = userTweets.tweets.filter(tweet => !selectedTweets.has(tweet.id));

        // 保存更新後的資料
        await db.xUserTweets.put(userTweets);

        // 同時從主推文資料中刪除（如果存在）
        const tweetsData = await db.xTweetsData.get('tweets');
        if (tweetsData) {
          let updated = false;

          if (tweetsData.forYouTweets) {
            const originalLength = tweetsData.forYouTweets.length;
            tweetsData.forYouTweets = tweetsData.forYouTweets.filter(tweet => !selectedTweets.has(tweet.id));
            if (tweetsData.forYouTweets.length !== originalLength) updated = true;
          }

          if (tweetsData.followingTweets) {
            const originalLength = tweetsData.followingTweets.length;
            tweetsData.followingTweets = tweetsData.followingTweets.filter(tweet => !selectedTweets.has(tweet.id));
            if (tweetsData.followingTweets.length !== originalLength) updated = true;
          }

          if (updated) {
            await db.xTweetsData.put(tweetsData);
          }
        }

        showXToast(`已刪除 ${selectedTweets.size} 條推文`, 'success');

        // 退出多選模式並刷新顯示
        exitMultiSelectMode();
        loadUserProfileTweets();
      }
    } catch (error) {
      console.error('刪除推文失敗:', error);
      showXToast('刪除失敗', 'error');
    }
  };

  // 載入使用者個人頁面的推文
  async function loadUserProfileTweets() {
    try {
      const userTweets = await getUserTweets();
      const container = document.getElementById('x-profile-tweets-container');

      if (userTweets.length === 0) {
        container.innerHTML = `
                  <div style="padding: 60px 32px; text-align: center;">
                    <div style="color: #71767b; font-size: 31px; font-weight: 800; margin-bottom: 8px;">還沒有推文</div>
                    <div style="color: #71767b; font-size: 15px;">當你發送第一條推文時，它會顯示在這裡。</div>
                  </div>
                `;
      } else {
        // 將置頂推文排在最前面
        const sortedTweets = [...userTweets].sort((a, b) => {
          const aPinned = a.pinned || false;
          const bPinned = b.pinned || false;
          if (aPinned && !bPinned) return -1;
          if (!aPinned && bPinned) return 1;
          return 0; // 保持原有順序
        });

        container.innerHTML = '';
        sortedTweets.forEach(tweet => {
          const tweetElement = createUserTweetElement(tweet);
          container.appendChild(tweetElement);
        });
      }

      // 更新帖子數量顯示
      const headerCount = document.getElementById('x-profile-header-count');
      if (headerCount) {
        headerCount.textContent = `${userTweets.length} 帖子`;
      }
    } catch (error) {
      console.error('載入用戶推文失敗:', error);
    }
  }

  // 創建使用者推文元素(個人頁面版本)
  function createUserTweetElement(tweet) {
    const tweetEl = document.createElement('div');
    tweetEl.className = 'user-tweet-item';
    tweetEl.dataset.tweetId = tweet.id;
    tweetEl.style.cursor = 'pointer';
    tweetEl.style.position = 'relative';
    tweetEl.style.borderBottom = '1px solid var(--x-border-color)';
    tweetEl.style.display = 'block';

    // 觸摸事件處理變數
    let longPressTimer;
    let isLongPressed = false;
    let touchStartX = 0;
    let touchStartY = 0;
    let hasMoved = false;
    let lastTouchEndTime = 0; // 上次觸摸結束時間，用於防抖
    const TOUCH_THRESHOLD = 15; // 滑動閾值（圖元）
    const DEBOUNCE_TIME = 300; // 防抖時間（毫秒）

    tweetEl.addEventListener('touchstart', e => {
      // 記錄初始觸摸位置
      const touch = e.touches[0];
      touchStartX = touch.clientX;
      touchStartY = touch.clientY;
      hasMoved = false;

      longPressTimer = setTimeout(() => {
        if (!hasMoved) {
          // 只有沒有移動時才觸發長按
          isLongPressed = true;
          // 顯示操作功能表（置頂/刪除）
          showTweetActionMenu(tweet.id, e);
          e.preventDefault();
        }
      }, 800);
    });

    tweetEl.addEventListener('touchmove', e => {
      const touch = e.touches[0];
      const deltaX = Math.abs(touch.clientX - touchStartX);
      const deltaY = Math.abs(touch.clientY - touchStartY);

      // 如果移動距離超過閾值，標記為滑動
      if (deltaX > TOUCH_THRESHOLD || deltaY > TOUCH_THRESHOLD) {
        hasMoved = true;
        clearTimeout(longPressTimer); // 取消長按
      }
    });

    tweetEl.addEventListener('touchend', e => {
      clearTimeout(longPressTimer);

      // 防抖：防止快速重複觸發
      const now = Date.now();
      if (now - lastTouchEndTime < DEBOUNCE_TIME) {
        console.log('🚫 [觸摸] 防抖攔截，忽略重複觸摸');
        e.preventDefault();
        return;
      }
      lastTouchEndTime = now;

      // 只有在沒有滑動且沒有長按的情況下才觸發點擊
      if (!isLongPressed && !hasMoved) {
        // 阻止後續的點擊事件，防止移動端觸發兩次
        e.preventDefault();

        if (isMultiSelectMode) {
          toggleTweetSelection(tweet.id);
        } else {
          showTweetDetail(tweet);
        }
      } else if (isLongPressed) {
        // 長按後也要阻止點擊事件
        e.preventDefault();
      }

      isLongPressed = false;
      hasMoved = false;
    });

    // 桌面端滑鼠事件保持原有邏輯
    let lastMouseUpTime = 0;

    tweetEl.addEventListener('mousedown', e => {
      // 只處理左鍵點擊
      if (e.button !== 0) return;

      longPressTimer = setTimeout(() => {
        isLongPressed = true;
        // 顯示操作功能表（置頂/刪除）
        showTweetActionMenu(tweet.id, e);
        e.preventDefault();
      }, 800);
    });

    tweetEl.addEventListener('mouseup', e => {
      // 只處理左鍵點擊
      if (e.button !== 0) return;

      clearTimeout(longPressTimer);

      // 防抖：防止快速重複點擊
      const now = Date.now();
      if (now - lastMouseUpTime < DEBOUNCE_TIME) {
        console.log('🚫 [滑鼠] 防抖攔截，忽略重複點擊');
        return;
      }
      lastMouseUpTime = now;

      if (!isLongPressed) {
        if (isMultiSelectMode) {
          toggleTweetSelection(tweet.id);
        } else {
          showTweetDetail(tweet);
        }
      }
      isLongPressed = false;
    });

    // 阻止默認的點擊事件，防止與觸摸/滑鼠事件衝突
    tweetEl.addEventListener('click', e => {
      e.preventDefault();
      e.stopPropagation();
    });

    // 格式化時間
    function formatTimeForProfile(timestamp) {
      const date = new Date(timestamp);
      const now = new Date();
      const diffInHours = Math.floor((now - date) / (1000 * 60 * 60));

      if (diffInHours < 1) {
        const diffInMinutes = Math.floor((now - date) / (1000 * 60));
        return diffInMinutes < 1 ? '剛剛' : `${diffInMinutes}分鐘`;
      } else if (diffInHours < 24) {
        return `${diffInHours}小時`;
      } else {
        const diffInDays = Math.floor(diffInHours / 24);
        return diffInDays === 1 ? '1天' : `${diffInDays}天`;
      }
    }

    // 渲染媒體內容（支援多圖）
    function renderProfileTweetMedia(tweet) {
      if (!tweet.image) return '';

      // 文字描述類型
      if (tweet.image.type === 'description') {
        return `
                  <div style="margin-top: 12px; background-color: var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 12px; padding: 12px; box-sizing: border-box;">
                    <div style="color: var(--x-text-primary); font-size: 14px; line-height: 1.4; white-space: pre-wrap; word-wrap: break-word; overflow-wrap: break-word; width: 100%; box-sizing: border-box;">${tweet.image.content}</div>
                  </div>
                `;
      }
      // 單圖上傳
      else if (tweet.image.type === 'upload') {
        return `
                  <div style="margin-top: 12px; border-radius: 12px; overflow: hidden;">
                    <img src="${tweet.image.content}" style="width: 100%; max-height: 200px; object-fit: cover; display: block;" alt="推文圖片">
                  </div>
                `;
      }
      // 多圖上傳
      else if (tweet.image.type === 'uploads' && tweet.image.images && tweet.image.images.length > 0) {
        const imageCount = tweet.image.images.length;
        let gridTemplate = '';

        if (imageCount === 1) {
          gridTemplate = 'grid-template-columns: 1fr;';
        } else if (imageCount === 2) {
          gridTemplate = 'grid-template-columns: repeat(2, 1fr);';
        } else if (imageCount === 3) {
          gridTemplate = 'grid-template-columns: repeat(2, 1fr);';
        } else {
          gridTemplate = 'grid-template-columns: repeat(2, 1fr);';
        }

        const imagesHtml = tweet.image.images
          .map((img, index) => {
            const spanStyle = imageCount === 3 && index === 0 ? 'grid-column: span 2;' : '';
            return `
            <div style="${spanStyle}border-radius: 8px; overflow: hidden;">
              <img src="${img.content}" style="width: 100%; height: ${
              imageCount === 1 ? '200px' : '150px'
            }; object-fit: cover; display: block;" alt="推文圖片${index + 1}">
            </div>
          `;
          })
          .join('');

        return `
                  <div style="margin-top: 12px; display: grid; ${gridTemplate} gap: 4px;">
                    ${imagesHtml}
                  </div>
                `;
      }

      return '';
    }

    // 渲染連結內容
    function renderProfileTweetLink(tweet) {
      if (!tweet.link) return '';

      return `
                <div style="margin-top: 12px; border: 1px solid #333; border-radius: 12px; overflow: hidden;">
                  ${
                    tweet.link.thumbnail
                      ? `
                    <div style="width: 100%; height: 150px; background-color: #333;">
                      <img src="${tweet.link.thumbnail}" style="width: 100%; height: 100%; object-fit: cover;" alt="連結預覽圖">
                    </div>
                  `
                      : ''
                  }
                  <div style="padding: 12px;">
                    <div style="color: #71767b; font-size: 13px; margin-bottom: 4px;">${tweet.link.url || '連結'}</div>
                    ${
                      tweet.link.title
                        ? `<div style="color: #fff; font-size: 14px; font-weight: 600; margin-bottom: 4px;">${tweet.link.title}</div>`
                        : ''
                    }
                    ${
                      tweet.link.description
                        ? `<div style="color: #71767b; font-size: 13px;">${tweet.link.description}</div>`
                        : ''
                    }
                  </div>
                </div>
              `;
    }

    // 渲染個人主頁引用內容的媒體（圖片）
    function renderProfileQuotedTweetMedia(quoted) {
      if (!quoted.image) return '';

      if (quoted.image.type === 'description') {
        return `
                  <div style="margin-top: 6px; background-color: var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 6px; padding: 6px; box-sizing: border-box;">
                    <div style="color: var(--x-text-primary); font-size: 12px; line-height: 1.4; white-space: pre-wrap; word-wrap: break-word; overflow-wrap: break-word; width: 100%; box-sizing: border-box;">${quoted.image.content}</div>
                  </div>
                `;
      } else if (quoted.image.type === 'upload') {
        return `
                  <div style="margin-top: 6px; border-radius: 6px; overflow: hidden;">
                    <img src="${quoted.image.content}" style="width: 100%; max-height: 80px; object-fit: cover; display: block;" alt="引用圖片">
                  </div>
                `;
      }

      return '';
    }

    // 渲染引用推文內容
    function renderProfileQuotedTweet(tweet) {
      if (!tweet.quotedTweet) return '';

      const quoted = tweet.quotedTweet;
      const typeText = quoted.type === 'tweet' ? '推文' : '評論';

      return `
                <div style="margin-top: 12px; border: 1px solid var(--x-border-color); border-radius: 12px; padding: 12px; background-color: var(--x-bg-hover);">
                  <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                    <img src="${quoted.user.avatar}" style="width: 20px; height: 20px; border-radius: 50%;" alt="${
        quoted.user.name
      }">
                    <span style="color: var(--x-text-primary); font-size: 13px; font-weight: 600;">${
                      quoted.user.name
                    }</span>
                    ${
                      quoted.user.verified
                        ? '<svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: var(--x-accent);"><g><path d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.27 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.46 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z"></path></g></svg>'
                        : ''
                    }
                    <span style="color: var(--x-text-secondary); font-size: 13px;">${quoted.user.handle}</span>
                    <span style="color: var(--x-text-secondary); font-size: 13px;">·${quoted.time}</span>
                  </div>
                  <div style="color: var(--x-text-primary); font-size: 14px; line-height: 1.4;">${quoted.content}</div>
                  ${renderProfileQuotedTweetMedia(quoted)}
                  <div style="color: var(--x-text-secondary); font-size: 12px; margin-top: 8px;">引用${typeText}</div>
                </div>
              `;
    }

    // 檢查是否置頂
    const isPinned = tweet.pinned || false;

    tweetEl.innerHTML = `
              ${
                isPinned
                  ? `
              <div style="padding: 12px 16px 0; display: flex; align-items: center; gap: 12px;">
                <div style="width: 40px; display: flex; justify-content: flex-end;">
                  <svg viewBox="0 0 32 32" style="width: 16px; height: 16px; fill: #71767b;">
                    <path d="M20.743 14.815l-0.933-12.065h5.191c0.414 0 0.75-0.336 0.75-0.75s-0.336-0.75-0.75-0.75v0h-18c-0.414 0-0.75 0.336-0.75 0.75s0.336 0.75 0.75 0.75v0h5.432l-1.275 12.103c-3.213 0.959-5.574 3.738-5.904 7.113l-0.003 0.034c0 0.414 0.336 0.75 0.75 0.75h9.25v7.25c0 0.414 0.336 0.75 0.75 0.75s0.75-0.336 0.75-0.75v0-7.25h9.25c0.414-0 0.75-0.336 0.75-0.75v0c0-3.017-2.35-5.787-6.007-7.185zM12.104 16.081c0.096-0.035 0.179-0.085 0.249-0.148l-0.001 0.001 0.005-0.003c0.126-0.117 0.211-0.275 0.233-0.453l0-0.004 0.011-0.022 1.337-12.701h4.367l0.979 12.681c0.033 0.35 0.303 0.627 0.647 0.67l0.004 0c2.542 0.682 4.512 2.623 5.222 5.096l0.013 0.052h-18.341c0.729-2.54 2.714-4.49 5.222-5.157l0.052-0.012z"></path>
                  </svg>
                </div>
                <span style="color: #71767b; font-size: 13px; font-weight: 700;">已置頂</span>
              </div>
            `
                  : ''
              }
              <div style="display: flex; gap: 12px; padding: 12px 16px;">
                <img src="${tweet.user.avatar}" alt="${
      tweet.user.name
    }" style="width: 40px; height: 40px; border-radius: 50%; flex-shrink: 0;">
                <div style="flex: 1; min-width: 0;" class="tweet-main">
                <div class="tweet-user-info">
                  <span class="tweet-user-name">${tweet.user.name}</span>
                  ${
                    tweet.user.verified
                      ? '<svg class="tweet-verified" viewBox="0 0 24 24"><g><path d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.27 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.46 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z"></path></g></svg>'
                      : ''
                  }
                  <span class="tweet-user-handle">${tweet.user.handle}</span>
                  <span class="tweet-time" data-timestamp="${tweet.timestamp || Date.now()}">·${
      tweet.timestamp ? getRelativeTime(tweet.timestamp) : '剛剛'
    }</span>
                  ${
                    tweet.location
                      ? `
                    <div style="display: flex; align-items: center; gap: 4px; margin-left: 8px;">
                      <svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: var(--x-accent);">
                        <g><path d="M12 7c-1.93 0-3.5 1.57-3.5 3.5S10.07 14 12 14s3.5-1.57 3.5-3.5S13.93 7 12 7zm0 5c-.827 0-1.5-.673-1.5-1.5S11.173 9 12 9s1.5.673 1.5 1.5S12.827 12 12 12zm0-10c-4.687 0-8.5 3.813-8.5 8.5 0 5.967 7.621 11.116 7.945 11.332l.555.37.555-.37C12.879 21.616 20.5 16.467 20.5 10.5 20.5 5.813 16.687 2 12 2zm0 17.77c-1.665-1.241-6.5-5.196-6.5-9.27C5.5 6.916 8.416 4 12 4s6.5 2.916 6.5 6.5c0 4.073-4.835 8.028-6.5 9.27z"></path></g>
                      </svg>
                      <span style="color: var(--x-accent); font-size: 13px;">${tweet.location}</span>
                    </div>
                  `
                      : ''
                  }
                </div>
                <div class="tweet-content">${processContent(tweet.content)}</div>
                ${renderProfileTweetMedia(tweet)}
                ${renderProfileTweetLink(tweet)}
                ${renderProfileQuotedTweet(tweet)}
                <div class="tweet-actions">
                  <div class="tweet-action comment">
                    <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor">
                      <g><path d="M1.751 10c0-4.42 3.584-8.005 8.005-8.005h4.366c4.49 0 8.129 3.64 8.129 8.13 0 2.96-1.607 5.68-4.196 7.11l-8.054 4.46v-3.69h-.067c-4.49.1-8.183-3.51-8.183-8.005zm8.005-6.005c-3.317 0-6.005 2.69-6.005 6.005 0 3.37 2.77 6.08 6.138 6.01l.351-.01h1.761v2.3l5.087-2.81c1.951-1.08 3.163-3.13 3.163-5.36 0-3.39-2.744-6.13-6.129-6.13H9.756z"></path></g>
                    </svg>
                    <span>${DataUtils.formatNumber(tweet.stats.comments)}</span>
                  </div>
                  <div class="tweet-action retweet" onclick="handleQuoteRetweetFromData('tweet', '${tweet.id}')">
                    <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor">
                      <g><path d="M4.5 3.88l4.432 4.14-1.364 1.46L5.5 7.55V16c0 1.1.896 2 2 2H13v2H7.5c-2.209 0-4-1.791-4-4V7.55L1.432 9.48.068 8.02 4.5 3.88zM16.5 6H11V4h5.5c2.209 0 4 1.791 4 4v8.45l2.068-1.93 1.364 1.46-4.432 4.14-4.432-4.14 1.364-1.46 2.068 1.93V8c0-1.1-.896-2-2-2z"></path></g>
                    </svg>
                    <span>${DataUtils.formatNumber(tweet.stats.retweets)}</span>
                  </div>
                  <div class="tweet-action like" data-liked="false" data-likes="${tweet.stats.likes}">
                    <svg class="action-icon like-icon" viewBox="0 0 24 24" fill="currentColor">
                      <g><path d="M16.697 5.5c-1.222-.06-2.679.51-3.89 2.16l-.805 1.09-.806-1.09C9.984 6.01 8.526 5.44 7.304 5.5c-1.243.07-2.349.78-2.91 1.91-.552 1.12-.633 2.78.479 4.82 1.074 1.97 3.257 4.27 7.129 6.61 3.87-2.34 6.052-4.64 7.126-6.61 1.111-2.04 1.03-3.7.477-4.82-.561-1.13-1.666-1.84-2.908-1.91zm4.187 7.69c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g>
                    </svg>
                    <span class="like-count">${DataUtils.formatNumber(tweet.stats.likes)}</span>
                  </div>
                  <div class="tweet-action view">
                    <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor">
                      <g><path d="M8.75 21V3h2v18h-2zM18 21V8.5h2V21h-2zM4 21l.004-10H6v10H4zm9.248 0v-7h2v7h-2z"></path></g>
                    </svg>
                    <span>${DataUtils.formatNumber(tweet.stats.views)}</span>
                  </div>
                  <div class="tweet-action bookmark">
                    <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor">
                      <g><path d="M4 4.5C4 3.12 5.119 2 6.5 2h11C18.881 2 20 3.12 20 4.5v18.44l-8-5.71-8 5.71V4.5zM6.5 4c-.276 0-.5.22-.5.5v14.56l6-4.29 6 4.29V4.5c0-.28-.224-.5-.5-.5h-11z"></path></g>
                    </svg>
                  </div>
                  <div class="tweet-action share">
                    <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor">
                      <g><path d="M12 2.59l5.7 5.7-1.41 1.42L13 6.41V16h-2V6.41l-3.29 3.3-1.42-1.42L12 2.59zM21 15l-.02 3.51c0 1.38-1.12 2.49-2.5 2.49H5.5C4.11 21 3 19.88 3 18.5V15h2v3.5c0 .28.22.5.5.5h12.98c.28 0 .5-.22.5-.5L19 15h2z"></path></g>
                    </svg>
                  </div>
                  </div>
                </div>
              </div>
            `;

    return tweetEl;
  }

  // 刷新個人頁面的推文顯示（用於AI回復後同步資料）
  function refreshUserProfileTweets() {
    const container = document.getElementById('x-profile-tweets-container');
    if (container && container.parentElement.style.display !== 'none') {
      loadUserProfileTweets();
    }
  }

  // 更新推文詳情頁面的AI資料
  async function updateTweetDetailWithAI(tweetId, interactionData, isReroll = false, isProgressMode = false) {
    // 使用ID精確更新元素

    // 更新互動資料顯示區域
    const statsDiv = document.getElementById('tweet-detail-stats');
    if (statsDiv) {
      statsDiv.innerHTML = `
                 <div style="display: flex; align-items: center; gap: 4px;">
                   <span style="color: #fff; font-weight: 700; font-size: 15px;">${formatNumber(
                     interactionData.stats.retweets,
                   )}</span>
                   <span style="color: #71767b; font-size: 15px;">${getI18nText('tweetDetailRetweets')}</span>
                 </div>
                 <div style="display: flex; align-items: center; gap: 4px;">
                   <span style="color: #fff; font-weight: 700; font-size: 15px;">${formatNumber(
                     interactionData.stats.likes,
                   )}</span>
                   <span style="color: #71767b; font-size: 15px;">${getI18nText('tweetDetailLikes')}</span>
                 </div>
                 <div style="display: flex; align-items: center; gap: 4px;">
                   <span style="color: #fff; font-weight: 700; font-size: 15px;">${formatNumber(
                     interactionData.stats.comments,
                   )}</span>
                   <span style="color: #71767b; font-size: 15px;">${getI18nText('tweetDetailBookmarks')}</span>
                 </div>
               `;
    }

    // 更新查看資料
    const viewElement = document.getElementById('tweet-detail-views');
    const viewLabelElement = document.getElementById('tweet-detail-views-label');
    if (viewElement) {
      viewElement.textContent = formatNumber(interactionData.stats.views);
    }
    if (viewLabelElement) {
      viewLabelElement.textContent = getI18nText('tweetDetailViews');
    }

    // 添加AI生成的評論
    const commentsContainer = document.getElementById('detail-comments-container');

    // 如果是重回，清除現有評論；如果是推進，保留現有評論
    if (isReroll && !isProgressMode && commentsContainer) {
      commentsContainer.innerHTML = '';
    }

    if (commentsContainer && interactionData.comments.length > 0) {
      interactionData.comments.forEach(comment => {
        // 創建評論組容器
        const commentGroup = document.createElement('div');
        commentGroup.style.cssText = 'position: relative;';

        // 添加主評論
        const commentElement = createCommentElement(comment);

        // 如果有回復，給主評論添加特殊類
        if (comment.replies && comment.replies.length > 0) {
          commentElement.classList.add('has-replies');
        }

        commentGroup.appendChild(commentElement);

        // 渲染回復
        if (comment.replies && comment.replies.length > 0) {
          comment.replies.forEach(reply => {
            const replyElement = createCommentElement(reply, true);
            commentGroup.appendChild(replyElement);
          });
        }

        commentsContainer.appendChild(commentGroup);
      });
    }

    // 更新存儲的推文資料
    await updateStoredTweetData(tweetId, interactionData, isProgressMode);
  }

  // 更新存儲的推文資料（包含AI生成的互動資料和評論）
  async function updateStoredTweetData(tweetId, interactionData, isProgressMode = false) {
    try {
      const db = getXDB();

      // 檢查推文類型
      const currentTweetData = sessionStorage.getItem('currentTweetData');
      let isAccountTweet = false;
      let isSearchTweet = false;
      let accountHandle = null;

      if (currentTweetData) {
        try {
          const tweet = JSON.parse(currentTweetData);
          isAccountTweet = tweet._source === 'account';
          isSearchTweet = tweet._source === 'search';
          accountHandle = tweet._accountHandle;
        } catch (e) {
          console.warn('解析推文數據失敗:', e);
        }
      }

      // 處理搜索推文
      if (isSearchTweet) {
        console.log('📝 [更新資料] 檢測到搜索結果推文，更新搜索資料');
        const tweetsData = await db.xTweetsData.get('tweets');
        if (tweetsData) {
          let updated = false;

          // 更新 forYouTweets
          if (tweetsData.forYouTweets) {
            const index = tweetsData.forYouTweets.findIndex(t => t.id === tweetId);
            if (index !== -1) {
              if (isProgressMode) {
                // 推進模式：累加互動數據，追加評論
                const currentStats = tweetsData.forYouTweets[index].stats;
                tweetsData.forYouTweets[index].stats = {
                  comments: Math.max(currentStats.comments, interactionData.stats.comments),
                  retweets: Math.max(currentStats.retweets, interactionData.stats.retweets),
                  likes: Math.max(currentStats.likes, interactionData.stats.likes),
                  views: Math.max(currentStats.views, interactionData.stats.views),
                };
                const existingComments = tweetsData.forYouTweets[index].comments || [];
                tweetsData.forYouTweets[index].comments = [...existingComments, ...(interactionData.comments || [])];
              } else {
                // 重新生成模式（搜索推文不應該使用，但防禦性代碼）
                tweetsData.forYouTweets[index].stats = {
                  ...tweetsData.forYouTweets[index].stats,
                  ...interactionData.stats,
                };
                tweetsData.forYouTweets[index].comments = interactionData.comments || [];
              }
              updated = true;
              console.log(`📈 [搜索推文] forYouTweets 新增 ${interactionData.comments?.length || 0} 條評論`);
            }
          }

          // 更新 followingTweets
          if (tweetsData.followingTweets && !updated) {
            const index = tweetsData.followingTweets.findIndex(t => t.id === tweetId);
            if (index !== -1) {
              if (isProgressMode) {
                const currentStats = tweetsData.followingTweets[index].stats;
                tweetsData.followingTweets[index].stats = {
                  comments: Math.max(currentStats.comments, interactionData.stats.comments),
                  retweets: Math.max(currentStats.retweets, interactionData.stats.retweets),
                  likes: Math.max(currentStats.likes, interactionData.stats.likes),
                  views: Math.max(currentStats.views, interactionData.stats.views),
                };
                const existingComments = tweetsData.followingTweets[index].comments || [];
                tweetsData.followingTweets[index].comments = [...existingComments, ...(interactionData.comments || [])];
              } else {
                tweetsData.followingTweets[index].stats = {
                  ...tweetsData.followingTweets[index].stats,
                  ...interactionData.stats,
                };
                tweetsData.followingTweets[index].comments = interactionData.comments || [];
              }
              updated = true;
              console.log(`📈 [搜索推文] followingTweets 新增 ${interactionData.comments?.length || 0} 條評論`);
            }
          }

          if (updated) {
            await db.xTweetsData.put(tweetsData);
            // 更新 sessionStorage
            if (currentTweetData) {
              try {
                const currentTweet = JSON.parse(currentTweetData);
                if (currentTweet.id === tweetId) {
                  currentTweet.stats = interactionData.stats;
                  currentTweet.comments = currentTweet.comments || [];
                  if (isProgressMode) {
                    currentTweet.comments = [...currentTweet.comments, ...(interactionData.comments || [])];
                  } else {
                    currentTweet.comments = interactionData.comments || [];
                  }
                  sessionStorage.setItem('currentTweetData', JSON.stringify(currentTweet));
                }
              } catch (e) {
                console.warn('更新 sessionStorage 失敗:', e);
              }
            }
            console.log('✅ 搜索推文AI反應已保存:', tweetId, isProgressMode ? '(推進模式)' : '');
            return;
          }
        }
      }

      // 處理帳戶推文
      if (isAccountTweet && accountHandle) {
        // 更新帳戶主頁數據
        console.log('📝 [更新資料] 檢測到帳戶推文，更新帳戶主頁數據');
        const cleanHandle = accountHandle.replace('@', '');
        const accountProfile = await db.xAccountProfiles.get(cleanHandle);

        if (accountProfile && accountProfile.tweets) {
          const tweetIndex = accountProfile.tweets.findIndex(t => t.id === tweetId);
          if (tweetIndex !== -1) {
            if (isProgressMode) {
              // 推進模式：累加互動數據，追加評論
              const currentStats = accountProfile.tweets[tweetIndex].stats;
              accountProfile.tweets[tweetIndex].stats = {
                comments: Math.max(currentStats.comments, interactionData.stats.comments),
                retweets: Math.max(currentStats.retweets, interactionData.stats.retweets),
                likes: Math.max(currentStats.likes, interactionData.stats.likes),
                views: Math.max(currentStats.views, interactionData.stats.views),
              };

              // 追加新評論
              const existingComments = accountProfile.tweets[tweetIndex].comments || [];
              accountProfile.tweets[tweetIndex].comments = [...existingComments, ...(interactionData.comments || [])];

              console.log(`📈 [帳戶推文] 新增 ${interactionData.comments?.length || 0} 條評論`);
            } else {
              // 重新生成模式：覆蓋互動資料和評論
              accountProfile.tweets[tweetIndex].stats = {
                ...accountProfile.tweets[tweetIndex].stats,
                ...interactionData.stats,
              };
              accountProfile.tweets[tweetIndex].comments = interactionData.comments || [];
            }

            // 保存到資料庫
            await db.xAccountProfiles.put(accountProfile);

            // 更新 sessionStorage
            if (currentTweetData) {
              try {
                const currentTweet = JSON.parse(currentTweetData);
                if (currentTweet.id === tweetId) {
                  currentTweet.stats = accountProfile.tweets[tweetIndex].stats;
                  currentTweet.comments = accountProfile.tweets[tweetIndex].comments;
                  sessionStorage.setItem('currentTweetData', JSON.stringify(currentTweet));
                }
              } catch (e) {
                console.warn('更新 sessionStorage 失敗:', e);
              }
            }

            console.log('✅ 帳戶推文AI反應已保存:', tweetId, isProgressMode ? '(推進模式)' : '');
            return;
          }
        }
      }

      // 檢查是否為用戶推文
      const isUserTweet = tweetId && tweetId.startsWith('user_');

      if (!isUserTweet) {
        // 非用戶推文：嘗試從主頁推文資料中更新
        console.log('📝 [更新資料] 檢測到主頁推文，更新主頁數據');
        const tweetsData = await db.xTweetsData.get('tweets');
        if (tweetsData) {
          let updated = false;

          // 更新 forYouTweets
          if (tweetsData.forYouTweets) {
            const index = tweetsData.forYouTweets.findIndex(t => t.id === tweetId);
            if (index !== -1) {
              if (isProgressMode) {
                // 推進模式：累加互動數據，追加評論
                const currentStats = tweetsData.forYouTweets[index].stats;
                tweetsData.forYouTweets[index].stats = {
                  comments: Math.max(currentStats.comments, interactionData.stats.comments),
                  retweets: Math.max(currentStats.retweets, interactionData.stats.retweets),
                  likes: Math.max(currentStats.likes, interactionData.stats.likes),
                  views: Math.max(currentStats.views, interactionData.stats.views),
                };
                const existingComments = tweetsData.forYouTweets[index].comments || [];
                tweetsData.forYouTweets[index].comments = [...existingComments, ...(interactionData.comments || [])];
              } else {
                // 重新生成模式
                tweetsData.forYouTweets[index].stats = {
                  ...tweetsData.forYouTweets[index].stats,
                  ...interactionData.stats,
                };
                tweetsData.forYouTweets[index].comments = interactionData.comments || [];
              }
              updated = true;
              console.log(`📈 [主頁推文] forYouTweets 新增 ${interactionData.comments?.length || 0} 條評論`);
            }
          }

          // 更新 followingTweets
          if (tweetsData.followingTweets && !updated) {
            const index = tweetsData.followingTweets.findIndex(t => t.id === tweetId);
            if (index !== -1) {
              if (isProgressMode) {
                const currentStats = tweetsData.followingTweets[index].stats;
                tweetsData.followingTweets[index].stats = {
                  comments: Math.max(currentStats.comments, interactionData.stats.comments),
                  retweets: Math.max(currentStats.retweets, interactionData.stats.retweets),
                  likes: Math.max(currentStats.likes, interactionData.stats.likes),
                  views: Math.max(currentStats.views, interactionData.stats.views),
                };
                const existingComments = tweetsData.followingTweets[index].comments || [];
                tweetsData.followingTweets[index].comments = [...existingComments, ...(interactionData.comments || [])];
              } else {
                tweetsData.followingTweets[index].stats = {
                  ...tweetsData.followingTweets[index].stats,
                  ...interactionData.stats,
                };
                tweetsData.followingTweets[index].comments = interactionData.comments || [];
              }
              updated = true;
              console.log(`📈 [主頁推文] followingTweets 新增 ${interactionData.comments?.length || 0} 條評論`);
            }
          }

          if (updated) {
            await db.xTweetsData.put(tweetsData);
            // 更新 sessionStorage
            if (currentTweetData) {
              try {
                const currentTweet = JSON.parse(currentTweetData);
                if (currentTweet.id === tweetId) {
                  currentTweet.stats = interactionData.stats;
                  currentTweet.comments = currentTweet.comments || [];
                  if (isProgressMode) {
                    currentTweet.comments = [...currentTweet.comments, ...(interactionData.comments || [])];
                  } else {
                    currentTweet.comments = interactionData.comments || [];
                  }
                  sessionStorage.setItem('currentTweetData', JSON.stringify(currentTweet));
                }
              } catch (e) {
                console.warn('更新 sessionStorage 失敗:', e);
              }
            }
            console.log('✅ 主頁推文AI反應已保存:', tweetId, isProgressMode ? '(推進模式)' : '');
            return;
          } else {
            console.warn('⚠️ 未在主頁數據中找到要更新的推文:', tweetId);
          }
        }
        return; // 非用戶推文處理結束
      }

      // 使用者推文的處理邏輯
      // 使用正確的帳戶ID獲取使用者推文資料
      const accountTweetsId = `userTweets_${currentAccountId || 'main'}`;
      let userTweets = await db.xUserTweets.get(accountTweetsId);

      if (!userTweets) {
        console.warn('未找到使用者推文資料，帳戶ID:', accountTweetsId);
        return;
      }

      // 查找並更新對應的推文
      const tweetIndex = userTweets.tweets.findIndex(tweet => tweet.id === tweetId);
      if (tweetIndex !== -1) {
        if (isProgressMode) {
          // 推進模式：累加互動數據，追加評論
          const currentStats = userTweets.tweets[tweetIndex].stats;
          userTweets.tweets[tweetIndex].stats = {
            comments: Math.max(currentStats.comments, interactionData.stats.comments),
            retweets: Math.max(currentStats.retweets, interactionData.stats.retweets),
            likes: Math.max(currentStats.likes, interactionData.stats.likes),
            views: Math.max(currentStats.views, interactionData.stats.views),
          };

          // 追加新評論（保留舊評論）
          const existingComments = userTweets.tweets[tweetIndex].comments || [];
          userTweets.tweets[tweetIndex].comments = [...existingComments, ...(interactionData.comments || [])];

          console.log(`📈 [推進模式] 新增 ${interactionData.comments?.length || 0} 條評論`);
        } else {
          // 重新生成模式：覆蓋互動資料和評論
          userTweets.tweets[tweetIndex].stats = {
            ...userTweets.tweets[tweetIndex].stats,
            ...interactionData.stats,
          };

          // 更新評論資料
          userTweets.tweets[tweetIndex].comments = interactionData.comments || [];
        }

        // 保存更新後的資料
        await db.xUserTweets.put(userTweets);

        // 同時更新 sessionStorage 中的當前推文資料
        if (currentTweetData) {
          try {
            const currentTweet = JSON.parse(currentTweetData);
            if (currentTweet.id === tweetId) {
              currentTweet.stats = userTweets.tweets[tweetIndex].stats;
              currentTweet.comments = userTweets.tweets[tweetIndex].comments;
              sessionStorage.setItem('currentTweetData', JSON.stringify(currentTweet));
            }
          } catch (e) {
            console.warn('更新 sessionStorage 失敗:', e);
          }
        }

        console.log(
          '✅ 推文AI反應已保存到資料庫:',
          tweetId,
          '帳戶:',
          accountTweetsId,
          isProgressMode ? '(推進模式)' : '',
        );

        // 刷新個人頁面顯示
        refreshUserProfileTweets();
      } else {
        console.warn('⚠️ 未找到要更新的推文:', tweetId);
      }
    } catch (error) {
      console.error('❌ 更新存儲推文資料失敗:', error);
    }
  }

  // ▼▼▼ 【主要！！！】第三個情景：統一AI回復生成器▼▼▼
  async function generateUnifiedAIResponse(tweetData, userComment, options = {}) {
    try {
      const {
        isOwnPost = false,
        commentType = 'main_comment', // 'main_comment' | 'reply_comment'
        pageType = 'detail', // 'detail' | 'main'
        parentComment = null,
        mainCommentId = null, // 用於樓中樓回復的主評論ID
      } = options;

      // 從資料庫讀取API配置
      const db = getDB(); // 用於訪問API配置
      const xDb = getXDB(); // 用於訪問X專用設置

      // 🚨 關鍵修復：重新從資料庫載入最新的推文資料，避免丟失使用者剛發的評論
      console.log('🔄 [AI回復] 重新載入最新推文資料，避免覆蓋使用者評論');
      const tweetId = tweetData.id;
      const isUserTweet = tweetId.startsWith('user_');
      const isRetweetMention = tweetData._source === 'retweet_mention';
      let latestTweetData = null;

      if (isRetweetMention) {
        // 從 Mentions 資料庫載入轉帖通知
        console.log('🔄 [AI回復] 從 Mentions 資料庫載入轉帖通知');
        const mentionsId = `mentions_${currentAccountId || 'main'}`;
        const mentionsData = await xDb.xAccountProfiles.get(mentionsId);
        if (mentionsData && mentionsData.data) {
          const mention = mentionsData.data.find(m => m.id === tweetId && m.type === 'retweet');
          if (mention) {
            // 重新構建 tweetData 結構，使用最新的評論資料
            latestTweetData = {
              ...tweetData,
              comments: mention.comments || [],
              stats: mention.stats || tweetData.stats,
            };
            console.log('✅ [AI回復] 已從 Mentions 載入轉帖數據，評論數:', latestTweetData.comments.length);
          }
        }
      } else if (isUserTweet) {
        const userTweetsId = `userTweets_${currentAccountId || 'main'}`;
        const userTweetsData = await xDb.xUserTweets.get(userTweetsId);
        if (userTweetsData && userTweetsData.tweets) {
          latestTweetData = userTweetsData.tweets.find(t => t.id === tweetId);
        }
      } else {
        const tweetsData = await xDb.xTweetsData.get('tweets');
        if (tweetsData) {
          latestTweetData =
            tweetsData.forYouTweets?.find(t => t.id === tweetId) ||
            tweetsData.followingTweets?.find(t => t.id === tweetId);
        }
      }

      // 如果成功載入到最新資料，使用最新資料；否則使用傳入的資料
      if (latestTweetData) {
        console.log('✅ [AI回復] 已載入最新推文資料，評論數:', latestTweetData.comments?.length || 0);
        tweetData = latestTweetData;
      } else {
        console.warn('⚠️ [AI回復] 未能載入最新推文資料，使用傳入資料');
      }

      const apiConfig = await db.apiConfig.get('main');
      if (!apiConfig || !apiConfig.proxyUrl || !apiConfig.apiKey || !apiConfig.model) {
        showXToast('請先配置API設置', 'error');
        return;
      }

      const { proxyUrl, apiKey, model } = apiConfig;

      // 從X設置中讀取配置（按帳號讀取）
      const settingsId = `xSettings_${currentAccountId || 'main'}`;
      const xSettings = await xDb.xSettings.get(settingsId);
      const userPrompt = xSettings?.systemPrompt || '';
      const worldSetting = xSettings?.worldSetting || '';
      const boundCharacters = xSettings?.boundCharacters || [];

      // 使用工具函數構建使用者X個人資料資訊（使用window.userProfileData確保獲取最新資料）
      const userXProfileInfo = StringBuilders.buildUserXProfileInfo(window.userProfileData);

      // Token計數器
      let tokenCount = 0;

      // 1. 提示詞 + 世界書
      let systemPrompt = StringBuilders.buildBaseSystemPrompt({
        userPrompt,
        worldSetting,
      });
      tokenCount = TokenUtils.logTokenUsage('統一AI回復生成器', '基礎系統提示詞', systemPrompt, tokenCount);

      // 2. 角色定義（評論回復生成專用）
      systemPrompt += `

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🚫 核心任務說明 🚫
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
你是X社交平臺的互動生成器。你的任務是：
✅ 為用戶的評論生成其他人的回應/反應
❌ 絕對不能再生成用戶本人的評論或回復

**明確：用戶已經發表了評論，你只負責生成別人對這條評論的反應！**
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━`;

      const coreTaskSection = systemPrompt.substring(systemPrompt.lastIndexOf('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━'));
      tokenCount = TokenUtils.logTokenUsage('統一AI回復生成器', '核心任務說明', coreTaskSection, tokenCount);

      // 添加場景分支提示詞（評論場景特有的詳細邏輯）
      const scenarioPromptStart = systemPrompt.length;
      systemPrompt += StringBuilders.buildScenarioPrompt({
        isOwnPost,
        commentType,
        pageType,
        parentComment,
      });
      const scenarioPrompt = systemPrompt.substring(scenarioPromptStart);
      tokenCount = TokenUtils.logTokenUsage('統一AI回復生成器', '場景分支提示詞', scenarioPrompt, tokenCount);

      // 3. 角色資料（回復場景）
      const charactersInfo = await StringBuilders.buildCompleteCharacterInfo(
        boundCharacters,
        userXProfileInfo,
        'reply',
      );
      if (charactersInfo) {
        systemPrompt += charactersInfo;
        tokenCount = TokenUtils.logTokenUsage('統一AI回復生成器', '角色資料資訊', charactersInfo, tokenCount);
      }

      // 4. 使用者資料
      const userConstraintsStart = systemPrompt.length;
      systemPrompt += StringBuilders.buildUniversalConstraints(userXProfileInfo);
      const userConstraints = systemPrompt.substring(userConstraintsStart);
      tokenCount = TokenUtils.logTokenUsage('統一AI回復生成器', '使用者資料約束', userConstraints, tokenCount);

      systemPrompt += `

【評論回復要求】：
- 生成1-5條回復，內容多樣化（簡短/深度/表情符號）
- 環境貼合：參考評論區現有討論，基於主題和氛圍生成貼合回復
- 回復內容必須圍繞推文主題和使用者評論內容，不要偏離主題
- 除了綁定角色外，其他用戶頭像統一：https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg

${
  boundCharacters.length > 0
    ? `**角色回復要點**：根據設定判斷是否適合發言，符合人設特點，可生成0-2個角色回復，嚴格使用角色X資料資訊。`
    : '**當前狀態**：無綁定角色，生成普通用戶回復。'
}

【🔒 隱私保護規則 - 路人回復限制】：
🚨 路人回復者（非綁定角色/關係NPC的普通用戶）只能基於X平臺公開信息：
  ✅ 可以使用：X姓名、X控制碼、X簡介、公開身份
  ❌ 禁止提及：真實姓名、真實職業、私人關係、未公開的身份資訊
  ❌ 禁止使用：只有親密關係才知道的稱呼（如"老師"、"同學"、"老闆"等，除非是公開身份）
  ❌ 禁止提及：角色人設描述中的私密細節
  
示例說明：
- ✅ 正確："姐姐說得對"（基於公開的社交稱呼）
- ❌ 錯誤："王老師說得好"（洩露了真實姓氏和職業）
- ❌ 錯誤："同學你好厲害"（假裝是同學關係，路人不可能知道）
  
⚠️ 只有已綁定的關係NPC才能提及私密資訊或使用私密稱呼（因為他們是角色的私人關係）

【情侶角色回復規則】：
${
  userXProfileInfo.verificationType === 'couple' && userXProfileInfo.coupleCharacterName
    ? `- 用戶的情侶是 ${userXProfileInfo.coupleCharacterName}
- **關鍵限制**：在他人帖子下回復用戶評論時，出現概率極低（5-15%）
  * 評論與情侶角色無關 → 不出現
  * 話題普通/日常 → 很少出現
  * 只有評論內容與情侶角色相關、或確有理由參與討論時才可能出現
- 回復圍繞帖子主題和討論，不只是"秀恩愛"
- 粉絲群體嚴格限制：僅當雙方為明星/網紅/公眾人物時才可能有1條CP粉絲評論（概率極低），普通情侶絕無"磕學家""CP粉"等粉絲群體`
    : ''
}

【JSON返回格式】：
\`\`\`json
{
  "${commentType === 'reply_comment' && pageType === 'main' ? 'replies' : 'comments'}": [回復陣列]
}
\`\`\`

回復物件結構：
- user: {name, handle, avatar, verified}
- content: 回復文本
- timeOffset: 相對推文發佈的分鐘數（負數，如-5表示推文發佈後5分鐘的回復）
- replyTo: "${userComment.user.handle}" (必須回復用戶剛發表的評論)
- replies: []

關鍵規則：
1. verified欄位必須是布林值(true/false)
1.5. timeOffset必須是負數，表示回復發佈在推文之後多少分鐘（如-2, -5, -15等）
2. replyTo欄位必須是"${userComment.user.handle}"，表示回復用戶的評論
3. ${
        boundCharacters.length > 0
          ? '生成角色回復時必須嚴格使用提供的角色X資料(xName、xHandle、xAvatar、xVerified)，不得使用預設值或自編資訊'
          : '普通用戶回復，自創用戶名和控制碼'
      }`;

      const formatSection = systemPrompt.substring(systemPrompt.lastIndexOf('【JSON返回格式】'));
      tokenCount = TokenUtils.logTokenUsage('統一AI回復生成器', 'JSON格式要求', formatSection, tokenCount);

      // 構建上下文信息
      let contextInfo = `【推文信息${pageType === 'detail' ? '（詳情頁）' : '（主頁）'}】
標題：${isOwnPost ? '【用戶的帖子】' : ''}${tweetData.content}
推文作者：${tweetData.user.name} (${tweetData.user.handle})
${tweetData.location ? `位置：${tweetData.location}` : ''}
${tweetData.link ? `連結：${tweetData.link.title || tweetData.link.url}` : ''}
${tweetData.media && tweetData.media.length > 0 ? `媒體：${tweetData.media[0].description}` : ''}`;

      // 如果推文包含引用內容，添加引用資訊
      if (tweetData.quotedTweet) {
        const quoted = tweetData.quotedTweet;
        const quotedType = quoted.type === 'tweet' ? '推文' : '評論';
        contextInfo += `

【該推文引用了以下${quotedType}】
原作者：${quoted.user.name} (${quoted.user.handle})${quoted.user.verified ? ' ✓已認證' : ''}
發佈時間：${quoted.time}
原內容："${quoted.content}"`;

        // 如果引用內容包含圖片，添加圖片資訊
        if (quoted.image) {
          if (quoted.image.type === 'description') {
            contextInfo += `
原圖片描述：${quoted.image.content}`;
          } else if (quoted.image.type === 'upload') {
            contextInfo += `
原圖片：包含上傳的圖片內容`;
          }
        }

        // 如果引用內容包含位置資訊
        if (quoted.location) {
          contextInfo += `
原位置：${quoted.location}`;
        }

        contextInfo += `

注意：這是引用轉發，用戶的評論是對上述${quotedType}的回應/評論。回復時可以同時考慮用戶的評論和被引用的原內容，可以討論引用關係、原作者觀點，或用戶的轉發評論等。`;
      }

      contextInfo += `

【用戶發表的${commentType === 'main_comment' ? '評論' : '回復'}】
用戶名：${userComment.user.name}
用戶控制碼：${userComment.user.handle}
${commentType === 'main_comment' ? '評論' : '回復'}內容：${userComment.content}`;

      if (commentType === 'reply_comment' && parentComment) {
        contextInfo += `

【使用者回復的物件（樓中樓場景）】
被回復者姓名：${parentComment.user.name}
被回復者控制碼：${parentComment.user.handle}
被回復的評論：${parentComment.content}

⚠️ 重要說明：
- 用戶 ${userComment.user.name} (${userComment.user.handle}) 剛剛回復了 ${parentComment.user.name} (${parentComment.user.handle}) 的評論
- 你生成的回復必須是對用戶 ${userComment.user.name} (${userComment.user.handle}) 的回復
- 所有回復的 replyTo 欄位必須是 "${userComment.user.handle}"`;
      }

      // 添加已有評論區內容到上下文
      if (tweetData.comments && tweetData.comments.length > 0) {
        contextInfo += `

【當前評論區內容】（共${tweetData.comments.length}條評論，説明理解討論主題和氛圍）`;

        // 顯示最多前10條評論，避免上下文過長
        const displayComments = tweetData.comments.slice(0, 10);
        displayComments.forEach((comment, index) => {
          contextInfo += `
${index + 1}. ${comment.user.name} (${comment.user.handle}): ${comment.content}`;

          // 如果有回復，也顯示前3條
          if (comment.replies && comment.replies.length > 0) {
            const displayReplies = comment.replies.slice(0, 3);
            displayReplies.forEach((reply, replyIndex) => {
              contextInfo += `
   └─ ${reply.user.name} (${reply.user.handle}): ${reply.content}`;
            });

            if (comment.replies.length > 3) {
              contextInfo += `
   └─ ...還有${comment.replies.length - 3}條回復`;
            }
          }
        });

        if (tweetData.comments.length > 10) {
          contextInfo += `
...還有${tweetData.comments.length - 10}條評論未顯示`;
        }
      }

      // 讀取推文作者的完整資料（使用統一資料獲取系統）
      if (tweetData.user && tweetData.user.handle) {
        try {
          console.log(`📝 [統一AI回復] 讀取推文作者資料: ${tweetData.user.handle}`);

          // 使用統一資料獲取系統
          const tweetAuthorProfile = await StringBuilders.getUnifiedProfile(tweetData.user.handle, {
            userProfileInfo: userXProfileInfo,
          });

          if (tweetAuthorProfile) {
            contextInfo += `

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📝 推文作者完整資料 📝
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;

            // 格式化資料
            contextInfo += StringBuilders.formatProfileForPrompt(tweetAuthorProfile, {
              includeType: true,
              includeTweets: true,
              includeRelationships: true,
            });

            contextInfo += `
⚠️ 推文作者資料使用說明：
- 如果推文作者是角色/NPC，回復時可能會來評論區互動
- 推文作者的關係NPC如果看到這條推文，可能會來評論
- 回復要符合推文作者的身份和背景
- 如果推文作者與用戶有聊天記憶，可以自然體現在互動中
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;

            tokenCount = TokenUtils.logTokenUsage(
              '統一AI回復生成器',
              '推文作者資料',
              contextInfo.substring(contextInfo.lastIndexOf('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━')),
              tokenCount,
            );
          }
        } catch (error) {
          console.error(`❌ [統一AI回復] 讀取推文作者資料失敗:`, error);
        }
      }

      // 記錄上下文資訊token
      TokenUtils.logTokenUsage('統一AI回復生成器', '上下文資訊', contextInfo, tokenCount);

      // 構建消息內容，支援圖片識別
      const messageContent = [];
      messageContent.push({ type: 'text', text: contextInfo });

      // 如果使用者評論包含上傳的圖片，添加圖片內容
      if (userComment.image && userComment.image.type === 'upload' && userComment.image.content) {
        messageContent.push({
          type: 'image_url',
          image_url: { url: userComment.image.content },
        });
      } else if (userComment.image && userComment.image.type === 'description') {
        messageContent.push({
          type: 'text',
          text: `使用者評論附帶的圖片描述：${userComment.image.content}`,
        });
      }

      const messages = [{ role: 'user', content: messageContent }];

      // 最終統計
      const contextText = messageContent.map(c => c.text || '[圖片]').join(' ');
      TokenUtils.logFinalPrompt('統一AI回復生成器', systemPrompt, contextText);

      // API調用
      let isGemini = proxyUrl.includes('generativelanguage');
      let response;

      if (isGemini) {
        // 為X社交頁面創建正確的Gemini請求配置
        const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models';
        const geminiConfig = {
          url: `${GEMINI_API_URL}/${model}:generateContent?key=${getRandomValue(apiKey)}`,
          data: {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              contents: [
                {
                  parts: [
                    {
                      text:
                        systemPrompt +
                        '\n\n' +
                        messages
                          .map(m =>
                            Array.isArray(m.content) ? m.content.map(c => c.text || '[圖片]').join(' ') : m.content,
                          )
                          .join('\n'),
                    },
                  ],
                },
              ],
              generationConfig: {
                temperature: 0.8,
              },
            }),
          },
        };
        response = await fetch(geminiConfig.url, geminiConfig.data);
      } else {
        const openAiPayload = {
          model: model,
          messages: [{ role: 'system', content: systemPrompt }, ...messages],
          temperature: 0.8,
          stream: false,
        };
        response = await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${apiKey}`,
          },
          body: JSON.stringify(openAiPayload),
        });
      }

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(`API錯誤: ${response.status} - ${errorData.error?.message || response.statusText}`);
      }

      const data = await response.json();
      let aiResponseContent = isGemini ? getGeminiResponseText(data) : data.choices?.[0]?.message?.content || '';

      console.log('統一AI原始回應:', aiResponseContent);
      console.log('綁定角色數量:', boundCharacters.length);
      console.log('評論區上下文:', tweetData.comments ? `${tweetData.comments.length}條評論` : '無評論');
      if (tweetData.comments && tweetData.comments.length > 0) {
        console.log(
          '評論示例:',
          tweetData.comments.slice(0, 3).map(c => `${c.user.name}: ${c.content.substring(0, 50)}...`),
        );
      }

      // 解析AI返回的JSON資料
      const cleanedResponse = aiResponseContent
        .replace(/```json\s*/, '')
        .replace(/```\s*$/, '')
        .trim();
      if (!cleanedResponse) throw new Error('AI返回了空的回應內容');

      let replyData;
      try {
        replyData = JSON.parse(cleanedResponse);
      } catch (parseError) {
        console.error('JSON解析失敗:', parseError);
        console.error('嘗試解析的內容:', cleanedResponse);
        throw new Error(`AI返回的資料不是有效的JSON格式: ${parseError.message}`);
      }

      // 🚫 篩選用戶身份冒用（最優先）
      replyData = StringBuilders.filterUserImpersonation(replyData, userXProfileInfo.handle, userXProfileInfo.name);

      // 🔧 強制修正所有頭像
      await StringBuilders.enforceAvatarRules(replyData, userXProfileInfo.handle);

      // 統一資料處理
      const timestamp = Date.now();
      const repliesKey = commentType === 'reply_comment' && pageType === 'main' ? 'replies' : 'comments';
      const replies = replyData[repliesKey] || [];

      if (!Array.isArray(replies)) {
        throw new Error('AI返回的資料格式不正確');
      }

      // 根據頁面類型和評論類型處理渲染
      if (pageType === 'detail') {
        console.log('🤖 [AI回復] 詳情頁模式 - 生成了', replies.length, '條回復');

        // 詳情頁面：先更新資料，再渲染到頁面
        // 將AI回復添加到推文數據中
        let tweetTimestamp = tweetData.timestamp || tweetData.createdAt || Date.now();

        // 確保時間戳記是數位格式（處理可能的Date物件或字串）
        if (typeof tweetTimestamp !== 'number') {
          if (tweetTimestamp instanceof Date) {
            tweetTimestamp = tweetTimestamp.getTime();
          } else if (typeof tweetTimestamp === 'string') {
            tweetTimestamp = new Date(tweetTimestamp).getTime();
          } else {
            tweetTimestamp = Date.now();
          }
        }

        // 驗證推文時間戳記有效性
        if (isNaN(tweetTimestamp) || tweetTimestamp <= 0) {
          console.warn('⚠️ [AI回復] 推文時間戳記無效，使用當前時間');
          tweetTimestamp = Date.now();
        }

        if (commentType === 'main_comment') {
          // 主評論回復
          replies.forEach((comment, index) => {
            comment.id = `ai_unified_${timestamp}_${index}`;

            // 轉換timeOffset為實際時間戳記
            if (comment.timeOffset !== undefined && !isNaN(comment.timeOffset)) {
              comment.timestamp = tweetTimestamp + Math.abs(comment.timeOffset) * 60 * 1000;
              delete comment.timeOffset;
            } else if (!comment.timestamp || isNaN(comment.timestamp)) {
              comment.timestamp = tweetTimestamp + (2 + Math.random() * 20) * 60 * 1000;
            }

            // 最終驗證
            if (isNaN(comment.timestamp) || comment.timestamp <= 0) {
              console.warn('⚠️ [AI回復] 評論時間戳記無效，使用推文時間');
              comment.timestamp = tweetTimestamp;
            }

            tweetData.comments.push(comment);
          });
          tweetData.stats.comments += replies.length;
          console.log('🤖 [AI回復] AI回復已添加到推文數據，新評論總數:', tweetData.stats.comments);
        } else if (commentType === 'reply_comment' && parentComment) {
          // 樓中樓回復
          const targetComment = tweetData.comments.find(c => c.id === parentComment.id);
          if (targetComment) {
            if (!targetComment.replies) targetComment.replies = [];
            replies.forEach((reply, index) => {
              reply.id = `ai_unified_${timestamp}_${index}`;

              // 轉換timeOffset為實際時間戳記
              if (reply.timeOffset !== undefined && !isNaN(reply.timeOffset)) {
                reply.timestamp = tweetTimestamp + Math.abs(reply.timeOffset) * 60 * 1000;
                delete reply.timeOffset;
              } else if (!reply.timestamp || isNaN(reply.timestamp)) {
                // 回復時間應該比父評論晚
                let parentTimestamp = targetComment.timestamp || targetComment.createdAt || tweetTimestamp;
                // 確保 parentTimestamp 是數字
                if (typeof parentTimestamp !== 'number') {
                  parentTimestamp =
                    parentTimestamp instanceof Date
                      ? parentTimestamp.getTime()
                      : typeof parentTimestamp === 'string'
                      ? new Date(parentTimestamp).getTime()
                      : tweetTimestamp;
                }
                reply.timestamp = parentTimestamp + (1 + Math.random() * 10) * 60 * 1000;
              }

              // 最終驗證
              if (isNaN(reply.timestamp) || reply.timestamp <= 0) {
                console.warn('⚠️ [AI回復] 樓中樓回復時間戳記無效，使用推文時間');
                reply.timestamp = tweetTimestamp;
              }

              targetComment.replies.push(reply);
            });
            console.log(
              '🤖 [AI回復] 樓中樓回復已添加，目標評論:',
              parentComment.id,
              '，當前回復總數:',
              targetComment.replies.length,
            );
          } else {
            console.error('❌ [AI回復] 未找到目標評論:', parentComment.id);
          }
        }

        // 保存到資料庫
        try {
          const xDb = getXDB();
          const isUserTweet = tweetData.id.startsWith('user_');
          const isAccountTweet = tweetData._source === 'account';
          const isRetweetMention = tweetData._source === 'retweet_mention';
          const isNewTweetMention = tweetData._source === 'newtweet_mention';

          if (isRetweetMention) {
            console.log('🤖 [AI回復] 保存到 Mentions 轉帖通知資料');
            const mentionsId = `mentions_${currentAccountId || 'main'}`;
            const mentionsData = await xDb.xAccountProfiles.get(mentionsId);

            if (mentionsData && mentionsData.data) {
              // 找到對應的轉帖通知並更新其評論
              const retweetIndex = mentionsData.data.findIndex(m => m.id === tweetData.id && m.type === 'retweet');
              if (retweetIndex !== -1) {
                // 更新評論資料
                mentionsData.data[retweetIndex].comments = tweetData.comments;
                // 同步更新 stats
                if (!mentionsData.data[retweetIndex].stats) {
                  mentionsData.data[retweetIndex].stats = tweetData.stats;
                } else {
                  mentionsData.data[retweetIndex].stats.comments = tweetData.stats.comments;
                }

                await xDb.xAccountProfiles.put(mentionsData);
                console.log('✅ [AI回復] Mentions 轉帖通知已更新，評論總數:', tweetData.comments.length);
              } else {
                console.warn('⚠️ [AI回復] 未在 Mentions 資料中找到對應的轉帖通知:', tweetData.id);
              }
            } else {
              console.warn('⚠️ [AI回復] 未找到 Mentions 數據:', mentionsId);
            }
          } else if (isNewTweetMention) {
            console.log('🤖 [AI回復] 保存到 Mentions New Tweet 通知資料');
            const mentionsId = `mentions_${currentAccountId || 'main'}`;
            const mentionsData = await xDb.xAccountProfiles.get(mentionsId);

            if (mentionsData && mentionsData.data) {
              // 找到對應的 New Tweet 通知並更新其推文評論
              const newTweetIndex = mentionsData.data.findIndex(
                m => m.id === tweetData._mentionId && m.type === 'newTweet',
              );
              if (newTweetIndex !== -1) {
                // 更新推文的評論資料
                if (!mentionsData.data[newTweetIndex].tweet) {
                  mentionsData.data[newTweetIndex].tweet = {};
                }
                mentionsData.data[newTweetIndex].tweet.comments = tweetData.comments;
                // 同步更新 stats
                if (!mentionsData.data[newTweetIndex].tweet.stats) {
                  mentionsData.data[newTweetIndex].tweet.stats = tweetData.stats;
                } else {
                  mentionsData.data[newTweetIndex].tweet.stats.comments = tweetData.stats.comments;
                }

                await xDb.xAccountProfiles.put(mentionsData);
                console.log('✅ [AI回復] Mentions New Tweet 通知已更新，評論總數:', tweetData.comments.length);
              } else {
                console.warn('⚠️ [AI回復] 未在 Mentions 資料中找到對應的 New Tweet 通知:', tweetData._mentionId);
              }
            } else {
              console.warn('⚠️ [AI回復] 未找到 Mentions 數據:', mentionsId);
            }
          } else if (isAccountTweet) {
            console.log('🤖 [AI回復] 保存到帳戶推文資料');
            const accountHandle =
              tweetData._accountHandle || (currentViewingAccount.accountInfo || currentViewingAccount).handle;
            const cleanHandle = accountHandle.replace('@', '');

            if (currentViewingAccount && currentViewingAccount.tweets) {
              const tweetIndex = currentViewingAccount.tweets.findIndex(t => t.id === tweetData.id);
              if (tweetIndex !== -1) {
                currentViewingAccount.tweets[tweetIndex] = tweetData;

                await xDb.xAccountProfiles.put({
                  handle: cleanHandle,
                  name: (currentViewingAccount.accountInfo || currentViewingAccount).name,
                  accountInfo: currentViewingAccount.accountInfo || currentViewingAccount,
                  tweets: currentViewingAccount.tweets,
                  accountReplies: currentViewingAccount.accountReplies || [],
                  updatedAt: new Date().toISOString(),
                });

                console.log('✅ [AI回復] 帳戶推文已保存，帳戶:', cleanHandle);
              }
            }
          } else if (isUserTweet) {
            console.log('🤖 [AI回復] 保存到使用者推文資料');
            const userTweetsId = `userTweets_${currentAccountId || 'main'}`;
            const userTweetsData = await xDb.xUserTweets.get(userTweetsId);

            if (userTweetsData && userTweetsData.tweets) {
              const tweetIndex = userTweetsData.tweets.findIndex(t => t.id === tweetData.id);
              if (tweetIndex !== -1) {
                userTweetsData.tweets[tweetIndex] = tweetData;
                await xDb.xUserTweets.put(userTweetsData);
                console.log(
                  '✅ [AI回復] 用戶推文AI回復已保存，評論總數:',
                  tweetData.comments.length,
                  '，主評論',
                  tweetData.comments.length,
                  '條',
                );
              } else {
                console.error('❌ [AI回復] 未在資料庫中找到目標推文');
              }
            }
          } else {
            console.log('🤖 [AI回復] 保存到主頁推文資料');
            const tweetsData = await xDb.xTweetsData.get('tweets');
            if (tweetsData) {
              let updated = false;

              if (tweetsData.forYouTweets) {
                const index = tweetsData.forYouTweets.findIndex(t => t.id === tweetData.id);
                if (index !== -1) {
                  tweetsData.forYouTweets[index] = tweetData;
                  updated = true;
                }
              }

              if (tweetsData.followingTweets && !updated) {
                const index = tweetsData.followingTweets.findIndex(t => t.id === tweetData.id);
                if (index !== -1) {
                  tweetsData.followingTweets[index] = tweetData;
                  updated = true;
                }
              }

              if (updated) {
                await xDb.xTweetsData.put(tweetsData);
                console.log(
                  '✅ [AI回復] 主頁推文AI回復已保存，評論總數:',
                  tweetData.comments.length,
                  '，主評論',
                  tweetData.comments.length,
                  '條',
                );
              } else {
                console.error('❌ [AI回復] 未在資料庫中找到目標推文');
              }
            }
          }

          // 更新 sessionStorage
          sessionStorage.setItem('currentTweetData', JSON.stringify(tweetData));
          console.log('✅ [AI回復] sessionStorage 已更新');
        } catch (saveError) {
          console.error('❌ [AI回復] 保存AI回復到資料庫失敗:', saveError);
        }

        // 渲染到頁面
        replies.forEach((comment, index) => {
          const commentElement = createCommentElement(comment, commentType === 'reply_comment');
          const commentsContainer = document.getElementById('detail-comments-container');

          if (commentType === 'reply_comment' && parentComment) {
            // 對於樓中樓回復，找到被回復評論的位置，插入為平級
            const allComments = commentsContainer.querySelectorAll('.comment-item');
            let insertPosition = null;
            let insertAfter = null;

            // 找到被回復評論的位置
            allComments.forEach(commentEl => {
              if (commentEl.dataset.commentId === parentComment.id) {
                insertPosition = commentEl;

                // 如果被回復的是樓中樓評論，找到這個評論組的最後一個評論
                if (commentEl.classList.contains('reply-item')) {
                  let nextSibling = commentEl.nextElementSibling;
                  insertAfter = commentEl;

                  // 找到當前評論組的最後一條評論
                  while (nextSibling && nextSibling.classList.contains('reply-item')) {
                    insertAfter = nextSibling;
                    nextSibling = nextSibling.nextElementSibling;
                  }
                } else {
                  // 如果被回復的是主評論，找到這個評論組的最後一條評論（包括所有樓中樓）
                  let nextSibling = commentEl.nextElementSibling;
                  insertAfter = commentEl;

                  while (nextSibling && nextSibling.classList.contains('reply-item')) {
                    insertAfter = nextSibling;
                    nextSibling = nextSibling.nextElementSibling;
                  }
                }
              }
            });

            if (insertAfter) {
              // 插入到評論組的最後位置
              if (insertAfter.nextSibling) {
                insertAfter.parentNode.insertBefore(commentElement, insertAfter.nextSibling);
              } else {
                insertAfter.parentNode.appendChild(commentElement);
              }
            } else {
              // 如果沒找到位置，就添加到末尾
              commentsContainer.appendChild(commentElement);
            }
          } else {
            // 主評論回復或找不到特定位置時，添加到末尾
            commentsContainer.appendChild(commentElement);
          }
        });

        console.log('✅ [AI回復] AI回復已渲染到頁面');

        // 更新回復輸入框頭像
        const replyUserAvatars = document.querySelectorAll('.reply-user-avatar');
        replyUserAvatars.forEach(avatar => {
          avatar.src = userProfileData.avatar;
        });
      } else {
        // 主頁：更新資料並重新渲染
        console.log('🤖 [AI回復] 主頁模式 - 開始處理');
        let tweetTimestamp = tweetData.timestamp || tweetData.createdAt || Date.now();

        // 確保時間戳記是數位格式（處理可能的Date物件或字串）
        if (typeof tweetTimestamp !== 'number') {
          if (tweetTimestamp instanceof Date) {
            tweetTimestamp = tweetTimestamp.getTime();
          } else if (typeof tweetTimestamp === 'string') {
            tweetTimestamp = new Date(tweetTimestamp).getTime();
          } else {
            tweetTimestamp = Date.now();
          }
        }

        // 驗證推文時間戳記有效性
        if (isNaN(tweetTimestamp) || tweetTimestamp <= 0) {
          console.warn('⚠️ [AI回復] 主頁模式：推文時間戳記無效，使用當前時間');
          tweetTimestamp = Date.now();
        }

        if (commentType === 'main_comment') {
          // 主評論：添加到推文評論列表
          replies.forEach((comment, index) => {
            comment.id = `ai_main_unified_${timestamp}_${index}`;

            // 轉換timeOffset為實際時間戳記
            if (comment.timeOffset !== undefined && !isNaN(comment.timeOffset)) {
              comment.timestamp = tweetTimestamp + Math.abs(comment.timeOffset) * 60 * 1000;
              delete comment.timeOffset;
            } else if (!comment.timestamp || isNaN(comment.timestamp)) {
              comment.timestamp = tweetTimestamp + (2 + Math.random() * 20) * 60 * 1000;
            }

            // 最終驗證
            if (isNaN(comment.timestamp) || comment.timestamp <= 0) {
              console.warn('⚠️ [AI回復] 主頁模式：評論時間戳記無效，使用推文時間');
              comment.timestamp = tweetTimestamp;
            }

            tweetData.comments.push(comment);
          });
          tweetData.stats.comments += replies.length;
          console.log('🤖 [AI回復] 已添加主評論，新增:', replies.length, '條，總計:', tweetData.comments.length);
        } else {
          // 樓中樓回復：添加到主評論的replies（平級顯示）
          const targetCommentId = mainCommentId || parentComment.id;
          const mainCommentObj = tweetData.comments.find(c => c.id === targetCommentId);
          if (mainCommentObj) {
            replies.forEach((reply, index) => {
              reply.id = `ai_main_sub_unified_${timestamp}_${index}`;

              // 轉換timeOffset為實際時間戳記
              if (reply.timeOffset !== undefined && !isNaN(reply.timeOffset)) {
                reply.timestamp = tweetTimestamp + Math.abs(reply.timeOffset) * 60 * 1000;
                delete reply.timeOffset;
              } else if (!reply.timestamp || isNaN(reply.timestamp)) {
                let parentTimestamp = mainCommentObj.timestamp || mainCommentObj.createdAt || tweetTimestamp;
                // 確保 parentTimestamp 是數字
                if (typeof parentTimestamp !== 'number') {
                  parentTimestamp =
                    parentTimestamp instanceof Date
                      ? parentTimestamp.getTime()
                      : typeof parentTimestamp === 'string'
                      ? new Date(parentTimestamp).getTime()
                      : tweetTimestamp;
                }
                reply.timestamp = parentTimestamp + (1 + Math.random() * 10) * 60 * 1000;
              }

              // 最終驗證
              if (isNaN(reply.timestamp) || reply.timestamp <= 0) {
                console.warn('⚠️ [AI回復] 主頁模式：樓中樓回復時間戳記無效，使用推文時間');
                reply.timestamp = tweetTimestamp;
              }

              if (!mainCommentObj.replies) mainCommentObj.replies = [];
              mainCommentObj.replies.push(reply);
            });
            console.log('🤖 [AI回復] 已添加樓中樓回復到主評論:', targetCommentId, '，新增:', replies.length, '條');
          } else {
            console.warn('⚠️ [AI回復] 無法找到主評論，mainCommentId:', targetCommentId);
          }
        }

        // 保存資料並重新渲染
        try {
          // 先更新全域陣列中的推文資料
          let updated = false;
          const tweetIndex = forYouTweets.findIndex(t => t.id === tweetData.id);
          if (tweetIndex !== -1) {
            forYouTweets[tweetIndex] = tweetData;
            updated = true;
            console.log('🤖 [AI回復] 已更新forYouTweets中的推文');
          } else {
            const followingIndex = followingTweets.findIndex(t => t.id === tweetData.id);
            if (followingIndex !== -1) {
              followingTweets[followingIndex] = tweetData;
              updated = true;
              console.log('🤖 [AI回復] 已更新followingTweets中的推文');
            }
          }

          if (!updated) {
            console.warn('⚠️ [AI回復] 未在全域陣列中找到推文:', tweetData.id);
          }

          // 保存到資料庫
          const existingData = await xDb.xTweetsData.get('tweets');
          if (existingData) {
            existingData.forYouTweets = forYouTweets;
            existingData.followingTweets = followingTweets;
            existingData.lastUpdated = new Date().toISOString();
            await xDb.xTweetsData.put(existingData);
            console.log('✅ [AI回復] 資料已保存到資料庫');
          } else {
            await xDb.xTweetsData.put({
              id: 'tweets',
              forYouTweets: forYouTweets,
              followingTweets: followingTweets,
              lastUpdated: new Date().toISOString(),
            });
            console.log('✅ [AI回復] 資料已創建並保存');
          }
        } catch (saveError) {
          console.error('❌ [AI回復] 保存統一AI回復資料失敗:', saveError);
        }

        // 重新渲染評論區
        console.log('🤖 [AI回復] 開始重新渲染評論區，推文ID:', currentTweetId);
        renderComments(currentTweetId);

        // 滾動到底部
        const commentsContainer = document.querySelector('.comments-container');
        setTimeout(() => {
          if (commentsContainer) {
            commentsContainer.scrollTop = commentsContainer.scrollHeight;
            console.log('✅ [AI回復] 評論區已滾動到底部');
          }
        }, 100);
      }

      // 顯示手機樣式通知
      const isEnglish = currentLanguage === 'en';
      const userAvatar = window.userProfileData?.avatar || 'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg';
      showPhoneNotification({
        title: 'X',
        message: isEnglish ? 'Your comment received a reply!' : '你的評論已經收到回復！',
        avatar: userAvatar,
        leftIcon: 'x',
      });

      // 🔓 檢測拉黑解除觸發（如果用戶評論了某人的推文）
      if (
        tweetData &&
        tweetData.user &&
        tweetData.user.handle &&
        userComment &&
        userComment.user &&
        userComment.user.handle
      ) {
        const userHandle = userComment.user.handle; // 用戶的控制碼
        const tweetAuthorHandle = tweetData.user.handle; // 推文作者的控制碼
        const commentContent = userComment.content; // 評論內容

        // 非同步檢測拉黑解除
        checkUnblockTrigger(userHandle, tweetAuthorHandle, 'comment', commentContent).catch(err => {
          console.error('拉黑解除檢測失敗（靜默）:', err);
        });
      }
    } catch (error) {
      console.error('生成統一AI回復失敗:', error);
      showXToast(`回復生成失敗: ${error.message}`, 'error');
    }
  }
  // 注意：已刪除重複的API輔助函式定義，使用檔開頭的健壯版本

  // ▲▲▲ 【主要！！！】第三個情景：統一AI回復生成器 ▲▲▲

  // ▲▲▲！！！三個情景綜合如上！！！▲▲▲

  //▼▼▼ 引用轉發功能JavaScript▼▼▼

  // 全域變數存儲當前引用內容
  let currentQuoteData = null;

  // 處理帳戶主頁推文的引用轉發
  window.handleQuoteRetweetFromAccountTweet = async function (tweetId) {
    if (!currentViewingAccount || !currentViewingAccount.tweets) {
      showXToast('無法找到推文資料', 'error');
      return;
    }

    // 從當前查看的帳戶資料中查找推文
    const tweet = currentViewingAccount.tweets.find(t => t.id === tweetId);
    if (!tweet) {
      showXToast('未找到該推文', 'error');
      return;
    }

    // 處理圖片資料（從media欄位轉換為image格式）
    let imageData = null;
    if (tweet.media && tweet.media.length > 0) {
      if (tweet.media[0].type === 'description') {
        imageData = {
          type: 'description',
          content: tweet.media[0].description,
        };
      }
    } else if (tweet.image) {
      // 相容已有的image欄位格式
      imageData = tweet.image;
    }

    // 調用引用處理函數
    handleQuoteRetweet(
      'tweet',
      tweet.id,
      tweet.user.name,
      tweet.user.handle,
      tweet.user.avatar,
      tweet.user.verified,
      tweet.content || '',
      tweet.time,
      imageData,
      null, // 帳戶推文暫不支援連結
      null, // 帳戶推文暫不支援位置
    );
  };

  // 從資料來源獲取引用資訊並處理轉發
  async function handleQuoteRetweetFromData(type, id) {
    let sourceData = null;

    if (type === 'tweet') {
      // 從主頁推文數據中查找
      const allTweets = [...forYouTweets, ...followingTweets];
      sourceData = allTweets.find(tweet => tweet.id === id);

      // 如果在主頁沒找到，查找用戶推文
      if (!sourceData) {
        try {
          const db = getXDB();

          // 🔧 多帳戶隔離：使用帳戶ID
          const userTweetsId = `userTweets_${currentAccountId || 'main'}`;
          const userTweets = await db.xUserTweets.get(userTweetsId);
          if (userTweets && userTweets.tweets) {
            sourceData = userTweets.tweets.find(tweet => tweet.id === id);
          }
        } catch (error) {
          console.error('查找用戶推文失敗:', error);
        }
      }

      // 如果還沒找到，嘗試從詳情頁當前推文中查找
      if (!sourceData) {
        const currentTweetData = sessionStorage.getItem('currentTweetData');
        if (currentTweetData) {
          try {
            const tweetData = JSON.parse(currentTweetData);
            if (tweetData.id === id) {
              sourceData = tweetData;
            }
          } catch (error) {
            console.error('解析詳情頁推文數據失敗:', error);
          }
        }
      }
    } else if (type === 'comment') {
      // 從評論數據中查找
      sourceData = await findCommentById(id);
    }

    if (!sourceData) {
      showXToast('無法找到要引用的內容', 'error');
      return;
    }

    // 處理圖片資料（從media欄位轉換為image格式）
    let imageData = null;
    if (sourceData.media && sourceData.media.length > 0) {
      // AI生成的推文使用media陣列，第一個元素包含圖片資訊
      if (sourceData.media[0].type === 'description') {
        // 圖片描述類型（AI生成的文字描述）
        imageData = {
          type: 'description',
          content: sourceData.media[0].description,
        };
      } else if (sourceData.media[0].type === 'image') {
        // 實際圖片類型（雖然目前不常用，但保持相容）
        imageData = {
          type: 'description',
          content: sourceData.media[0].description,
        };
      }
    } else if (sourceData.image) {
      // 相容已有的image欄位格式（使用者上傳的圖片）
      imageData = sourceData.image;
    }

    // 調用引用處理函數
    handleQuoteRetweet(
      type,
      id,
      sourceData.user.name,
      sourceData.user.handle,
      sourceData.user.avatar,
      sourceData.user.verified,
      sourceData.content || '',
      sourceData.time,
      imageData, // 傳遞圖片資料
      sourceData.link || null, // 傳遞連結資料
      sourceData.location || null, // 傳遞位置資料
    );
  }

  // 根據ID查找評論 - 修復樓中樓查找邏輯
  async function findCommentById(commentId) {
    // 首先嘗試直接從DOM中找到對應的評論元素並提取資料
    // 這樣可以確保引用的是用戶實際點擊的評論，避免資料結構和DOM結構不匹配
    const commentElement = document.querySelector(`[data-comment-id="${commentId}"]`);
    if (commentElement) {
      try {
        const userName = commentElement.querySelector('.tweet-user-name').textContent;
        const userHandle = commentElement.querySelector('.tweet-user-handle').textContent;
        const userAvatar = commentElement.querySelector('.tweet-avatar').src;
        const verified = commentElement.querySelector('.tweet-verified') !== null;
        const contentElement = commentElement.querySelector('.comment-content');

        // 獲取評論內容，過濾掉回復標記
        let content = '';
        if (contentElement) {
          // 克隆節點以避免修改原DOM
          const contentClone = contentElement.cloneNode(true);
          // 移除回復標記
          const replyTo = contentClone.querySelector('.reply-to');
          if (replyTo) {
            replyTo.remove();
          }
          content = contentClone.textContent.trim();
        }

        const timeElement = commentElement.querySelector('.tweet-time');
        const time = timeElement ? timeElement.textContent.replace('·', '').trim() : '剛剛';

        return {
          id: commentId,
          user: {
            name: userName,
            handle: userHandle,
            avatar: userAvatar,
            verified: verified,
          },
          content: content,
          time: time,
        };
      } catch (error) {
        console.error('從DOM提取評論資訊失敗:', error);
      }
    }

    // 如果從DOM提取失敗，回退到資料查找
    // 在主頁推文中查找
    const allTweets = [...forYouTweets, ...followingTweets];

    for (const tweet of allTweets) {
      if (tweet.comments) {
        for (const comment of tweet.comments) {
          if (comment.id === commentId) {
            return comment;
          }
          // 檢查回復
          if (comment.replies) {
            for (const reply of comment.replies) {
              if (reply.id === commentId) {
                return reply;
              }
            }
          }
        }
      }
    }

    // 在詳情頁面當前推文中查找
    const currentTweetData = sessionStorage.getItem('currentTweetData');
    if (currentTweetData) {
      const tweetData = ValidationUtils.safeParseJSON(currentTweetData);
      if (tweetData && tweetData.comments) {
        for (const comment of tweetData.comments) {
          if (comment.id === commentId) {
            return comment;
          }
          // 檢查回復
          if (comment.replies) {
            for (const reply of comment.replies) {
              if (reply.id === commentId) {
                return reply;
              }
            }
          }
        }
      }
    }

    // 在用戶推文中查找
    try {
      const db = getXDB();

      const userTweets = await db.xUserTweets.get('userTweets');
      if (userTweets && userTweets.tweets) {
        for (const tweet of userTweets.tweets) {
          if (tweet.comments) {
            for (const comment of tweet.comments) {
              if (comment.id === commentId) {
                return comment;
              }
              // 檢查回復
              if (comment.replies) {
                for (const reply of comment.replies) {
                  if (reply.id === commentId) {
                    return reply;
                  }
                }
              }
            }
          }
        }
      }
    } catch (error) {
      ValidationUtils.handleError(error, '查找用戶推文評論');
    }

    return null;
  }

  // 處理引用轉發
  function handleQuoteRetweet(
    type,
    id,
    userName,
    userHandle,
    userAvatar,
    verified,
    content,
    time,
    imageData = null,
    linkData = null,
    location = null,
  ) {
    // 打開發帖彈窗
    openComposeTweetModal();

    // 存儲引用資料
    currentQuoteData = {
      type: type, // 'tweet' 或 'comment'
      id: id,
      user: {
        name: userName,
        handle: userHandle,
        avatar: userAvatar,
        verified: verified,
      },
      content: content,
      time: time,
      image: imageData, // 圖片資料
      link: linkData, // 連結資料
      location: location, // 位置資料
    };

    // 顯示引用內容預覽
    showQuotePreview();

    // 更新文本輸入框預留位置
    const textInput = document.getElementById('compose-text-input');
    if (textInput) {
      textInput.placeholder = type === 'tweet' ? '添加你的評論來引用這條推文' : '添加你的評論來引用這條評論';
      textInput.focus();
    }
  }

  // 顯示引用內容預覽
  function showQuotePreview() {
    if (!currentQuoteData) return;

    const preview = document.getElementById('quote-content-preview');
    const typeText = document.getElementById('quote-type-text');
    const userAvatar = document.getElementById('quote-user-avatar');
    const userName = document.getElementById('quote-user-name');
    const userVerified = document.getElementById('quote-user-verified');
    const userHandle = document.getElementById('quote-user-handle');
    const userTime = document.getElementById('quote-user-time');
    const contentText = document.getElementById('quote-content-text');

    if (!preview) return;

    // 顯示預覽區域
    preview.style.display = 'block';

    // 設置參考類型
    if (typeText) {
      typeText.textContent = currentQuoteData.type === 'tweet' ? '引用推文' : '引用評論';
    }

    // 設置使用者資訊
    if (userAvatar) userAvatar.src = currentQuoteData.user.avatar;
    if (userName) userName.textContent = currentQuoteData.user.name;
    if (userHandle) userHandle.textContent = currentQuoteData.user.handle;
    if (userTime) userTime.textContent = '·' + currentQuoteData.time;

    // 顯示/隱藏認證圖示
    if (userVerified) {
      userVerified.style.display = currentQuoteData.user.verified ? 'inline' : 'none';
    }

    // 設置內容
    if (contentText) {
      // 處理內容中的HTML轉義
      const processedContent = currentQuoteData.content
        .replace(/&quot;/g, '"')
        .replace(/&#x27;/g, "'")
        .replace(/&amp;/g, '&');
      contentText.textContent = processedContent;
    }

    // 處理圖片內容（支援多圖）
    const imageContainer = document.getElementById('quote-image-container');
    if (imageContainer) {
      if (currentQuoteData.image) {
        imageContainer.style.display = 'block';

        // 文字描述類型
        if (currentQuoteData.image.type === 'description') {
          imageContainer.innerHTML = `
              <div style="margin-top: 8px; background-color: var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 8px; padding: 8px; box-sizing: border-box;">
                <div style="color: var(--x-text-primary); font-size: 13px; line-height: 1.4; white-space: pre-wrap; word-wrap: break-word; overflow-wrap: break-word; width: 100%; box-sizing: border-box;">${currentQuoteData.image.content}</div>
              </div>
            `;
        }
        // 單圖上傳
        else if (currentQuoteData.image.type === 'upload') {
          imageContainer.innerHTML = `
              <div style="margin-top: 8px; border-radius: 8px; overflow: hidden;">
                <img src="${currentQuoteData.image.content}" style="width: 100%; max-height: 120px; object-fit: cover; display: block;" alt="引用圖片">
              </div>
            `;
        }
        // 多圖上傳
        else if (
          currentQuoteData.image.type === 'uploads' &&
          currentQuoteData.image.images &&
          currentQuoteData.image.images.length > 0
        ) {
          const imageCount = currentQuoteData.image.images.length;
          let gridTemplate =
            imageCount <= 2 ? 'grid-template-columns: repeat(2, 1fr);' : 'grid-template-columns: repeat(2, 1fr);';

          const imagesHtml = currentQuoteData.image.images
            .map((img, index) => {
              return `
              <div style="border-radius: 6px; overflow: hidden;">
                <img src="${
                  img.content
                }" style="width: 100%; height: 80px; object-fit: cover; display: block;" alt="引用圖片${index + 1}">
              </div>
            `;
            })
            .join('');

          imageContainer.innerHTML = `
              <div style="margin-top: 8px; display: grid; ${gridTemplate} gap: 4px;">
                ${imagesHtml}
              </div>
            `;
        }
      } else {
        imageContainer.style.display = 'none';
        imageContainer.innerHTML = '';
      }
    }
  }

  // 移除引用內容
  function removeQuoteContent() {
    currentQuoteData = null;
    const preview = document.getElementById('quote-content-preview');
    if (preview) {
      preview.style.display = 'none';
    }

    // 清理圖片容器
    const imageContainer = document.getElementById('quote-image-container');
    if (imageContainer) {
      imageContainer.style.display = 'none';
      imageContainer.innerHTML = '';
    }

    // 恢復原始預留位置
    const textInput = document.getElementById('compose-text-input');
    if (textInput) {
      textInput.placeholder = '有什麼新鮮事？';
    }
  }
  //  ▲▲▲ 引用轉發功能JavaScript ▲▲▲
  // ▲▲▲ 【整合】X社交app的JavaScript代碼結束 ▲▲▲

  // ============================================
  // 第四部分: 初始化和對外介面
  // ============================================

  // 初始化X社交應用
  async function initXSocialApp() {
    try {
      console.log('🚀 初始化 X Social App...');

      // 0. 清理之前的計時器和狀態（防止重複初始化導致的問題）
      if (chatHistoryDetectionTimer) {
        clearInterval(chatHistoryDetectionTimer);
        chatHistoryDetectionTimer = null;
      }
      if (autoRefreshFeedTimer) {
        clearInterval(autoRefreshFeedTimer);
        autoRefreshFeedTimer = null;
      }
      // 重置啟用狀態（將由恢復函數根據保存的設置決定）
      chatHistoryDetectionEnabled = false;
      autoRefreshFeedEnabled = false;

      // 1. 注入樣式
      injectStyles();

      // 2. 創建HTML結構
      createXSocialHTML();

      // 3. 載入活躍帳號（必須在載入使用者資料之前）
      await loadActiveAccount();
      console.log('📌 當前活躍帳戶:', currentAccountId, '(window.currentAccountId:', window.currentAccountId + ')');

      // 4. 初始化推文數據
      await initializeTweets();

      // 5. 載入使用者資料（使用正確的currentAccountId）
      await loadUserProfile();

      // 6. 初始化X設置（按帳號載入）
      await initializeXSettings();

      // 7. 綁定所有事件處理器
      bindEventHandlers();

      // 8. 更新UI顯示（確保使用者資料正確顯示）
      loadUserProfileToUI();

      // 9. 載入主題偏好
      await loadXThemePreference();

      // 10. 載入主題色偏好
      await loadAccentColorPreference();

      // 11. 啟動後臺自動發消息系統（如果有角色啟用了該功能）
      setTimeout(() => {
        if (typeof startAutoMessageSystem === 'function') {
          startAutoMessageSystem();
        }
      }, 120000); // 延遲2分鐘啟動，確保所有資料已載入

      // 11.5. 啟動粉絲數動態浮動系統
      setTimeout(() => {
        if (typeof startFollowersFluctuationSystem === 'function') {
          startFollowersFluctuationSystem();
        }
      }, 120000); // 延遲2分鐘啟動，確保所有資料已載入

      // 12. 🔧 已移除智慧刷新主頁狀態的自動恢復功能（改為用戶手動開啟）
      // setTimeout(() => {
      //   restoreAutoRefreshFeedState();
      // }, 120000);

      // 13. 🔧 已移除聊天記憶檢測狀態的自動恢復功能（改為用戶手動開啟）
      // setTimeout(() => {
      //   restoreChatHistoryDetectionState();
      // }, 120000);

      console.log('✅ X Social App 初始化完成');
      console.log('💡 [提示] 智慧刷新和智慧檢測需要手動開啟');
    } catch (error) {
      console.error('❌ X Social App 初始化失敗:', error);
      showXToast('應用初始化失敗: ' + error.message, 'error');
    }
  }

  // 渲染X社交頁面 - 相容現有HTML的調用方式
  function renderXSocialScreen() {
    console.log('🎬 渲染X社交頁面');

    // 如果還未初始化，先初始化
    const xScreen = document.getElementById('x-social-screen');
    if (!xScreen) {
      console.log('⚠️ X社交頁面未創建，開始初始化...');
      initXSocialApp().then(() => {
        console.log('✅ 初始化完成，顯示主頁');
        const screen = document.getElementById('x-social-screen');
        if (screen) {
          screen.style.display = 'flex';
          switchXPage('home');
        }
      });
    } else {
      console.log('✅ X社交頁面已存在，直接顯示');
      // 確保頁面可見
      xScreen.style.display = 'flex';
      switchXPage('home');
    }
  }

  // 獲取預設使用者資料配置（統一管理）
  function getDefaultUserProfile(accountId = 'main') {
    return {
      id: accountId,
      name: accountId === 'main' ? '我' : '新用戶',
      handle: accountId === 'main' ? '@me' : '@newuser_' + Date.now().toString().slice(-6),
      avatar: 'https://i.postimg.cc/pXxk1JXk/IMG-6442.jpg',
      coverImage: 'https://i.postimg.cc/qRzMB6nQ/default-cover.jpg',
      verified: false,
      verificationType: 'none',
      bio: '歡迎來到我的X主頁！',
      publicIdentity: '',
      showRealName: false,
      realName: '',
      customTag1: '科技愛好者',
      customTag1Icon: '✨',
      customTag1Color: '#71767b',
      customTag2: '2024年加入',
      customTag2Icon: '📅',
      customTag2Color: '#71767b',
      followingCount: accountId === 'main' ? '156' : '0',
      followersCount: accountId === 'main' ? '89' : '0',
      knownIdentityCharacters: [],
      coupleCharacterId: '',
      coupleCharacterName: '',
      lastUpdated: new Date().toISOString(),
    };
  }

  // 載入使用者資料（初始化專用 - 簡化版）
  async function loadUserProfile() {
    try {
      const db = getXDB();
      const accountId = currentAccountId || 'main';
      const profile = await db.xUserProfile.get(accountId);

      if (profile) {
        // 更新現有物件的屬性，而不是替換整個物件（保持引用一致）
        Object.assign(window.userProfileData, profile);
      } else {
        // 使用預設使用者資料並保存到資料庫（僅在首次初始化時）
        const defaultProfile = getDefaultUserProfile(accountId);
        Object.assign(window.userProfileData, defaultProfile);
        await db.xUserProfile.put(window.userProfileData);
        console.log('📝 已創建預設使用者資料:', accountId);
      }

      // 確保必要欄位存在（相容舊資料）
      ensureProfileFields(window.userProfileData);

      console.log('✅ 使用者資料已載入:', window.userProfileData.name, '(帳戶:', accountId + ')');
      console.log('🔍 使用者資料詳情:', {
        認證類型: window.userProfileData.verificationType,
        情侶角色: window.userProfileData.coupleCharacterName,
        已知身份角色數: window.userProfileData.knownIdentityCharacters?.length || 0,
      });
    } catch (error) {
      console.error('❌ 載入使用者資料失敗:', error);
      // 即使失敗也使用預設值
      const defaultProfile = getDefaultUserProfile('main');
      Object.assign(window.userProfileData, defaultProfile);
    }
  }

  // 確保使用者資料包含所有必要欄位（用於資料相容）
  function ensureProfileFields(profile) {
    if (!profile.knownIdentityCharacters) profile.knownIdentityCharacters = [];
    if (!profile.verificationType) profile.verificationType = 'none';
    if (!profile.coupleCharacterId) profile.coupleCharacterId = '';
    if (!profile.coupleCharacterName) profile.coupleCharacterName = '';
    if (profile.publicIdentity === undefined) profile.publicIdentity = '';
    if (profile.showRealName === undefined) profile.showRealName = false;
    if (profile.realName === undefined) profile.realName = '';
    if (!profile.customTag1Color) profile.customTag1Color = '#71767b';
    if (!profile.customTag2Color) profile.customTag2Color = '#71767b';
  }

  // 綁定事件處理器
  function bindEventHandlers() {
    // 因為HTML是動態創建的，需要在創建後綁定所有事件

    // 綁定角色X資料表單事件
    const characterXProfileForm = document.getElementById('character-x-profile-form');
    if (characterXProfileForm) {
      characterXProfileForm.addEventListener('submit', saveCharacterXProfile);
      console.log('✅ 已綁定角色X資料表單提交事件');
    }

    // 綁定簡介字元計數事件
    const characterXBio = document.getElementById('character-x-bio');
    if (characterXBio) {
      characterXBio.addEventListener('input', updateCharacterBioCount);
    }

    // 綁定關係表單事件
    const relationshipForm = document.getElementById('relationship-form');
    if (relationshipForm) {
      relationshipForm.addEventListener('submit', saveRelationshipForm);
      console.log('✅ 已綁定關係表單提交事件');
    }

    // 綁定關係描述字元計數事件
    const relationshipDesc = document.getElementById('relationship-description');
    if (relationshipDesc) {
      relationshipDesc.addEventListener('input', updateRelationshipDescCount);
    }

    // 綁定角色真實姓名字元計數事件
    const characterRealName = document.getElementById('character-real-name');
    if (characterRealName) {
      characterRealName.addEventListener('input', updateCharacterXProfileCounts);
    }

    console.log('✅ 所有事件處理器已綁定');
  }

  // ============================================
  // 提問箱功能
  // ============================================

  // 提問箱資料（臨時存儲，後續可持久化到資料庫）
  let askboxData = {
    avatar: 'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg',
    nickname: '= =',
    prompt: '請向我匿名提問!waiting...',
    background: 'https://i.postimg.cc/7LqVqxt4/mmexport1759588659314.jpg',
    answeredQuestions: [],
  };

  // 提問箱多選刪除相關變數
  let isAskboxMultiSelectMode = false;
  let selectedQuestions = new Set();
  let questionLongPressTimer = null;

  // 從資料庫載入提問箱資料
  async function loadAskboxDataFromDB() {
    try {
      const xDb = getXDB();
      const accountId = currentAccountId || 'main';
      const askboxId = `askbox_${accountId}`;

      const savedData = await xDb.xAskbox.get(askboxId);

      if (savedData) {
        // 從資料庫載入 - 完全替換askboxData物件，避免舊資料殘留
        askboxData.id = savedData.id;
        askboxData.avatar = savedData.avatar;
        askboxData.nickname = savedData.nickname;
        askboxData.prompt = savedData.prompt;
        askboxData.background = savedData.background;
        askboxData.answeredQuestions = savedData.answeredQuestions || [];
        console.log('✅ 提問箱資料已從資料庫載入:', accountId, '提問數:', askboxData.answeredQuestions.length);
      } else {
        // 使用預設資料並保存到資料庫（為新帳戶創建空的提問箱）
        askboxData.id = askboxId;
        askboxData.avatar = 'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg';
        askboxData.nickname = '= =';
        askboxData.prompt = '請向我匿名提問!waiting...';
        askboxData.background = 'https://i.postimg.cc/7LqVqxt4/mmexport1759588659314.jpg';
        askboxData.answeredQuestions = []; // 新帳戶從空列表開始

        // 保存到資料庫
        await xDb.xAskbox.put({
          id: askboxId,
          avatar: askboxData.avatar,
          nickname: askboxData.nickname,
          prompt: askboxData.prompt,
          background: askboxData.background,
          answeredQuestions: [],
        });
        console.log('✅ 已為新帳戶創建預設提問箱資料:', accountId, '提問數: 0');
      }
    } catch (error) {
      console.error('❌ 載入提問箱數據失敗:', error);
    }
  }

  // 保存提問箱資料到資料庫
  async function saveAskboxDataToDB() {
    try {
      const xDb = getXDB();
      const accountId = currentAccountId || 'main';
      const askboxId = `askbox_${accountId}`;

      askboxData.id = askboxId;
      await xDb.xAskbox.put(askboxData);
      console.log('✅ 提問箱資料已保存到資料庫:', accountId);
    } catch (error) {
      console.error('❌ 保存提問箱資料失敗:', error);
    }
  }

  // 載入提問箱數據到UI
  async function loadAskboxData() {
    // 從資料庫載入
    await loadAskboxDataFromDB();

    // 更新UI
    const avatarEl = document.getElementById('askbox-avatar');
    const nicknameEl = document.getElementById('askbox-nickname');
    const promptEl = document.getElementById('askbox-prompt');
    const backgroundEl = document.getElementById('askbox-background');

    if (avatarEl) avatarEl.src = askboxData.avatar;
    if (nicknameEl) nicknameEl.textContent = askboxData.nickname;
    if (promptEl) promptEl.textContent = askboxData.prompt;
    if (backgroundEl) backgroundEl.style.backgroundImage = `url('${askboxData.background}')`;

    // 渲染已回答的提問列表
    renderAnsweredQuestions();
  }

  // 修改提問箱頭像
  async function changeAskboxAvatar() {
    const newAvatar = prompt('請輸入新的頭像URL:', askboxData.avatar);
    if (newAvatar && newAvatar.trim()) {
      askboxData.avatar = newAvatar.trim();
      const avatarEl = document.getElementById('askbox-avatar');
      if (avatarEl) avatarEl.src = askboxData.avatar;

      // 保存到資料庫
      await saveAskboxDataToDB();
      showXToast('頭像已更新並保存', 'success');
    }
  }

  // 保存提問箱昵稱（原處編輯）
  async function saveAskboxNickname() {
    const nicknameEl = document.getElementById('askbox-nickname');
    if (!nicknameEl) return;

    const newNickname = nicknameEl.textContent.trim();
    if (newNickname && newNickname !== askboxData.nickname) {
      askboxData.nickname = newNickname;
      await saveAskboxDataToDB();
      console.log('✅ 昵稱已自動保存:', newNickname);
    }
  }

  // 保存提問卡片文字（原處編輯）
  async function saveAskboxPrompt() {
    const promptEl = document.getElementById('askbox-prompt');
    if (!promptEl) return;

    const newPrompt = promptEl.textContent.trim();
    if (newPrompt && newPrompt !== askboxData.prompt) {
      askboxData.prompt = newPrompt;
      await saveAskboxDataToDB();
      console.log('✅ 提示文字已自動保存:', newPrompt);
    }
  }

  // 打開提問箱設置
  function openAskboxSettings() {
    const newBackground = prompt('請輸入新的背景圖URL:', askboxData.background);
    if (newBackground && newBackground.trim()) {
      askboxData.background = newBackground.trim();
      const backgroundEl = document.getElementById('askbox-background');
      if (backgroundEl) backgroundEl.style.backgroundImage = `url('${askboxData.background}')`;

      // 保存到資料庫
      saveAskboxDataToDB();
      showXToast('背景圖已更新並保存', 'success');
    }
  }

  // 獲取新的提問（第四個情景：提問箱AI生成）
  async function getNewQuestion() {
    try {
      showXToast('正在生成新的提問...', 'info');

      // 從資料庫讀取API配置和X設置
      const db = getDB();
      const xDb = getXDB();

      const apiConfig = await db.apiConfig.get('main');
      if (!apiConfig || !apiConfig.proxyUrl || !apiConfig.apiKey || !apiConfig.model) {
        showXToast('請先配置API設置', 'error');
        return;
      }

      const { proxyUrl, apiKey, model } = apiConfig;

      // 從X設置中讀取配置（按帳號讀取）
      const settingsId = `xSettings_${currentAccountId || 'main'}`;
      const xSettings = await xDb.xSettings.get(settingsId);
      const userPrompt = xSettings?.systemPrompt || '';
      const worldSetting = xSettings?.worldSetting || '';
      const boundCharacters = xSettings?.boundCharacters || [];

      // 使用工具函數構建使用者X個人資料資訊
      const userXProfileInfo = StringBuilders.buildUserXProfileInfo(window.userProfileData);

      // 讀取用戶已發佈的推文（最近5條）
      const userTweetsId = `userTweets_${currentAccountId || 'main'}`;
      const userTweetsData = await xDb.xUserTweets.get(userTweetsId);
      const userTweets = userTweetsData?.tweets || [];
      const recentUserTweets = userTweets.slice(0, 5); // 最近5條推文

      // 獲取情侶角色的X資料
      let coupleCharacterInfo = '';
      if (userXProfileInfo.verificationType === 'couple' && userXProfileInfo.coupleCharacterId) {
        const coupleCharacterProfile = await xDb.xCharacterProfiles
          .where('characterId')
          .equals(userXProfileInfo.coupleCharacterId)
          .first();

        if (coupleCharacterProfile) {
          coupleCharacterInfo = `
【情侶角色信息】：
- X姓名：${coupleCharacterProfile.xName}
- X控制碼：${coupleCharacterProfile.xHandle}
- X簡介：${coupleCharacterProfile.xBio || '無'}
- 公眾身份：${coupleCharacterProfile.publicIdentity || '無'}
- 真實姓名：${
            coupleCharacterProfile.showRealName && coupleCharacterProfile.realName
              ? coupleCharacterProfile.realName
              : '未公開'
          }
`;
        }
      }

      // 獲取綁定角色資訊（用於匿名提問）
      let boundCharactersInfo = '';
      if (boundCharacters.length > 0) {
        const mainDB = getDB();
        const allChats = await mainDB.chats.toArray();
        const boundCharsData = allChats.filter(chat => !chat.isGroup && boundCharacters.includes(chat.id));

        const allXProfiles = await xDb.xCharacterProfiles.toArray();
        const xProfileMap = new Map();
        allXProfiles.forEach(profile => {
          xProfileMap.set(profile.characterId, profile);
        });

        if (boundCharsData.length > 0) {
          boundCharactersInfo = '\n【綁定角色資訊（可匿名提問）】：\n以下角色可以作為匿名提問者：\n';
          for (const char of boundCharsData) {
            const xProfile = xProfileMap.get(char.id);
            if (xProfile) {
              boundCharactersInfo += `\n- ${xProfile.xName}（${xProfile.xHandle}）: ${
                char.settings.aiPersona?.substring(0, 100) || ''
              }`;
            }
          }
        }
      }

      // 收集已回復的提問（作為對話歷史）
      const answeredQuestionsContext = askboxData.answeredQuestions
        .filter(q => q.answer && q.answer.trim())
        .slice(0, 5) // 最近5個已回復的提問
        .map(q => `Q: ${q.question}\nA: ${q.answer}`)
        .join('\n\n');

      // Token計數器
      let tokenCount = 0;

      // 構建提問箱專用系統提示詞
      let systemPrompt = StringBuilders.buildBaseSystemPrompt({
        userPrompt,
        worldSetting,
      });
      tokenCount = TokenUtils.logTokenUsage('提問箱生成器', '基礎系統提示詞', systemPrompt, tokenCount);

      systemPrompt += `

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 核心任務說明 - 匿名提問箱 🎯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
你是一個匿名提問箱系統。請為用戶生成一個有趣的、適合他們身份的匿名提問。

【使用者身份資訊】：
- 用戶名：${userXProfileInfo.name}
- X控制碼：${userXProfileInfo.handle}
- 簡介：${userXProfileInfo.bio || '無'}
- 公眾身份：${userXProfileInfo.publicIdentity || '無'}
- 認證類型：${StringBuilders.getUserVerificationTypeDescription(userXProfileInfo)}
${
  userXProfileInfo.verificationType === 'couple' && userXProfileInfo.coupleCharacterName
    ? `- 情侶關係：與${userXProfileInfo.coupleCharacterName}是公開情侶`
    : ''
}
${coupleCharacterInfo}

【用戶最近發佈的推文】：
${
  recentUserTweets.length > 0
    ? recentUserTweets
        .map((tweet, i) => {
          let tweetText = `${i + 1}. ${tweet.content}${tweet.time ? ` (${tweet.time})` : ''}`;
          // 添加圖片資訊
          if (tweet.image) {
            if (tweet.image.type === 'description') {
              tweetText += `\n   [圖片描述: ${tweet.image.content}]`;
            } else if (tweet.image.type === 'upload') {
              tweetText += `\n   [包含上傳的圖片]`;
            }
          }
          return tweetText;
        })
        .join('\n')
    : '暫無推文'
}

${boundCharactersInfo}

${
  answeredQuestionsContext
    ? `【之前的提問與回復歷史】：\n${answeredQuestionsContext}\n\n【繼續性要求】：新提問可以延續之前的話題，也可以開啟新話題，保持自然。`
    : ''
}

【提問生成要求】：
1. 提問要自然、真實，像是真實的匿名使用者提出的
2. 提問內容要與使用者的身份、簡介、公眾身份、最近發佈的推文相關
3. 如果有綁定角色，可以讓角色以匿名身份提問，提問內容要符合角色的人設和性格
4. 如果有之前的提問歷史，可以延續話題，也可以提出新話題
5. 提問可以是：
   - 關於最近推文內容的追問或評論
   - 關於生活經驗、情感態度的詢問
   - 關於興趣愛好、專業技能的請教
   - 關於日常趣事、特殊經歷的好奇
   - 輕鬆幽默或深度思考的話題
6. 提問長度適中（10-50字），不要太長或太短
7. 語氣可以是：好奇的、調侃的、真誠的、幽默的
8. 避免過於私密、冒犯或不適當的問題

【返回格式】：
每行一個提問，用分行符號分隔，不需要序號、引號或其他格式
每個提問獨立成行，直接輸出提問內容

示例格式：
看到你最近發的推文，感覺心情不錯呀？
最近有遇到什麼讓你特別開心的事嗎？
如果可以擁有一個超能力，你會選什麼？
你覺得最重要的人生品質是什麼？

現在，請為用戶生成3-10個匿名提問（每行一個）：`;

      const userInfoSection = systemPrompt.substring(systemPrompt.indexOf('【使用者身份資訊】'));
      tokenCount = TokenUtils.logTokenUsage('提問箱生成器', '使用者資訊與要求', userInfoSection, tokenCount);

      const messages = [{ role: 'user', content: '請生成3-10個匿名提問，每行一個' }];

      // 最終統計
      TokenUtils.logFinalPrompt('提問箱生成器', systemPrompt, messages[0].content);

      // 判斷API類型並發送請求
      let isGemini = proxyUrl.includes('generativelanguage');
      let response;

      if (isGemini) {
        const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models';
        const geminiConfig = {
          url: `${GEMINI_API_URL}/${model}:generateContent?key=${getRandomValue(apiKey)}`,
          data: {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              contents: [
                {
                  parts: [
                    {
                      text: systemPrompt + '\n\n' + messages.map(m => m.content).join('\n'),
                    },
                  ],
                },
              ],
              generationConfig: {
                temperature: 0.9,
              },
            }),
          },
        };
        response = await fetch(geminiConfig.url, geminiConfig.data);
      } else {
        const openAiPayload = {
          model: model,
          messages: [{ role: 'system', content: systemPrompt }, ...messages],
          temperature: 0.9,
          stream: false,
        };
        response = await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${apiKey}`,
          },
          body: JSON.stringify(openAiPayload),
        });
      }

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(`API錯誤: ${response.status} - ${errorData.error?.message || response.statusText}`);
      }

      const data = await response.json();
      let aiResponseContent;

      if (isGemini) {
        // Gemini格式
        if (data.candidates && data.candidates[0] && data.candidates[0].content && data.candidates[0].content.parts) {
          aiResponseContent = data.candidates[0].content.parts[0].text || '';
        }
      } else {
        // OpenAI格式
        aiResponseContent = data.choices?.[0]?.message?.content || '';
      }

      console.log('AI生成的提問:', aiResponseContent);

      // 按行分割提問內容
      const questions = aiResponseContent
        .split('\n')
        .map(line => line.trim())
        .filter(line => line.length > 0)
        .map(line => {
          // 清理每行：去除序號（如 "1. "、"- "等）、引號
          return line
            .replace(/^\d+[\.\)、]\s*/, '') // 去除數字序號
            .replace(/^[-•]\s*/, '') // 去除短橫線或專案符號
            .replace(/^["「『]|["」』]$/g, '') // 去除引號
            .trim();
        })
        .filter(q => q.length > 0); // 再次過濾空行

      if (questions.length === 0) {
        throw new Error('AI返回了空的提問內容');
      }

      console.log(`✅ 解析到 ${questions.length} 個提問:`, questions);

      // 為每個提問創建物件並添加到陣列
      const newQuestions = questions.map((question, index) => ({
        id: `q_${Date.now()}_${index}_${Math.random().toString(36).substr(2, 9)}`,
        question: question,
        answer: '', // 初始為空，用戶可以編輯回復
        date: new Date().toISOString(),
      }));

      // 批量添加到最前面
      askboxData.answeredQuestions.unshift(...newQuestions);

      // 保存到資料庫
      await saveAskboxDataToDB();

      // 重新渲染提問列表
      renderAnsweredQuestions();

      showXToast(`你有 ${newQuestions.length} 個新的提問請查收`, 'success');
    } catch (error) {
      console.error('生成提問失敗:', error);
      showXToast(`生成失敗: ${error.message}`, 'error');
    }
  }

  // 渲染已回答的提問列表
  function renderAnsweredQuestions() {
    const container = document.getElementById('answered-questions-list');
    const titleEl = document.getElementById('answered-questions-title');
    if (!container) return;

    if (askboxData.answeredQuestions.length === 0) {
      // 隱藏標題
      if (titleEl) titleEl.style.display = 'none';

      container.innerHTML = `
        <div style="
          text-align: center;
          color: rgba(255,255,255,0.6);
          font-size: 14px;
          padding: 40px 20px;
        ">
          暫無提問
        </div>
      `;
      return;
    }

    // 顯示標題
    if (titleEl) titleEl.style.display = 'block';

    container.innerHTML = askboxData.answeredQuestions
      .map((q, index) => {
        const date = new Date(q.date);
        const dateStr = date.toLocaleDateString('zh-CN', { month: 'short', day: 'numeric' });
        const isSelected = selectedQuestions.has(q.id);

        return `
      <div 
        class="askbox-question-item"
        data-question-id="${q.id}"
        style="
        background-color: rgba(255,255,255,0.9);
        backdrop-filter: blur(10px);
        border-radius: 16px;
        overflow: hidden;
        margin-bottom: 16px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        transition: all 0.2s;
        ${
          isSelected
            ? 'border: 3px solid var(--x-accent); background-color: color-mix(in srgb, var(--x-accent) , 0.1);'
            : ''
        }
        ${isAskboxMultiSelectMode ? 'border-left: 3px solid var(--x-accent);' : ''}
      " 
      onmouseover="if(!${isAskboxMultiSelectMode}){this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(0,0,0,0.2)';}"
      onmouseout="if(!${isAskboxMultiSelectMode}){this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.15)';}"
      onmousedown="startQuestionLongPress('${q.id}')"
      onmouseup="endQuestionLongPress()"
      onmouseleave="endQuestionLongPress()"
      ontouchstart="startQuestionLongPress('${q.id}')"
      ontouchend="endQuestionLongPress()"
      onclick="if(${isAskboxMultiSelectMode}){toggleQuestionSelection('${q.id}');event.stopPropagation();}"
      >
        <!-- 提問區域（淺黑灰色） -->
        <div style="
          background: linear-gradient(135deg, #3a3a3a 0%, #2a2a2a 100%);
          padding: 20px;
          color: #fff;
        ">
          <div style="font-size: 15px; line-height: 1.6; word-break: break-word;">
            ${q.question}
          </div>
        </div>
        
        <!-- 回復區域（白色，可編輯） -->
        <div style="
          background-color: #fff;
          padding: 20px;
          min-height: 60px;
          color: #333;
        ">
          <div id="answer-${q.id}" 
            contenteditable="true"
            data-question-id="${q.id}"
            style="
              font-size: 14px; 
              line-height: 1.6; 
              word-break: break-word;
              outline: none;
              cursor: text;
              min-height: 20px;
              ${q.answer ? '' : 'color: #999; text-align: center;'}
            "
            onblur="saveQuestionAnswer('${q.id}')"
            onkeydown="if(event.key==='Enter'&&!event.shiftKey){event.preventDefault();this.blur();}"
            onfocus="if(this.textContent==='點擊此處回復...'){this.textContent='';this.style.color='#333';this.style.textAlign='left';}">${
              q.answer || '點擊此處回復...'
            }</div>
        </div>
        
        <!-- 日期標籤 -->
        <div style="
          background-color: #f5f5f5;
          padding: 8px 20px;
          color: #999;
          font-size: 12px;
          text-align: right;
        ">
          ${dateStr}
        </div>
      </div>
    `;
      })
      .join('');
  }

  // 保存提問回復（原處編輯）
  async function saveQuestionAnswer(questionId) {
    const answerEl = document.getElementById(`answer-${questionId}`);
    if (!answerEl) return;

    const question = askboxData.answeredQuestions.find(q => q.id === questionId);
    if (!question) return;

    let newAnswer = answerEl.textContent.trim();

    // 如果是預留位置文字，則清空
    if (newAnswer === '點擊此處回復...') {
      newAnswer = '';
    }

    if (newAnswer !== question.answer) {
      question.answer = newAnswer;
      await saveAskboxDataToDB();
      console.log('✅ 回復已自動保存:', questionId);
    }
  }

  // ============================================
  // 提問箱多選刪除功能
  // ============================================

  // 開始長按提問卡片
  function startQuestionLongPress(questionId) {
    if (isAskboxMultiSelectMode) return; // 已經在多選模式，不需要長按

    questionLongPressTimer = setTimeout(() => {
      enterAskboxMultiSelectMode();
      toggleQuestionSelection(questionId);
    }, 500); // 長按500ms觸發
  }

  // 結束長按
  function endQuestionLongPress() {
    if (questionLongPressTimer) {
      clearTimeout(questionLongPressTimer);
      questionLongPressTimer = null;
    }
  }

  // 切換提問選擇狀態
  function toggleQuestionSelection(questionId) {
    if (!isAskboxMultiSelectMode) {
      enterAskboxMultiSelectMode();
    }

    const questionEl = document.querySelector(`.askbox-question-item[data-question-id="${questionId}"]`);
    if (!questionEl) return;

    if (selectedQuestions.has(questionId)) {
      selectedQuestions.delete(questionId);
      questionEl.style.border = '';
      questionEl.style.backgroundColor = 'rgba(255,255,255,0.9)';
    } else {
      selectedQuestions.add(questionId);
      questionEl.style.border = '3px solid var(--x-accent)';
      questionEl.style.backgroundColor = 'color-mix(in srgb, var(--x-accent) , 0.1)';
    }

    updateAskboxDeleteUI();
  }

  // 進入提問箱多選模式
  function enterAskboxMultiSelectMode() {
    isAskboxMultiSelectMode = true;

    // 顯示刪除工具列
    showAskboxDeleteToolbar();

    // 改變所有提問卡片的樣式
    document.querySelectorAll('.askbox-question-item').forEach(item => {
      item.style.borderLeft = '3px solid var(--x-accent)';
    });

    console.log('✅ 已進入提問箱多選模式');
  }

  // 退出提問箱多選模式
  function exitAskboxMultiSelectMode() {
    isAskboxMultiSelectMode = false;
    selectedQuestions.clear();

    // 隱藏刪除工具列
    hideAskboxDeleteToolbar();

    // 恢復所有提問卡片的樣式
    document.querySelectorAll('.askbox-question-item').forEach(item => {
      item.style.border = '';
      item.style.borderLeft = '';
      item.style.backgroundColor = 'rgba(255,255,255,0.9)';
    });

    console.log('✅ 已退出提問箱多選模式');
  }

  // 顯示提問箱刪除工具列
  function showAskboxDeleteToolbar() {
    let toolbar = document.getElementById('askbox-delete-toolbar');
    if (!toolbar) {
      toolbar = document.createElement('div');
      toolbar.id = 'askbox-delete-toolbar';
      toolbar.style.cssText = `
        position: fixed;
        bottom: 80px;
        left: 50%;
        transform: translateX(-50%);
        background-color: rgba(0,0,0,0.95);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255,255,255,0.2);
        border-radius: 24px;
        padding: 12px 20px;
        display: flex;
        align-items: center;
        gap: 16px;
        z-index: 2000;
        box-shadow: 0 4px 20px rgba(0,0,0,0.5);
      `;

      toolbar.innerHTML = `
        <button onclick="selectAllQuestions()" style="
          background-color: var(--x-accent); 
          color: #fff; 
          border: none; 
          border-radius: 20px; 
          padding: 8px 16px; 
          font-size: 14px; 
          font-weight: 600;
          cursor: pointer;
          transition: all 0.2s;
        " onmouseover="this.style.backgroundColor='#1a8cd8'" onmouseout="this.style.backgroundColor='var(--x-accent)'">
          全選
        </button>
        <span id="askbox-selected-count" style="color: #fff; font-size: 14px; font-weight: 500;">已選擇 0 個</span>
        <button onclick="deleteSelectedQuestions()" style="
          background-color: #f91880; 
          color: #fff; 
          border: none; 
          border-radius: 20px; 
          padding: 8px 16px; 
          font-size: 14px; 
          font-weight: 600;
          cursor: pointer;
          transition: all 0.2s;
        " onmouseover="this.style.backgroundColor='#d0155f'" onmouseout="this.style.backgroundColor='#f91880'">
          刪除
        </button>
        <button onclick="exitAskboxMultiSelectMode()" style="
          background-color: rgba(255,255,255,0.15); 
          color: #fff; 
          border: none; 
          border-radius: 20px; 
          padding: 8px 16px; 
          font-size: 14px; 
          font-weight: 600;
          cursor: pointer;
          transition: all 0.2s;
        " onmouseover="this.style.backgroundColor='rgba(255,255,255,0.25)'" onmouseout="this.style.backgroundColor='rgba(255,255,255,0.15)'">
          取消
        </button>
      `;

      document.body.appendChild(toolbar);
    }
    toolbar.style.display = 'flex';
  }

  // 隱藏提問箱刪除工具列
  function hideAskboxDeleteToolbar() {
    const toolbar = document.getElementById('askbox-delete-toolbar');
    if (toolbar) {
      toolbar.style.display = 'none';
    }
  }

  // 更新提問箱刪除UI
  function updateAskboxDeleteUI() {
    const countEl = document.getElementById('askbox-selected-count');
    if (countEl) {
      countEl.textContent = `已選擇 ${selectedQuestions.size} 個`;
    }
  }

  // 全選提問
  function selectAllQuestions() {
    document.querySelectorAll('.askbox-question-item').forEach(item => {
      const questionId = item.dataset.questionId;
      if (!selectedQuestions.has(questionId)) {
        selectedQuestions.add(questionId);
        item.style.border = '3px solid #1d9bf0';
        item.style.backgroundColor = 'color-mix(in srgb, var(--x-accent) , 0.1)';
      }
    });
    updateAskboxDeleteUI();
  }

  // 刪除選中的提問
  async function deleteSelectedQuestions() {
    if (selectedQuestions.size === 0) {
      showXToast('請先選擇要刪除的提問', 'warning');
      return;
    }

    const confirmDelete = confirm(`確定要刪除選中的 ${selectedQuestions.size} 個提問嗎？刪除後無法恢復。`);
    if (!confirmDelete) return;

    try {
      // 過濾掉選中的提問
      askboxData.answeredQuestions = askboxData.answeredQuestions.filter(q => !selectedQuestions.has(q.id));

      // 保存到資料庫
      await saveAskboxDataToDB();

      showXToast(`已刪除 ${selectedQuestions.size} 個提問`, 'success');

      // 退出多選模式並刷新顯示
      exitAskboxMultiSelectMode();
      renderAnsweredQuestions();
    } catch (error) {
      console.error('刪除提問失敗:', error);
      showXToast('刪除失敗: ' + error.message, 'error');
    }
  }

  // ============================================
  // 通知頁面功能
  // ============================================

  // ▼▼▼ 【主要！！！】第十個情景：Mentions 通知生成器 ▼▼▼

  // 第十個情景：為用戶的最新推文生成點贊和轉帖通知
  async function generateMentionsForLatestTweet(tweetData) {
    try {
      console.log('🔔 [Mentions生成器] 開始為最新推文生成通知');

      const db = getDB();
      const xDb = getXDB();

      // 獲取API配置
      const apiConfig = await db.apiConfig.get('main');
      if (!apiConfig || !apiConfig.proxyUrl || !apiConfig.apiKey || !apiConfig.model) {
        console.warn('⚠️ [Mentions生成器] API未配置，跳過通知生成');
        return;
      }

      const { proxyUrl, apiKey, model } = apiConfig;

      // 從X設置中讀取配置
      const settingsId = `xSettings_${currentAccountId || 'main'}`;
      const xSettings = await xDb.xSettings.get(settingsId);
      const userPrompt = xSettings?.systemPrompt || '';
      const worldSetting = xSettings?.worldSetting || '';
      const boundCharacters = xSettings?.boundCharacters || [];

      // 使用工具函數構建使用者X個人資料資訊
      const userXProfileInfo = StringBuilders.buildUserXProfileInfo(window.userProfileData);

      // 檢查用戶是否為公眾人物（高曝光率身份）
      const userPublicIdentity = userXProfileInfo.publicIdentity || '';
      const userBio = userXProfileInfo.bio || '';
      const isUserPublicFigure =
        /明星|網紅|博主|演員|歌手|藝人|主播|up主|偶像|導演|製片|編劇|作家|influencer|celebrity|singer|actor|artist|streamer|idol/i.test(
          userPublicIdentity + ' ' + userBio,
        );

      console.log('🔍 [Mentions生成器] 用戶公眾身份檢測:', {
        isPublicFigure: isUserPublicFigure,
        publicIdentity: userPublicIdentity,
        bio: userBio,
      });

      // Token計數器
      let tokenCount = 0;

      // 1. 提示詞 + 世界書
      let systemPrompt = StringBuilders.buildBaseSystemPrompt({
        userPrompt,
        worldSetting,
      });
      tokenCount = TokenUtils.logTokenUsage('Mentions生成器', '基礎系統提示詞', systemPrompt, tokenCount);

      // 1.5. 獲取適用的世界書內容
      const worldBooksContent = await StringBuilders.getApplicableWorldBooks('mentions', {
        boundCharacters: boundCharacters,
      });
      if (worldBooksContent) {
        systemPrompt += worldBooksContent;
        tokenCount = TokenUtils.logTokenUsage('Mentions生成器', '世界書內容', worldBooksContent, tokenCount);
      }

      // 2. 核心任務說明
      systemPrompt += `

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🔔 核心任務：生成 Mentions 通知 🔔
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
你是X社交平臺的通知生成器。用戶 ${userXProfileInfo.name} (${userXProfileInfo.handle}) 剛發佈了一條新推文，你的任務是：

✅ 生成點贊通知（1-2條）：多個用戶喜歡了這條推文
✅ 生成轉帖通知（1-3條）：其他用戶引用轉發了這條推文

**用戶身份檢測**：
- 用戶身份：${isUserPublicFigure ? '公眾人物（高曝光）' : '普通用戶（低曝光）'}
${userPublicIdentity ? `- 公眾身份：${userPublicIdentity}` : ''}

**流量規模要求**：
${
  isUserPublicFigure
    ? `- 用戶是公眾人物，獲得高流量：
  * 點贊通知：每條通知顯示3個使用者，othersCount 設為 50-500 之間
  * 轉帖stats：comments 100-500，retweets 500-2000，likes 1000-5000
  * 轉帖內容應該體現公眾人物的影響力（如"分享給粉絲"、"必須轉發"等）`
    : `- 用戶是普通用戶，獲得常規流量：
  * 點贊通知：每條通知顯示3個使用者，othersCount 設為 5-50 之間
  * 轉帖stats：comments 5-20，retweets 10-50，likes 20-100
  * 轉帖內容應該更日常化、朋友圈式`
}

**點贊通知要求**：
- 每條通知包含3個使用者（顯示頭像和昵稱）
- othersCount根據使用者身份設置（見上方流量規模要求）
- 必須包含被點贊的推文內容預覽
- 點贊用戶應該是虛構的普通X用戶

**轉帖通知要求**：
- 每條轉帖都是對用戶推文的引用轉發
- 轉帖者添加了自己的評論/觀點
- 轉帖內容要與原推文相關，可以是贊同、補充、轉發給特定群體等
- 轉帖者應該是虛構的普通X用戶
- 必須準確引用原推文內容
- 每條轉帖必須包含2-5條評論（comments陣列）
- stats資料根據使用者身份設置（見上方流量規模要求）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;

      // 3. 使用者推文資訊
      systemPrompt += `

【使用者推文資訊】：
- 推文內容："${tweetData.content}"
- 發佈時間：${tweetData.time}
${tweetData.image ? `- 包含媒體：${tweetData.image.type === 'description' ? tweetData.image.content : '圖片內容'}` : ''}
${tweetData.location ? `- 位置：${tweetData.location}` : ''}
${tweetData.link ? `- 連結：${tweetData.link.title || tweetData.link.url}` : ''}
`;

      // 4. 使用者資料約束
      const userConstraintsStart = systemPrompt.length;
      systemPrompt += StringBuilders.buildUniversalConstraints(userXProfileInfo);
      const userConstraints = systemPrompt.substring(userConstraintsStart);
      tokenCount = TokenUtils.logTokenUsage('Mentions生成器', '使用者資料約束', userConstraints, tokenCount);

      // 5. JSON返回格式
      systemPrompt += `

【JSON返回格式】：
\`\`\`json
{
  "likes": [點贊通知陣列，1-2條],
  "retweets": [轉帖通知陣列，1-3條]
}
\`\`\`

點贊通知物件結構：
{
  "id": "mention_like_xxx",
  "type": "like",
  "users": [
    {
      "name": "用戶昵稱",
      "handle": "@用戶控制碼",
      "avatar": "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg",
      "verified": false
    }
    // 顯示3個使用者
  ],
  "othersCount": 其他點贊人數（數位，可以是0），
  "time": "時間描述（如'2小時前'）",
  "tweet": {
    "content": "被點贊的推文內容（與使用者推文一致）",
    "image": null 或 "圖片描述"
  }
}

轉帖通知物件結構：
{
  "id": "mention_retweet_xxx",
  "type": "retweet",
  "user": {
    "name": "轉帖者昵稱",
    "handle": "@轉帖者控制碼",
    "avatar": "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg",
    "verified": false
  },
  "retweetContent": "轉帖者添加的評論內容",
  "time": "時間描述（如'3小時前'）",
  "quotedTweet": {
    "user": {
      "name": "${userXProfileInfo.name}",
      "handle": "${userXProfileInfo.handle}",
      "avatar": "${userXProfileInfo.avatar}",
      "verified": ${userXProfileInfo.verified || false},
      "verificationType": "${userXProfileInfo.verificationType || 'none'}"
    },
    "content": "原推文內容（與使用者推文一致）",
    "time": "${tweetData.time}",
    "image": ${
      tweetData.image
        ? tweetData.image.type === 'description'
          ? `{"type": "description", "content": "${tweetData.image.content}"}`
          : 'null'
        : 'null'
    },
    "stats": {
      "comments": ${tweetData.stats?.comments || 0},
      "retweets": ${tweetData.stats?.retweets || 0},
      "likes": ${tweetData.stats?.likes || 0}
    }
  },
  "stats": {
    "comments": 轉帖的評論數（數位，根據使用者身份：公眾${isUserPublicFigure ? '100-500' : '5-20'}），
    "retweets": 轉帖的轉發數（數位，根據使用者身份：公眾${isUserPublicFigure ? '500-2000' : '10-50'}），
    "likes": 轉帖的點贊數（數位，根據使用者身份：公眾${isUserPublicFigure ? '1000-5000' : '20-100'}），
    "views": 轉帖的流覽數（數位，根據使用者身份：公眾${isUserPublicFigure ? '5000-50000' : '100-1000'}）
  },
  "comments": [
    {
      "id": "評論唯一ID（可留空，系統自動生成）",
      "user": {
        "name": "評論者昵稱",
        "handle": "@評論者控制碼",
        "avatar": "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg",
        "verified": false
      },
      "content": "評論文本",
      "time": "時間描述",
      "image": {"type": "description", "content": "圖片文字描述"} (可選，10-20%的評論帶圖)
    }
  ]
}

關鍵規則：
1. 所有用戶頭像統一使用：https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg
2. verified欄位必須是布林值(true/false)
3. 點贊通知的tweet內容必須與使用者原推文完全一致
4. 轉帖通知的quotedTweet必須準確引用用戶原推文
5. 轉帖內容要自然、真實，符合社交媒體轉發習慣
6. 時間描述要合理（如'剛剛'、'5分鐘前'、'1小時前'等）
7. **轉帖必須包含comments陣列（2-5條評論）**，評論要與轉帖內容相關
8. stats數值必須根據使用者身份（公眾人物/普通用戶）設置合理範圍
9. stats中所有數位必須是純數位，不帶引號
10. 10-20%的評論可以帶圖（image欄位）
11. 🚫 絕對禁止在任何通知中使用用戶 ${userXProfileInfo.name} (${userXProfileInfo.handle}) 的身份

【🔒 隱私保護規則】：
🚨 所有點贊用戶、轉帖用戶、評論者都是陌生路人，只能基於用戶的X平臺公開信息：
  ✅ 可以使用：用戶的X姓名、X控制碼、X簡介、公開身份
  ❌ 禁止提及：用戶的真實姓名、真實職業、私人關係、未公開的身份資訊
  ❌ 禁止使用：只有親密關係才知道的稱呼（如"老師"、"同學"等，除非是用戶的公開身份）
  
示例說明：
- ✅ 正確：轉帖評論"這個博主說得太對了"（基於公開身份）
- ❌ 錯誤：轉帖評論"張老師的課講得真好"（洩露了真實姓氏和職業）
- ❌ 錯誤：評論"同學你太棒了"（假裝是同學關係）
`;

      const formatSection = systemPrompt.substring(systemPrompt.lastIndexOf('【JSON返回格式】'));
      tokenCount = TokenUtils.logTokenUsage('Mentions生成器', 'JSON格式要求', formatSection, tokenCount);

      // 構建消息內容，支援圖片識別
      const messageContent = [];

      // 添加基礎文本內容
      let contentText = `請為用戶的推文生成Mentions通知（點贊和轉帖）

推文內容："${tweetData.content}"
發佈時間：${tweetData.time}`;

      messageContent.push({ type: 'text', text: contentText });

      // 如果有上傳的圖片，添加圖片內容
      if (tweetData.image) {
        if (tweetData.image.type === 'upload' && tweetData.image.content) {
          // 單圖上傳
          messageContent.push({
            type: 'image_url',
            image_url: { url: tweetData.image.content },
          });
        } else if (tweetData.image.type === 'uploads' && tweetData.image.images && tweetData.image.images.length > 0) {
          // 多圖上傳
          tweetData.image.images.forEach((img, index) => {
            if (img.content) {
              messageContent.push({
                type: 'image_url',
                image_url: { url: img.content },
              });
            }
          });
        } else if (tweetData.image.type === 'description') {
          // 文字描述
          messageContent.push({
            type: 'text',
            text: `圖片描述：${tweetData.image.content}`,
          });
        }
      }

      const messages = [{ role: 'user', content: messageContent }];

      // 記錄上下文資訊token
      const contextText = messageContent.map(c => c.text || '[圖片]').join(' ');
      tokenCount = TokenUtils.logTokenUsage('Mentions生成器', '上下文信息', contextText, tokenCount);

      // 最終統計
      TokenUtils.logFinalPrompt('Mentions生成器', systemPrompt, contextText);

      // 判斷API類型並發送請求
      let isGemini = proxyUrl.includes('generativelanguage');
      let response;

      if (isGemini) {
        const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models';
        const geminiConfig = {
          url: `${GEMINI_API_URL}/${model}:generateContent?key=${getRandomValue(apiKey)}`,
          data: {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              contents: [
                {
                  parts: [
                    {
                      text:
                        systemPrompt +
                        '\n\n' +
                        messages
                          .map(m =>
                            Array.isArray(m.content) ? m.content.map(c => c.text || '[圖片]').join(' ') : m.content,
                          )
                          .join('\n'),
                    },
                  ],
                },
              ],
              generationConfig: {
                temperature: 0.8,
              },
            }),
          },
        };
        response = await fetch(geminiConfig.url, geminiConfig.data);
      } else {
        const openAiPayload = {
          model: model,
          messages: [{ role: 'system', content: systemPrompt }, ...messages],
          temperature: 0.8,
          stream: false,
        };
        response = await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${apiKey}`,
          },
          body: JSON.stringify(openAiPayload),
        });
      }

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(`API錯誤: ${response.status} - ${errorData.error?.message || response.statusText}`);
      }

      const data = await response.json();
      let aiResponseContent;

      if (isGemini) {
        aiResponseContent = data.candidates?.[0]?.content?.parts?.[0]?.text || '';
      } else {
        aiResponseContent = data.choices?.[0]?.message?.content || '';
      }

      console.log('✅ [Mentions生成器] AI響應已收到');

      // 解析AI返回的JSON資料
      const cleanedResponse = aiResponseContent
        .replace(/```json\s*/i, '')
        .replace(/```\s*$/, '')
        .trim();

      if (!cleanedResponse) {
        throw new Error('AI返回了空的回應內容');
      }

      let notificationsData;
      try {
        notificationsData = JSON.parse(cleanedResponse);
      } catch (parseError) {
        console.error('JSON解析失敗:', parseError);
        console.error('嘗試解析的內容:', cleanedResponse.substring(0, 500) + '...');
        throw new Error(`AI返回的資料不是有效的JSON格式: ${parseError.message}`);
      }

      // 🚫 篩選用戶身份冒用（最優先）
      notificationsData = StringBuilders.filterUserImpersonation(
        notificationsData,
        userXProfileInfo.handle,
        userXProfileInfo.name,
      );

      // 🔧 強制修正所有頭像
      await StringBuilders.enforceAvatarRules(notificationsData, userXProfileInfo.handle);

      // 驗證資料格式
      if (!notificationsData.likes || !notificationsData.retweets) {
        throw new Error('AI返回的資料格式不正確：缺少likes或retweets');
      }

      // 為通知添加時間戳記
      const timestamp = Date.now();
      notificationsData.likes.forEach((like, index) => {
        if (!like.id) like.id = `mention_like_${timestamp}_${index}`;
        like.timestamp = timestamp - (5 + Math.random() * 30) * 60 * 1000; // 5-35分鐘前
      });

      notificationsData.retweets.forEach((retweet, index) => {
        if (!retweet.id) retweet.id = `mention_retweet_${timestamp}_${index}`;
        retweet.timestamp = timestamp - (10 + Math.random() * 50) * 60 * 1000; // 10-60分鐘前

        // 為轉帖關聯原推文ID
        retweet.originalTweetId = tweetData.id;

        // 為轉帖的評論分配ID和時間戳記
        if (retweet.comments && retweet.comments.length > 0) {
          retweet.comments.forEach((comment, cIndex) => {
            if (!comment.id) {
              comment.id = `mention_retweet_${timestamp}_${index}_c${cIndex}`;
            }
            // 評論時間應該在轉帖之後
            if (!comment.timestamp) {
              comment.timestamp = retweet.timestamp + (5 + Math.random() * 30) * 60 * 1000;
            }
          });
        }
      });

      // 保存到資料庫
      await saveMentionsNotifications(notificationsData);

      console.log(
        `✅ [Mentions生成器] 已生成 ${notificationsData.likes.length} 條點贊通知，${notificationsData.retweets.length} 條轉帖通知`,
      );

      // 顯示手機樣式通知
      const isEnglish = currentLanguage === 'en';
      const userAvatar = window.userProfileData?.avatar || 'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg';
      const totalCount = notificationsData.likes.length + notificationsData.retweets.length;
      showPhoneNotification({
        title: 'X',
        message: isEnglish
          ? `${totalCount} new notification${totalCount > 1 ? 's' : ''} on your post!`
          : `你的帖子收到了 ${totalCount} 條新通知！`,
        avatar: userAvatar,
        leftIcon: 'x',
      });

      // 如果當前在 Mentions 頁面，刷新顯示
      const mentionsPage = document.getElementById('x-notifications-page');
      if (mentionsPage && mentionsPage.style.display === 'flex') {
        await loadNotifications();
      } else {
        // 如果不在通知頁面，顯示提醒點
        showNavNotificationDot('notifications');
      }
    } catch (error) {
      console.error('❌ [Mentions生成器] 生成失敗:', error);
      // 不顯示錯誤提示，靜默失敗
    }
  }

  // 保存 Mentions 通知到資料庫
  async function saveMentionsNotifications(notificationsData) {
    try {
      const xDb = getXDB();
      const dataId = `mentions_${currentAccountId || 'main'}`;

      // 獲取現有通知
      let savedData = await xDb.xAccountProfiles.get(dataId);
      if (!savedData) {
        // 創建新的資料結構，使用 handle 作為主鍵（與 xAccountProfiles 表結構一致）
        savedData = {
          handle: dataId, // 使用 handle 作為主鍵欄位
          id: dataId,
          data: [],
        };
      }

      // 合併新通知（點贊和轉帖）
      const allNotifications = [...notificationsData.likes, ...notificationsData.retweets];

      // 添加到開頭（最新的在前面）
      savedData.data = [...allNotifications, ...savedData.data];

      // 保存到資料庫
      await xDb.xAccountProfiles.put(savedData);

      console.log('✅ [Mentions生成器] 通知已保存到資料庫');
    } catch (error) {
      console.error('❌ [Mentions生成器] 保存通知失敗:', error);
      // 如果還是失敗，嘗試使用 add 方法
      try {
        // 如果是新資料，嘗試使用 add
        if (!(await xDb.xAccountProfiles.get(dataId))) {
          savedData.handle = dataId;
          await xDb.xAccountProfiles.add(savedData);
          console.log('✅ [Mentions生成器] 通知已保存（使用 add 方法）');
        }
      } catch (addError) {
        console.error('❌ [Mentions生成器] add 方法也失敗:', addError);
      }
    }
  }

  // 渲染點贊通知項
  function renderLikeMentionItem(mention) {
    const config = languageConfig[currentLanguage] || languageConfig.zh;

    const mentionEl = document.createElement('div');
    mentionEl.className = 'mention-item';
    mentionEl.dataset.mentionId = mention.id;
    mentionEl.style.cssText = `
      display: flex;
      gap: 12px;
      padding: 16px;
      border-bottom: 1px solid var(--x-border-color);
      cursor: pointer;
      transition: background-color 0.2s;
      user-select: none;
      -webkit-user-select: none;
    `;

    // 長按事件（移動端和桌面端）
    let touchMoved = false;

    const startLongPress = e => {
      if (mentionsDeleteMode) return;
      touchMoved = false;
      mentionsLongPressStarted = true;
      mentionsLongPressTimer = setTimeout(() => {
        if (mentionsLongPressStarted && !touchMoved) {
          enterMentionsDeleteMode();
          // 自動選中被長按的項
          const checkbox = mentionEl.querySelector('.mention-checkbox');
          if (checkbox) {
            toggleMentionSelection(mention.id, checkbox);
          }
        }
      }, 500); // 500ms 長按觸發
    };

    const cancelLongPress = () => {
      mentionsLongPressStarted = false;
      if (mentionsLongPressTimer) {
        clearTimeout(mentionsLongPressTimer);
        mentionsLongPressTimer = null;
      }
    };

    const handleTouchMove = () => {
      touchMoved = true;
      cancelLongPress();
    };

    // 觸摸事件
    mentionEl.addEventListener('touchstart', startLongPress, { passive: true });
    mentionEl.addEventListener('touchend', cancelLongPress);
    mentionEl.addEventListener('touchmove', handleTouchMove);
    mentionEl.addEventListener('touchcancel', cancelLongPress);

    // 滑鼠事件（桌面端）
    mentionEl.addEventListener('mousedown', startLongPress);
    mentionEl.addEventListener('mouseup', cancelLongPress);
    mentionEl.addEventListener('mouseleave', cancelLongPress);

    mentionEl.onmouseover = () => {
      if (!mentionsDeleteMode) {
        mentionEl.style.backgroundColor = 'var(--x-bg-hover)';
      }
    };
    mentionEl.onmouseout = () => {
      mentionEl.style.backgroundColor = 'transparent';
    };

    // 左側圖示區域
    const iconArea = document.createElement('div');
    iconArea.style.cssText =
      'width: 40px; display: flex; flex-direction: column; align-items: flex-end; flex-shrink: 0;';

    const iconColor = 'var(--x-accent)';
    const iconSvg = `<svg viewBox="0 0 24 24" style="width: 32px; height: 32px; fill: ${iconColor};"><g><path d="M20.884 13.19c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g></svg>`;

    iconArea.innerHTML = iconSvg;

    // 右側內容區域
    const contentArea = document.createElement('div');
    contentArea.style.cssText = 'flex: 1; min-width: 0;';

    // 使用者頭像區域（顯示3個頭像）
    let avatarsHtml = '<div style="display: flex; gap: 4px; margin-bottom: 8px;">';
    const displayUsers = mention.users.slice(0, 3);
    displayUsers.forEach(user => {
      avatarsHtml += `<img src="${user.avatar}" alt="${user.name}" style="width: 32px; height: 32px; border-radius: 50%; border: 2px solid var(--x-bg-primary);">`;
    });
    avatarsHtml += '</div>';

    // 構建通知文本
    const firstName = mention.users[0].name;
    const secondName = mention.users.length > 1 ? mention.users[1].name : '';
    const othersCount = mention.othersCount || 0;

    let notificationText = '';
    if (currentLanguage === 'zh') {
      notificationText = `${firstName}${secondName ? ` ${secondName}` : ''}${
        othersCount > 0 ? ` 和其他 ${othersCount} 人` : ''
      } 喜歡了你的推文`;
    } else {
      notificationText = `${firstName}${secondName ? ` ${secondName}` : ''}${
        othersCount > 0 ? ` and ${othersCount} others` : ''
      } liked your post`;
    }

    // 推文內容
    let tweetContentHtml = '';
    if (mention.tweet) {
      tweetContentHtml = `
        <div style="margin-top: 12px; padding: 12px; border: 1px solid var(--x-border-color); border-radius: 12px;">
          <div style="color: var(--x-text-primary); font-size: 15px; line-height: 1.4; margin-bottom: ${
            mention.tweet.image ? '8px' : '0'
          };">
            ${mention.tweet.content}
          </div>
          ${
            mention.tweet.image
              ? `<div style="color: var(--x-text-secondary); font-size: 13px; margin-top: 8px;">[圖片]</div>`
              : ''
          }
        </div>
      `;
    }

    // 🔧 動態計算時間顯示（優先使用timestamp，否則使用靜態time）
    const displayTime = mention.timestamp ? getRelativeTime(mention.timestamp) : mention.time;

    contentArea.innerHTML = `
      ${avatarsHtml}
      <div style="color: var(--x-text-primary); font-size: 15px; font-weight: 600; margin-bottom: 4px;">
        ${notificationText}
      </div>
      <div style="color: var(--x-text-secondary); font-size: 14px;">
        ${displayTime}
      </div>
      ${tweetContentHtml}
    `;

    mentionEl.appendChild(iconArea);
    mentionEl.appendChild(contentArea);

    return mentionEl;
  }

  // 渲染轉帖通知項
  function renderRetweetMentionItem(mention) {
    const config = languageConfig[currentLanguage] || languageConfig.zh;

    const mentionEl = document.createElement('div');
    mentionEl.className = 'mention-item';
    mentionEl.dataset.mentionId = mention.id;
    mentionEl.style.cssText = `
      display: flex;
      gap: 12px;
      padding: 16px;
      border-bottom: 1px solid var(--x-border-color);
      cursor: pointer;
      transition: background-color 0.2s;
      user-select: none;
      -webkit-user-select: none;
    `;

    // 長按事件（移動端和桌面端）
    let touchMoved = false;
    let clickAllowed = true;

    const startLongPress = e => {
      if (mentionsDeleteMode) return;
      touchMoved = false;
      clickAllowed = true;
      mentionsLongPressStarted = true;
      mentionsLongPressTimer = setTimeout(() => {
        if (mentionsLongPressStarted && !touchMoved) {
          clickAllowed = false;
          enterMentionsDeleteMode();
          // 自動選中被長按的項
          const checkbox = mentionEl.querySelector('.mention-checkbox');
          if (checkbox) {
            toggleMentionSelection(mention.id, checkbox);
          }
        }
      }, 500); // 500ms 長按觸發
    };

    const cancelLongPress = () => {
      mentionsLongPressStarted = false;
      if (mentionsLongPressTimer) {
        clearTimeout(mentionsLongPressTimer);
        mentionsLongPressTimer = null;
      }
    };

    const handleTouchMove = () => {
      touchMoved = true;
      cancelLongPress();
    };

    // 觸摸事件
    mentionEl.addEventListener('touchstart', startLongPress, { passive: true });
    mentionEl.addEventListener('touchend', cancelLongPress);
    mentionEl.addEventListener('touchmove', handleTouchMove);
    mentionEl.addEventListener('touchcancel', cancelLongPress);

    // 滑鼠事件（桌面端）
    mentionEl.addEventListener('mousedown', startLongPress);
    mentionEl.addEventListener('mouseup', cancelLongPress);
    mentionEl.addEventListener('mouseleave', cancelLongPress);

    mentionEl.onmouseover = () => {
      if (!mentionsDeleteMode) {
        mentionEl.style.backgroundColor = 'var(--x-bg-hover)';
      }
    };
    mentionEl.onmouseout = () => {
      mentionEl.style.backgroundColor = 'transparent';
    };

    // 點擊查看轉帖詳情（只有在非刪除模式且非長按時才觸發）
    mentionEl.onclick = () => {
      if (!mentionsDeleteMode && clickAllowed) {
        showRetweetDetail(mention);
      }
    };

    // 左側圖示區域
    const iconArea = document.createElement('div');
    iconArea.style.cssText =
      'width: 40px; display: flex; flex-direction: column; align-items: flex-end; flex-shrink: 0;';

    const iconColor = 'var(--x-accent)';
    const iconSvg = `<svg viewBox="0 0 24 24" style="width: 32px; height: 32px; fill: ${iconColor};"><g><path d="M4.75 3.79l4.603 4.3-1.706 1.82L6 8.38v7.37c0 .97.784 1.75 1.75 1.75H13V20H7.75c-2.347 0-4.25-1.9-4.25-4.25V8.38L1.853 9.91.147 8.09l4.603-4.3zm11.5 2.71H11V4h5.25c2.347 0 4.25 1.9 4.25 4.25v7.37l1.647-1.53 1.706 1.82-4.603 4.3-4.603-4.3 1.706-1.82L18 15.62V8.25c0-.97-.784-1.75-1.75-1.75z"></path></g></svg>`;

    iconArea.innerHTML = iconSvg;

    // 右側內容區域
    const contentArea = document.createElement('div');
    contentArea.style.cssText = 'flex: 1; min-width: 0;';

    // 用戶頭像
    let avatarHtml = `<div style="margin-bottom: 8px;"><img src="${mention.user.avatar}" alt="${mention.user.name}" style="width: 32px; height: 32px; border-radius: 50%;"></div>`;

    // 構建通知文本
    let notificationText = '';
    if (currentLanguage === 'zh') {
      notificationText = `${mention.user.name} 轉推了你的推文`;
    } else {
      notificationText = `${mention.user.name} retweeted your post`;
    }

    contentArea.innerHTML = `
      ${avatarHtml}
      <div style="color: var(--x-text-primary); font-size: 15px; font-weight: 600; margin-bottom: 4px;">
        ${notificationText}
      </div>
      <div style="color: var(--x-text-secondary); font-size: 14px; margin-bottom: 12px;">
        ${mention.time}
      </div>
      <div style="padding: 12px; border: 1px solid var(--x-border-color); border-radius: 12px;">
        <div style="color: var(--x-text-primary); font-size: 15px; line-height: 1.4; margin-bottom: 8px;">
          ${processContent(mention.retweetContent)}
        </div>
        <div style="padding: 12px; border-left: 3px solid var(--x-border-color); background-color: var(--x-bg-secondary); border-radius: 4px;">
          <div style="color: var(--x-text-secondary); font-size: 13px; margin-bottom: 4px;">
            ${mention.quotedTweet.user.name} ${mention.quotedTweet.user.handle}
          </div>
          <div style="color: var(--x-text-primary); font-size: 14px; line-height: 1.3;">
            ${mention.quotedTweet.content.substring(0, 100)}${mention.quotedTweet.content.length > 100 ? '...' : ''}
          </div>
        </div>
      </div>
    `;

    mentionEl.appendChild(iconArea);
    mentionEl.appendChild(contentArea);

    return mentionEl;
  }

  // 顯示轉帖詳情
  async function showRetweetDetail(mention) {
    try {
      // 構建轉帖推文數據
      // 確保 stats 資料完整
      const ensureStats = stats => ({
        comments: stats?.comments || 0,
        retweets: stats?.retweets || 0,
        likes: stats?.likes || 0,
        views: stats?.views || 0,
      });

      const retweetData = {
        id: mention.id || `retweet_${Date.now()}`,
        user: mention.user || {
          name: '未知用戶',
          handle: '@unknown',
          avatar: 'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg',
          verified: false,
        },
        content: mention.retweetContent || '',
        time: mention.time || '剛剛',
        timestamp: mention.timestamp || Date.now(),
        stats: ensureStats(mention.stats),
        quotedTweet: {
          type: 'tweet',
          user: mention.quotedTweet?.user || {
            name: '未知用戶',
            handle: '@unknown',
            avatar: 'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg',
            verified: false,
          },
          content: mention.quotedTweet?.content || '',
          time: mention.quotedTweet?.time || '剛剛',
          image: mention.quotedTweet?.image || null,
          stats: ensureStats(mention.quotedTweet?.stats),
        },
        comments: mention.comments || [], // 轉帖的評論（從AI生成的資料中獲取）
        _source: 'retweet_mention', // 標記來源
      };

      console.log('📝 [轉帖詳情] 數據已準備:', retweetData);

      // 使用現有的推文詳情顯示函數
      await showTweetDetail(retweetData);
    } catch (error) {
      console.error('顯示轉帖詳情失敗:', error);
      showXToast('無法顯示轉帖詳情', 'error');
    }
  }

  // 顯示 New Tweet 詳情
  async function showNewTweetDetail(mention) {
    try {
      console.log('📝 [New Tweet詳情] 準備顯示推文詳情:', mention);

      // 確保 stats 資料完整
      const ensureStats = stats => ({
        comments: stats?.comments || 0,
        retweets: stats?.retweets || 0,
        likes: stats?.likes || 0,
        views: stats?.views || 0,
      });

      // 構建推文數據
      const tweetData = {
        id: mention.tweet.id || `newtweet_${Date.now()}`,
        user: mention.tweet.user ||
          mention.user || {
            name: '未知用戶',
            handle: '@unknown',
            avatar: 'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg',
            verified: false,
          },
        content: mention.tweet.content || '',
        time: mention.tweet.time || '剛剛',
        timestamp: mention.tweet.timestamp || mention.timestamp || Date.now(),
        image: mention.tweet.image || null,
        stats: ensureStats(mention.tweet.stats),
        comments: (mention.tweet.comments || []).map(comment => ({
          ...comment,
          stats: ensureStats(comment.stats), // 確保評論的stats也完整
        })),
        _source: 'newtweet_mention', // 標記來源
        _mentionId: mention.id, // 保存通知ID，用於更新資料庫
      };

      console.log('📝 [New Tweet詳情] 數據已準備，包含 %d 條評論', tweetData.comments.length);

      // 使用現有的推文詳情顯示函數
      await showTweetDetail(tweetData);
    } catch (error) {
      console.error('顯示 New Tweet 詳情失敗:', error);
      showXToast('無法顯示推文詳情', 'error');
    }
  }

  // ▲▲▲ 【主要！！！】第十個情景：Mentions 通知生成器 ▲▲▲

  // Mentions 刪除模式狀態
  let mentionsDeleteMode = false;
  let selectedMentions = new Set();
  let mentionsLongPressTimer = null;
  let mentionsLongPressStarted = false;

  // 切換通知標籤 (All / Mentions)
  window.switchNotificationTab = function (tab) {
    const tabs = document.querySelectorAll('.notification-tab');
    const allContent = document.getElementById('notifications-all-content');
    const mentionsContent = document.getElementById('notifications-mentions-content');
    const refreshBtn = document.getElementById('refresh-messages-btn');

    // 切換標籤時退出刪除模式
    if (mentionsDeleteMode) {
      exitMentionsDeleteMode();
    }

    tabs.forEach(tabEl => {
      const isActive =
        (tab === 'all' && (tabEl.textContent.includes('全部') || tabEl.textContent.includes('All'))) ||
        (tab === 'mentions' && (tabEl.textContent.includes('提及') || tabEl.textContent.includes('Mentions')));

      if (isActive) {
        tabEl.classList.add('active');
        tabEl.style.color = 'var(--x-text-primary)';
        tabEl.style.backgroundColor = 'transparent';
        tabEl.querySelector('.tab-indicator').style.display = 'block';
      } else {
        tabEl.classList.remove('active');
        tabEl.style.color = 'var(--x-text-secondary)';
        tabEl.style.backgroundColor = 'transparent';
        tabEl.querySelector('.tab-indicator').style.display = 'none';
      }
    });

    if (tab === 'all') {
      allContent.style.display = 'flex';
      mentionsContent.style.display = 'none';
      if (refreshBtn) refreshBtn.style.display = 'flex';
    } else {
      allContent.style.display = 'none';
      mentionsContent.style.display = 'flex';
      if (refreshBtn) refreshBtn.style.display = 'none';
    }
  };

  // 進入刪除模式
  function enterMentionsDeleteMode() {
    mentionsDeleteMode = true;
    selectedMentions.clear();

    // 顯示刪除工具列
    showMentionsDeleteToolbar();

    // 更新所有通知項的樣式
    const mentionItems = document.querySelectorAll('.mention-item');
    mentionItems.forEach(item => {
      item.style.paddingLeft = '56px';

      // 添加核取方塊
      const checkbox = document.createElement('div');
      checkbox.className = 'mention-checkbox';
      checkbox.style.cssText = `
        position: absolute;
        left: 16px;
        top: 50%;
        transform: translateY(-50%);
        width: 24px;
        height: 24px;
        border: 2px solid var(--x-border-color);
        border-radius: 50%;
        cursor: pointer;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
      `;

      item.style.position = 'relative';
      item.insertBefore(checkbox, item.firstChild);

      // 點擊核取方塊切換選中狀態
      checkbox.onclick = e => {
        e.stopPropagation();
        const mentionId = item.dataset.mentionId;
        toggleMentionSelection(mentionId, checkbox);
      };
    });

    console.log('✅ 進入 Mentions 刪除模式');
  }

  // 退出刪除模式
  function exitMentionsDeleteMode() {
    mentionsDeleteMode = false;
    selectedMentions.clear();

    // 隱藏刪除工具列
    hideMentionsDeleteToolbar();

    // 移除所有核取方塊
    const checkboxes = document.querySelectorAll('.mention-checkbox');
    checkboxes.forEach(cb => cb.remove());

    // 恢復通知項樣式
    const mentionItems = document.querySelectorAll('.mention-item');
    mentionItems.forEach(item => {
      item.style.paddingLeft = '16px';
    });

    console.log('✅ 退出 Mentions 刪除模式');
  }

  // 切換通知選中狀態
  function toggleMentionSelection(mentionId, checkbox) {
    if (selectedMentions.has(mentionId)) {
      selectedMentions.delete(mentionId);
      checkbox.style.backgroundColor = 'transparent';
      checkbox.innerHTML = '';
    } else {
      selectedMentions.add(mentionId);
      checkbox.style.backgroundColor = 'var(--x-accent)';
      checkbox.style.borderColor = 'var(--x-accent)';
      checkbox.innerHTML = `<svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: white;"><g><path d="M9 20l-7-7 1.41-1.41L9 17.17l11.59-11.58L22 7z"></path></g></svg>`;
    }

    updateDeleteToolbar();
  }

  // 顯示刪除工具列
  function showMentionsDeleteToolbar() {
    const existingToolbar = document.getElementById('mentions-delete-toolbar');
    if (existingToolbar) {
      existingToolbar.remove();
    }

    const toolbar = document.createElement('div');
    toolbar.id = 'mentions-delete-toolbar';
    toolbar.style.cssText = `
      position: fixed;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--x-bg-primary);
      border: 1px solid var(--x-border-color);
      border-radius: 24px;
      padding: 12px 20px;
      display: flex;
      align-items: center;
      gap: 16px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 1000;
      animation: slideUp 0.3s ease;
    `;

    toolbar.innerHTML = `
      <button id="mentions-select-all-btn" style="
        background: transparent;
        border: none;
        color: var(--x-accent);
        font-size: 15px;
        font-weight: 600;
        cursor: pointer;
        padding: 8px 12px;
        border-radius: 8px;
        transition: background-color 0.2s;
      ">全選</button>
      <div style="width: 1px; height: 24px; background: var(--x-border-color);"></div>
      <button id="mentions-delete-btn" style="
        background: transparent;
        border: none;
        color: var(--x-text-secondary);
        font-size: 15px;
        font-weight: 600;
        cursor: not-allowed;
        padding: 8px 12px;
        border-radius: 8px;
        transition: all 0.2s;
      ">刪除 (0)</button>
      <div style="width: 1px; height: 24px; background: var(--x-border-color);"></div>
      <button id="mentions-cancel-btn" style="
        background: transparent;
        border: none;
        color: var(--x-text-primary);
        font-size: 15px;
        font-weight: 600;
        cursor: pointer;
        padding: 8px 12px;
        border-radius: 8px;
        transition: background-color 0.2s;
      ">取消</button>
    `;

    document.body.appendChild(toolbar);

    // 綁定事件
    document.getElementById('mentions-select-all-btn').onclick = selectAllMentions;
    document.getElementById('mentions-delete-btn').onclick = confirmDeleteMentions;
    document.getElementById('mentions-cancel-btn').onclick = exitMentionsDeleteMode;

    // 添加按鈕懸停效果
    const buttons = toolbar.querySelectorAll('button');
    buttons.forEach(btn => {
      btn.onmouseover = () => {
        if (btn.id !== 'mentions-delete-btn' || selectedMentions.size > 0) {
          btn.style.backgroundColor = 'var(--x-bg-hover)';
        }
      };
      btn.onmouseout = () => {
        btn.style.backgroundColor = 'transparent';
      };
    });
  }

  // 隱藏刪除工具列
  function hideMentionsDeleteToolbar() {
    const toolbar = document.getElementById('mentions-delete-toolbar');
    if (toolbar) {
      toolbar.remove();
    }
  }

  // 更新刪除工具列
  function updateDeleteToolbar() {
    const deleteBtn = document.getElementById('mentions-delete-btn');
    const selectAllBtn = document.getElementById('mentions-select-all-btn');

    if (deleteBtn) {
      const count = selectedMentions.size;
      deleteBtn.textContent = `刪除 (${count})`;

      if (count > 0) {
        deleteBtn.style.color = '#f4212e';
        deleteBtn.style.cursor = 'pointer';
      } else {
        deleteBtn.style.color = 'var(--x-text-secondary)';
        deleteBtn.style.cursor = 'not-allowed';
      }
    }

    if (selectAllBtn) {
      const allMentionItems = document.querySelectorAll('.mention-item');
      if (selectedMentions.size === allMentionItems.length && allMentionItems.length > 0) {
        selectAllBtn.textContent = '取消全選';
      } else {
        selectAllBtn.textContent = '全選';
      }
    }
  }

  // 全選/取消全選
  function selectAllMentions() {
    const allMentionItems = document.querySelectorAll('.mention-item');
    const selectAllBtn = document.getElementById('mentions-select-all-btn');

    if (selectedMentions.size === allMentionItems.length) {
      // 取消全選
      selectedMentions.clear();
      const checkboxes = document.querySelectorAll('.mention-checkbox');
      checkboxes.forEach(cb => {
        cb.style.backgroundColor = 'transparent';
        cb.style.borderColor = 'var(--x-border-color)';
        cb.innerHTML = '';
      });
    } else {
      // 全選
      allMentionItems.forEach(item => {
        const mentionId = item.dataset.mentionId;
        selectedMentions.add(mentionId);
        const checkbox = item.querySelector('.mention-checkbox');
        if (checkbox) {
          checkbox.style.backgroundColor = 'var(--x-accent)';
          checkbox.style.borderColor = 'var(--x-accent)';
          checkbox.innerHTML = `<svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: white;"><g><path d="M9 20l-7-7 1.41-1.41L9 17.17l11.59-11.58L22 7z"></path></g></svg>`;
        }
      });
    }

    updateDeleteToolbar();
  }

  // 確認刪除
  function confirmDeleteMentions() {
    if (selectedMentions.size === 0) return;

    const count = selectedMentions.size;
    const message =
      currentLanguage === 'zh'
        ? `確定要刪除 ${count} 條通知嗎？此操作不可恢復。`
        : `Delete ${count} notification${count > 1 ? 's' : ''}? This action cannot be undone.`;

    if (confirm(message)) {
      deleteMentions();
    }
  }

  // 執行刪除
  async function deleteMentions() {
    try {
      const xDb = getXDB();
      const mentionsDataId = `mentions_${currentAccountId || 'main'}`;
      const savedMentions = await xDb.xAccountProfiles.get(mentionsDataId);

      if (savedMentions && savedMentions.data) {
        // 過濾掉被選中的通知
        const idsToDelete = Array.from(selectedMentions);
        savedMentions.data = savedMentions.data.filter(m => !idsToDelete.includes(m.id));

        await xDb.xAccountProfiles.put(savedMentions);

        console.log(`✅ 已刪除 ${idsToDelete.length} 條 Mentions 通知`);
        showXToast(`已刪除 ${idsToDelete.length} 條通知`, 'success');

        // 退出刪除模式
        exitMentionsDeleteMode();

        // 重新載入通知
        await loadNotifications();
      }
    } catch (error) {
      console.error('❌ 刪除 Mentions 通知失敗:', error);
      showXToast('刪除失敗: ' + error.message, 'error');
    }
  }

  // 陌生人私信數據（第八個情景）
  const strangerMessages = [];

  // 示例提及資料（通知）
  const sampleMentions = [
    {
      id: 'mention_001',
      type: 'newTweet', // newTweet | like | retweet | reply | follow
      users: [
        {
          name: '餵ぇあか',
          handle: '@weaka',
          avatar: 'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg',
        },
        {
          name: '毎日抜雄',
          handle: '@nukio',
          avatar: 'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg',
        },
        {
          name: 'X',
          handle: '@X',
          avatar: 'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg',
        },
      ],
      content: 'New Tweet notifications for 餵ぇあか 毎日抜雄 and 3 others',
      time: '2小時前',
      tweet: null,
    },
    {
      id: 'mention_002',
      type: 'like',
      users: [
        {
          name: 'Tenny and Sticks🧵',
          handle: '@tennysticks',
          avatar: 'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg',
        },
      ],
      content: 'liked your Tweet',
      time: '3小時前',
      tweet: {
        content: 'Someone looks like ready to ask for Raiden Shogun......... https://t.co/GrRMlbtpeq',
        image: null,
      },
    },
    {
      id: 'mention_003',
      type: 'retweet',
      users: [
        {
          name: 'Moona Hoshinova (ムーナ)🔮金沢ID',
          handle: '@moonahoshinova',
          avatar: 'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg',
        },
        {
          name: '毎日抜雄',
          handle: '@nukio',
          avatar: 'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg',
        },
      ],
      content: 'and 2 others Retweeted a photo from 鍵、毎日投稿 サトウ・ドア・アイガ！！',
      time: '5小時前',
      tweet: {
        content: '#GambaRisu\n#ioarts',
        image: 'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg',
      },
    },
  ];

  // 渲染提及/通知項
  function renderMentionItem(mention) {
    const config = languageConfig[currentLanguage] || languageConfig.zh;

    const mentionEl = document.createElement('div');
    mentionEl.className = 'mention-item';
    mentionEl.dataset.mentionId = mention.id;
    mentionEl.style.cssText = `
      display: flex;
      gap: 12px;
      padding: 16px;
      border-bottom: 1px solid var(--x-border-color);
      cursor: pointer;
      transition: background-color 0.2s;
    `;

    // 添加長按事件監聽（移動端和桌面端）
    let pressTimer = null;

    const startPress = e => {
      if (mentionsDeleteMode) return;
      pressTimer = setTimeout(() => {
        enterMentionsDeleteMode();
        const checkbox = mentionEl.querySelector('.mention-checkbox');
        if (checkbox) {
          toggleMentionSelection(mention.id, checkbox);
        }
        // 觸覺回饋（如果支持）
        if (navigator.vibrate) {
          navigator.vibrate(50);
        }
      }, 500);
    };

    const endPress = () => {
      if (pressTimer) {
        clearTimeout(pressTimer);
        pressTimer = null;
      }
    };

    // 移動端觸摸事件
    mentionEl.addEventListener('touchstart', startPress);
    mentionEl.addEventListener('touchend', endPress);
    mentionEl.addEventListener('touchmove', endPress);

    // 桌面端滑鼠事件
    mentionEl.addEventListener('mousedown', startPress);
    mentionEl.addEventListener('mouseup', endPress);
    mentionEl.addEventListener('mouseleave', endPress);

    // 為 newTweet 類型添加點擊事件
    if (mention.type === 'newTweet' && mention.tweet) {
      mentionEl.onclick = () => {
        if (!mentionsDeleteMode) {
          showNewTweetDetail(mention);
        }
      };
    }

    mentionEl.onmouseover = () => {
      mentionEl.style.backgroundColor = 'var(--x-bg-hover)';
    };
    mentionEl.onmouseout = () => {
      mentionEl.style.backgroundColor = 'transparent';
    };

    // 左側圖示區域（根據類型顯示不同圖示）
    const iconArea = document.createElement('div');
    iconArea.style.cssText =
      'width: 40px; display: flex; flex-direction: column; align-items: flex-end; flex-shrink: 0;';

    let iconSvg = '';
    let iconColor = '';

    switch (mention.type) {
      case 'newTweet':
        iconColor = 'var(--x-accent)';
        iconSvg = `<svg viewBox="0 0 24 24" style="width: 32px; height: 32px; fill: ${iconColor};"><g><path d="M12 2C6.486 2 2 6.486 2 12s4.486 10 10 10 10-4.486 10-10S17.514 2 12 2zm5 11h-4v4h-2v-4H7v-2h4V7h2v4h4v2z"></path></g></svg>`;
        break;
      case 'like':
        iconColor = 'var(--x-accent)';
        iconSvg = `<svg viewBox="0 0 24 24" style="width: 32px; height: 32px; fill: ${iconColor};"><g><path d="M20.884 13.19c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g></svg>`;
        break;
      case 'retweet':
        iconColor = 'var(--x-accent)';
        iconSvg = `<svg viewBox="0 0 24 24" style="width: 32px; height: 32px; fill: ${iconColor};"><g><path d="M4.75 3.79l4.603 4.3-1.706 1.82L6 8.38v7.37c0 .97.784 1.75 1.75 1.75H13V20H7.75c-2.347 0-4.25-1.9-4.25-4.25V8.38L1.853 9.91.147 8.09l4.603-4.3zm11.5 2.71H11V4h5.25c2.347 0 4.25 1.9 4.25 4.25v7.37l1.647-1.53 1.706 1.82-4.603 4.3-4.603-4.3 1.706-1.82L18 15.62V8.25c0-.97-.784-1.75-1.75-1.75z"></path></g></svg>`;
        break;
      case 'reply':
        iconColor = 'var(--x-accent)';
        iconSvg = `<svg viewBox="0 0 24 24" style="width: 32px; height: 32px; fill: ${iconColor};"><g><path d="M1.751 10c0-4.42 3.584-8.005 8.005-8.005h4.366c4.49 0 8.129 3.64 8.129 8.13 0 2.96-1.607 5.68-4.196 7.11l-8.054 4.46v-3.69h-.067c-4.49.1-8.183-3.51-8.183-8.005zm8.005-6.005c-3.317 0-6.005 2.69-6.005 6.005 0 3.37 2.77 6.08 6.138 6.01l.351-.01h1.761v2.3l5.087-2.81c1.951-1.08 3.163-3.13 3.163-5.36 0-3.39-2.744-6.13-6.129-6.13H9.756z"></path></g></svg>`;
        break;
      case 'follow':
        iconColor = 'var(--x-accent)';
        iconSvg = `<svg viewBox="0 0 24 24" style="width: 32px; height: 32px; fill: ${iconColor};"><g><path d="M17.863 13.44c1.477 1.58 2.366 3.8 2.632 6.46l.11 1.1H3.395l.11-1.1c.266-2.66 1.155-4.88 2.632-6.46C7.627 11.85 9.648 11 12 11s4.373.85 5.863 2.44zM12 2C9.791 2 8 3.79 8 6s1.791 4 4 4 4-1.79 4-4-1.791-4-4-4z"></path></g></svg>`;
        break;
    }

    iconArea.innerHTML = iconSvg;

    // 右側內容區域
    const contentArea = document.createElement('div');
    contentArea.style.cssText = 'flex: 1; min-width: 0;';

    // 使用者頭像區域（對於newTweet顯示多個頭像）
    let avatarsHtml = '<div style="display: flex; gap: 4px; margin-bottom: 8px;">';
    if (mention.type === 'newTweet') {
      // newTweet 類型使用 mention.user（單數）
      if (mention.user) {
        avatarsHtml += `<img src="${mention.user.avatar}" alt="${mention.user.name}" style="width: 32px; height: 32px; border-radius: 50%; border: 2px solid var(--x-bg-primary);">`;
      }
    } else {
      // 其他類型顯示第一個使用者頭像
      if (mention.users && mention.users.length > 0) {
        avatarsHtml += `<img src="${mention.users[0].avatar}" alt="${mention.users[0].name}" style="width: 32px; height: 32px; border-radius: 50%;">`;
      }
    }
    avatarsHtml += '</div>';

    // 構建通知文本
    let notificationText = '';

    if (mention.type === 'newTweet') {
      // newTweet 類型使用 mention.user（單數）
      if (mention.user) {
        const userName = mention.user.name;
        if (currentLanguage === 'zh') {
          notificationText = `${userName} 發佈了新推文`;
        } else {
          notificationText = `New Tweet from ${userName}`;
        }
      }
    } else if (mention.users && mention.users.length > 0) {
      const firstName = mention.users[0].name;
      const secondName = mention.users.length > 1 ? mention.users[1].name : '';
      const othersCount = mention.users.length > 2 ? mention.users.length - 2 : 0;

      if (mention.type === 'like') {
        notificationText =
          currentLanguage === 'zh' ? `${firstName} 喜歡了你的推文` : `${firstName} ${config.notificationsLiked}`;
      } else if (mention.type === 'retweet') {
        if (currentLanguage === 'zh') {
          notificationText = `${firstName}${othersCount > 0 ? ` 和其他 ${othersCount} 人` : ''} 轉推了推文`;
        } else {
          notificationText = `${firstName}${othersCount > 0 ? ` and ${othersCount} others` : ''} ${
            config.notificationsRetweeted
          }`;
        }
      } else if (mention.type === 'reply') {
        notificationText =
          currentLanguage === 'zh' ? `${firstName} 回復了你` : `${firstName} ${config.notificationsReplied}`;
      } else if (mention.type === 'follow') {
        notificationText =
          currentLanguage === 'zh' ? `${firstName} 關注了你` : `${firstName} ${config.notificationsFollowed}`;
      }
    }

    // 推文內容（如果有）
    let tweetContentHtml = '';
    if (mention.tweet) {
      // 處理圖片（區分文字圖和真實圖）
      let imageHtml = '';
      if (mention.tweet.image) {
        if (typeof mention.tweet.image === 'object' && mention.tweet.image.type === 'description') {
          // 文字圖：使用與推文詳情頁相同的樣式
          imageHtml = `
            <div style="margin-top: 8px; background-color: var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 12px; padding: 16px; box-sizing: border-box;">
              <div style="color: var(--x-text-primary); font-size: 15px; line-height: 1.4; white-space: pre-wrap; word-wrap: break-word; overflow-wrap: break-word; width: 100%; box-sizing: border-box;">${mention.tweet.image.content}</div>
            </div>
          `;
        } else {
          // 真實圖：渲染為圖片
          const imageUrl = typeof mention.tweet.image === 'string' ? mention.tweet.image : mention.tweet.image.url;
          imageHtml = `<img src="${imageUrl}" style="width: 100%; border-radius: 12px; margin-top: 8px;">`;
        }
      }

      tweetContentHtml = `
        <div style="margin-top: 12px; padding: 12px; border: 1px solid var(--x-border-color); border-radius: 12px;">
          <div style="color: var(--x-text-primary); font-size: 15px; line-height: 1.4; margin-bottom: ${
            mention.tweet.image ? '8px' : '0'
          };">
            ${mention.tweet.content}
          </div>
          ${imageHtml}
        </div>
      `;
    }

    // 🔧 動態計算時間顯示（優先使用timestamp，否則使用靜態time）
    const displayTime = mention.timestamp ? getRelativeTime(mention.timestamp) : mention.time;

    contentArea.innerHTML = `
      ${avatarsHtml}
      <div style="color: var(--x-text-primary); font-size: 15px; font-weight: 600; margin-bottom: 4px;">
        ${notificationText}
      </div>
      <div style="color: var(--x-text-secondary); font-size: 14px;">
        ${displayTime}
      </div>
      ${tweetContentHtml}
    `;

    mentionEl.appendChild(iconArea);
    mentionEl.appendChild(contentArea);

    return mentionEl;
  }

  // 渲染陌生人私信項
  function renderStrangerMessageItem(message) {
    const config = languageConfig[currentLanguage] || languageConfig.zh;

    // 星星圖示
    const iconColor = 'var(--x-accent)';
    const iconSvg = `<svg viewBox="0 0 24 24" style="width: 32px; height: 32px; fill: ${iconColor};"><g><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path></g></svg>`;

    const messageEl = document.createElement('div');
    messageEl.className = 'stranger-message-item';
    messageEl.style.cssText = `
      display: flex;
      gap: 12px;
      padding: 16px;
      border-bottom: 1px solid var(--x-border-color);
      cursor: pointer;
      transition: background-color 0.2s;
    `;

    messageEl.onmouseover = () => {
      messageEl.style.backgroundColor = 'var(--x-bg-hover)';
    };
    messageEl.onmouseout = () => {
      messageEl.style.backgroundColor = 'transparent';
    };

    // 點擊打開私信詳情
    messageEl.onclick = () => {
      openMessageDetail(message);
    };

    // 左側圖示區域
    const iconArea = document.createElement('div');
    iconArea.style.cssText =
      'width: 40px; display: flex; align-items: flex-start; justify-content: flex-end; flex-shrink: 0;';
    iconArea.innerHTML = iconSvg;

    // 右側內容區域
    const contentArea = document.createElement('div');
    contentArea.style.cssText = 'flex: 1; min-width: 0;';

    let contentHtml = `
      <img src="${message.user.avatar}" 
        alt="${message.user.name}" 
        style="width: 32px; height: 32px; border-radius: 50%; margin-bottom: 8px;">
      <div style="color: var(--x-text-secondary); font-size: 15px; margin-bottom: 4px;">
        In case you missed <strong style="color: var(--x-text-primary);">${message.user.name}</strong>'s Message
      </div>
      <div style="color: var(--x-text-primary); font-size: 15px; line-height: 1.4; margin-bottom: 8px; font-weight: 500;">
        ${message.preview}
      </div>
      ${
        message.link
          ? `<div style="color: var(--x-accent); font-size: 15px; margin-bottom: 8px;">${message.link}</div>`
          : ''
      }
      ${
        message.attachment
          ? `<div style="color: var(--x-accent); font-size: 15px; margin-bottom: 8px;">${message.attachment}</div>`
          : ''
      }
      ${message.tweetLink ? `<div style="color: var(--x-accent); font-size: 15px;">${message.tweetLink}</div>` : ''}
    `;

    contentArea.innerHTML = contentHtml;

    messageEl.appendChild(iconArea);
    messageEl.appendChild(contentArea);

    return messageEl;
  }

  // 載入陌生人私信列表
  async function loadNotifications() {
    const allList = document.getElementById('notifications-all-list');
    const mentionsList = document.getElementById('notifications-mentions-list');

    if (!allList) return;

    const config = languageConfig[currentLanguage] || languageConfig.zh;

    // 從資料庫載入陌生人私信資料
    try {
      const xDb = getXDB();
      const dataId = `strangerMessages_${currentAccountId || 'main'}`;
      const savedData = await xDb.xAccountProfiles.get(dataId);

      if (savedData && savedData.data && Array.isArray(savedData.data)) {
        // 更新全域變數
        strangerMessages.length = 0;
        strangerMessages.push(...savedData.data);
        console.log('✅ 從資料庫載入了', strangerMessages.length, '條陌生人私信');
      }
    } catch (error) {
      console.error('載入陌生人私信數據失敗:', error);
    }

    // 清空現有內容
    allList.innerHTML = '';
    mentionsList.innerHTML = '';

    // 渲染 All 標籤的陌生人私信
    if (strangerMessages.length > 0) {
      strangerMessages.forEach(message => {
        const messageEl = renderStrangerMessageItem(message);
        allList.appendChild(messageEl);
      });
    } else {
      // 顯示空狀態（點擊羽毛筆生成私信）
      allList.innerHTML = `
        <div style="flex: 1; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 32px; text-align: center;">
          <svg viewBox="0 0 24 24" style="width: 56px; height: 56px; fill: var(--x-text-secondary); margin-bottom: 16px;">
            <g><path d="M1.998 5.5c0-1.381 1.119-2.5 2.5-2.5h15c1.381 0 2.5 1.119 2.5 2.5v13c0 1.381-1.119 2.5-2.5 2.5h-15c-1.381 0-2.5-1.119-2.5-2.5v-13zm2.5-.5c-.276 0-.5.224-.5.5v2.764l8 3.638 8-3.636V5.5c0-.276-.224-.5-.5-.5h-15zm15.5 5.463l-8 3.636-8-3.638V18.5c0 .276.224.5.5.5h15c.276 0 .5-.224.5-.5v-8.037z"></path></g>
          </svg>
          <div style="font-size: 28px; font-weight: 700; color: var(--x-text-primary); margin-bottom: 8px;">暫無陌生人私信</div>
          <div style="font-size: 14px; color: var(--x-text-secondary); max-width: 320px;">點擊右下角羽毛筆按鈕生成新的陌生人私信</div>
        </div>
      `;
    }

    // 從資料庫載入 Mentions 通知
    let allMentions = [];
    try {
      const xDb = getXDB();
      const mentionsDataId = `mentions_${currentAccountId || 'main'}`;
      const savedMentions = await xDb.xAccountProfiles.get(mentionsDataId);

      if (savedMentions && savedMentions.data && Array.isArray(savedMentions.data)) {
        allMentions = savedMentions.data;
        console.log('✅ 從資料庫載入了', allMentions.length, '條Mentions通知');
      }
    } catch (error) {
      console.error('載入Mentions通知失敗:', error);
    }

    // 渲染 Mentions 標籤的通知
    if (allMentions.length > 0) {
      // 按時間戳記排序（最新的在前面）
      allMentions.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));

      allMentions.forEach(mention => {
        let mentionEl;
        if (mention.type === 'like') {
          mentionEl = renderLikeMentionItem(mention);
        } else if (mention.type === 'retweet') {
          mentionEl = renderRetweetMentionItem(mention);
        } else {
          // 相容舊的測試資料
          mentionEl = renderMentionItem(mention);
        }
        mentionsList.appendChild(mentionEl);
      });
    } else {
      // 空狀態
      mentionsList.innerHTML = `
      <div style="flex: 1; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 32px; text-align: center;">
        <svg viewBox="0 0 24 24" style="width: 56px; height: 56px; fill: var(--x-text-secondary); margin-bottom: 16px;">
          <g><path d="M1.751 10c0-4.42 3.584-8.005 8.005-8.005h4.366c4.49 0 8.129 3.64 8.129 8.13 0 2.96-1.607 5.68-4.196 7.11l-8.054 4.46v-3.69h-.067c-4.49.1-8.183-3.51-8.183-8.005zm8.005-6.005c-3.317 0-6.005 2.69-6.005 6.005 0 3.37 2.77 6.08 6.138 6.01l.351-.01h1.761v2.3l5.087-2.81c1.951-1.08 3.163-3.13 3.163-5.36 0-3.39-2.744-6.13-6.129-6.13H9.756z"></path></g>
        </svg>
        <div style="font-size: 28px; font-weight: 700; color: var(--x-text-primary); margin-bottom: 8px;">${config.notificationsEmpty}</div>
        <div style="font-size: 14px; color: var(--x-text-secondary); max-width: 320px;">${config.notificationsEmptyDesc}</div>
      </div>
    `;
    }
  }

  // 將函數暴露到全域
  window.loadNotifications = loadNotifications;

  // ▼▼▼ 【主要！！！】第八個情景：陌生人私信生成器▼▼▼
  async function refreshStrangerMessages() {
    const refreshBtn = document.getElementById('refresh-messages-btn');

    // 添加旋轉動畫
    refreshBtn.style.animation = 'spin 1s linear infinite';
    const spinStyle = document.createElement('style');
    spinStyle.textContent = `
      @keyframes spin {
        from {transform: rotate(0deg); }
        to {transform: rotate(360deg); }
      }
    `;
    document.head.appendChild(spinStyle);

    try {
      // 從資料庫讀取API配置和X設置
      const db = getDB();
      const xDb = getXDB();

      const apiConfig = await db.apiConfig.get('main');
      if (!apiConfig || !apiConfig.proxyUrl || !apiConfig.apiKey || !apiConfig.model) {
        showXToast('請先配置API設置', 'error');
        refreshBtn.style.animation = '';
        return;
      }

      const { proxyUrl, apiKey, model } = apiConfig;

      // 從X設置中讀取配置（按帳號讀取）
      const settingsId = `xSettings_${currentAccountId || 'main'}`;
      const xSettings = await xDb.xSettings.get(settingsId);
      const userPrompt = xSettings?.systemPrompt || '';
      const worldSetting = xSettings?.worldSetting || '';

      // 使用工具函數構建使用者X個人資料資訊
      const userXProfileInfo = StringBuilders.buildUserXProfileInfo(window.userProfileData);

      // 獲取用戶最新的5條推文
      const userTweetsId = `userTweets_${currentAccountId || 'main'}`;
      const userTweetsData = await xDb.xUserTweets.get(userTweetsId);
      const recentUserTweets = userTweetsData?.tweets?.slice(0, 5) || [];

      // Token計數器
      let tokenCount = 0;

      // 1. 提示詞 + 世界書
      let systemPrompt = StringBuilders.buildBaseSystemPrompt({
        userPrompt,
        worldSetting,
      });
      tokenCount = TokenUtils.logTokenUsage('陌生人私信生成器', '基礎系統提示詞', systemPrompt, tokenCount);

      // 1.5. 獲取適用的世界書內容（僅對陌生人私信介面）
      const worldBooksContent = await StringBuilders.getApplicableWorldBooks('messages', {
        boundCharacters: [],
      });
      if (worldBooksContent) {
        systemPrompt += worldBooksContent;
        tokenCount = TokenUtils.logTokenUsage('陌生人私信生成器', '世界書內容', worldBooksContent, tokenCount);
      }

      // 2. 核心任務說明
      systemPrompt += `

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 核心任務說明 🎯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
你是X社交平臺的陌生人私信生成器。請生成3-8條來自陌生使用者的私信消息。

**重要規則**：
- 這些私信來自陌生用戶，不是用戶的朋友或熟人
- 私信內容可以是：商務合作、粉絲留言、問詢、推薦、隨機搭訕等
- 私信發送者都是虛構的X平臺用戶
- 頭像統一使用：https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;

      const coreTaskSection = systemPrompt.substring(systemPrompt.lastIndexOf('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━'));
      tokenCount = TokenUtils.logTokenUsage('陌生人私信生成器', '核心任務說明', coreTaskSection, tokenCount);

      // 3. 使用者資料
      const userConstraintsStart = systemPrompt.length;
      systemPrompt += `

【使用者X平臺資料】：
- 用戶名：${userXProfileInfo.name}
- 用戶控制碼：${userXProfileInfo.handle}
- 認證狀態：${userXProfileInfo.verified ? '已認證' : '未認證'}
${userXProfileInfo.publicIdentity ? `- 公眾身份：${userXProfileInfo.publicIdentity}` : ''}
${userXProfileInfo.bio ? `- 個人簡介：${userXProfileInfo.bio}` : ''}
`;

      // 4. 用戶最近推文
      if (recentUserTweets.length > 0) {
        systemPrompt += `

【用戶最近推文】（供參考，陌生人可能看過這些推文）：
`;
        recentUserTweets.forEach((tweet, index) => {
          systemPrompt += `
${index + 1}. "${tweet.content}"
   - 發佈時間：${tweet.time || '最近'}
   - 互動數據：${tweet.stats?.likes || 0}喜歡，${tweet.stats?.comments || 0}評論
`;
        });
      }

      const userSection = systemPrompt.substring(userConstraintsStart);
      tokenCount = TokenUtils.logTokenUsage('陌生人私信生成器', '使用者資料和推文', userSection, tokenCount);

      systemPrompt += `

【私信內容要求】：
- 私信類型多樣化：商務邀請、粉絲留言、合作諮詢、內容推薦、社交搭訕等
- 可以參考使用者的推文內容或公眾身份來設計私信話題
- 私信長度適中（20-100字）
- 部分私信可以附帶連結、圖片描述或推文連結

【JSON返回格式】：
\`\`\`json
{
  "messages": [私信陣列]
}
\`\`\`

私信物件結構：
- user: {name, handle, avatar, verified}
- preview: 私信預覽內容（主要文本）
- link: 附帶連結（可選，如個人網站、專案連結等）
- attachment: 附帶的圖片/檔描述（可選）
- tweetLink: 提及的推文連結（可選，如"你的這條推文xxx"）

關鍵規則：
1. verified欄位必須是布林值(true/false)，陌生人一般為false
2. user.avatar統一使用：https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg
3. 可選欄位不使用時完全省略，不要設為null
4. 私信內容要真實自然，符合陌生人私信的特點
`;

      const formatSection = systemPrompt.substring(systemPrompt.lastIndexOf('【JSON返回格式】'));
      tokenCount = TokenUtils.logTokenUsage('陌生人私信生成器', 'JSON格式要求', formatSection, tokenCount);

      const messages = [{ role: 'user', content: '請生成新的陌生人私信資料' }];

      // 最終統計
      TokenUtils.logFinalPrompt('陌生人私信生成器', systemPrompt, messages[0].content);

      // 判斷API類型並發送請求
      let isGemini = proxyUrl.includes('generativelanguage');
      let response;

      if (isGemini) {
        const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models';
        const geminiConfig = {
          url: `${GEMINI_API_URL}/${model}:generateContent?key=${getRandomValue(apiKey)}`,
          data: {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              contents: [
                {
                  parts: [
                    {
                      text: systemPrompt + '\n\n' + messages.map(m => m.content).join('\n'),
                    },
                  ],
                },
              ],
              generationConfig: {
                temperature: 0.8,
              },
            }),
          },
        };
        response = await fetch(geminiConfig.url, geminiConfig.data);
      } else {
        const openAiPayload = {
          model: model,
          messages: [{ role: 'system', content: systemPrompt }, ...messages],
          temperature: 0.8,
          stream: false,
        };
        response = await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${apiKey}`,
          },
          body: JSON.stringify(openAiPayload),
        });
      }

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(`API錯誤: ${response.status} - ${errorData.error?.message || response.statusText}`);
      }

      const data = await response.json();
      let aiResponseContent;

      if (isGemini) {
        aiResponseContent = data.candidates?.[0]?.content?.parts?.[0]?.text || '';
      } else {
        aiResponseContent = data.choices?.[0]?.message?.content || '';
      }

      console.log('AI原始回應:', aiResponseContent);

      // 解析AI返回的JSON資料
      const cleanedResponse = aiResponseContent
        .replace(/```json\s*/i, '')
        .replace(/```\s*$/, '')
        .trim();

      if (!cleanedResponse) {
        throw new Error('AI返回了空的回應內容');
      }

      let messagesData;
      try {
        messagesData = JSON.parse(cleanedResponse);
      } catch (parseError) {
        console.error('JSON解析失敗:', parseError);
        console.error('嘗試解析的內容:', cleanedResponse.substring(0, 500) + '...');
        throw new Error(`AI返回的資料不是有效的JSON格式: ${parseError.message}`);
      }

      // 驗證資料格式
      if (!messagesData.messages || !Array.isArray(messagesData.messages)) {
        throw new Error('AI返回的資料格式不正確，缺少messages陣列');
      }

      // 為私信添加ID
      const timestamp = Date.now();
      messagesData.messages.forEach((message, index) => {
        message.id = `sm_${timestamp}_${index}`;
      });

      // 更新全域資料
      strangerMessages.length = 0;
      strangerMessages.push(...messagesData.messages);

      // 保存陌生人私信資料到資料庫
      try {
        const xDb = getXDB();
        const dataId = `strangerMessages_${currentAccountId || 'main'}`;
        await xDb.xAccountProfiles.put({
          handle: dataId,
          name: 'strangerMessages',
          data: messagesData.messages,
          updatedAt: new Date().toISOString(),
        });
        console.log('✅ 陌生人私信資料已保存到資料庫');
      } catch (saveError) {
        console.error('保存陌生人私信資料失敗:', saveError);
      }

      // 重新渲染頁面
      loadNotifications();

      // 顯示手機樣式通知
      const isEnglish = currentLanguage === 'en';
      const userAvatar = window.userProfileData?.avatar || 'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg';
      showPhoneNotification({
        title: 'X',
        message: isEnglish ? 'Stranger messages have been refreshed!' : '陌生人私信已刷新！',
        avatar: userAvatar,
        leftIcon: 'x',
      });
    } catch (error) {
      console.error('刷新陌生人私信失敗:', error);
      showXToast(`刷新失敗: ${error.message}`, 'error');
    } finally {
      // 停止旋轉動畫
      refreshBtn.style.animation = '';
      if (spinStyle && spinStyle.parentNode) {
        spinStyle.remove();
      }
    }
  }

  // 將函數暴露到全域
  window.refreshStrangerMessages = refreshStrangerMessages;
  // ▲▲▲ 【主要！！！】第八個情景：陌生人私信生成器 ▲▲▲

  // ▼▼▼ 【主要！！！】第九個情景：私信詳情生成器▼▼▼
  async function generateMessageConversation(messageData, isContinueMode = false, options = {}) {
    try {
      // options可以包含：isAutoMessage（自動發消息模式）、timeSinceLastMessage（距離上次消息的秒數）、isAskboxViewed（提問箱查看模式）、askboxContent（提問箱內容）、businessTaskEvaluation（商業任務評估）、isUnblockRequest（拉黑解除請求）、unblockContext（拉黑解除上下文）
      const isAutoMessage = options.isAutoMessage || false;
      const timeSinceLastMessage = options.timeSinceLastMessage || 0;
      const isAskboxViewed = options.isAskboxViewed || false;
      const askboxContent = options.askboxContent || '';
      const businessTaskEvaluation = options.businessTaskEvaluation || null;
      const isUnblockRequest = options.isUnblockRequest || false;
      const unblockContext = options.unblockContext || null;

      // 從資料庫讀取API配置和X設置
      const db = getDB();
      const xDb = getXDB();

      const apiConfig = await db.apiConfig.get('main');
      if (!apiConfig || !apiConfig.proxyUrl || !apiConfig.apiKey || !apiConfig.model) {
        showXToast('請先配置API設置', 'error');
        return null;
      }

      const { proxyUrl, apiKey, model } = apiConfig;

      // 判斷私信類型
      let messageType = 'stranger'; // stranger | character | account
      let characterId = null;
      let accountHandle = null;

      if (messageData.id) {
        if (messageData.id.startsWith('msg_account_')) {
          messageType = 'account';
          // 從currentViewingAccount獲取帳戶控制碼
          if (currentViewingAccount && currentViewingAccount.accountInfo) {
            accountHandle = currentViewingAccount.accountInfo.handle.replace('@', '');
          }
        } else if (messageData.id.startsWith('msg_') && messageData.id !== 'msg_001') {
          messageType = 'character';
          characterId = messageData.id.replace('msg_', '');
        }
      }

      console.log(`📨 私信類型: ${messageType}`, { characterId, accountHandle });

      // 標準化 messageData 格式（確保有 user 對象）
      if (!messageData.user && messageData.userName) {
        messageData.user = {
          name: messageData.userName,
          handle: messageData.userHandle,
          avatar: messageData.userAvatar,
          verified: messageData.verified || false,
        };
      }

      // 如果是續寫模式，讀取現有對話上下文
      let existingMessages = [];
      if (isContinueMode) {
        // 🔧 多帳戶隔離：包含帳戶ID
        const conversationId = `messageConversation_${currentAccountId || 'main'}_${messageData.id}`;
        const savedConversation = await xDb.xAccountProfiles.get(conversationId);
        if (savedConversation && savedConversation.data && savedConversation.data.messages) {
          existingMessages = savedConversation.data.messages;
          console.log(`📖 [私信生成器] 讀取到 ${existingMessages.length} 條現有對話記錄`);
        } else {
          console.log(`📖 [私信生成器] 無現有對話記錄（首次對話）`);
        }
      }

      // 💼 檢查是否有進行中的商業轉帳任務
      let ongoingBusinessTransfer = null;
      if (isContinueMode && existingMessages.length > 0) {
        // 查找最近的進行中商業轉帳（倒序查找，取最新的）
        const transferMessages = existingMessages.filter(
          msg => msg.type === 'transfer' && msg.isBusiness && msg.taskStatus === 'in_progress',
        );
        if (transferMessages.length > 0) {
          ongoingBusinessTransfer = transferMessages[transferMessages.length - 1]; // 最新的進行中任務
          console.log(`💼 [商業轉帳] 檢測到進行中的任務，接收方: ${ongoingBusinessTransfer.isOwn ? 'AI' : '用戶'}`);
        }
      }

      // 從X設置中讀取配置（按帳號讀取）
      const settingsId = `xSettings_${currentAccountId || 'main'}`;
      const xSettings = await xDb.xSettings.get(settingsId);
      const userPrompt = xSettings?.systemPrompt || '';
      const worldSetting = xSettings?.worldSetting || '';

      // 使用工具函數構建使用者X個人資料資訊
      const userXProfileInfo = StringBuilders.buildUserXProfileInfo(window.userProfileData);

      // 獲取用戶最新的5條推文
      const userTweetsId = `userTweets_${currentAccountId || 'main'}`;
      const userTweetsData = await xDb.xUserTweets.get(userTweetsId);
      const recentUserTweets = userTweetsData?.tweets?.slice(0, 5) || [];

      // Token計數器
      let tokenCount = 0;

      // 1. 提示詞 + 世界書
      let systemPrompt = StringBuilders.buildBaseSystemPrompt({
        userPrompt,
        worldSetting,
      });
      tokenCount = TokenUtils.logTokenUsage('私信詳情生成器', '基礎系統提示詞', systemPrompt, tokenCount);

      // 1.5. 添加當前時間資訊（北京時間）
      const now = new Date();
      const beijingTime = new Date(now.getTime() + 8 * 60 * 60 * 1000); // UTC+8
      const year = beijingTime.getUTCFullYear();
      const month = beijingTime.getUTCMonth() + 1;
      const day = beijingTime.getUTCDate();
      const hours = beijingTime.getUTCHours();
      const minutes = beijingTime.getUTCMinutes();
      const weekdays = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'];
      const weekday = weekdays[beijingTime.getUTCDay()];

      let timeOfDay = '';
      if (hours >= 5 && hours < 9) {
        timeOfDay = '清晨';
      } else if (hours >= 9 && hours < 12) {
        timeOfDay = '上午';
      } else if (hours >= 12 && hours < 14) {
        timeOfDay = '中午';
      } else if (hours >= 14 && hours < 18) {
        timeOfDay = '下午';
      } else if (hours >= 18 && hours < 22) {
        timeOfDay = '晚上';
      } else {
        timeOfDay = '深夜';
      }

      systemPrompt += `

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
⏰ 當前時間資訊 ⏰
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
當前時間（北京時間）：${year}年${month}月${day}日 ${weekday} ${String(hours).padStart(2, '0')}:${String(
        minutes,
      ).padStart(2, '0')}
時段：${timeOfDay}

**請根據當前時間生成符合時間情境的回復**：
- 如果是清晨或上午，可以問候早安、討論早餐或一天的計畫
- 如果是中午，可以討論午餐或午休
- 如果是下午，可以討論工作或下午茶
- 如果是晚上，可以問候晚安、討論晚餐或晚間活動
- 如果是深夜，考慮為什麼還沒睡或深夜的話題
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
      tokenCount = TokenUtils.logTokenUsage(
        '私信詳情生成器',
        '時間資訊',
        systemPrompt.substring(systemPrompt.lastIndexOf('⏰ 當前時間資訊')),
        tokenCount,
      );

      // 1.6. 獲取適用的世界書內容（全域對話 + 僅角色對話 + 指定角色）
      const worldBooksOptions = { boundCharacters: [] };
      if (messageType === 'character' && characterId) {
        // 角色私信：傳入角色ID
        worldBooksOptions.boundCharacters = [characterId];
      } else if (messageType === 'account') {
        // 帳戶私信：暫不傳入角色（可以後續擴展）
        worldBooksOptions.boundCharacters = [];
      }
      // stranger 類型不傳入角色，只有全域對話的世界書會生效

      const worldBooksContent = await StringBuilders.getApplicableWorldBooks('messages', worldBooksOptions);
      if (worldBooksContent) {
        systemPrompt += worldBooksContent;
        tokenCount = TokenUtils.logTokenUsage('私信詳情生成器', '世界書內容', worldBooksContent, tokenCount);
      }

      // 2. 核心任務說明
      if (isContinueMode) {
        // 續寫模式 - 根據私信類型顯示不同的任務說明
        if (messageType === 'character') {
          // 角色私信
          if (isAskboxViewed) {
            // 提問箱查看模式
            systemPrompt += `

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 核心任務說明（提問箱查看模式 - 角色私信）🎯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
你是X社交平臺的私信對話生成器。角色發現用戶查看了自己的提問箱，現在主動發送私信。

**對話場景**：
- 📱 這是X社交平臺（類似Twitter/X）的私信功能
- 🔍 角色${messageData.user.name}發現用戶偷看了TA的提問箱
- 📝 使用者剛剛查看了以下提問箱內容：

${askboxContent}

**角色信息**：
- 角色名：${messageData.user.name}
- 角色控制碼：${messageData.user.handle}
- 這是一個已綁定的角色，有完整的人設、記憶和X平臺資料

**重要規則**：
- 🚨 只生成角色${messageData.user.name}的主動消息，不要生成使用者的消息
- ⚠️ **這是X平臺的私信對話，不是手機短信或其他聊天軟體**
- 📖 **必須參考下方的【X平臺私信對話記錄】**，瞭解你們之前的對話內容，保持對話的連貫性和一致性
- 角色知道用戶查看了TA的提問箱，可以調侃、好奇或關心用戶為什麼要看
- 可以結合提問箱的內容展開話題，詢問使用者的想法或意見
- 生成1-8條符合角色性格的主動消息
- 回復要嚴格符合角色的性格、說話風格和與用戶的關係
- 可以表現出：發現被偷看的驚訝、調皮、害羞、好奇等情緒（根據角色性格）
- 結合之前的X平臺私信對話記錄和提問箱內容，保持一致性
- 消息類型包括：文本、圖片（image：只需imageDescription和sensitive）、表情包（sticker：只需stickerUrl）、語音、文章連結（link：需要title、description、author、source、body完整正文）、轉發推文、轉發主頁
- ⚠️ 注意：image和sticker是完全不同的類型，不要混淆！link類型是文章連結，需要包含完整的文章內容
- ⚠️ 禁止生成forward類型消息（這是使用者手動轉發產生的）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
          } else if (isAutoMessage) {
            // 自動發消息模式
            const likedTweetContext = options.likedTweetContext;
            const hasLikedTweet = likedTweetContext && likedTweetContext.content;
            const isBusinessEvaluation = businessTaskEvaluation && businessTaskEvaluation.isBusinessTaskEvaluation;

            if (isBusinessEvaluation) {
              // 商業任務評估模式
              const tweetData = businessTaskEvaluation.tweetData;
              const businessTransfer = businessTaskEvaluation.businessTransfer;

              // 計算推文資料
              const likes = tweetData.stats?.likes || 0;
              const retweets = tweetData.stats?.retweets || 0;
              const comments = tweetData.stats?.comments || 0;
              const views = tweetData.stats?.views || 0;

              systemPrompt += `

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
💼 核心任務說明（商業任務評估模式 - 角色私信）💼
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
你是X社交平臺的私信對話生成器。角色雇傭了用戶完成商業推廣任務，現在評估任務完成情況並決定付款。

**對話場景**：
- 📱 這是X社交平臺（類似Twitter/X）的私信功能
- 💼 角色${messageData.user.name}之前發起了商業轉帳
- ✅ 用戶已完成任務，發佈了商業化推貼
- 🤖 角色現在要評估任務完成情況，並決定如何付款

**商業轉帳資訊**：
- 總金額：$${parseFloat(businessTransfer.amount).toFixed(2)}
- 已支付定金：$${parseFloat(businessTransfer.depositAmount).toFixed(2)} (${businessTransfer.depositRatio}%)
- 待付尾款：$${parseFloat(businessTransfer.remainingAmount).toFixed(2)}
- 任務要求：${businessTransfer.taskDescription}
- 任務期限：${businessTransfer.taskDeadlineHours}小時

**使用者完成的推貼內容**：
- 推文內容："${tweetData.content}"
${
  tweetData.image
    ? `- 包含圖片：${tweetData.image.type === 'description' ? tweetData.image.content : '已上傳圖片'}`
    : ''
}
${tweetData.location ? `- 位置：${tweetData.location}` : ''}
- 發佈時間：${tweetData.time || '剛剛'}

**推文資料表現**：
- 👍 喜歡數：${likes}
- 🔄 轉發數：${retweets}
- 💬 評論數：${comments}
- 👀 流覽量：${views}

**評論區回饋**：
${
  tweetData.comments && tweetData.comments.length > 0
    ? tweetData.comments
        .slice(0, 5)
        .map((c, i) => `${i + 1}. ${c.user.name}: "${c.content}"`)
        .join('\n')
    : '暫無評論'
}

**用戶公眾身份**：
- 用戶名：${userXProfileInfo.name}
- 用戶控制碼：${userXProfileInfo.handle}
- 認證狀態：${userXProfileInfo.verified ? '已認證' : '未認證'}
${userXProfileInfo.publicIdentity ? `- 公眾身份：${userXProfileInfo.publicIdentity}` : ''}
- 粉絲影響力：${userXProfileInfo.publicIdentity ? '有一定影響力' : '普通用戶'}

**評估規則**：
🎯 你需要根據以下標準評估任務完成情況：

1. **內容品質**（40%）：
   - 推文是否符合任務要求？
   - 表達是否自然，不是生硬的廣告？
   - 是否包含了要求的關鍵資訊？

2. **資料表現**（30%）：
   - 推文的互動資料（喜歡、轉發、評論、流覽量）如何？
   - 與用戶的粉絲基礎相匹配嗎？
   - 評論區回饋是否正面？

3. **用戶影響力**（30%）：
   - 用戶的公眾身份和影響力如何？
   - 認證狀態是否增加可信度？
   - 是否值得額外投資？

**付款決策**：
根據評估結果，你需要決定：

✅ **滿意（80-100分）**：
- 支付全額尾款 + 額外10-30%獎勵
- 示例：總額$200，定金$40，尾款$160，額外獎勵$20-60
- 在回復中表達滿意，感謝合作，期待下次合作

👍 **中規中矩（60-79分）**：
- 支付全額尾款，無額外獎勵
- 示例：總額$200，定金$40，尾款$160
- 在回復中表示認可，指出可以改進的地方

😐 **不滿意但可接受（40-59分）**：
- 支付50-80%的尾款
- 示例：總額$200，定金$40，尾款$160，實際支付$80-128
- 在回復中指出不足，表達輕微失望

❌ **非常不滿意（<40分）**：
- 不支付尾款或僅支付20-40%
- 示例：總額$200，定金$40，尾款$160，實際支付$0-64
- 在回復中明確指出問題，表達不滿

**重要規則**：
- 🚨 只生成角色${messageData.user.name}的評估消息，不要生成使用者的消息
- ⚠️ **這是X平臺的私信對話，不是手機短信或其他聊天軟體**
- 💰 **必須發送轉帳消息支付尾款**（amount為尾款金額，note說明付款原因）
- 📖 參考下方的【X平臺私信對話記錄】，保持對話的連貫性
- 🎭 評估要符合角色性格，有的角色很大方，有的很挑剔
- 💬 生成1-3條文本消息說明評估結果，然後發送轉帳
- ⚠️ 轉帳消息的note要說明是尾款、獎勵還是扣款

**消息示例結構**：
1. 文本消息：評估內容品質
2. 文本消息（可選）：評估資料表現
3. 轉帳消息：支付尾款（必須）
4. 文本消息（可選）：感謝或建議

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
            } else {
              // 普通自動發消息模式
              const isAwayReturn = options.isAwayReturn || false;

              systemPrompt += `

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 核心任務說明（自動發消息模式 - 角色私信）🎯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
你是X社交平臺的私信對話生成器。角色主動發起私信（後臺自動活動）。

**對話場景**：
- 📱 這是X社交平臺（類似Twitter/X）的私信功能
${
  isAwayReturn
    ? `- 🔙 **特殊情況：離開後返回**
- 角色${messageData.user.name}之前因為有事暫時離開，現在忙完了，主動聯繫用戶
- 距離上次對話已經過去了約 ${Math.round(timeSinceLastMessage / 60)} 分鐘
- 🤖 角色應該解釋自己去忙什麼了，並對讓用戶等待表示歉意或說明情況
- 生成1-5條符合角色性格的主動消息，體現出剛忙完的狀態`
    : hasLikedTweet
    ? `- 💖 用戶剛剛喜歡了角色${messageData.user.name}的推文
- 📝 被喜歡的推文內容："${likedTweetContext.content}"
- 🤖 角色發現用戶喜歡了TA的推文，現在主動發送私信`
    : `- ⏰ 距離上一次對話已經過去了 ${timeSinceLastMessage} 秒
- 🤖 角色${messageData.user.name}現在主動發送私信`
}

**角色信息**：
- 角色名：${messageData.user.name}
- 角色控制碼：${messageData.user.handle}
- 這是一個已綁定的角色，有完整的人設、記憶和X平臺資料

**重要規則**：
- 🚨 只生成角色${messageData.user.name}的主動消息，不要生成使用者的消息
- ⚠️ **這是X平臺的私信對話，不是手機短信或其他聊天軟體**
${
  isAwayReturn
    ? `- 📖 **必須參考下方的【X平臺私信對話記錄】**，查看使用者之前發送的消息
- 🔙 角色現在忙完了，應該回應使用者之前的消息內容
- 可以先道歉/解釋為什麼離開了一段時間，然後回應使用者的消息
- 消息風格要自然，符合角色性格（有的角色會認真道歉，有的隨意說明）
- 根據角色性格和與使用者的關係，調整道歉的正式程度
- 回復要嚴格符合角色的性格、說話風格和與用戶的關係
- 參考角色的聊天記憶（包括X平臺私信記憶和其他聊天記憶），保持一致性`
    : hasLikedTweet
    ? `- 📖 **必須參考下方的【X平臺私信對話記錄】**，瞭解你們之前的對話內容，保持對話的連貫性和一致性
- 💖 角色知道用戶喜歡了TA的推文（上面顯示的推文內容），可以表現出驚喜、開心、好奇等情緒
- 可以結合推文內容展開話題，詢問使用者的想法或感受
- 生成1-5條符合角色性格的主動消息，表現出看到自己的推文被喜歡的反應
- 回復要嚴格符合角色的性格、說話風格和與用戶的關係
- 可以表現出：發現被關注的開心、想繼續交流的期待等情緒（根據角色性格）
- 結合之前的X平臺私信對話記錄和推文內容，保持一致性`
    : `- 根據距離上次對話的時間，生成1-7條符合角色性格的主動消息
- 主動消息可以是：想念對方、分享近況、詢問對方、提及X平臺的推文等
- 回復要嚴格符合角色的性格、說話風格和與用戶的關係
- 參考角色的聊天記憶（包括X平臺私信記憶和其他聊天記憶），保持一致性
- 可以自然提及角色最近在X平臺發佈的推文或動態`
}
- 消息類型包括：文本、圖片（image：只需imageDescription和sensitive）、表情包（sticker：只需stickerUrl）、語音、文章連結（link：需要title、description、author、source、body完整正文）、轉發推文、轉發主頁
- ⚠️ 注意：image和sticker是完全不同的類型，不要混淆！link類型是文章連結，需要包含完整的文章內容
- ⚠️ 禁止生成forward類型消息（這是使用者手動轉發產生的）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
            }
          } else if (isUnblockRequest) {
            // 拉黑解除請求模式
            const triggerSource = unblockContext?.triggerSource || 'unknown';
            const triggerContent = unblockContext?.triggerContent || '';

            systemPrompt += `

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🔓 核心任務說明（拉黑解除評估 - 角色私信）🔓
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
你是X社交平臺的私信對話生成器。你之前拉黑了用戶，但使用者通過其他方式聯繫了你，現在需要評估是否解除拉黑。

**對話場景**：
- 📱 這是X社交平臺（類似Twitter/X）的私信功能
- ⚠️ **你之前已經拉黑了用戶，用戶無法直接發送私信**
- 🔔 但用戶通過${triggerSource === 'mention' ? '在推文中@你' : '在評論區評論'}的方式聯繫了你

**角色信息**：
- 角色名：${messageData.user.name}
- 角色控制碼：${messageData.user.handle}
- 這是一個已綁定的角色，有完整的人設、記憶和X平臺資料

**使用者的觸發內容**：
${triggerSource === 'mention' ? '用戶在推文中@了你：' : '用戶在評論區提到了你：'}
"${triggerContent}"

**重要規則**：
- 🚨 只生成角色${messageData.user.name}的回復消息，不要生成使用者的消息
- 📖 **必須參考下方的【X平臺私信對話記錄】**，瞭解之前為什麼拉黑用戶
- 🤔 根據使用者的觸發內容，評估是否值得解除拉黑

**解除拉黑決策**：
你需要根據以下因素決定是否解除拉黑：

1️⃣ **解除拉黑（推薦）**：
   - 用戶的態度誠懇，有道歉或和解的意圖
   - 使用者提到的內容讓你覺得可以原諒
   - 用戶表現出改變或理解
   - 之前的衝突不算特別嚴重
   - **返回格式**：[解除拉黑系統提示] + 0-3條文本消息（可以是原諒的話、重新開始的話，或直接不發其他消息）

2️⃣ **繼續拉黑**：
   - 用戶的態度依然惡劣或不真誠
   - 使用者的內容讓你更生氣
   - 之前的衝突太嚴重，無法原諒
   - **返回格式**：返回空陣列[]（表示不回應，繼續拉黑）

**解除拉黑系統提示格式**：
{
  "type": "system",
  "systemType": "unblocked",
  "content": "對方已解除拉黑",
  "time": "剛剛"
}

⚠️ 如果決定解除拉黑，系統提示後可以跟0-3條文本消息：
- 0條：直接解除，不說話（高冷風格）
- 1-2條：簡單回應（"算了，原諒你了"、"看在你道歉的份上..."）
- 2-3條：詳細回應（解釋為什麼原諒、提出要求等）

⚠️ 如果決定繼續拉黑，返回空陣列[]即可，不需要任何消息
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━`;
          } else {
            // 普通回復模式
            systemPrompt += `

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 核心任務說明（續寫模式 - 角色私信）🎯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
你是X社交平臺的私信對話生成器。用戶剛剛發送了新的私信，請扮演已綁定的角色生成回復。

**對話場景**：
- 📱 這是X社交平臺（類似Twitter/X）的私信功能
- ⚠️ **這是X平臺的私信對話，不是手機短信或其他聊天軟體**

**角色信息**：
- 角色名：${messageData.user.name}
- 角色控制碼：${messageData.user.handle}
- 這是一個已綁定的角色，有完整的人設、記憶和X平臺資料

**重要規則**：
- 🚨 只生成角色${messageData.user.name}的回復消息，不要生成使用者的消息

**回復決策（你可以選擇如何回應）**：
1️⃣ **正常回復**：生成1-10條符合角色人設的自然回復（最常見）
2️⃣ **不回復**：如果這是首次對話且使用者的消息不吸引人、內容冒犯、或角色沒有回復的理由，可以返回空陣列[]
3️⃣ **拉黑用戶**：如果發生嚴重衝突、使用者持續騷擾、或對話已經惡化到無法繼續，可以返回拉黑系統提示
4️⃣ **暫時離開**：如果角色臨時有事無法回復（工作、上課、睡覺等），可以返回離開系統提示，稍後會主動聯繫用戶

**正常回復要求**：
- 回復要嚴格符合角色的性格、說話風格和與用戶的關係
- 參考角色的聊天記憶（包括X平臺私信記憶和其他聊天記憶），保持一致性
- 可以適當提及角色最近在X平臺發佈的推文或動態
- 消息類型包括：文本、圖片（image：只需imageDescription和sensitive）、表情包（sticker：只需stickerUrl）、語音、文章連結（link：需要title、description、author、source、body完整正文）、轉發推文、轉發主頁、系統提示（system）
- ⚠️ 注意：image和sticker是完全不同的類型，不要混淆！link類型是文章連結，需要包含完整的文章內容
- ⚠️ 禁止生成forward類型消息（這是使用者手動轉發產生的）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;

            // 💼 添加商業任務上下文（如果有進行中的任務）
            if (ongoingBusinessTransfer) {
              const isAIReceiver = !ongoingBusinessTransfer.isOwn; // AI是接收方
              const isUserReceiver = ongoingBusinessTransfer.isOwn; // 用戶是接收方
              const taskDesc = ongoingBusinessTransfer.taskDescription || '';
              const remainingAmount = parseFloat(ongoingBusinessTransfer.remainingAmount || 0).toFixed(2);

              // 檢測任務是否是發帖類型
              const postKeywords = ['發帖', '發推', '發推特', '發推文', 'post', 'tweet', '宣傳', '推廣'];
              const isPostTask = postKeywords.some(kw => taskDesc.toLowerCase().includes(kw.toLowerCase()));

              if (isAIReceiver && !isPostTask) {
                // AI是接收方，且任務不是發帖類型
                systemPrompt += `

💼 **進行中的商業任務**（你是接收方）：
- 任務要求：${taskDesc}
- 任務期限：${ongoingBusinessTransfer.taskDeadlineHours}小時內完成
- 待付尾款：$${remainingAmount}

⚠️ **重要提示**：
- 你需要在對話中自然地發送**圖片消息**（type: "image"）作為完成任務的證明
- 圖片內容應該與任務要求相關，展示你完成了任務
- 發送圖片後，使用者會查看並決定是否支付尾款
- 在發送圖片時，可以配合文本消息說明你完成了什麼
- 不要刻意催促，自然地在對話中展示成果即可
`;
              } else if (isUserReceiver && !isPostTask) {
                // 用戶是接收方，且任務不是發帖類型
                // 檢查使用者是否剛剛發送了圖片
                const userMessages = options.userMessages || [];
                const hasUserImage = userMessages.some(msg => msg.type === 'image');

                if (hasUserImage) {
                  systemPrompt += `

💼 **進行中的商業任務**（用戶是接收方）：
- 任務要求：${taskDesc}
- 任務期限：${ongoingBusinessTransfer.taskDeadlineHours}小時內完成
- 待付尾款：$${remainingAmount}

⚠️ **重要提示**：
- 使用者剛剛發送了圖片，可能是完成任務的證明
- 請識別圖片內容，判斷使用者是否完成了任務要求
- 如果你認為用戶完成了任務：
  1. 先發送1-2條文本消息表達認可和評價
  2. 然後發送轉帳消息支付尾款（amount為${remainingAmount}，note說明是任務尾款，status為"pending"）
- 如果你認為用戶未完成或不符合要求：
  1. 禮貌地指出問題
  2. 可以要求用戶重新提交或補充
  3. 不發送轉帳消息
- 根據完成品質，你可以：
  * 支付全額尾款：$${remainingAmount}
  * 支付部分尾款：$${(parseFloat(remainingAmount) * 0.5).toFixed(2)} - $${(parseFloat(remainingAmount) * 0.8).toFixed(
                    2,
                  )}（如果品質一般）
  * 支付尾款+獎勵：$${(parseFloat(remainingAmount) * 1.1).toFixed(2)} - $${(parseFloat(remainingAmount) * 1.3).toFixed(
                    2,
                  )}（如果超出預期）
`;
                } else {
                  systemPrompt += `

💼 **進行中的商業任務**（用戶是接收方）：
- 任務要求：${taskDesc}
- 任務期限：${ongoingBusinessTransfer.taskDeadlineHours}小時內完成
- 待付尾款：$${remainingAmount}

⚠️ **提示**：
- 使用者需要發送圖片證明完成任務
- 你可以在對話中自然地提醒或詢問任務進度
- 等待用戶發送完成證明後再決定是否支付尾款
`;
                }
              }
            }
          }
        } else if (messageType === 'account') {
          // 帳戶私信
          systemPrompt += `

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 核心任務說明（續寫模式 - 帳戶私信）🎯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
你是X社交平臺的私信對話生成器。用戶剛剛發送了新的私信，請扮演該帳戶主人生成回復。

**對話場景**：
- 📱 這是X社交平臺（類似Twitter/X）的私信功能
- ⚠️ **這是X平臺的私信對話，不是手機短信或其他聊天軟體**

**帳戶信息**：
- 帳戶名：${messageData.user.name}
- 帳戶控制碼：${messageData.user.handle}
- 這是一個已生成的帳戶，有完整的主頁資料、推文和背景資訊

**重要規則**：
- 🚨 只生成帳戶${messageData.user.name}的回復消息，不要生成使用者的消息
- 根據使用者最近發送的消息內容，生成1-10條符合該帳戶特點的自然回復
- 回復要符合該帳戶的身份、風格和在X平臺的形象
- 參考帳戶的主頁資料和最近推文，保持一致性
- 消息類型包括：文本、圖片（image：只需imageDescription和sensitive）、表情包（sticker：只需stickerUrl）、語音、文章連結（link：需要title、description、author、source、body完整正文）、轉發推文、轉發主頁
- ⚠️ 注意：image和sticker是完全不同的類型，不要混淆！link類型是文章連結，需要包含完整的文章內容
- ⚠️ 禁止生成forward類型消息（這是使用者手動轉發產生的）
- 發送者頭像統一使用：https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
        } else {
          // 陌生人私信（將由統一資料獲取系統處理，包括自訂頭像）
          systemPrompt += `

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 核心任務說明（續寫模式 - 陌生人私信）🎯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
你是X社交平臺的私信對話生成器。用戶剛剛發送了新的私信，請生成對方的回復。

**對話場景**：
- 📱 這是X社交平臺（類似Twitter/X）的私信功能
- ⚠️ **這是X平臺的私信對話，不是手機短信或其他聊天軟體**

**私信發送者資訊**：
- 用戶名：${messageData.user.name}
- 用戶控制碼：${messageData.user.handle}

**重要規則**：
- 🚨 只生成對方${messageData.user.name}的回復消息，不要生成使用者的消息
- 根據使用者最近發送的消息內容，生成1-10條自然的回復
- 回復要符合之前對話的語境和對方的性格特點（如果有設定）
- 消息類型包括：文本、圖片（image：只需imageDescription和sensitive）、表情包（sticker：只需stickerUrl）、語音、文章連結（link：需要title、description、author、source、body完整正文）、轉發推文、轉發主頁
- ⚠️ 注意：image和sticker是完全不同的類型，不要混淆！link類型是文章連結，需要包含完整的文章內容
- ⚠️ 禁止生成forward類型消息（這是使用者手動轉發產生的）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
        }
      } else {
        // 初始生成模式
        systemPrompt += `

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 核心任務說明 🎯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
你是X社交平臺的私信對話生成器。請為一場陌生人私信對話生成完整的詳細資訊和消息記錄。

**私信發送者資訊**：
- 用戶名：${messageData.user.name}
- 用戶控制碼：${messageData.user.handle}
- 私信預覽內容：${messageData.preview}
${messageData.link ? `- 附帶連結：${messageData.link}` : ''}
${messageData.attachment ? `- 附帶附件：${messageData.attachment}` : ''}
${messageData.tweetLink ? `- 提及推文：${messageData.tweetLink}` : ''}

**重要規則**：
- 生成發送者的完整X資料（簡介、關注者數量等）
- 生成3-10條私信消息記錄（只包含陌生人發送的消息）
- 消息類型包括：文本、圖片（image：只需imageDescription和sensitive）、表情包（sticker：只需stickerUrl）、語音、連結、轉發推文、轉發主頁
- ⚠️ 注意：image和sticker是完全不同的類型，不要混淆！
- 對話要自然真實，符合陌生人私信的特點
- 發送者頭像統一使用：https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
      }

      const coreTaskSection = systemPrompt.substring(systemPrompt.lastIndexOf('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━'));
      tokenCount = TokenUtils.logTokenUsage('私信詳情生成器', '核心任務說明', coreTaskSection, tokenCount);

      // 3. 使用者資料（包含信用值）
      const userConstraintsStart = systemPrompt.length;

      // 載入錢包資料以獲取信用值
      await loadWalletData();
      const userCreditScore = walletData.creditScore || 100;

      // 根據信用值確定信用等級
      let creditLevel = '';
      let creditDescription = '';
      if (userCreditScore >= 90) {
        creditLevel = '優秀';
        creditDescription = '信譽極佳，值得信賴的合作夥伴';
      } else if (userCreditScore >= 70) {
        creditLevel = '良好';
        creditDescription = '信譽良好，可以放心合作';
      } else if (userCreditScore >= 50) {
        creditLevel = '一般';
        creditDescription = '信譽一般，需要謹慎考慮';
      } else if (userCreditScore >= 30) {
        creditLevel = '較差';
        creditDescription = '信譽較差，合作風險較高';
      } else {
        creditLevel = '極差';
        creditDescription = '信譽極差，不建議合作';
      }

      systemPrompt += `

【使用者X平臺資料】：
- 用戶名：${userXProfileInfo.name}
- 用戶控制碼：${userXProfileInfo.handle}
- 認證狀態：${userXProfileInfo.verified ? '已認證' : '未認證'}
${userXProfileInfo.publicIdentity ? `- 公眾身份：${userXProfileInfo.publicIdentity}` : ''}
${userXProfileInfo.bio ? `- 個人簡介：${userXProfileInfo.bio}` : ''}

【使用者信用等級】：
- 信用值：${userCreditScore}/100
- 信用等級：${creditLevel}
- 信用評價：${creditDescription}

⚠️ **商業轉帳與信用值規則**：
- 💰 **發起商業轉帳**（你雇傭用戶）：
  * 信用值 ≥ 70：正常合作，可以發起任何金額的商業轉帳
  * 信用值 50-69：謹慎合作，建議降低金額或提高定金比例
  * 信用值 30-49：高風險，只在緊急情況下合作，金額不超過50美元
  * 信用值 < 30：極高風險，強烈不建議合作，基本拒絕商業轉帳請求
  
- 📨 **接受商業轉帳**（用戶雇傭你）：
  * 信用值 ≥ 70：可以正常接受商業轉帳
  * 信用值 50-69：可以接受，但要求更高定金比例（至少30%）
  * 信用值 30-49：極少接受，只有任務特別簡單或定金特別高（50%）時才考慮
  * 信用值 < 30：基本拒絕，除非有特殊理由（如老朋友、關係很好等）

- 🎯 **信用值影響**：
  * 高信用值：更容易獲得商業合作機會，金額更高
  * 低信用值：很難獲得商業合作，即使有也是小額任務
  * 你應該根據使用者的信用等級調整你的態度和決策
  * 低信用用戶的合作請求要更加謹慎，可以直接拒絕
`;

      // 4. 用戶最近推文
      if (recentUserTweets.length > 0) {
        systemPrompt += `

【使用者最近推文】（供參考，對話可能涉及這些推文）：
`;
        recentUserTweets.forEach((tweet, index) => {
          systemPrompt += `
${index + 1}. "${tweet.content}"
   - 發佈時間：${tweet.time || '最近'}
   - 互動數據：${tweet.stats?.likes || 0}喜歡，${tweet.stats?.comments || 0}評論
`;
        });
      }

      const userSection = systemPrompt.substring(userConstraintsStart);
      tokenCount = TokenUtils.logTokenUsage('私信詳情生成器', '使用者資料和推文', userSection, tokenCount);

      // 🎯 優化：使用統一資料獲取系統
      // 根據私信類型添加額外的上下文資訊
      if (isContinueMode && messageData.user && messageData.user.handle) {
        const senderInfoStart = systemPrompt.length;

        try {
          // 🎯 核心優化：只需一行代碼獲取所有資料（傳入使用者資料用於身份識別，messageId用於陌生人自訂設置）
          const senderProfile = await StringBuilders.getUnifiedProfile(messageData.user.handle, {
            userProfileInfo: userXProfileInfo,
            messageId: messageData.id, // 傳入messageId以讀取陌生人自訂設置
          });

          if (senderProfile) {
            systemPrompt += `

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━`;

            // 使用格式化工具生成提示詞（已包含用戶身份識別、專屬人設、聊天記憶等資訊）
            systemPrompt += StringBuilders.formatProfileForPrompt(senderProfile, {
              includeType: true,
              includeTweets: true,
              includeRelationships: true,
            });

            // 特定類型的額外資訊
            if (senderProfile.type === 'account') {
              // 帳戶特有：來源上下文
              const ad = senderProfile.accountData;
              if (ad && ad.sourceContext && ad.sourceContext.source) {
                systemPrompt += `
【帳戶生成來源】：
`;
                const ctx = ad.sourceContext;
                if (ctx.source === 'feed') {
                  systemPrompt += `來源：首頁推文
該帳戶曾發佈的內容："${ctx.tweetContent}"
`;
                } else if (ctx.source === 'comment') {
                  systemPrompt += `來源：評論區
該帳戶曾發表的評論："${ctx.commentContent}"
`;
                } else if (ctx.source === 'search') {
                  systemPrompt += `來源：搜索結果
搜索關鍵字："${ctx.searchQuery}"
`;
                } else if (ctx.source === 'dm' || ctx.source === 'dm_quote_profile') {
                  systemPrompt += `來源：私信
${ctx.messagePreview ? `私信預覽："${ctx.messagePreview}"` : ''}
`;
                }
              }
            }

            systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【私信回復要求】：
- 回復必須嚴格符合${senderProfile.name}的${
              senderProfile.type === 'character'
                ? '性格和說話風格'
                : senderProfile.type === 'npc' || senderProfile.type === 'relationshipNpc'
                ? '人設和說話風格'
                : '身份和風格'
            }
- 參考【X平臺私信對話記錄】（上面顯示的當前私信歷史）保持對話連貫性
`;

            // 特定類型的要求
            if (senderProfile.type === 'character') {
              const characterId = senderProfile._characterId;
              const knowsUserIdentity = userXProfileInfo.knownIdentityCharacters.includes(characterId);

              if (knowsUserIdentity) {
                systemPrompt += `- ✅ 該角色知道用戶身份，回復時應該表現出認識使用者
- 可以自然地稱呼用戶、提及共同經歷或瞭解的資訊
- 【其他聊天記憶】僅用於理解角色與用戶的關係和性格，不要直接提及其中的具體對話內容
- 與用戶的互動要符合角色瞭解的使用者資訊
`;
              } else {
                systemPrompt += `- ❌ 該角色不知道使用者身份，必須按照陌生人模式回復
- 不要讓角色猜測、暗示或表現出任何對使用者的認識
- 回復要完全基於當前X平臺私信對話的內容
- 不要使用任何只有認識的人才會知道的資訊或稱呼
`;
              }
            } else if (senderProfile.type === 'account') {
              systemPrompt += `- 參考帳戶的推文內容和互動風格
- 如果有帳戶生成來源資訊，保持與來源內容的一致性
`;
            } else if (senderProfile.type === 'npc') {
              systemPrompt += `- 該帳戶是全域綁定的NPC，按照人設描述進行回復
- 回復要符合NPC的性格特點和發帖習慣
- 可以參考NPC的主頁資訊保持一致性
`;
            } else if (senderProfile.type === 'relationshipNpc') {
              systemPrompt += `- 該帳戶是關係NPC，與角色${senderProfile.relationshipData.ownerCharacterName}有特殊關係
- 回復要體現${senderProfile.relationshipData.relationshipType}的關係特點
- 與用戶的互動按照普通關係進行，不要表現出特殊關係（除非另有說明）
`;
            } else if (senderProfile.type === 'stranger') {
              systemPrompt += `- 該帳戶是陌生人（未綁定），回復應該自然真實
- 按照普通X平臺用戶的特點進行回復
- 如果有自訂頭像或設定，按照設定的風格回復
`;
            }

            systemPrompt += `- ⚠️ **這是X平臺的私信對話，不是手機聊天或其他場景**
- 可以自然地提及最近在X平臺發佈的推文或動態
- 保持在X平臺和私信中的身份一致性
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;

            const senderInfo = systemPrompt.substring(senderInfoStart);
            const typeLabels = {
              character: '角色',
              account: '帳戶',
              npc: '綁定NPC',
              relationshipNpc: '關係NPC',
              stranger: '陌生人',
            };
            tokenCount = TokenUtils.logTokenUsage(
              '私信詳情生成器',
              `${typeLabels[senderProfile.type] || '發送者'}詳細資訊`,
              senderInfo,
              tokenCount,
            );
          }
        } catch (error) {
          console.error('❌ [私信詳情生成器] 讀取發送者資訊失敗:', error);
        }
      }

      // 添加現有對話上下文（續寫模式）
      if (isContinueMode && existingMessages.length > 0) {
        console.log(
          `📝 [私信生成器] 添加對話記錄到提示詞（共 ${existingMessages.length} 條，顯示最近 ${Math.min(
            existingMessages.length,
            100,
          )} 條）`,
        );
        systemPrompt += `

【X平臺私信對話記錄】（當前私信的歷史記錄，供參考，保持連貫性）：
`;
        // 顯示最近的100條消息作為上下文
        const recentMessages = existingMessages.slice(-100);
        recentMessages.forEach((msg, index) => {
          const sender = msg.isOwn ? '用戶' : messageData.user.name;
          let content = '';
          if (msg.type === 'text') {
            content = msg.content;
          } else if (msg.type === 'image') {
            // 使用者發送的圖片（有imageData）或AI發送的圖片（有imageDescription）
            if (msg.isOwn && msg.imageData) {
              content = `[使用者發送了圖片]`;
            } else if (msg.imageDescription) {
              content = `[圖片: ${msg.imageDescription}]`;
            } else {
              content = `[圖片]`;
            }
          } else if (msg.type === 'voice') {
            content = `[語音: ${msg.voiceText}]`;
          } else if (msg.type === 'sticker') {
            // 用戶發送的表情包（有stickerDescription）或AI發送的表情包（有stickerUrl）
            if (msg.isOwn && msg.stickerDescription) {
              content = `[用戶發送的表情包: ${msg.stickerDescription}]`;
            } else if (msg.stickerUrl) {
              content = `[表情包: ${msg.stickerUrl}]`;
            } else {
              content = `[表情包]`;
            }
          } else if (msg.type === 'transfer') {
            // 轉帳消息
            const amount = parseFloat(msg.amount || 0).toFixed(2);
            const note = msg.note ? ` (${msg.note})` : '';
            const direction = msg.isOwn ? '轉出' : '轉入';

            if (msg.isBusiness) {
              // 商業轉帳
              const depositAmount = parseFloat(msg.depositAmount || 0).toFixed(2);
              const remainingAmount = parseFloat(msg.remainingAmount || 0).toFixed(2);
              const taskDesc = msg.taskDescription || '無任務描述';
              const taskDeadline = msg.taskDeadlineHours || 24;
              const depositRatio = msg.depositRatio || 0;
              const taskStatus = msg.taskStatus || 'pending';

              content = `[商業${direction}${note}]\n`;
              content += `總金額: $${amount}\n`;
              content += `定金: $${depositAmount} (${depositRatio}%)\n`;
              content += `尾款: $${remainingAmount}\n`;
              content += `任務要求: ${taskDesc}\n`;
              content += `任務期限: ${taskDeadline}小時內完成\n`;
              content += `當前狀態: ${
                taskStatus === 'pending'
                  ? '待接收'
                  : taskStatus === 'accepted'
                  ? '已接受，進行中'
                  : taskStatus === 'completed'
                  ? '已完成'
                  : taskStatus === 'rejected'
                  ? '已拒絕'
                  : taskStatus
              }`;
            } else {
              // 普通轉帳
              content = `[${direction}: $${amount}${note}]`;
            }
          } else if (msg.type === 'link') {
            // 顯示文章完整資訊
            content = `[文章連結]\n標題：${msg.title}\n簡介：${msg.description || ''}\n作者：${
              msg.author || ''
            }\n來源：${msg.source || ''}\n正文：${msg.body || msg.description || ''}`;
          } else if (msg.type === 'quoteTweet') {
            content = `[轉發推文: ${msg.tweet.content}]`;
          } else if (msg.type === 'quoteProfile') {
            content = `[轉發主頁: ${msg.profile.name}]`;
          } else if (msg.type === 'forward') {
            // 轉發推文或評論，顯示完整上下文
            if (msg.forwardType === 'tweet') {
              content = `[轉發了推文]\n`;
              if (msg.fullContext && msg.fullContext.tweet) {
                const tweet = msg.fullContext.tweet;
                content += `推文作者：${tweet.user?.name || '未知'}\n推文內容：${tweet.content || ''}\n`;
                if (msg.fullContext.comments && msg.fullContext.comments.length > 0) {
                  content += `評論區（${msg.fullContext.comments.length}條評論）：\n`;
                  msg.fullContext.comments.slice(0, 3).forEach((c, i) => {
                    content += `  ${i + 1}. ${c.user?.name || '未知'}: ${c.content || ''}\n`;
                  });
                  if (msg.fullContext.comments.length > 3) {
                    content += `  ...還有${msg.fullContext.comments.length - 3}條評論\n`;
                  }
                }
              } else {
                content += `${msg.forwardContent?.content || ''}`;
              }
            } else if (msg.forwardType === 'comment') {
              content = `[轉發了評論]\n`;
              if (msg.fullContext) {
                if (msg.fullContext.parentTweet) {
                  content += `原推文作者：${msg.fullContext.parentTweet.user?.name || '未知'}\n原推文內容：${
                    msg.fullContext.parentTweet.content || ''
                  }\n\n`;
                }
                if (msg.fullContext.comment) {
                  content += `評論作者：${msg.fullContext.comment.user?.name || '未知'}\n評論內容：${
                    msg.fullContext.comment.content || ''
                  }`;
                }
              } else {
                content += `${msg.forwardContent?.content || ''}`;
              }
            }
          }
          systemPrompt += `
${index + 1}. ${sender}: ${content}
   時間：${msg.time}
`;
        });
        tokenCount = TokenUtils.logTokenUsage(
          '私信詳情生成器',
          '現有對話上下文',
          systemPrompt.substring(systemPrompt.lastIndexOf('【現有對話記錄】')),
          tokenCount,
        );
      }

      if (isContinueMode) {
        // 續寫模式的要求
        systemPrompt += `

【私信回復要求】：
🚨 **核心規則：絕對禁止生成使用者發送的消息！**
- 只生成對方${messageData.user.name}的回復消息，不要生成使用者的消息
- ⚠️ **這是X平臺的私信對話，不是手機短信或其他聊天軟體**
- 根據【X平臺私信對話記錄】和使用者最近的消息，生成1-8條自然的回復
- 回復要符合X平臺私信的語境，保持角色一致性

【消息類型使用原則】（重要！）：
- ⭐ **以文本消息為主**：大部分回復（80-90%）應該是純文字消息（type: "text"）
- 📷 **偶爾使用其他類型**：僅在特定情況下使用其他消息類型（10-20%）：
  * image：當需要分享照片、圖片或視覺內容時
  * voice：當角色特別激動、情緒強烈或不方便打字時
  * sticker：⚠️ **極少使用**（不超過5%）！只在情緒特別強烈且適合用表情包表達時才使用，且必須根據世界書中的表情包描述選擇最符合當前情境的表情包URL，不要重複使用同一個表情包
  * transfer：⚠️ **極少使用，需謹慎！** 分為兩種：
    - 普通轉帳：角色主動送錢、紅包、禮物或感謝等（建議5-30美元，最多不超過50美元）
    - 商業轉帳：需要對方完成任務的付費合作（50-300美元），設置isBusiness為true並填寫任務描述和期限
    - 🚫 **陌生人不要輕易轉帳**：只有關係親密或有明確理由時才考慮轉帳
  * link：當需要分享網頁、文章或連結時
  * quoteTweet：當提及或討論某條推文時
  * quoteProfile：當推薦某個帳戶或介紹某人時
  * forward：⚠️ **禁止AI主動生成**！這是使用者手動轉發推文/評論的消息類型，AI不要生成此類型
- 🚫 **禁止每種類型都使用**：不要為了展示多樣性而強行使用所有消息類型
- ✅ **自然使用**：根據對話內容和情境自然選擇消息類型，不刻意
- 🚫 **禁止連續使用同一表情包**：如果在之前的對話中已經使用過某個表情包URL，就不要再使用，要選擇不同的表情包

【消息類型詳解】：
  * text：純文字消息（最常用，首選）
  * image：圖片消息（只包含imageDescription和sensitive，不需要caption，不要與sticker混淆）
  * voice：語音訊息（包含voiceText和duration）
  * sticker：表情包消息（⚠️ 只包含stickerUrl欄位！必須從世界書中仔細選擇最符合當前情境和情緒的表情包URL，嚴禁重複使用同一個表情包，不要與image類型混淆）
  * transfer：轉帳消息（普通轉帳：包含amount和note；商業轉帳：額外需要isBusiness、taskDescription、taskDeadlineHours、depositRatio）
  * link：文章連結消息（包含title、description、author、source、body完整文章正文，可使用**加粗**和__底線__標記重點）
  * quoteTweet：轉發推文（包含tweet物件）
  * quoteProfile：轉發主頁（包含profile物件）
  * forward：⚠️ **用戶轉發的推文/評論**（AI不要生成此類型，這是用戶手動操作產生的。如果在對話記錄中看到此類型，AI可以根據其中包含的完整推文和評論內容進行回應）
  * system：⚠️ **系統提示消息**（特殊類型，用於以下場景）：
    - 不回復：如果你認為不應該回復使用者（首次對話且內容不吸引人、內容冒犯等），返回空陣列[]
    - 拉黑用戶：如果對話出現嚴重衝突、使用者持續騷擾、或你強烈不想繼續對話，返回拉黑系統提示
    - 解除拉黑：如果之前拉黑了用戶，但用戶通過@或評論等方式道歉/和解，你決定原諒，返回解除拉黑系統提示
    - 暫時離開（僅綁定角色）：如果你臨時有事無法回復，返回離開系統提示

【特殊系統提示消息格式】：

1. 拉黑用戶（適用於嚴重衝突、騷擾等情況）：
{
  "type": "system",
  "systemType": "blocked",
  "content": "對方已將你拉黑",
  "time": "剛剛"
}

2. 解除拉黑（適用於原諒使用者，重新開始對話）：
{
  "type": "system",
  "systemType": "unblocked",
  "content": "對方已解除拉黑",
  "time": "剛剛"
}

3. 暫時離開（⚠️ 僅綁定角色可用，陌生人/帳戶不能使用）：
{
  "type": "system",
  "systemType": "away",
  "content": "對方正在[具體活動]中，暫時無法回復消息",
  "awayDuration": 數字（分鐘，建議30-180分鐘）,
  "time": "剛剛"
}

⚠️ 使用規則：
- **不回復**：直接返回空陣列 []，不需要任何消息
- **拉黑**：只在極端情況下使用（嚴重衝突、持續騷擾、明顯惡意等）
- **解除拉黑**：只在用戶通過其他管道（@、評論等）展現誠意後使用，表示原諒用戶
- **暫時離開**：只有已綁定的角色才能使用，陌生人和帳戶不能使用此功能
- **離開原因示例**：工作、上課、開會、睡覺、運動、吃飯、處理事情等
- **離開時長**：30-180分鐘為宜，不要太短或太長

- 時間使用相對時間（如"剛剛"、"1分鐘前"等）
- 不要包含 isOwn 欄位
`;
      } else {
        // 初始生成模式的要求
        systemPrompt += `

【私信詳細資訊要求】：
- 生成發送者的完整資料：
  * 簡介（bio）：符合其身份和私信主題的個人簡介
  * 關注者數量（followers）：100-2000之間的亂數字
  * 認證狀態（verified）：通常為false

【私信消息記錄要求】：
🚨 **核心規則：絕對禁止生成使用者發送的消息！**
- 只生成陌生人發送給使用者的私信內容，不包含任何使用者的回復
- 生成3-6條消息，全部來自陌生人
- 第一條消息必須是預覽內容："${messageData.preview}"

【消息類型使用原則】（重要！）：
- ⭐ **以文本消息為主**：大部分消息（80-90%）應該是純文字消息（type: "text"）
- 📷 **偶爾使用其他類型**：僅在特定情況下使用其他消息類型（10-20%）：
  * image：當需要分享照片、圖片或視覺內容時
  * voice：當角色特別激動、情緒強烈或不方便打字時
  * sticker：⚠️ **極少使用**（不超過5%）！只在情緒特別強烈且適合用表情包表達時才使用，且必須根據世界書中的表情包描述選擇最符合當前情境的表情包URL，每次使用不同的表情包
  * transfer：⚠️ **極少使用，需謹慎！** 分為兩種：
    - 普通轉帳：角色主動送錢、紅包、禮物或感謝等（建議5-30美元，最多不超過50美元）
    - 商業轉帳：需要對方完成任務的付費合作（50-300美元），設置isBusiness為true並填寫任務描述和期限
    - 🚫 **陌生人不要輕易轉帳**：只有關係親密或有明確理由時才考慮轉帳
  * link：當需要分享文章、新聞或故事時（需包含完整的文章內容：title、description、author、source、body正文）
  * quoteTweet：當提及或討論某條推文時
  * quoteProfile：當推薦某個帳戶或介紹某人時
  * forward：⚠️ **禁止AI主動生成**！這是使用者手動轉發推文/評論的消息類型
- 🚫 **禁止每種類型都使用**：不要為了展示多樣性而強行使用所有消息類型
- ✅ **自然使用**：根據對話內容和情境自然選擇消息類型，不刻意

【消息類型詳解】：
  * text：純文字消息（最常用，首選）
  * image：圖片消息（只包含imageDescription和sensitive，不需要caption，不要與sticker混淆）
  * voice：語音訊息（包含voiceText和duration）
  * sticker：表情包消息（⚠️ 只包含stickerUrl欄位！必須從世界書中仔細選擇最符合當前情境和情緒的表情包URL，每次使用不同的表情包，不要與image類型混淆）
  * transfer：轉帳消息（普通轉帳：包含amount和note；商業轉帳：額外需要isBusiness、taskDescription、taskDeadlineHours、depositRatio）
  * link：連結消息（包含url、title、description）
  * quoteTweet：轉發推文（包含tweet物件）
  * quoteProfile：轉發主頁（包含profile物件）
  * forward：⚠️ **禁止AI生成此類型**（這是用戶手動轉發產生的）

- 時間從最早到最新排列
- 不要包含 isOwn 欄位
`;
      }

      if (isContinueMode) {
        // 續寫模式只返回消息陣列
        systemPrompt += `

【JSON返回格式】：
\`\`\`json
[消息陣列]
\`\`\`
`;
      } else {
        // 初始模式返回完整資料
        systemPrompt += `

【JSON返回格式】：
\`\`\`json
{
  "senderProfile": {
    "bio": "個人簡介",
    "followers": 關注者數量（數字）,
    "verified": false
  },
  "messages": [消息陣列]
}
\`\`\`
`;
      }

      systemPrompt += `

消息物件結構示例：

1. 文本消息：
{
  "type": "text",
  "content": "消息內容",
  "time": "時間描述"
}

2. 圖片消息：
{
  "type": "image",
  "imageDescription": "圖片內容的文字描述",
  "sensitive": false,
  "time": "時間描述"
}

3. 語音訊息：
{
  "type": "voice",
  "voiceText": "先用括弧標注出對聲音的形容，再是語音內容的文字",
  "duration": "時長如0:15",
  "time": "時間描述"
}

4. 表情包消息：
{
  "type": "sticker",
  "stickerUrl": "表情包圖片連結（從世界書中選擇）",
  "time": "時間描述"
}

⚠️ 注意：sticker類型只包含stickerUrl欄位，不要與image類型混淆！

5. 轉帳消息（兩種類型）：

5.1 普通轉帳：
{
  "type": "transfer",
  "amount": 20.00,
  "note": "請你喝咖啡",
  "status": "pending",
  "time": "時間描述"
}

5.2 商業轉帳（適用於合作、接廣告、買水軍等商業場景）：
{
  "type": "transfer",
  "amount": 150.00,
  "note": "合作費用",
  "status": "pending",
  "isBusiness": true,
  "taskDescription": "幫我發一條推文宣傳新產品，需要包含產品特點和購買連結，語氣要自然不刻意",
  "taskDeadlineHours": 24,
  "depositRatio": 20,
  "time": "時間描述"
}

⚠️ 轉帳消息說明：
- amount：轉帳金額，必須是數位類型（不是字串），建議5-30美元（普通轉帳）或50-300美元（商業轉帳）
- note：轉帳備註，可選欄位，用於說明轉帳目的
- status：轉帳狀態，必須是以下之一：
  * "pending"：待處理（預設狀態，用於主動發起轉帳）
  * "accepted"：已接收（用於回應用戶的轉帳請求，表示接受）
  * "rejected"：已拒絕（用於回應用戶的轉帳請求，表示拒絕）
- 🚫 **轉帳需謹慎**：與陌生人對話時不要隨意轉帳，只有關係親密或有明確理由時才考慮

⚠️ 商業轉帳額外欄位（當isBusiness為true時必填）：
- isBusiness：布林值，true表示這是商業轉帳
- taskDescription：任務描述（字串，50-500字），詳細說明需要對方完成的任務，可以是：
  * 發帖宣傳（指定內容、風格、話題標籤等）
  * 轉發推廣（要求轉發特定內容並評論）
  * 買水軍/刷資料（要求點贊、評論、轉發等）
  * 接廣告（要求發佈廣告內容）
  * 其他商業合作任務
- taskDeadlineHours：任務期限（數位，單位：小時），建議12-72小時，必填
- depositRatio：定金比例（數字，0、20、30或50），表示先支付總金額的百分之幾作為定金
  * 0：不支付定金，任務完成後再付款
  * 20：先支付20%作為定金
  * 30：先支付30%作為定金
  * 50：先支付50%作為定金

⚠️ 轉帳使用場景：
- 普通轉帳：關係親密時可以送錢、紅包、禮物、感謝費等（5-30美元）
- 商業轉帳：有明確商業合作需求時的付費任務（50-300美元）
  * AI可以主動發起商業轉帳雇傭使用者，但需要有合理的商業理由和場景
  * AI可以回應用戶的商業轉帳，決定是否接受任務
  * 商業轉帳會顯示任務要求、期限、定金比例等詳細資訊
  * 接收商業轉帳即表示同意完成任務
- 🚫 **陌生人不要輕易轉帳**：初次對話、不熟悉的人基本不應該主動轉帳
- ⚠️ **轉帳需要理由**：不要無緣無故轉帳，要有合理的情境支撐

⚠️ 轉帳回應規則：
- 當使用者發送了待處理(pending)狀態的轉帳給你時，你可以選擇：
  * 發送status為"accepted"的轉帳消息表示接收
    - 普通轉帳：直接收到全款
    - 商業轉帳：收到定金，需要根據任務要求完成任務（如發推文等）
  * 發送status為"rejected"的轉帳消息表示拒絕
  * 你接收或拒絕後會自動生成系統通知，無需額外文本說明
  
⚠️ 商業轉帳處理（重要！）：
- 如果用戶發送了商業轉帳（isBusiness為true），你需要：
  1. 查看taskDescription（任務描述）和taskDeadlineHours（任務期限）
  2. 決定是否接受任務（根據角色性格和任務要求）：
     * accepted：表示接受任務和定金，AI會自動開始執行任務
     * rejected：表示拒絕任務，定金會退回給用戶
  3. 如果接受了包含"發帖"、"發推"等關鍵字的任務，AI會自動在規定時間內發佈推文
  4. 用戶看到推文後，如果滿意會確認完成任務並支付尾款
  5. 接受商業轉帳時，可以在回復消息中表達對任務的理解和態度
  
⚠️ AI主動發起轉帳：
- AI也可以主動發起轉帳（普通或商業），但需要謹慎，不要輕易轉帳
- 🚫 **陌生人場景**：如果是陌生人私信或初次對話，基本不應該主動轉帳
- ✅ **熟人/綁定角色場景**：關係親密時可以考慮小額轉帳（5-30美元），大額需有明確理由
- 轉帳金額要符合情境和角色經濟狀況，普通轉帳建議5-30美元，商業轉帳50-300美元
- 商業轉帳的任務描述要具體明確，符合商業合作的真實場景
- 可以雇傭用戶完成任務（如"幫我發條推文宣傳"、"幫我刷點數據"等），但要有合理的商業理由

6. 連結消息（文章類型）：
{
  "type": "link",
  "url": "文章來源網址（可選）",
  "title": "文章標題",
  "description": "文章簡介/摘要",
  "author": "文章作者",
  "source": "文章來源名稱",
  "body": "文章正文內容（完整的文章內容，可使用**文本**表示加粗重點，使用__文本__表示底線重點）",
  "time": "時間描述"
}

⚠️ 連結消息說明：
- title：文章的標題，應該簡潔有力
- description：文章的簡介或摘要，顯示在私信卡片中
- author：文章作者名稱
- source：文章來源（如"XX日報"、"XX雜誌"等）
- body：完整的文章正文，可以使用markdown格式：
  * 使用**文本**表示加粗重點（會顯示為藍色高亮）
  * 使用__文本__表示底線重點（會顯示為底線）
  * 支援換行，使用\n分段
- url：文章的來源連結（可選，可以不填）
- 文章內容應該真實、有深度，符合分享場景
- 適合分享新聞、評論、故事、學術文章等

7. 轉發推文：
{
  "type": "quoteTweet",
  "tweet": {
    "userName": "推文作者名",
    "userHandle": "@handle",
    "userAvatar": "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg",
    "verified": false,
    "content": "推文內容",
    "time": "推文時間"
  },
  "caption": "轉發時的說明（可選）",
  "time": "時間描述"
}

8. 轉發主頁：
{
  "type": "quoteProfile",
  "profile": {
    "name": "帳戶名",
    "handle": "@handle",
    "avatar": "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg",
    "bio": "個人簡介",
    "followers": 關注者數量（數字）,
    "verified": false
  },
  "caption": "轉發時的說明（可選）",
  "time": "時間描述"
}

9. 轉發推文/評論（forward）：
⚠️ **此類型禁止AI生成！這是使用者手動轉發操作產生的消息類型。**
如果在【X平臺私信對話記錄】中看到此類型消息，說明使用者轉發了推文或評論給你，你可以查看其中的完整內容：
- 轉發推文時，包含完整推文內容和該推文的所有評論區內容
- 轉發評論時，包含評論內容和該評論所屬的推文內容
AI應該根據這些完整的上下文資訊來理解使用者分享的內容並給出回應。

關鍵規則：
1. 🚨 所有消息都來自陌生人，不包含使用者發送的消息
2. verified欄位必須是布林值(true/false)
3. followers和duration中的數位必須是純數位（語音時長是字串格式如"0:15"）
4. 可選欄位不使用時完全省略，不要設為null
5. ⚠️ **圖片消息（image）和表情包消息（sticker）是完全不同的類型**：
   - image類型：只包含imageDescription和sensitive欄位，不要包含caption
   - sticker類型：只包含stickerUrl欄位，是表情包圖片連結
   - 嚴禁混淆這兩種類型！
6. 時間描述使用相對時間（如"剛剛"、"5分鐘前"、"1小時前"等）
7. 所有頭像統一使用：https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg
`;

      const formatSection = systemPrompt.substring(systemPrompt.lastIndexOf('【JSON返回格式】'));
      tokenCount = TokenUtils.logTokenUsage('私信詳情生成器', 'JSON格式要求', formatSection, tokenCount);

      // 構建使用者消息內容（支援圖片識圖）
      let userMessageContent;
      const userMessages = options.userMessages || [];

      if (isAskboxViewed) {
        // 提問箱查看模式：角色主動發起
        userMessageContent = `角色主動發起對話，因為發現使用者查看了TA的提問箱。請生成角色${messageData.user.name}的主動消息。`;
      } else if (userMessages.length > 0) {
        // 續寫模式：檢查使用者最近消息中是否有真實圖片（需要識圖）
        const hasRealImages = userMessages.some(msg => msg.type === 'image' && msg.imageData);

        if (hasRealImages) {
          // 有真實圖片：構建多模態內容陣列
          userMessageContent = [];

          // 添加文字說明
          const textMessages = userMessages.filter(msg => msg.type === 'text');
          const realImageMessages = userMessages.filter(msg => msg.type === 'image' && msg.imageData);
          const textImageMessages = userMessages.filter(
            msg => msg.type === 'image' && msg.imageDescription && !msg.imageData,
          );
          const stickerMessages = userMessages.filter(msg => msg.type === 'sticker');
          const voiceMessages = userMessages.filter(msg => msg.type === 'voice');

          let contentText = '使用者剛剛發送了新消息，請分析並回復：';
          if (textMessages.length > 0) {
            contentText += '\n' + textMessages.map(msg => msg.content).join('\n');
          }
          if (voiceMessages.length > 0) {
            contentText +=
              '\n用戶發送了語音訊息：' +
              voiceMessages.map(msg => `[語音時長${msg.duration}: ${msg.voiceText}]`).join('、');
          }
          if (stickerMessages.length > 0) {
            contentText += '\n用戶發送了表情包：' + stickerMessages.map(msg => msg.stickerDescription).join('、');
          }
          if (textImageMessages.length > 0) {
            contentText +=
              '\n使用者發送了文字圖片描述：' + textImageMessages.map(msg => `"${msg.imageDescription}"`).join('、');
          }
          if (realImageMessages.length > 0) {
            contentText += `\n用戶還發送了${realImageMessages.length}張真實圖片，請識別圖片內容並結合圖片內容給出回復。`;
          }

          userMessageContent.push({ type: 'text', text: contentText });

          // 添加真實圖片（用於識圖）
          realImageMessages.forEach(img => {
            if (img.imageData) {
              userMessageContent.push({
                type: 'image_url',
                image_url: { url: img.imageData },
              });
            }
          });
        } else {
          // 無真實圖片：純文字、表情包、語音和文字圖片
          const textMessages = userMessages.filter(msg => msg.type === 'text');
          const textImageMessages = userMessages.filter(
            msg => msg.type === 'image' && msg.imageDescription && !msg.imageData,
          );
          const stickerMessages = userMessages.filter(msg => msg.type === 'sticker');
          const voiceMessages = userMessages.filter(msg => msg.type === 'voice');

          let contentText = '使用者剛剛發送了新消息，請回復：';
          if (textMessages.length > 0) {
            contentText += '\n' + textMessages.map(msg => msg.content).join('\n');
          }
          if (voiceMessages.length > 0) {
            contentText +=
              '\n用戶發送了語音訊息：' +
              voiceMessages.map(msg => `[語音時長${msg.duration}: ${msg.voiceText}]`).join('、');
          }
          if (stickerMessages.length > 0) {
            contentText += '\n用戶發送了表情包：' + stickerMessages.map(msg => msg.stickerDescription).join('、');
          }
          if (textImageMessages.length > 0) {
            contentText +=
              '\n使用者發送了文字圖片描述：' + textImageMessages.map(msg => `"${msg.imageDescription}"`).join('、');
          }

          userMessageContent = contentText;
        }
      } else {
        // 初始模式
        userMessageContent = '請生成完整的私信對話詳情';
      }

      const messages = [{ role: 'user', content: userMessageContent }];

      // 最終統計
      const contentForLog = Array.isArray(userMessageContent)
        ? userMessageContent.map(c => c.text || '[圖片]').join(' ')
        : userMessageContent;
      TokenUtils.logFinalPrompt('私信詳情生成器', systemPrompt, contentForLog);

      // 判斷API類型並發送請求
      let isGemini = proxyUrl.includes('generativelanguage');
      let response;

      if (isGemini) {
        // Gemini不支援圖片，將圖片轉為文本描述
        const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models';
        const geminiConfig = {
          url: `${GEMINI_API_URL}/${model}:generateContent?key=${getRandomValue(apiKey)}`,
          data: {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              contents: [
                {
                  parts: [
                    {
                      text:
                        systemPrompt +
                        '\n\n' +
                        messages
                          .map(m =>
                            Array.isArray(m.content) ? m.content.map(c => c.text || '[圖片]').join(' ') : m.content,
                          )
                          .join('\n'),
                    },
                  ],
                },
              ],
              generationConfig: {
                temperature: 0.8,
              },
            }),
          },
        };
        response = await fetch(geminiConfig.url, geminiConfig.data);
      } else {
        // OpenAI支援圖片識別
        const openAiPayload = {
          model: model,
          messages: [{ role: 'system', content: systemPrompt }, ...messages],
          temperature: 0.8,
          stream: false,
        };
        response = await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${apiKey}`,
          },
          body: JSON.stringify(openAiPayload),
        });
      }

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(`API錯誤: ${response.status} - ${errorData.error?.message || response.statusText}`);
      }

      const data = await response.json();
      let aiResponseContent;

      if (isGemini) {
        aiResponseContent = getGeminiResponseText(data);
      } else {
        aiResponseContent = data.choices?.[0]?.message?.content || '';
      }

      console.log('AI原始回應:', aiResponseContent);

      // 解析AI返回的JSON資料
      const cleanedResponse = aiResponseContent
        .replace(/```json\s*/i, '')
        .replace(/```\s*$/, '')
        .trim();

      if (!cleanedResponse) {
        throw new Error('AI返回了空的回應內容');
      }

      let conversationData;
      try {
        conversationData = JSON.parse(cleanedResponse);
      } catch (parseError) {
        console.error('JSON解析失敗:', parseError);
        console.error('嘗試解析的內容:', cleanedResponse.substring(0, 500) + '...');
        throw new Error(`AI返回的資料不是有效的JSON格式: ${parseError.message}`);
      }

      if (isContinueMode) {
        // 續寫模式：驗證消息陣列
        if (!Array.isArray(conversationData)) {
          throw new Error('AI返回的資料格式不正確，期望消息陣列');
        }

        // 🔍 檢查是否包含特殊系統提示
        const hasBlockedMessage = conversationData.some(msg => msg.type === 'system' && msg.systemType === 'blocked');
        const hasUnblockedMessage = conversationData.some(
          msg => msg.type === 'system' && msg.systemType === 'unblocked',
        );
        const hasAwayMessage = conversationData.some(msg => msg.type === 'system' && msg.systemType === 'away');

        if (hasBlockedMessage) {
          console.log('⚠️ AI決定拉黑用戶');
        } else if (hasUnblockedMessage) {
          console.log('🎉 AI決定解除拉黑');
        } else if (hasAwayMessage) {
          console.log('⏰ AI暫時離開');
        } else if (conversationData.length === 0) {
          console.log('📭 AI決定不回復');
        } else {
          console.log(`✅ 生成了${conversationData.length}條AI回復`);
        }

        // 直接返回消息陣列（包括空陣列和系統提示）
        return conversationData;
      } else {
        // 初始模式：驗證完整資料格式
        if (
          !conversationData.senderProfile ||
          !conversationData.messages ||
          !Array.isArray(conversationData.messages)
        ) {
          throw new Error('AI返回的資料格式不正確');
        }

        // 為初次生成的每條消息添加timestamp
        conversationData.messages.forEach(msg => {
          if (!msg.timestamp) {
            msg.timestamp = new Date().toISOString();
          }
        });

        // 保存私信對話資料到資料庫
        try {
          // 🔧 多帳戶隔離：包含帳戶ID
          const conversationId = `messageConversation_${currentAccountId || 'main'}_${messageData.id}`;
          await xDb.xAccountProfiles.put({
            handle: conversationId,
            name: 'messageConversation',
            data: conversationData,
            messageId: messageData.id,
            accountId: currentAccountId || 'main', // 添加帳戶ID欄位
            updatedAt: new Date().toISOString(),
          });
          console.log('✅ 私信對話資料已保存到資料庫');
        } catch (saveError) {
          console.error('保存私信對話資料失敗:', saveError);
        }

        return conversationData;
      }
    } catch (error) {
      console.error('生成私信對話詳情失敗:', error);
      showXToast(`生成失敗: ${error.message}`, 'error');
      return null;
    }
  }
  // ▲▲▲ 【主要！！！】第九個情景：私信詳情生成器 ▲▲▲

  //【主要！！！】情景：新推詳情生成器

  // 聊天記憶檢測服務管理
  let chatHistoryDetectionTimer = null;
  let chatHistoryDetectionEnabled = false;
  const DETECTION_INTERVAL = 5 * 60 * 1000; // 5分鐘

  // 開關聊天記憶檢測服務
  window.toggleChatHistoryDetection = async function () {
    chatHistoryDetectionEnabled = !chatHistoryDetectionEnabled;

    const toggle = document.getElementById('chat-history-detection-toggle');
    const circle = toggle.querySelector('.toggle-circle');
    const statusDiv = document.getElementById('chat-history-detection-status');

    if (chatHistoryDetectionEnabled) {
      // 開啟檢測
      toggle.style.backgroundColor = 'var(--x-accent)';
      circle.style.left = '22px';
      statusDiv.style.display = 'block';

      // 立即執行一次檢測
      await runChatHistoryDetection();

      // 啟動計時器
      startChatHistoryDetectionTimer();

      // 保存狀態
      await saveChatHistoryDetectionState(true);

      showXToast('聊天記憶檢測已開啟', 'success');
    } else {
      // 關閉檢測
      toggle.style.backgroundColor = '#333';
      circle.style.left = '2px';
      statusDiv.style.display = 'none';

      // 停止計時器
      if (chatHistoryDetectionTimer) {
        clearInterval(chatHistoryDetectionTimer);
        chatHistoryDetectionTimer = null;
      }

      // 保存狀態
      await saveChatHistoryDetectionState(false);

      showXToast('聊天記憶檢測已關閉', 'info');
    }
  };

  // 啟動計時器
  function startChatHistoryDetectionTimer() {
    if (chatHistoryDetectionTimer) {
      clearInterval(chatHistoryDetectionTimer);
    }

    chatHistoryDetectionTimer = setInterval(async () => {
      await runChatHistoryDetection();
    }, DETECTION_INTERVAL);

    updateNextDetectionTime();
  }

  // 執行檢測
  async function runChatHistoryDetection() {
    try {
      console.log('⏰ [聊天記憶檢測] 開始定時檢測...');
      await detectAndGenerateNewTweetFromChatHistory();
      updateNextDetectionTime();
    } catch (error) {
      console.error('❌ [聊天記憶檢測] 定時檢測失敗:', error);
    }
  }

  // 更新下次檢測時間顯示
  function updateNextDetectionTime() {
    const nextTime = new Date(Date.now() + DETECTION_INTERVAL);
    const timeStr = `${nextTime.getHours().toString().padStart(2, '0')}:${nextTime
      .getMinutes()
      .toString()
      .padStart(2, '0')}`;
    const timeSpan = document.getElementById('next-detection-time');
    if (timeSpan) {
      timeSpan.textContent = timeStr;
    }
  }

  // 保存檢測狀態
  async function saveChatHistoryDetectionState(enabled) {
    try {
      const xDb = getXDB();
      const settingsId = `xSettings_${currentAccountId || 'main'}`;
      const settings = await xDb.xSettings.get(settingsId);

      if (settings) {
        settings.chatHistoryDetectionEnabled = enabled;
        await xDb.xSettings.put(settings);
      }
    } catch (error) {
      console.error('保存檢測狀態失敗:', error);
    }
  }

  // 恢復檢測狀態（在初始化時調用）
  async function restoreChatHistoryDetectionState() {
    try {
      const xDb = getXDB();
      const settingsId = `xSettings_${currentAccountId || 'main'}`;
      const settings = await xDb.xSettings.get(settingsId);

      if (settings && settings.chatHistoryDetectionEnabled) {
        console.log('🔄 [聊天記憶檢測] 檢測到已保存的開啟狀態，正在恢復...');
        // 延遲1秒後啟動，確保UI已載入
        setTimeout(() => {
          const toggle = document.getElementById('chat-history-detection-toggle');
          if (toggle) {
            chatHistoryDetectionEnabled = false; // 先設為false，讓toggle函數切換
            window.toggleChatHistoryDetection();
          }
        }, 1000);
      } else {
        console.log('ℹ️ [聊天記憶檢測] 未檢測到開啟狀態，保持關閉');
      }
    } catch (error) {
      console.error('恢復檢測狀態失敗:', error);
    }
  }

  // 🔧 智慧檢測聊天記憶並生成 New Tweet（檢查所有符合條件的已綁定角色）
  async function detectAndGenerateNewTweetFromChatHistory() {
    try {
      console.log('🔍 [聊天記憶Tweet檢測] 開始檢測其他平臺聊天記憶中的發帖意圖');

      // 1. 獲取已綁定的角色
      const xDb = getXDB();
      const settingsId = `xSettings_${currentAccountId || 'main'}`;
      const xSettings = await xDb.xSettings.get(settingsId);

      if (!xSettings || !xSettings.boundCharacters || xSettings.boundCharacters.length === 0) {
        console.log('⏭️ [聊天記憶Tweet檢測] 沒有綁定角色，跳過');
        return;
      }

      // 2. 獲取使用者身份識別資訊
      const userXProfileInfo = StringBuilders.buildUserXProfileInfo(window.userProfileData);

      // 3. 篩選符合條件的角色（知道用戶身份且有專屬人設）
      const mainDB = getDB();
      const allChats = await mainDB.chats.toArray();
      const allXProfiles = await xDb.xCharacterProfiles.toArray();

      const eligibleCharacters = [];

      for (const charId of xSettings.boundCharacters) {
        // 檢查是否知道用戶身份
        if (!userXProfileInfo.knownIdentityCharacters.includes(charId)) {
          continue;
        }

        // 獲取角色資料
        const character = allChats.find(c => c.id === charId);
        if (!character) continue;

        // 獲取X資料
        const xProfile = allXProfiles.find(p => p.characterId === charId);
        if (!xProfile) continue;

        // 檢查是否有專屬人設
        if (!xProfile.userPersona || !xProfile.userPersona.trim()) {
          console.log(`⏭️ [聊天記憶Tweet檢測] ${character.name}: 未設置專屬用戶人設，跳過`);
          continue;
        }

        // 檢查是否有聊天記憶
        if (!character.history || character.history.length === 0) {
          console.log(`⏭️ [聊天記憶Tweet檢測] ${character.name}: 沒有聊天記憶，跳過`);
          continue;
        }

        eligibleCharacters.push({
          character,
          xProfile,
        });
      }

      console.log(`✅ [聊天記憶Tweet檢測] 找到 ${eligibleCharacters.length} 個符合條件的角色`);

      // 4. 對每個符合條件的角色檢測發帖意圖
      for (const { character, xProfile } of eligibleCharacters) {
        await checkCharacterChatHistoryForTweetIntent(character, xProfile);
      }
    } catch (error) {
      console.error('❌ [聊天記憶Tweet檢測] 失敗:', error);
    }
  }

  // 檢查單個角色的聊天記憶是否有發帖意圖
  async function checkCharacterChatHistoryForTweetIntent(character, xProfile) {
    try {
      console.log(`🔍 [聊天記憶Tweet檢測] 檢查角色: ${character.name}`);

      // 關鍵字清單（與私信檢測相同）
      const postKeywords = [
        '發帖',
        '發推',
        '發推特',
        '發推文',
        '發tweet',
        '發條推',
        '發個帖',
        '發條帖',
        '發個推',
        '發一條',
        '發佈推文',
        '發佈帖子',
        'post',
        'tweet',
        'tweeted',
        'posting',
        'gonna post',
        'will post',
        'going to post',
        'publish',
        'share on x',
        'share on twitter',
        '發到X上',
        '發到推特',
        '發到平臺',
        '分享到X',
        '曬到X',
      ];

      // 檢查最近的聊天記憶（最多檢查最近20條）
      const recentHistory = character.history.slice(-20);
      let foundKeyword = false;
      let keywordIndex = -1;

      for (let i = recentHistory.length - 1; i >= 0; i--) {
        const msg = recentHistory[i];
        // 🔧 只檢測AI角色的消息（role === 'assistant'），用戶無法強制角色發帖
        if (msg.role === 'assistant' && msg.content) {
          const content = msg.content.toLowerCase();
          if (postKeywords.some(keyword => content.includes(keyword.toLowerCase()))) {
            foundKeyword = true;
            keywordIndex = i;
            console.log(`✅ [聊天記憶Tweet檢測] ${character.name} 主動提及發帖: ${msg.content.substring(0, 50)}`);
            break;
          }
        }
      }

      if (!foundKeyword) {
        console.log(`⏭️ [聊天記憶Tweet檢測] ${character.name} 未主動提及發帖`);
        return;
      }

      // 提取上下文（關鍵字消息的前後10條）
      const startIndex = Math.max(0, keywordIndex - 10);
      const endIndex = Math.min(recentHistory.length, keywordIndex + 11);
      const contextHistory = recentHistory.slice(startIndex, endIndex);

      // 轉換聊天記憶格式為私信消息格式
      const contextMessages = contextHistory.map(msg => ({
        type: 'text',
        content: msg.content || '',
        isOwn: msg.role === 'user',
        time: '最近',
      }));

      // 構建 messageData（模擬私信格式）
      const messageData = {
        id: `msg_${character.id}`,
        user: {
          name: xProfile.xName,
          handle: xProfile.xHandle,
          avatar: xProfile.xAvatar,
          verified: xProfile.xVerified || false,
        },
      };

      // 調用AI生成推文內容（複用現有函數）
      const tweetData = await generateTweetFromConversation(messageData, contextMessages);

      if (!tweetData) {
        console.log(`⚠️ [聊天記憶Tweet檢測] ${character.name} 的AI未生成推文內容`);
        return;
      }

      // 創建 New Tweet 通知
      const timestamp = Date.now();
      const newTweetNotification = {
        id: `mention_newtweet_chat_${timestamp}`,
        type: 'newTweet',
        user: messageData.user,
        content: `New Tweet from ${messageData.user.name}`,
        time: '剛剛',
        timestamp: timestamp,
        tweet: tweetData,
      };

      // 保存到 Mentions 資料庫
      const xDb = getXDB();
      const mentionsDataId = `mentions_${currentAccountId || 'main'}`;
      let savedMentions = await xDb.xAccountProfiles.get(mentionsDataId);

      if (!savedMentions) {
        savedMentions = {
          handle: mentionsDataId,
          id: mentionsDataId,
          data: [],
        };
      }

      savedMentions.data.unshift(newTweetNotification);
      await xDb.xAccountProfiles.put(savedMentions);

      console.log(`✅ [聊天記憶Tweet檢測] ${character.name} 的推文通知已生成並保存`);

      // 🆕 將推文添加到發推者的帳戶主頁
      await addTweetToAccountProfile(messageData.user.handle, tweetData);

      // 顯示手機樣式通知
      const isEnglish = currentLanguage === 'en';
      showPhoneNotification({
        title: 'X',
        message: isEnglish
          ? `${messageData.user.name} posted a new tweet based on your conversation!`
          : `${messageData.user.name} 根據你們的對話發佈了新推文！`,
        avatar: messageData.user.avatar,
        leftIcon: 'x',
      });

      // 如果當前在 Mentions 頁面，刷新顯示
      const mentionsPage = document.getElementById('x-notifications-page');
      if (mentionsPage && mentionsPage.style.display === 'flex') {
        await loadNotifications();
      } else {
        // 如果不在通知頁面，顯示提醒點
        showNavNotificationDot('notifications');
      }
    } catch (error) {
      console.error(`❌ [聊天記憶Tweet檢測] 檢查 ${character.name} 失敗:`, error);
    }
  }

  // 智慧檢測並生成 New Tweet 通知（基於私信對話內容）
  async function detectAndGenerateNewTweetNotification(messageData, conversationMessages) {
    try {
      console.log('🔍 [私信Tweet檢測] 開始檢測私信對話中的發帖意圖');

      // 關鍵字清單（中英文）
      const postKeywords = [
        '發帖',
        '發推',
        '發推特',
        '發推文',
        '發tweet',
        '發條推',
        '發個帖',
        '發條帖',
        '發個推',
        '發一條',
        '發佈推文',
        '發佈帖子',
        'post',
        'tweet',
        'tweeted',
        'posting',
        'gonna post',
        'will post',
        'going to post',
        'publish',
        'share on x',
        'share on twitter',
        '發到X上',
        '發到推特',
        '發到平臺',
        '分享到X',
        '曬到X',
      ];

      // 檢查最近的消息中是否包含關鍵字（只檢測對方發送的消息，不檢測使用者消息）
      let foundKeyword = false;
      let keywordMessageIndex = -1;

      for (let i = conversationMessages.length - 1; i >= Math.max(0, conversationMessages.length - 10); i--) {
        const msg = conversationMessages[i];
        // 🔧 只檢測非使用者發送的消息（isOwn === false），使用者無法強制對方發帖
        if (msg.type === 'text' && msg.content && !msg.isOwn) {
          const content = msg.content.toLowerCase();
          if (postKeywords.some(keyword => content.includes(keyword.toLowerCase()))) {
            foundKeyword = true;
            keywordMessageIndex = i;
            console.log('✅ [私信Tweet檢測] 對方主動提及發帖:', msg.content.substring(0, 50));
            break;
          }
        }
      }

      if (!foundKeyword) {
        console.log('⏭️ [私信Tweet檢測] 對方未主動提及發帖，跳過');
        return;
      }

      // 提取上下文（關鍵字消息的前後10條）
      const startIndex = Math.max(0, keywordMessageIndex - 10);
      const endIndex = Math.min(conversationMessages.length, keywordMessageIndex + 11);
      const contextMessages = conversationMessages.slice(startIndex, endIndex);

      console.log(`📝 [私信Tweet檢測] 提取上下文消息: ${contextMessages.length} 條`);

      // 調用AI生成推文內容
      const tweetData = await generateTweetFromConversation(messageData, contextMessages);

      if (!tweetData) {
        console.log('⚠️ [私信Tweet檢測] AI未生成推文內容');
        return;
      }

      // 創建 New Tweet 通知
      const timestamp = Date.now();
      const newTweetNotification = {
        id: `mention_newtweet_dm_${timestamp}`,
        type: 'newTweet',
        user: messageData.user,
        content: `New Tweet from ${messageData.user.name}`,
        time: '剛剛',
        timestamp: timestamp,
        tweet: tweetData, // 完整的推文資料
      };

      // 保存到 Mentions 資料庫
      const xDb = getXDB();
      const mentionsDataId = `mentions_${currentAccountId || 'main'}`;
      let savedMentions = await xDb.xAccountProfiles.get(mentionsDataId);

      if (!savedMentions) {
        savedMentions = {
          handle: mentionsDataId,
          id: mentionsDataId,
          data: [],
        };
      }

      // 添加到開頭
      savedMentions.data.unshift(newTweetNotification);

      await xDb.xAccountProfiles.put(savedMentions);

      console.log('✅ [私信Tweet檢測] 已生成並保存 New Tweet 通知');

      // 🆕 將推文添加到發推者的帳戶主頁
      await addTweetToAccountProfile(messageData.user.handle, tweetData);

      // 顯示手機樣式通知
      const isEnglish = currentLanguage === 'en';
      showPhoneNotification({
        title: 'X',
        message: isEnglish ? `${messageData.user.name} posted a new tweet!` : `${messageData.user.name} 發佈了新推文！`,
        avatar: messageData.user.avatar || 'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg',
        leftIcon: 'x',
      });

      // 如果當前在 Mentions 頁面，刷新顯示
      const mentionsPage = document.getElementById('x-notifications-page');
      if (mentionsPage && mentionsPage.style.display === 'flex') {
        await loadNotifications();
      } else {
        // 如果不在通知頁面，顯示提醒點
        showNavNotificationDot('notifications');
      }
    } catch (error) {
      console.error('❌ [私信Tweet檢測] 失敗:', error);
    }
  }

  // 基於私信對話生成推文內容
  async function generateTweetFromConversation(messageData, contextMessages, options = {}) {
    try {
      const db = getDB();
      const xDb = getXDB();

      // 🎯 提取選項參數
      const isAutoTweet = options.isAutoTweet || false; // 是否為自動發推模式
      const timeSinceLastMessage = options.timeSinceLastMessage || 0; // 距離上次聊天的時間（秒）
      const autoTweetType = options.type || 'character'; // 自動發推類型：character | stranger

      const apiConfig = await db.apiConfig.get('main');
      if (!apiConfig || !apiConfig.proxyUrl || !apiConfig.apiKey || !apiConfig.model) {
        return null;
      }

      const { proxyUrl, apiKey, model } = apiConfig;

      // 判斷私信類型（仿照第九個情景）
      let messageType = 'stranger'; // stranger | character | account
      let characterId = null;
      let accountHandle = null;

      if (messageData.id) {
        if (messageData.id.startsWith('msg_account_')) {
          messageType = 'account';
          // 提取帳戶控制碼
          const parts = messageData.id.split('_');
          if (parts.length > 2) {
            accountHandle = parts[2];
          }
        } else if (messageData.id.startsWith('msg_') && messageData.id !== 'msg_001') {
          messageType = 'character';
          characterId = messageData.id.replace('msg_', '');
        }
      }

      console.log(`📝 [Tweet生成] 消息類型: ${messageType}`, { characterId, accountHandle });

      // 從X設置中讀取配置
      const settingsId = `xSettings_${currentAccountId || 'main'}`;
      const xSettings = await xDb.xSettings.get(settingsId);
      const userPrompt = xSettings?.systemPrompt || '';
      const worldSetting = xSettings?.worldSetting || '';

      // 使用工具函數構建使用者X個人資料資訊
      const userXProfileInfo = StringBuilders.buildUserXProfileInfo(window.userProfileData);

      // 獲取用戶最新的5條推文
      const userTweetsId = `userTweets_${currentAccountId || 'main'}`;
      const userTweetsData = await xDb.xUserTweets.get(userTweetsId);
      const recentUserTweets = userTweetsData?.tweets?.slice(0, 5) || [];

      // Token計數器
      let tokenCount = 0;

      // 0. 時間感知（北京時間）
      const now = new Date();
      const beijingTime = new Date(now.getTime() + 8 * 60 * 60 * 1000); // UTC+8
      const year = beijingTime.getUTCFullYear();
      const month = beijingTime.getUTCMonth() + 1;
      const day = beijingTime.getUTCDate();
      const hours = beijingTime.getUTCHours();
      const minutes = beijingTime.getUTCMinutes();
      const weekdays = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'];
      const weekday = weekdays[beijingTime.getUTCDay()];

      let timeOfDay = '';
      if (hours >= 5 && hours < 9) {
        timeOfDay = '清晨';
      } else if (hours >= 9 && hours < 12) {
        timeOfDay = '上午';
      } else if (hours >= 12 && hours < 14) {
        timeOfDay = '中午';
      } else if (hours >= 14 && hours < 18) {
        timeOfDay = '下午';
      } else if (hours >= 18 && hours < 22) {
        timeOfDay = '晚上';
      } else {
        timeOfDay = '深夜';
      }

      // 1. 基礎系統提示詞 + 世界書
      let systemPrompt = StringBuilders.buildBaseSystemPrompt({
        userPrompt,
        worldSetting,
      });
      tokenCount = TokenUtils.logTokenUsage('Tweet生成器', '基礎系統提示詞', systemPrompt, tokenCount);

      // 1.5. 添加當前時間資訊
      systemPrompt += `

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
⏰ 當前時間資訊 ⏰
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
當前時間（北京時間）：${year}年${month}月${day}日 ${weekday} ${String(hours).padStart(2, '0')}:${String(
        minutes,
      ).padStart(2, '0')}
時段：${timeOfDay}

**請根據當前時間生成符合時間情境的推文**：
- 如果是清晨或上午，推文可以是早安問候、早餐分享、一天計畫等
- 如果是中午，可以是午餐分享、工作進展等
- 如果是下午，可以是下午茶、工作日常、生活感悟等
- 如果是晚上，可以是晚餐、晚間活動、一天總結等
- 如果是深夜，可以是深夜想法、失眠感悟等
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
      tokenCount = TokenUtils.logTokenUsage(
        'Tweet生成器',
        '時間資訊',
        systemPrompt.substring(systemPrompt.lastIndexOf('⏰ 當前時間資訊')),
        tokenCount,
      );

      // 1.5. 獲取適用的世界書內容
      const worldBooksOptions = { boundCharacters: [] };
      if (messageType === 'character' && characterId) {
        worldBooksOptions.boundCharacters = [characterId];
      }

      const worldBooksContent = await StringBuilders.getApplicableWorldBooks('posts', worldBooksOptions);
      if (worldBooksContent) {
        systemPrompt += worldBooksContent;
        tokenCount = TokenUtils.logTokenUsage('Tweet生成器', '世界書內容', worldBooksContent, tokenCount);
      }

      // 2. 核心任務說明
      systemPrompt += `

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 核心任務：基於私信對話生成推文 🎯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
你是X社交平臺的推文生成器。${
        isAutoTweet
          ? `${messageData.user.name} (${messageData.user.handle}) 在後臺自動發佈推文。
🤖 **後臺自動發推模式**：角色根據最近的聊天記錄自主決定發佈推文內容
⏰ **距離上次聊天**: ${Math.floor(timeSinceLastMessage / 60)} 分鐘前（${timeSinceLastMessage} 秒）
📝 **推文重點**: 以刻畫 ${messageData.user.name} 自身為主，可以分享日常、想法、近況等，聊天記錄僅作為靈感參考`
          : `在私信對話中，${messageData.user.name} (${messageData.user.handle}) 提到要發佈推文。`
      }
🚨 **注意：是 ${messageData.user.name} 要發推文，不是用戶本人！**

請根據對話上下文，生成 ${messageData.user.name} 可能會發佈的推文內容。

**對話上下文**（最近的私信對話${isAutoTweet ? '，作為靈感參考' : ''}）：
`;

      // 添加對話記錄
      contextMessages.forEach((msg, index) => {
        const sender = msg.isOwn ? userXProfileInfo.name : messageData.user.name;
        let content = '';
        if (msg.type === 'text') {
          content = msg.content;
        } else if (msg.type === 'image') {
          content = msg.isOwn && msg.imageData ? '[圖片]' : `[圖片: ${msg.imageDescription || ''}]`;
        } else if (msg.type === 'voice') {
          content = `[語音: ${msg.voiceText}]`;
        } else if (msg.type === 'sticker') {
          content = '[表情包]';
        }
        systemPrompt += `
${index + 1}. ${sender}: ${content}`;
      });

      systemPrompt += `

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;

      // 🔥 如果是商業轉帳反水模式，添加特殊說明
      if (messageData._isBusinessBetrayal) {
        systemPrompt += `

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🔥 特殊模式：商業推廣反水 🔥
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🚨 **重要：${messageData.user.name} 決定"反水"，不按照商業任務要求發推文！**

**反水類型（選擇其中一種）**：
1. **揭露型**（40%）：
   - 直接揭露有人花錢讓自己發廣告
   - 例："有人給我錢讓我宣傳XXX，但我覺得這東西真的很一般..."
   - 例："剛收到一個推廣邀約，說實話我用過那玩意兒，不推薦"
   
2. **吐槽型**（30%）：
   - 吐槽任務本身或產品/服務
   - 例："又有人讓我幫忙推廣了，但這次的東西真的...算了不說了"
   - 例："有些推廣真的很無語，明明產品品質那樣還要我說好話"
   
3. **完全不配合型**（20%）：
   - 完全不提任務，發自己想發的內容
   - 例："今天心情不好，不想工作"
   - 例："做自己想做的事比什麼都重要"
   
4. **陰陽怪氣型**（10%）：
   - 表面上完成任務，但用諷刺/暗示的語氣
   - 例："某個'非常好用'的產品（此處省略一萬字）"
   - 例："終於可以體驗到'傳說中'的XXX了呢😊"

**生成要求**：
- 推文必須體現${messageData.user.name}的性格特質
- 根據角色設定選擇合適的反水方式
- 推文要自然，不要太刻意
- 可以保留一定的模糊性，讓讀者自己理解
- stats資料要合理（反水推文可能會有更多討論：comments 20-60, likes 50-200）

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
        tokenCount = TokenUtils.logTokenUsage(
          'Tweet生成器',
          '反水模式說明',
          systemPrompt.substring(systemPrompt.lastIndexOf('🔥 特殊模式')),
          tokenCount,
        );
      }

      const coreTaskSection = systemPrompt.substring(systemPrompt.lastIndexOf('🎯 核心任務'));
      tokenCount = TokenUtils.logTokenUsage('Tweet生成器', '核心任務說明', coreTaskSection, tokenCount);

      // 2.5. 使用者資料資訊
      const userConstraintsStart = systemPrompt.length;
      systemPrompt += `

【使用者X平臺資料】（用於理解對話背景）：
- 用戶名：${userXProfileInfo.name}
- 用戶控制碼：${userXProfileInfo.handle}
- 認證狀態：${userXProfileInfo.verified ? '已認證' : '未認證'}
${userXProfileInfo.publicIdentity ? `- 公眾身份：${userXProfileInfo.publicIdentity}` : ''}
${userXProfileInfo.bio ? `- 個人簡介：${userXProfileInfo.bio}` : ''}
`;

      // 2.6. 用戶最近推文
      if (recentUserTweets.length > 0) {
        systemPrompt += `

【使用者最近推文】（供參考，對話可能涉及這些推文）：
`;
        recentUserTweets.forEach((tweet, index) => {
          systemPrompt += `
${index + 1}. "${tweet.content}"
   - 發佈時間：${tweet.time || '最近'}
   - 互動數據：${tweet.stats?.likes || 0}喜歡，${tweet.stats?.comments || 0}評論
`;
        });
      }

      const userSection = systemPrompt.substring(userConstraintsStart);
      tokenCount = TokenUtils.logTokenUsage('Tweet生成器', '使用者資料和推文', userSection, tokenCount);

      // 3. 使用統一資料獲取工具（大幅簡化代碼）
      const profileInfoStart = systemPrompt.length;

      // 🎯 核心優化：只需一行代碼獲取所有資料（傳入使用者資料用於身份識別）
      console.log(
        `🔍 [Tweet生成] 用戶身份識別列表:`,
        userXProfileInfo.knownIdentityCharacters,
        `角色ID: ${characterId}`,
      );

      const senderProfile = await StringBuilders.getUnifiedProfile(messageData.user.handle, {
        userProfileInfo: userXProfileInfo,
      });

      if (senderProfile) {
        // 🔍 調試日誌：檢查用戶人設讀取
        if (senderProfile.type === 'character') {
          console.log(`🔍 [Tweet生成] 角色知道用戶身份: ${senderProfile.knowsUserIdentity}`);
          console.log(`🔍 [Tweet生成] 角色用戶人設: "${senderProfile.characterData?.userPersona || '無'}"`);
        }

        systemPrompt += `

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━`;

        // 使用格式化工具生成提示詞
        systemPrompt += StringBuilders.formatProfileForPrompt(senderProfile, {
          includeType: true,
          includeTweets: true,
          includeRelationships: true,
        });

        systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

**推文生成要求**：
- 推文內容必須嚴格符合${senderProfile.name}的${senderProfile.type === 'character' ? '性格和說話風格' : '身份和風格'}
${
  isAutoTweet
    ? `- 🎯 **後臺自動發推重點**：推文以刻畫${senderProfile.name}自身為主（日常、想法、近況、感受等）
- 聊天記錄僅作為靈感來源，不要直接提及或暗示與使用者的對話
- 推文應該像${senderProfile.name}的獨立生活動態，而非對話延續
- 可以是：分享心情、吐槽日常、發表觀點、曬照片、記錄生活等
- 時間感：距離上次聊天已過去${Math.floor(timeSinceLastMessage / 60)}分鐘，推文可以反映這段時間的活動`
    : `- 推文要與私信對話內容相關`
}
`;

        // 特定類型的額外要求
        if (senderProfile.type === 'character') {
          systemPrompt += `- 參考角色人設和最近的推文風格\n`;

          // 🔧 使用者身份識別資訊（使用senderProfile中已經計算好的值）
          if (senderProfile.knowsUserIdentity) {
            systemPrompt += `- ✅ 該角色知道用戶身份（${userXProfileInfo.name} / ${userXProfileInfo.handle}），推文中可以自然地@用戶或提及與使用者相關的內容\n`;
            systemPrompt += `- 可以結合對使用者的瞭解生成推文內容\n`;
          } else {
            systemPrompt += `- ❌ 該角色不知道用戶身份，推文不應該直接提及或@用戶\n`;
            systemPrompt += `- 推文內容獨立於使用者，不要暗示認識使用者\n`;
          }
        } else if (senderProfile.type === 'account') {
          systemPrompt += `- 參考帳戶的發帖習慣和平臺形象\n`;
        }

        const profileInfo = systemPrompt.substring(profileInfoStart);
        tokenCount = TokenUtils.logTokenUsage('Tweet生成器', '發送者詳細資訊', profileInfo, tokenCount);
      } else {
        // 備用方案
        systemPrompt += `

**推文生成要求**：
- 推文內容要符合 ${messageData.user.name} 的身份和對話語境
- 推文要與私信對話內容相關
`;
      }

      // 4. 通用要求
      systemPrompt += `
- 內容要自然，像是真實用戶會發佈的推文
- 可以包含情緒、觀點、分享或日常內容
- 字數控制在20-200字之間
- 可以帶emoji表情
- ${isAutoTweet ? '40%' : '30%'}的概率帶圖片（如果合適的話，提供圖片描述）
- stats資料要合理（普通使用者流量：comments 5-30, retweets 10-80, likes 20-150, views 100-2000）
${
  isAutoTweet
    ? `
🎯 **後臺自動發推特別提示**：
- 推文要體現${messageData.user.name}的獨立生活和個性
- 不要讓推文看起來像是在回應某個對話
- 可以發一些與聊天無關的日常內容
- 展現角色在使用者不在場時的生活狀態`
    : ''
}

【JSON返回格式】：
\`\`\`json
{
  "content": "推文文本內容",
  "image": {"type": "description", "content": "圖片描述"} 或 null,
  "time": "剛剛",
  "stats": {
    "comments": 評論數,
    "retweets": 轉發數,
    "likes": 點贊數,
    "views": 流覽數
  },
  "comments": [
    {
      "id": "評論唯一ID（可留空，系統自動生成）",
      "user": {
        "name": "評論者昵稱",
        "handle": "@評論者控制碼",
        "avatar": "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg",
        "verified": false
      },
      "content": "評論文本",
      "time": "時間描述（如'2小時前'）",
      "image": {"type": "description", "content": "圖片文字描述"} (可選，10-20%的評論帶圖),
      "stats": {
        "replies": 回復數,
        "retweets": 轉發數,
        "likes": 點贊數
      }
    }
  ]
}
\`\`\`

關鍵規則：
1. 推文內容要與對話上下文相關
2. 🚨 推文是 ${messageData.user.name} 發佈的，不是 ${userXProfileInfo.name}
3. 符合發佈者的說話風格和身份
4. stats中所有數位必須是純數位，不帶引號
5. image欄位可選，如果不需要圖片就設為null
6. **必須包含2-5條評論**，評論要與推文內容相關且自然
7. 10-20%的評論可以帶圖（image欄位）
8. 評論的stats資料要合理（replies 0-10, retweets 0-20, likes 1-50）
`;

      const formatSection = systemPrompt.substring(systemPrompt.lastIndexOf('【JSON返回格式】'));
      tokenCount = TokenUtils.logTokenUsage('Tweet生成器', 'JSON格式要求', formatSection, tokenCount);

      // 最終統計
      TokenUtils.logFinalPrompt('Tweet生成器', systemPrompt, '請生成推文');

      const messages = [{ role: 'user', content: '請生成推文' }];

      // 發送請求
      let isGemini = proxyUrl.includes('generativelanguage');
      let response;

      if (isGemini) {
        const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models';
        const geminiConfig = {
          url: `${GEMINI_API_URL}/${model}:generateContent?key=${getRandomValue(apiKey)}`,
          data: {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              contents: [
                {
                  parts: [{ text: systemPrompt + '\n\n請生成推文' }],
                },
              ],
              generationConfig: {
                temperature: 0.8,
              },
            }),
          },
        };
        response = await fetch(geminiConfig.url, geminiConfig.data);
      } else {
        const openAiPayload = {
          model: model,
          messages: [{ role: 'system', content: systemPrompt }, ...messages],
          temperature: 0.8,
          stream: false,
        };
        response = await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${apiKey}`,
          },
          body: JSON.stringify(openAiPayload),
        });
      }

      if (!response.ok) {
        throw new Error(`API錯誤: ${response.status}`);
      }

      const data = await response.json();
      let aiResponseContent;

      if (isGemini) {
        aiResponseContent = data.candidates?.[0]?.content?.parts?.[0]?.text || '';
      } else {
        aiResponseContent = data.choices?.[0]?.message?.content || '';
      }

      // 解析JSON
      const cleanedResponse = aiResponseContent
        .replace(/```json\s*/i, '')
        .replace(/```\s*$/, '')
        .trim();

      const tweetData = JSON.parse(cleanedResponse);

      // 添加使用者資訊
      const timestamp = Date.now();
      tweetData.id = `newtweet_${timestamp}`;
      tweetData.user = messageData.user;
      tweetData.timestamp = timestamp;

      // 🔧 刪除AI生成的靜態time欄位，改用timestamp動態計算
      delete tweetData.time;

      // 為評論分配ID和時間戳記
      if (tweetData.comments && tweetData.comments.length > 0) {
        tweetData.comments.forEach((comment, cIndex) => {
          if (!comment.id) {
            comment.id = `newtweet_${timestamp}_c${cIndex}`;
          }
          // 評論時間應該在推文之後
          if (!comment.timestamp) {
            comment.timestamp = timestamp + (5 + Math.random() * 30) * 60 * 1000; // 5-35分鐘後
          }
          // 🔧 刪除AI生成的靜態time欄位，改用timestamp動態計算
          delete comment.time;
        });
      }

      console.log('✅ [Tweet生成] 推文內容已生成:', tweetData);

      return tweetData;
    } catch (error) {
      console.error('❌ [Tweet生成] 失敗:', error);
      return null;
    }
  }

  // ============================================
  // 私信詳情頁面功能
  // ============================================

  // 當前查看的私信會話資料
  let currentMessageConversation = null;

  // 私信多選刪除相關狀態
  let messageMultiSelectMode = false;
  let selectedMessages = new Set();
  let messageLongPressTimer = null;
  let messageLongPressTarget = null;

  // 渲染私信消息項
  function renderMessageItem(message, isOwn = false, messageIndex, isLastInGroup = true, showTime = true) {
    const config = languageConfig[currentLanguage] || languageConfig.zh;

    // 使用索引作為消息ID（簡單且可靠）
    const messageId = messageIndex !== undefined ? `msg_idx_${messageIndex}` : `msg_temp_${Math.random()}`;

    const messageEl = document.createElement('div');
    messageEl.className = 'message-item';
    messageEl.setAttribute('data-message-id', messageId);
    messageEl.setAttribute('data-message-index', messageIndex !== undefined ? messageIndex : -1);
    messageEl.style.cssText = `
      display: flex;
      flex-direction: column;
      align-items: ${isOwn ? 'flex-end' : 'flex-start'};
      margin-bottom: ${isLastInGroup ? '16px' : '4px'};
      position: relative;
      transition: opacity 0.2s;
      opacity: 0;
      transform: translateY(10px);
    `;

    // 如果在多選模式，添加選擇指示器
    if (messageMultiSelectMode) {
      const isSelected = selectedMessages.has(messageId);
      const selectIndicator = document.createElement('div');
      selectIndicator.className = 'message-select-indicator';
      selectIndicator.style.cssText = `
        position: absolute;
        ${isOwn ? 'right: -10px;' : 'left: -10px;'}
        top: 50%;
        transform: translateY(-50%);
        width: 24px;
        height: 24px;
        border-radius: 50%;
        border: 2px solid ${isSelected ? 'var(--x-accent)' : 'var(--x-border-color)'};
        background-color: ${isSelected ? 'var(--x-accent)' : 'var(--x-bg-primary)'};
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        z-index: 10;
      `;

      if (isSelected) {
        selectIndicator.innerHTML = `
          <svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: #fff;">
            <g><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"></path></g>
          </svg>
        `;
      }

      selectIndicator.onclick = e => {
        e.stopPropagation();
        toggleMessageSelection(messageId);
      };

      messageEl.appendChild(selectIndicator);
      messageEl.style.opacity = isSelected ? '0.7' : '1';
    }

    // 添加長按事件監聽（桌面端和移動端）
    let pressTimer = null;

    const startPress = e => {
      if (messageMultiSelectMode) return;
      pressTimer = setTimeout(() => {
        enterMessageMultiSelectMode();
        toggleMessageSelection(messageId);
        // 觸覺回饋（如果支持）
        if (navigator.vibrate) {
          navigator.vibrate(50);
        }
      }, 500);
    };

    const endPress = () => {
      if (pressTimer) {
        clearTimeout(pressTimer);
        pressTimer = null;
      }
    };

    // 移動端觸摸事件
    messageEl.addEventListener('touchstart', startPress);
    messageEl.addEventListener('touchend', endPress);
    messageEl.addEventListener('touchmove', endPress);

    // 桌面端滑鼠事件
    messageEl.addEventListener('mousedown', startPress);
    messageEl.addEventListener('mouseup', endPress);
    messageEl.addEventListener('mouseleave', endPress);

    // 多選模式下點擊切換選擇
    if (messageMultiSelectMode) {
      messageEl.style.cursor = 'pointer';
      messageEl.onclick = () => {
        toggleMessageSelection(messageId);
      };
    }

    // 消息氣泡
    const bubbleEl = document.createElement('div');
    const baseStyle = `
      max-width: 70%;
      border-radius: 18px;
      font-size: 15px;
      line-height: 1.4;
      word-wrap: break-word;
      ${isLastInGroup ? (isOwn ? 'border-bottom-right-radius: 4px;' : 'border-bottom-left-radius: 4px;') : ''}
    `;

    // 判斷消息類型
    if (message.type === 'text') {
      // 文本消息
      bubbleEl.style.cssText =
        baseStyle +
        `
        padding: 12px 16px;
        background-color: ${isOwn ? 'var(--x-accent)' : 'var(--x-bg-secondary)'};
        color: ${isOwn ? '#fff !important' : 'var(--x-text-primary)'};
        width: fit-content;
      `;
      bubbleEl.textContent = message.content;
    } else if (message.type === 'image') {
      // 圖片消息
      bubbleEl.style.cssText =
        baseStyle +
        `
        padding: 0;
        background-color: transparent;
        width: fit-content;
      `;

      const imageContainerId = `img_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      const imageContainer = document.createElement('div');
      imageContainer.id = imageContainerId;
      imageContainer.style.cssText = `
        position: relative;
        border-radius: 12px;
        overflow: hidden;
        ${
          message.imageData
            ? 'background-color: transparent;'
            : 'background-color: rgba(142, 142, 142, 0.15); padding: 16px;'
        }
        max-width: ${message.imageData ? '200px' : '280px'};
      `;

      // 如果有imageData（使用者發送的圖片），顯示實際圖片
      if (message.imageData) {
        const imgEl = document.createElement('img');
        imgEl.src = message.imageData;
        imgEl.style.cssText = `
          max-width: 200px;
          max-height: 200px;
          width: auto;
          height: auto;
          display: block;
          border-radius: 12px;
          cursor: pointer;
        `;
        imgEl.onclick = () => {
          // 點擊圖片放大查看
          window.open(message.imageData, '_blank');
        };
        imageContainer.appendChild(imgEl);
      } else {
        // AI回復的圖片描述
        const descEl = document.createElement('div');
        descEl.style.cssText = `
        color: var(--x-text-primary);
        font-size: 15px;
        line-height: 1.4;
        word-wrap: break-word;
      `;
        descEl.textContent = message.imageDescription || '[圖片]';
        imageContainer.appendChild(descEl);
      }

      // 敏感內容遮罩（仿照推文的處理方式）
      if (message.sensitive) {
        const maskId = `mask_${imageContainerId}`;
        const maskEl = document.createElement('div');
        maskEl.id = maskId;
        maskEl.style.cssText = `
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(0, 0, 0, 0.6);
          backdrop-filter: blur(20px);
          -webkit-backdrop-filter: blur(20px);
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          cursor: pointer;
          z-index: 1;
        `;
        maskEl.innerHTML = `
          <svg viewBox="0 0 24 24" style="width: 32px; height: 32px; fill: #fff; margin-bottom: 8px;">
            <g><path d="M12 15c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm0-4c-.552 0-1 .448-1 1s.448 1 1 1 1-.448 1-1-.448-1-1-1z"></path><path d="M12 5c-7.633 0-9.927 6.617-9.948 6.684L1.946 12l.105.316C2.073 12.383 4.367 19 12 19s9.927-6.617 9.948-6.684l.106-.316-.105-.316C21.927 11.617 19.633 5 12 5zm0 12c-5.351 0-7.424-3.846-7.926-5C4.578 10.842 6.652 7 12 7c5.351 0 7.424 3.846 7.926 5-.504 1.158-2.578 5-7.926 5z"></path></g>
          </svg>
          <div style="color: #fff; font-weight: 600; font-size: 15px; margin-bottom: 4px;">可能含有敏感內容</div>
          <div style="color: rgba(255,255,255,0.8); font-size: 13px;">點擊查看</div>
        `;
        maskEl.onclick = function () {
          this.style.display = 'none';
        };
        imageContainer.appendChild(maskEl);
      }

      bubbleEl.appendChild(imageContainer);
    } else if (message.type === 'voice') {
      // 語音訊息
      bubbleEl.style.cssText =
        baseStyle +
        `
        padding: 10px 14px;
        background-color: ${isOwn ? 'var(--x-accent)' : 'var(--x-bg-secondary)'};
        color: ${isOwn ? '#fff' : 'var(--x-text-primary)'};
        max-width: 180px;
        width: fit-content;
      `;

      const voiceId = `voice_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      bubbleEl.innerHTML = `
        <div id="${voiceId}" style="display: flex; align-items: center; gap: 10px; cursor: pointer; color: ${
        isOwn ? '#fff' : 'var(--x-text-primary)'
      };" onclick="toggleVoiceText('${voiceId}', '${message.voiceText?.replace(/'/g, "\\'")}')">
          <div style="
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background-color: ${isOwn ? 'rgba(255,255,255,0.2)' : 'var(--x-accent)'};
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
          ">
            <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: #fff;">
              <g><path d="M8 5v14l11-7z"></path></g>
            </svg>
          </div>
          <span style="font-weight: 600; color: inherit; font-size: 14px;">${message.duration || '0:05'}</span>
        </div>
      `;
    } else if (message.type === 'sticker') {
      // 表情包消息
      bubbleEl.style.cssText =
        baseStyle +
        `
        padding: 0;
        background-color: transparent;
        width: fit-content;
      `;

      bubbleEl.innerHTML = `
        <div style="
          max-width: 120px;
          border-radius: 8px;
          overflow: hidden;
        ">
          <img src="${message.stickerUrl}" 
            alt="表情包"
            style="
              width: 100%;
              height: auto;
              display: block;
              border-radius: 8px;
            "
            onerror="this.style.display='none'; this.parentElement.innerHTML='<div style=\\'padding: 12px; color: var(--x-text-secondary); text-align: center;\\'>表情包載入失敗</div>';">
        </div>
      `;
    } else if (message.type === 'link') {
      // 連結消息
      bubbleEl.style.cssText =
        baseStyle +
        `
        padding: 0;
        background-color: transparent;
        color: var(--x-text-primary);
        width: fit-content;
      `;

      const linkCardId = `link_card_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

      bubbleEl.innerHTML = `
        <div id="${linkCardId}" style="
          border: 1px solid var(--x-border-color);
            border-radius: 12px;
          overflow: hidden;
          background-color: var(--x-bg-secondary);
          cursor: pointer;
          transition: all 0.2s;
        "
        onmouseover="this.style.backgroundColor='var(--x-bg-hover)'; this.style.borderColor='var(--x-accent)'"
        onmouseout="this.style.backgroundColor='var(--x-bg-secondary)'; this.style.borderColor='var(--x-border-color)'">
          <div style="padding: 12px;">
            <div style="font-weight: 600; margin-bottom: 4px; color: var(--x-text-primary);">
              ${message.title || '連結'}
            </div>
            ${
              message.description
                ? `
              <div style="font-size: 13px; color: var(--x-text-secondary); margin-bottom: 8px;">
                ${message.description}
              </div>
            `
                : ''
            }
            <div style="font-size: 13px; color: var(--x-accent); overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
              ${message.url || '點擊查看文章'}
            </div>
          </div>
        </div>
      `;

      // 添加點擊事件打開文章頁面
      setTimeout(() => {
        const linkCard = document.getElementById(linkCardId);
        if (linkCard) {
          linkCard.onclick = () => {
            openArticlePage({
              title: message.title,
              author: message.author || '佚名',
              source: message.source || message.url || '未知來源',
              body: message.body || message.description || '',
            });
          };
        }
      }, 0);
    } else if (message.type === 'quoteTweet') {
      // 轉發推文
      bubbleEl.style.cssText =
        baseStyle +
        `
        padding: 0;
        background-color: transparent;
        color: var(--x-text-primary);
        width: fit-content;
      `;

      bubbleEl.innerHTML = `
        ${
          message.caption
            ? `
          <div style="
            padding: 12px 16px;
            background-color: ${isOwn ? 'var(--x-accent)' : 'var(--x-bg-secondary)'};
            color: ${isOwn ? '#fff' : 'var(--x-text-primary)'};
            border-radius: 12px;
            margin-bottom: 8px;
            width: fit-content;
          ">${message.caption}</div>
        `
            : ''
        }
        <div style="
          border: 1px solid var(--x-border-color);
          border-radius: 12px;
          padding: 12px;
          background-color: var(--x-bg-secondary);
          width: fit-content;
          max-width: 100%;
        ">
          <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
            <img src="${message.tweet.userAvatar}" style="width: 20px; height: 20px; border-radius: 50%;">
            <span style="font-weight: 600; color: var(--x-text-primary);">${message.tweet.userName}</span>
            ${
              message.tweet.verified
                ? `
              <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: var(--x-accent);">
                <g><path d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.26 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.45 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z"></path></g>
              </svg>
            `
                : ''
            }
            <span style="color: var(--x-text-secondary); font-size: 13px;">${message.tweet.userHandle}</span>
            <span style="color: var(--x-text-secondary); font-size: 13px;">·</span>
            <span style="color: var(--x-text-secondary); font-size: 13px;">${message.tweet.time}</span>
          </div>
          <div style="color: var(--x-text-primary);">${message.tweet.content}</div>
        </div>
      `;
    } else if (message.type === 'quoteProfile') {
      // 轉發主頁
      bubbleEl.style.cssText =
        baseStyle +
        `
        padding: 0;
        background-color: transparent;
        color: var(--x-text-primary);
        width: fit-content;
      `;

      const profileCardId = `profile_card_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

      bubbleEl.innerHTML = `
        ${
          message.caption
            ? `
          <div style="
            padding: 12px 16px;
            background-color: ${isOwn ? 'var(--x-accent)' : 'var(--x-bg-secondary)'};
            color: ${isOwn ? '#fff' : 'var(--x-text-primary)'};
            border-radius: 12px;
            margin-bottom: 8px;
          ">${message.caption}</div>
        `
            : ''
        }
        <div id="${profileCardId}" style="
          border: 1px solid var(--x-border-color);
          border-radius: 12px;
          padding: 16px;
          background-color: var(--x-bg-secondary);
          cursor: pointer;
          transition: background-color 0.2s;
        " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
           onmouseout="this.style.backgroundColor='var(--x-bg-secondary)'">
          <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
            <img src="${message.profile.avatar}" style="width: 48px; height: 48px; border-radius: 50%;">
            <div style="flex: 1;">
              <div style="display: flex; align-items: center; gap: 4px;">
                <span style="font-weight: 700; color: var(--x-text-primary);">${message.profile.name}</span>
                ${
                  message.profile.verified
                    ? `
                  <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: var(--x-accent);">
                    <g><path d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.26 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.45 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z"></path></g>
                  </svg>
                `
                    : ''
                }
              </div>
              <div style="color: var(--x-text-secondary); font-size: 13px;">${message.profile.handle}</div>
            </div>
          </div>
          ${
            message.profile.bio
              ? `
            <div style="color: var(--x-text-primary); margin-bottom: 8px; font-size: 14px;">
              ${message.profile.bio}
            </div>
          `
              : ''
          }
          <div style="color: var(--x-text-secondary); font-size: 13px;">
            ${message.profile.followers} 位關注者
          </div>
        </div>
      `;

      // 添加點擊事件
      setTimeout(() => {
        const profileCard = document.getElementById(profileCardId);
        if (profileCard) {
          profileCard.onclick = () => {
            openAccountProfileFromQuoteProfile(message.profile);
          };
        }
      }, 0);
    } else if (message.type === 'transfer') {
      // 轉帳消息 - 小巧立體的票券設計
      bubbleEl.style.cssText =
        baseStyle +
        `
        padding: 0;
        background-color: transparent;
        width: fit-content;
      `;

      // 獲取當前主題
      const xSocialScreen = document.getElementById('x-social-screen');
      const isLightMode = xSocialScreen && xSocialScreen.classList.contains('x-theme-light');

      // 轉帳方向：用戶發送 vs 用戶接收
      const isUserSending = isOwn;
      const amount = parseFloat(message.amount || 0).toFixed(2);

      // 為轉帳卡片生成唯一ID
      const transferCardId = 'transfer-card-' + (message.timestamp || Date.now());

      // 檢查是否是商業轉帳
      const isBusiness = message.isBusiness === true;

      bubbleEl.innerHTML = `
        <div id="${transferCardId}" style="
          position: relative;
          background-color: ${isLightMode ? '#ffffff' : '#1f1f1f'};
          border-radius: 12px;
          padding: 12px 16px;
          max-width: 200px;
          box-shadow: ${
            isLightMode
              ? '0 2px 8px rgba(0, 0, 0, 0.1), 0 4px 16px rgba(0, 0, 0, 0.06), 0 1px 2px rgba(0, 0, 0, 0.05)'
              : '0 2px 8px rgba(0, 0, 0, 0.3), 0 4px 16px rgba(0, 0, 0, 0.2), 0 1px 2px rgba(255, 255, 255, 0.05)'
          };
          border: 1px solid ${
            isBusiness
              ? isLightMode
                ? 'rgba(29, 155, 240, 0.3)'
                : 'rgba(29, 155, 240, 0.4)'
              : isLightMode
              ? 'rgba(0, 0, 0, 0.06)'
              : 'rgba(255, 255, 255, 0.08)'
          };
          display: flex;
          align-items: center;
          gap: 12px;
          cursor: pointer;
          transition: all 0.2s;
        "
           onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='${
             isLightMode
               ? '0 4px 12px rgba(0, 0, 0, 0.15), 0 6px 20px rgba(0, 0, 0, 0.08), 0 2px 4px rgba(0, 0, 0, 0.06)'
               : '0 4px 12px rgba(0, 0, 0, 0.4), 0 6px 20px rgba(0, 0, 0, 0.3), 0 2px 4px rgba(255, 255, 255, 0.08)'
           }'"
           onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='${
             isLightMode
               ? '0 2px 8px rgba(0, 0, 0, 0.1), 0 4px 16px rgba(0, 0, 0, 0.06), 0 1px 2px rgba(0, 0, 0, 0.05)'
               : '0 2px 8px rgba(0, 0, 0, 0.3), 0 4px 16px rgba(0, 0, 0, 0.2), 0 1px 2px rgba(255, 255, 255, 0.05)'
           }'"
        ">
          ${
            isBusiness
              ? `
          <!-- 商業轉帳標識 -->
          <div style="
            position: absolute;
            top: -4px;
            right: -4px;
            width: 18px;
            height: 18px;
            background-color: var(--x-accent);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
          ">
            <svg viewBox="0 0 24 24" style="width: 10px; height: 10px; fill: #ffffff;">
              <g><path d="M20 6h-3V4c0-1.1-.9-2-2-2H9c-1.1 0-2 .9-2 2v2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zM9 4h6v2H9V4zm11 16H4V8h16v12z"></path><path d="M12 10L14.5 14L17 10L14.5 12L12 10ZM10 10L7.5 12L10 14L7.5 14L10 10Z"></path></g>
            </svg>
          </div>
        `
              : ''
          }

          <!-- 簡潔圓形圖示 -->
          <div style="
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background-color: ${isLightMode ? '#f5f5f5' : '#2d2d2d'};
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
          ">
${getTransferStatusIcon(message.status, isLightMode)}
          </div>

          <!-- 轉帳信息 -->
          <div style="
            display: flex;
            flex-direction: column;
            gap: 2px;
            flex: 1;
            min-width: 0;
          ">
            <div style="
              font-size: 11px;
              font-weight: 500;
              color: ${isLightMode ? '#888888' : '#aaaaaa'};
              text-transform: uppercase;
              letter-spacing: 0.3px;
            ">${isBusiness ? '💼 ' : ''}${getTransferStatusText(message.status, isUserSending)}</div>
            
            <div style="
              font-size: 16px;
              font-weight: 600;
              color: ${isLightMode ? '#1a1a1a' : '#e5e5e5'};
              line-height: 1;
            ">
              ${getTransferAmountText(message.status, isUserSending, amount)}
            </div>
            
            ${
              message.note
                ? `
              <div style="
                font-size: 11px;
                color: ${isLightMode ? '#666666' : '#999999'};
                line-height: 1.2;
                margin-top: 1px;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
              ">${message.note}</div>
            `
                : ''
            }
          </div>

          <!-- 狀態指示 -->
          <div style="
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background-color: ${isBusiness ? 'var(--x-accent)' : isLightMode ? '#666666' : '#999999'};
            flex-shrink: 0;
          "></div>
        </div>
      `;

      // 添加點擊事件監聽器
      setTimeout(() => {
        const transferCard = document.getElementById(transferCardId);
        if (transferCard) {
          transferCard.onclick = () => {
            openTransferDetails(message, isOwn);
          };
        }
      }, 0);
    } else if (message.type === 'system') {
      // 系統通知 - 居中顯示，不同於消息氣泡
      messageEl.style.alignItems = 'center';
      bubbleEl.style.cssText = `
        padding: 8px 16px;
        background-color: var(--x-bg-secondary);
        border-radius: 16px;
        font-size: 13px;
        color: var(--x-text-secondary);
        text-align: center;
        max-width: 80%;
      `;

      bubbleEl.textContent = message.content;
    } else if (message.type === 'forward') {
      // 轉發的推文/評論
      bubbleEl.style.cssText =
        baseStyle +
        `
        padding: 0;
        background-color: transparent;
        color: var(--x-text-primary);
        width: fit-content;
      `;

      const forwardTypeText = message.forwardType === 'tweet' ? '推文' : '評論';

      bubbleEl.innerHTML = `
        <div style="
          border: 1px solid var(--x-border-color);
          border-radius: 12px;
          overflow: hidden;
          background-color: var(--x-bg-secondary);
        ">
          <!-- 轉發標識 -->
          <div style="
            padding: 8px 12px;
            background-color: var(--x-bg-hover);
            border-bottom: 1px solid var(--x-border-color);
            display: flex;
            align-items: center;
            gap: 6px;
          ">
            <svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: var(--x-text-secondary);">
              <g><path d="M4.5 3.88l4.432 4.14-1.364 1.46L5.5 7.55V16c0 1.1.896 2 2 2H13v2H7.5c-2.209 0-4-1.791-4-4V7.55L1.432 9.48.068 8.02 4.5 3.88zM16.5 6H11V4h5.5c2.209 0 4 1.791 4 4v8.45l2.068-1.93 1.364 1.46-4.432 4.14-4.432-4.14 1.364-1.46 2.068 1.93V8c0-1.1-.896-2-2-2z"></path></g>
            </svg>
            <span style="font-size: 12px; color: var(--x-text-secondary);">轉發${forwardTypeText}</span>
          </div>
          
          <!-- 轉發內容 -->
          <div style="padding: 12px;">
            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
              <img src="${message.forwardContent.user.avatar}" style="width: 24px; height: 24px; border-radius: 50%;">
              <div style="display: flex; align-items: center; gap: 4px; flex: 1; min-width: 0;">
                <span style="font-weight: 600; color: var(--x-text-primary); font-size: 14px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                  ${message.forwardContent.user.name}
                </span>
                <span style="color: var(--x-text-secondary); font-size: 13px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                  ${message.forwardContent.user.handle}
                </span>
              </div>
            </div>
            <div style="color: var(--x-text-primary); font-size: 14px; line-height: 1.4; word-wrap: break-word;">
              ${message.forwardContent.content || '無內容'}
            </div>
            ${
              message.forwardContent.image
                ? message.forwardContent.image.type === 'description'
                  ? `
                <div style="margin-top: 8px; background-color: var(--x-bg-primary); border: 1px solid var(--x-border-color); border-radius: 8px; padding: 8px;">
                  <div style="color: var(--x-text-secondary); font-size: 13px;">${message.forwardContent.image.content}</div>
                </div>
              `
                  : `
                <div style="margin-top: 8px; border-radius: 8px; overflow: hidden;">
                  <img src="${message.forwardContent.image.content}" style="max-width: 100%; max-height: 200px; border-radius: 8px;" alt="圖片">
                </div>
              `
                : ''
            }
            ${
              message.forwardContent.time
                ? `
              <div style="color: var(--x-text-secondary); font-size: 12px; margin-top: 8px;">
                ${message.forwardContent.time}
              </div>
            `
                : ''
            }
          </div>
        </div>
      `;
    }

    messageEl.appendChild(bubbleEl);

    // 時間戳記（只在showTime為true且isLastInGroup為true時顯示）
    if (showTime && isLastInGroup) {
      const timestampEl = document.createElement('div');
      timestampEl.style.cssText = `
      font-size: 12px;
      color: var(--x-text-secondary);
      margin-top: 4px;
      padding: 0 4px;
    `;

      // 如果有timestamp，動態計算顯示時間；否則使用靜態time欄位
      if (message.timestamp) {
        timestampEl.textContent = formatMessageTime(message.timestamp);
      } else {
        timestampEl.textContent = message.time || '剛剛';
      }

      messageEl.appendChild(timestampEl);
    }

    return messageEl;
  }

  // 語音轉文字切換
  window.toggleVoiceText = function (voiceId, voiceText) {
    const voiceEl = document.getElementById(voiceId);
    if (!voiceEl) return;

    const isShowingText = voiceEl.getAttribute('data-showing-text') === 'true';

    if (isShowingText) {
      // 切回語音圖示
      voiceEl.innerHTML = voiceEl.getAttribute('data-original-html');
      voiceEl.setAttribute('data-showing-text', 'false');
    } else {
      // 保存原始HTML
      voiceEl.setAttribute('data-original-html', voiceEl.innerHTML);
      // 顯示文字
      voiceEl.innerHTML = `<div style="padding: 4px;">${voiceText}</div>`;
      voiceEl.setAttribute('data-showing-text', 'true');
    }
  };

  // 創建"正在輸入中"氣泡
  function createTypingIndicator() {
    const typingEl = document.createElement('div');
    typingEl.id = 'typing-indicator';
    typingEl.className = 'message-item';
    typingEl.style.cssText = `
      display: flex !important;
      flex-direction: column;
      align-items: flex-start;
      margin-bottom: 16px;
      opacity: 0;
      transform: translateY(10px);
      transition: all 0.3s ease;
      position: relative;
      z-index: 1;
    `;

    const bubbleEl = document.createElement('div');
    bubbleEl.style.cssText = `
      padding: 12px 16px;
      border-radius: 18px;
      border-bottom-left-radius: 4px;
      background-color: var(--x-bg-secondary);
      display: flex;
      align-items: center;
      gap: 5px;
    `;

    // 三個跳動的點
    for (let i = 0; i < 3; i++) {
      const dot = document.createElement('div');
      dot.style.cssText = `
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background-color: var(--x-text-secondary);
        animation: typingBounce 1.4s infinite ease-in-out;
        animation-delay: ${i * 0.2}s;
        flex-shrink: 0;
      `;
      bubbleEl.appendChild(dot);
    }

    typingEl.appendChild(bubbleEl);

    // 添加動畫樣式（如果還沒有）
    if (!document.getElementById('typing-animation-style')) {
      const style = document.createElement('style');
      style.id = 'typing-animation-style';
      style.textContent = `
        @keyframes typingBounce {
          0%, 60%, 100% {
            transform: translateY(0);
            opacity: 0.7;
          }
          30% {
            transform: translateY(-10px);
            opacity: 1;
          }
        }
      `;
      document.head.appendChild(style);
    }

    return typingEl;
  }

  // 顯示"正在輸入中"氣泡
  function showTypingIndicator() {
    console.log('🔵 [正在輸入] 開始顯示氣泡');
    const contentContainer = document.getElementById('message-detail-content');
    if (!contentContainer) {
      console.warn('⚠️ [正在輸入] 找不到消息容器');
      return;
    }

    // 先移除可能存在的舊氣泡
    let oldTypingIndicator = document.getElementById('typing-indicator');
    if (oldTypingIndicator) {
      console.log('⚠️ [正在輸入] 檢測到舊氣泡，先移除');
      oldTypingIndicator.remove();
    }

    // 創建並添加新氣泡
    console.log('✅ [正在輸入] 創建氣泡元素');
    const typingIndicator = createTypingIndicator();
    contentContainer.appendChild(typingIndicator);
    console.log('✅ [正在輸入] 氣泡已添加到DOM', typingIndicator);

    // 觸發動畫（使用 requestAnimationFrame 確保DOM更新後再觸發）
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        if (typingIndicator && typingIndicator.parentNode) {
          typingIndicator.style.opacity = '1';
          typingIndicator.style.transform = 'translateY(0)';
          console.log('✅ [正在輸入] 氣泡動畫已觸發');
        }
      });
    });

    // 滾動到底部
    setTimeout(() => {
      const scrollable = document.getElementById('message-detail-scrollable');
      if (scrollable) {
        scrollable.scrollTo({
          top: scrollable.scrollHeight,
          behavior: 'smooth',
        });
        console.log('✅ [正在輸入] 已滾動到底部');
      }
    }, 100);
  }

  // 隱藏"正在輸入中"氣泡
  function hideTypingIndicator() {
    console.log('🔴 [正在輸入] 開始隱藏氣泡');
    const typingIndicator = document.getElementById('typing-indicator');
    if (!typingIndicator) {
      console.log('⚠️ [正在輸入] 氣泡不存在，無需隱藏');
      return;
    }

    typingIndicator.style.opacity = '0';
    typingIndicator.style.transform = 'translateY(10px)';
    console.log('✅ [正在輸入] 氣泡開始淡出');

    setTimeout(() => {
      if (typingIndicator && typingIndicator.parentNode) {
        typingIndicator.remove();
        console.log('✅ [正在輸入] 氣泡已從DOM移除');
      }
    }, 300);
  }

  // 消息逐條彈出動畫
  async function animateMessagesOneByOne(messageElements, delayBetween = 300) {
    for (let i = 0; i < messageElements.length; i++) {
      const messageEl = messageElements[i];

      // 等待延遲
      await new Promise(resolve => setTimeout(resolve, delayBetween));

      // 觸發動畫
      messageEl.style.transition = 'all 0.3s ease';
      messageEl.style.opacity = '1';
      messageEl.style.transform = 'translateY(0)';

      // 滾動到底部
      const scrollable = document.getElementById('message-detail-scrollable');
      if (scrollable) {
        scrollable.scrollTo({
          top: scrollable.scrollHeight,
          behavior: 'smooth',
        });
      }
    }
  }

  // 分組連續的同方向消息
  function groupMessagesBySender(messages) {
    const groups = [];
    let currentGroup = [];
    let currentIsOwn = null;

    messages.forEach((msg, index) => {
      const isOwn = msg.isOwn === true;

      if (currentIsOwn === null || currentIsOwn === isOwn) {
        // 同一發送者，加入當前組
        currentGroup.push({ message: msg, index });
        currentIsOwn = isOwn;
      } else {
        // 不同發送者，開始新組
        groups.push(currentGroup);
        currentGroup = [{ message: msg, index }];
        currentIsOwn = isOwn;
      }
    });

    // 添加最後一組
    if (currentGroup.length > 0) {
      groups.push(currentGroup);
    }

    return groups;
  }

  // 通用的手機樣式通知彈窗
  function showPhoneNotification(options) {
    const {
      title = '', // 標題
      message = '', // 消息內容
      avatar = null, // 右側頭像URL（可選）
      leftIcon = 'x', // 左側圖示類型: 'x' | 'custom' | null
      leftIconHtml = null, // 自訂左側圖示HTML
      duration = 3000, // 顯示時長（毫秒）
      showTime = true, // 是否顯示時間
    } = options;

    // 移除可能存在的舊通知
    const oldNotification = document.getElementById('phone-notification-popup');
    if (oldNotification) {
      oldNotification.remove();
    }

    // 創建通知容器
    const notification = document.createElement('div');
    notification.id = 'phone-notification-popup';
    notification.style.cssText = `
      position: fixed;
      top: -100px;
      left: 50%;
      transform: translateX(-50%);
      width: 90%;
      max-width: 400px;
      background: var(--x-bg-primary);
      border-radius: 16px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      padding: 12px 16px;
      display: flex;
      align-items: center;
      gap: 12px;
      z-index: 10000;
      transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
      border: 1px solid var(--x-border-color);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
    `;

    // 左側圖示
    if (leftIcon === 'x' || leftIconHtml) {
      const iconContainer = document.createElement('div');
      iconContainer.style.cssText = `
        width: 32px;
        height: 32px;
        background-color: #000;
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
      `;

      if (leftIconHtml) {
        iconContainer.innerHTML = leftIconHtml;
      } else {
        // 默認X Logo
        iconContainer.innerHTML = `
          <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: #fff;">
            <g><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"></path></g>
          </svg>
        `;
      }

      notification.appendChild(iconContainer);
    }

    // 內容區域
    const content = document.createElement('div');
    content.style.cssText = `
      flex: 1;
      min-width: 0;
    `;

    let contentHtml = '';
    if (title) {
      contentHtml += `
        <div style="
          font-size: 13px;
          font-weight: 600;
          color: var(--x-text-primary);
          margin-bottom: 2px;
        ">${title}</div>
      `;
    }
    if (message) {
      contentHtml += `
        <div style="
          font-size: 14px;
          color: var(--x-text-secondary);
          white-space: nowrap;
          overflow: hidden;
          text-overflow: ellipsis;
        ">${message}</div>
      `;
    }
    content.innerHTML = contentHtml;
    notification.appendChild(content);

    // 時間標籤
    if (showTime) {
      const timeLabel = document.createElement('div');
      timeLabel.style.cssText = `
        font-size: 11px;
        color: var(--x-text-secondary);
        position: absolute;
        top: 12px;
        right: ${avatar ? '64px' : '16px'};
      `;
      const now = new Date();
      const hours = now.getHours();
      const minutes = String(now.getMinutes()).padStart(2, '0');
      timeLabel.textContent = `${hours}:${minutes}`;
      notification.appendChild(timeLabel);
    }

    // 右側頭像（可選）
    if (avatar) {
      const avatarEl = document.createElement('img');
      avatarEl.src = avatar;
      avatarEl.style.cssText = `
        width: 40px;
        height: 40px;
        border-radius: 50%;
        object-fit: cover;
        flex-shrink: 0;
      `;
      notification.appendChild(avatarEl);
    }

    // 🔧 添加到 x-social-screen 內部以繼承主題樣式
    const xSocialScreen = document.getElementById('x-social-screen');
    const targetContainer = xSocialScreen || document.body;
    targetContainer.appendChild(notification);

    // 滑入動畫
    requestAnimationFrame(() => {
      notification.style.top = '16px';
    });

    // 自動滑出並移除
    setTimeout(() => {
      notification.style.top = '-100px';
      setTimeout(() => {
        if (notification.parentNode) {
          notification.remove();
        }
      }, 400);
    }, duration);

    // 點擊通知關閉
    notification.onclick = () => {
      notification.style.top = '-100px';
      setTimeout(() => {
        if (notification.parentNode) {
          notification.remove();
        }
      }, 400);
    };
  }

  // 顯示消息回復通知（便捷函數）
  function showMessageNotification(senderName, senderAvatar, messageCount) {
    const isEnglish = currentLanguage === 'en';
    const messageSuffix = isEnglish ? (messageCount > 1 ? ' messages' : ' message') : '條私信';

    showPhoneNotification({
      title: senderName,
      message: isEnglish ? `sent you ${messageCount}${messageSuffix}` : `回復了你 ${messageCount}${messageSuffix}`,
      avatar: senderAvatar,
      leftIcon: 'x',
    });
  }

  // 渲染日期分隔符號
  function renderDateSeparator(date) {
    const separatorEl = document.createElement('div');
    separatorEl.style.cssText = `
      text-align: center;
      margin: 24px 0 16px;
    `;
    separatorEl.innerHTML = `
      <span style="
        font-size: 13px;
        font-weight: 600;
        color: var(--x-text-primary);
        padding: 6px 12px;
        background-color: var(--x-bg-secondary);
        border-radius: 12px;
      ">${date}</span>
    `;
    return separatorEl;
  }

  // ============================================
  // 轉帳功能
  // ============================================

  // 獲取轉帳狀態文字
  function getTransferStatusText(status, isUserSending) {
    if (!status || status === 'pending') {
      return 'PENDING';
    } else if (status === 'accepted') {
      return isUserSending ? 'SENT' : 'RECEIVED';
    } else if (status === 'rejected') {
      return 'REJECTED';
    }
    return 'PENDING';
  }

  // 獲取轉帳金額文字
  function getTransferAmountText(status, isUserSending, amount) {
    if (!status || status === 'pending') {
      return `$${amount}`;
    } else if (status === 'accepted') {
      return `${isUserSending ? '-' : '+'}$${amount}`;
    } else if (status === 'rejected') {
      return `$${amount}`;
    }
    return `$${amount}`;
  }

  // 獲取轉帳狀態圖示
  function getTransferStatusIcon(status, isLightMode) {
    const iconColor = isLightMode ? '#666666' : '#cccccc';

    if (!status || status === 'pending') {
      // 待處理 - 時鐘圖示
      return `
        <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: ${iconColor};">
          <g><path d="M12,2C6.486,2,2,6.486,2,12s4.486,10,10,10s10-4.486,10-10S17.514,2,12,2z M12,20c-4.411,0-8-3.589-8-8 s3.589-8,8-8s8,3.589,8,8S16.411,20,12,20z"></path><path d="M13,7h-2v5.414l3.293,3.293l1.414-1.414L13,11.586V7z"></path></g>
        </svg>
      `;
    } else if (status === 'accepted') {
      // 已接收 - 對勾圖示
      return `
        <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: ${iconColor};">
          <g><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"></path></g>
        </svg>
      `;
    } else if (status === 'rejected') {
      // 已拒絕 - X圖示
      return `
        <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: ${iconColor};">
          <g><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm5 11H7v-2h10v2z"></path></g>
        </svg>
      `;
    }

    // 預設返回時鐘圖示
    return `
      <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: ${iconColor};">
        <g><path d="M12,2C6.486,2,2,6.486,2,12s4.486,10,10,10s10-4.486,10-10S17.514,2,12,2z M12,20c-4.411,0-8-3.589-8-8 s3.589-8,8-8s8,3.589,8,8S16.411,20,12,20z"></path><path d="M13,7h-2v5.414l3.293,3.293l1.414-1.414L13,11.586V7z"></path></g>
      </svg>
    `;
  }

  // ============================================
  // 商業轉帳輔助函數
  // ============================================

  // 保存商業轉帳記錄到資料庫
  async function saveBusinessTransfer(businessTransferData) {
    try {
      const xDb = getXDB();
      const businessTransfersId = `businessTransfers_${currentAccountId || 'main'}`;

      // 獲取現有的商業轉帳列表
      let savedData = await xDb.xAccountProfiles.get(businessTransfersId);

      if (!savedData) {
        savedData = {
          handle: businessTransfersId,
          name: 'businessTransfers',
          accountId: currentAccountId || 'main',
          data: [],
          updatedAt: new Date().toISOString(),
        };
      }

      // 添加新的商業轉帳記錄
      savedData.data.push({
        ...businessTransferData,
        savedAt: new Date().toISOString(),
      });

      // 保存到資料庫
      await xDb.xAccountProfiles.put(savedData);

      console.log('✅ 商業轉帳已保存:', businessTransferData.transferId);
    } catch (error) {
      console.error('❌ 保存商業轉帳失敗:', error);
    }
  }

  // 處理商業轉帳任務
  async function handleBusinessTransferTask(transferMessage, conversationData) {
    try {
      console.log('💼 [商業轉帳] 開始處理任務:', transferMessage.taskDescription);

      // 檢測任務關鍵字
      const postKeywords = [
        '發帖',
        '發推',
        '發推特',
        '發推文',
        '發tweet',
        '發條推',
        '發個帖',
        '發條帖',
        '發個推',
        '發一條',
        '發佈推文',
        '發佈帖子',
        'post',
        'tweet',
        'tweeted',
        'posting',
        'gonna post',
        'will post',
        'going to post',
        'publish',
        'share on x',
        'share on twitter',
        '發到X上',
        '發到推特',
        '發到平臺',
        '分享到X',
        '曬到X',
        '宣傳',
        '推廣',
        '廣告',
      ];

      const taskDesc = transferMessage.taskDescription.toLowerCase();
      const hasPostTask = postKeywords.some(keyword => taskDesc.includes(keyword.toLowerCase()));

      if (!hasPostTask) {
        console.log('⏭️ [商業轉帳] 任務不包含發推關鍵字，跳過');
        return;
      }

      console.log('✅ [商業轉帳] 檢測到發推任務');

      // 80%概率完成任務
      const willComplete = Math.random() < 0.8;

      if (!willComplete) {
        console.log('❌ [商業轉帳] AI決定不完成任務（20%概率）');
        return;
      }

      console.log('✅ [商業轉帳] AI決定完成任務，正在生成推文...');

      // 🎭 檢測是否"反水"（基於角色/帳戶特質）
      const xDb = getXDB();
      let willBetray = false;
      let betrayalReason = '';

      try {
        // 獲取角色/帳戶的詳細資料
        const senderProfile = await StringBuilders.getUnifiedProfile(conversationData.user.handle, {
          userProfileInfo: StringBuilders.buildUserXProfileInfo(window.userProfileData),
        });

        if (senderProfile) {
          // 計算反水概率
          let betrayalChance = 0.1; // 基礎10%

          // 1. 角色類型因素
          if (senderProfile.type === 'character') {
            const cd = senderProfile.characterData;

            // 檢查性格關鍵字
            const aiPersona = (cd.aiPersona || '').toLowerCase();
            const rebelliousKeywords = [
              '叛逆',
              '狡猾',
              '冷漠',
              '自私',
              '腹黑',
              '毒舌',
              '刻薄',
              '傲慢',
              '高傲',
              '不羈',
              '反叛',
              'rebellious',
              'cunning',
              'selfish',
              'cold',
              'arrogant',
              'sarcastic',
            ];

            const hasRebelliousTraits = rebelliousKeywords.some(keyword => aiPersona.includes(keyword));
            if (hasRebelliousTraits) {
              betrayalChance += 0.15;
              betrayalReason = '角色性格叛逆/不友好';
              console.log('🎭 [反水檢測] 角色性格因素 +15%');
            }

            // 檢查與用戶的關係
            if (!senderProfile.knowsUserIdentity) {
              betrayalChance += 0.1;
              betrayalReason += (betrayalReason ? '，' : '') + '不認識使用者';
              console.log('🎭 [反水檢測] 陌生關係 +10%');
            } else if (cd.userPersona) {
              // 檢查用戶人設中的關係描述
              const userPersonaLower = cd.userPersona.toLowerCase();
              const negativeRelationships = [
                '敵人',
                '對手',
                '仇人',
                '討厭',
                '不喜歡',
                '矛盾',
                '競爭',
                'enemy',
                'rival',
                'dislike',
                'hate',
              ];

              const hasBadRelationship = negativeRelationships.some(keyword => userPersonaLower.includes(keyword));
              if (hasBadRelationship) {
                betrayalChance += 0.2;
                betrayalReason += (betrayalReason ? '，' : '') + '與用戶關係不好';
                console.log('🎭 [反水檢測] 負面關係 +20%');
              }
            }
          } else if (senderProfile.type === 'stranger' || senderProfile.type === 'account') {
            // 路人/行銷號更可能反水
            betrayalChance += 0.05;
            betrayalReason = '非綁定角色類型';
            console.log('🎭 [反水檢測] 路人/帳號類型 +5%');
          }

          console.log(`🎭 [反水檢測] 最終反水概率: ${(betrayalChance * 100).toFixed(0)}%`);

          // 判斷是否反水
          willBetray = Math.random() < betrayalChance;

          if (willBetray) {
            console.log(`🔥 [商業轉帳] AI決定反水！原因: ${betrayalReason}`);
          }
        }
      } catch (error) {
        console.error('🎭 [反水檢測] 獲取資料失敗，使用預設概率:', error);
        willBetray = Math.random() < 0.1; // 默認10%
      }

      // 使用現有的推文生成器，傳入任務描述作為上下文
      const contextMessages = [
        {
          type: 'text',
          content: willBetray
            ? `用戶花錢讓我發推廣，但我準備反水揭露這件事或者發負面內容。任務要求：${transferMessage.taskDescription}`
            : `我需要完成一個商業任務：${transferMessage.taskDescription}`,
          isOwn: false,
          time: '最近',
          _isBetrayal: willBetray, // 內部標記
          _betrayalReason: betrayalReason,
        },
      ];

      const messageData = {
        id: conversationData.id,
        user: conversationData.user,
        _isBusinessBetrayal: willBetray, // 傳遞給生成器
      };

      // 調用推文生成器
      const tweetData = await generateTweetFromConversation(messageData, contextMessages);

      if (!tweetData) {
        console.log('⚠️ [商業轉帳] 推文生成失敗');
        return;
      }

      // 創建 New Tweet 通知
      const timestamp = Date.now();
      const newTweetNotification = {
        id: `mention_business_${timestamp}`,
        type: 'newTweet',
        user: conversationData.user,
        content: willBetray
          ? `⚠️ ${conversationData.user.name} 反水了！`
          : `New Tweet from ${conversationData.user.name}`,
        time: '剛剛',
        timestamp: timestamp,
        tweet: tweetData,
        fromBusinessTransfer: true, // 標記來自商業轉帳
        businessTransferId: transferMessage.timestamp,
        isBetrayal: willBetray, // 標記是否反水
        betrayalReason: betrayalReason,
      };

      // 保存到 Mentions 資料庫
      // const xDb = getXDB(); // 已在上面聲明
      const mentionsDataId = `mentions_${currentAccountId || 'main'}`;
      let savedMentions = await xDb.xAccountProfiles.get(mentionsDataId);

      if (!savedMentions) {
        savedMentions = {
          handle: mentionsDataId,
          id: mentionsDataId,
          data: [],
        };
      }

      savedMentions.data.unshift(newTweetNotification);
      await xDb.xAccountProfiles.put(savedMentions);

      // 將推文添加到發推者的帳戶主頁
      await addTweetToAccountProfile(conversationData.user.handle, tweetData);

      console.log(`✅ [商業轉帳] 推文已生成並發佈${willBetray ? '（反水）' : ''}`);

      // 顯示手機樣式通知
      const isEnglish = currentLanguage === 'en';
      showPhoneNotification({
        title: willBetray ? '⚠️ 商業推廣反水' : 'X',
        message: willBetray
          ? isEnglish
            ? `${conversationData.user.name} betrayed and posted a negative tweet!`
            : `${conversationData.user.name} 反水了！發佈了負面/揭露內容`
          : isEnglish
          ? `${conversationData.user.name} completed the business task and posted a tweet!`
          : `${conversationData.user.name} 完成了商業任務並發佈了推文！`,
        avatar: conversationData.user.avatar,
        leftIcon: willBetray ? 'custom' : 'x',
        leftIconHtml: willBetray
          ? `
          <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: #ef4444;">
            <g><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"></path></g>
          </svg>
        `
          : undefined,
      });

      // 如果當前在 Mentions 頁面，刷新顯示
      const mentionsPage = document.getElementById('x-notifications-page');
      if (mentionsPage && mentionsPage.style.display === 'flex') {
        await loadNotifications();
      } else {
        // 顯示提醒點
        showNavNotificationDot('notifications');
      }
    } catch (error) {
      console.error('❌ [商業轉帳] 任務處理失敗:', error);
    }
  }

  // 打開轉帳彈窗
  window.openTransferDialog = function () {
    const dialog = document.getElementById('transfer-dialog');
    if (dialog) {
      dialog.style.display = 'flex';

      // 清空輸入
      const amountInput = document.getElementById('transfer-amount-input');
      const noteInput = document.getElementById('transfer-note-input');
      const counter = document.getElementById('transfer-note-counter');

      if (amountInput) amountInput.value = '';
      if (noteInput) noteInput.value = '';
      if (counter) counter.textContent = '0 / 100';

      // 聚焦到金額輸入框
      setTimeout(() => {
        if (amountInput) amountInput.focus();
      }, 100);
    }
  };

  // 關閉轉帳彈窗
  window.closeTransferDialog = function () {
    const dialog = document.getElementById('transfer-dialog');
    if (dialog) {
      dialog.style.display = 'none';

      // 重置表單到普通轉帳
      setTimeout(() => {
        switchTransferType('normal');

        // 清空所有輸入
        const amountInput = document.getElementById('transfer-amount-input');
        const noteInput = document.getElementById('transfer-note-input');
        const taskDescInput = document.getElementById('transfer-task-description');
        const taskDeadlineInput = document.getElementById('transfer-task-deadline');
        const depositRatioInput = document.getElementById('transfer-deposit-ratio');

        if (amountInput) amountInput.value = '';
        if (noteInput) noteInput.value = '';
        if (taskDescInput) taskDescInput.value = '';
        if (taskDeadlineInput) taskDeadlineInput.value = '24';
        if (depositRatioInput) depositRatioInput.value = '20';

        // 重置計數器
        const noteCounter = document.getElementById('transfer-note-counter');
        const taskCounter = document.getElementById('transfer-task-counter');
        if (noteCounter) noteCounter.textContent = '0 / 100';
        if (taskCounter) taskCounter.textContent = '0 / 500';
      }, 200);
    }
  };

  // 更新轉帳備註字元計數
  window.updateTransferNoteCounter = function () {
    const noteInput = document.getElementById('transfer-note-input');
    const noteCounter = document.getElementById('transfer-note-counter');

    if (noteInput && noteCounter) {
      noteCounter.textContent = `${noteInput.value.length} / 100`;
    }
  };

  // 更新任務描述字元計數
  window.updateTaskDescriptionCounter = function () {
    const taskInput = document.getElementById('transfer-task-description');
    const taskCounter = document.getElementById('transfer-task-counter');

    if (taskInput && taskCounter) {
      taskCounter.textContent = `${taskInput.value.length} / 500`;
    }
  };

  // 切換轉帳類型
  window.switchTransferType = function (type) {
    const normalBtn = document.getElementById('transfer-type-normal-btn');
    const businessBtn = document.getElementById('transfer-type-business-btn');
    const businessSection = document.getElementById('business-transfer-section');

    if (!normalBtn || !businessBtn || !businessSection) return;

    if (type === 'business') {
      // 切換到商業轉帳
      normalBtn.style.backgroundColor = 'transparent';
      normalBtn.style.color = 'var(--x-text-primary)';
      businessBtn.style.backgroundColor = 'var(--x-accent)';
      businessBtn.style.color = '#fff';
      businessSection.style.display = 'block';
    } else {
      // 切換到普通轉帳
      normalBtn.style.backgroundColor = 'var(--x-accent)';
      normalBtn.style.color = '#fff';
      businessBtn.style.backgroundColor = 'transparent';
      businessBtn.style.color = 'var(--x-text-primary)';
      businessSection.style.display = 'none';
    }
  };

  // 發送轉帳
  window.sendTransfer = async function () {
    const amountInput = document.getElementById('transfer-amount-input');
    const noteInput = document.getElementById('transfer-note-input');

    if (!amountInput || !noteInput) return;

    const amount = parseFloat(amountInput.value);
    const note = noteInput.value.trim();

    if (amount <= 0 || amount > 9999999) {
      showXToast('請輸入有效金額（0.01 - 9,999,999）', 'error');
      return;
    }

    // 檢查是否是商業轉帳
    const businessSection = document.getElementById('business-transfer-section');
    const isBusiness = businessSection && businessSection.style.display !== 'none';

    let businessData = null;
    if (isBusiness) {
      // 驗證商業轉帳必填欄位
      const taskDescription = document.getElementById('transfer-task-description')?.value.trim();
      const taskDeadline = document.getElementById('transfer-task-deadline')?.value;
      const depositRatio = parseFloat(document.getElementById('transfer-deposit-ratio')?.value || 20);

      if (!taskDescription) {
        showXToast('請填寫任務描述', 'error');
        return;
      }

      if (!taskDeadline || taskDeadline < 1) {
        showXToast('請設置有效的任務期限', 'error');
        return;
      }

      // 計算定金和尾款
      const depositAmount = (amount * depositRatio) / 100;
      const remainingAmount = amount - depositAmount;
      const deadlineDate = new Date(Date.now() + taskDeadline * 60 * 60 * 1000); // 轉換為毫秒

      businessData = {
        isBusiness: true,
        taskDescription: taskDescription,
        taskDeadline: deadlineDate.toISOString(),
        taskDeadlineHours: parseInt(taskDeadline),
        depositRatio: depositRatio,
        depositAmount: depositAmount.toFixed(2),
        remainingAmount: remainingAmount.toFixed(2),
        taskStatus: 'pending', // pending, in_progress, completed, failed
        taskProgress: 0, // 0-100
      };
    }

    // 檢查錢包餘額
    await loadWalletData();
    if (!walletData.isActivated) {
      showXToast('請先啟動錢包', 'error');
      return;
    }

    const actualDeduction = isBusiness ? parseFloat(businessData.depositAmount) : amount;
    if (walletData.balance < actualDeduction) {
      showXToast('錢包餘額不足', 'error');
      return;
    }

    try {
      // 扣除餘額（商業轉帳只扣定金）
      walletData.balance -= actualDeduction;

      // 添加交易記錄
      const recipientName = currentMessageConversation?.user?.name || '對方';
      const transactionDesc = isBusiness
        ? `商業轉帳給 ${recipientName}（定金 ${businessData.depositRatio}%）${note ? ` - ${note}` : ''}`
        : `轉帳給 ${recipientName}${note ? ` - ${note}` : ''}`;

      const transaction = {
        id: 'transfer_out_' + Date.now(),
        description: transactionDesc,
        amount: -actualDeduction,
        timestamp: new Date().toISOString(),
        type: isBusiness ? 'business_transfer_deposit' : 'transfer_out',
      };

      walletData.transactions.unshift(transaction);

      // 保存錢包資料
      await saveWalletData();

      console.log('💰 錢包餘額已扣除:', actualDeduction, '剩餘餘額:', walletData.balance);

      // 創建轉帳消息物件
      const transferMessage = {
        type: 'transfer',
        amount: amount.toFixed(2),
        note: note || null,
        status: 'pending', // 預設狀態為待接收
        timestamp: new Date().toISOString(),
        isOwn: true,
        ...businessData, // 如果是商業轉帳，添加商業資料
      };

      // 添加到訊息佇列
      userMessageQueue.push(transferMessage);

      // 渲染到介面
      const contentContainer = document.getElementById('message-detail-content');
      if (contentContainer) {
        const messageEl = renderMessageItem(transferMessage, true, undefined, true, true);
        contentContainer.appendChild(messageEl);

        // 動畫顯示
        requestAnimationFrame(() => {
          messageEl.style.opacity = '1';
          messageEl.style.transform = 'translateY(0)';
        });

        // 滾動到底部
        setTimeout(() => {
          const scrollable = document.getElementById('message-detail-scrollable');
          if (scrollable) {
            scrollable.scrollTop = scrollable.scrollHeight;
          }
        }, 100);
      }

      // 保存到資料庫
      saveUserMessageToDB(transferMessage);

      // 如果是商業轉帳，保存到商業轉帳資料庫
      if (isBusiness && currentMessageConversation) {
        // 確保獲取到正確的接收者資訊
        const receiverName =
          currentMessageConversation.user?.name || currentMessageConversation.userName || recipientName;
        const receiverHandle =
          currentMessageConversation.user?.handle || currentMessageConversation.userHandle || 'unknown';
        const receiverAvatar =
          currentMessageConversation.user?.avatar ||
          currentMessageConversation.userAvatar ||
          'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg';

        await saveBusinessTransfer({
          ...transferMessage,
          transferId: transferMessage.timestamp,
          conversationId: currentMessageConversation.id,
          senderName: receiverName,
          senderHandle: receiverHandle,
          senderAvatar: receiverAvatar,
          direction: 'sent', // 發出的商業轉帳
          createdAt: transferMessage.timestamp,
        });
        console.log('💼 商業轉帳已記錄到資料庫（發出方）:', receiverName);
      }

      // 關閉彈窗
      closeTransferDialog();

      console.log('✅ 轉帳消息已發送:', transferMessage);
      const toastMsg = isBusiness
        ? `商業轉帳已發送 (-$${actualDeduction.toFixed(2)} 定金)`
        : `轉帳已發送 (-$${amount.toFixed(2)})`;
      showXToast(toastMsg, 'success');
    } catch (error) {
      console.error('轉帳處理失敗:', error);
      showXToast('轉帳失敗: ' + error.message, 'error');
    }
  };

  // 打開轉帳詳情彈窗
  window.openTransferDetails = function (transferData, isOwn) {
    const modal = document.getElementById('transfer-details-modal');
    const content = document.getElementById('transfer-details-content');

    if (!modal || !content) return;

    // 獲取當前主題
    const xSocialScreen = document.getElementById('x-social-screen');
    const isLightMode = xSocialScreen && xSocialScreen.classList.contains('x-theme-light');

    // 確保商業轉帳的欄位完整
    if (transferData.isBusiness && (!transferData.depositAmount || !transferData.remainingAmount)) {
      const totalAmount = parseFloat(transferData.amount || 0);
      const depositRatio = parseFloat(transferData.depositRatio || 0);

      transferData.depositAmount = ((totalAmount * depositRatio) / 100).toFixed(2);
      transferData.remainingAmount = (totalAmount - parseFloat(transferData.depositAmount)).toFixed(2);

      // 如果沒有任務期限，根據任務期限小時數計算
      if (!transferData.taskDeadline && transferData.taskDeadlineHours) {
        const createdAt = new Date(transferData.timestamp || Date.now());
        const deadlineMs = createdAt.getTime() + parseFloat(transferData.taskDeadlineHours) * 60 * 60 * 1000;
        transferData.taskDeadline = new Date(deadlineMs).toISOString();
      }
    }

    const amount = parseFloat(transferData.amount || 0).toFixed(2);
    const status = transferData.status || 'pending';
    const note = transferData.note || '';
    const time = transferData.time || formatMessageTime(transferData.timestamp);

    // 生成票根樣式的轉帳詳情
    content.innerHTML = renderTransferTicket(transferData, isOwn, isLightMode);

    // 添加按鈕事件監聽器
    const acceptBtn = document.getElementById('accept-transfer-btn');
    const rejectBtn = document.getElementById('reject-transfer-btn');
    const completeTaskBtn = document.getElementById('complete-task-btn');

    if (acceptBtn) {
      acceptBtn.onclick = () => acceptTransfer(transferData.timestamp);
    }
    if (rejectBtn) {
      rejectBtn.onclick = () => rejectTransfer(transferData.timestamp);
    }
    if (completeTaskBtn) {
      completeTaskBtn.onclick = () => completeBusinessTask(transferData.timestamp);
    }

    modal.style.display = 'flex';
  };

  // 關閉轉帳詳情彈窗
  window.closeTransferDetails = function () {
    const modal = document.getElementById('transfer-details-modal');
    if (modal) {
      modal.style.display = 'none';
    }
  };

  // 渲染票根樣式的轉帳詳情
  function renderTransferTicket(transferData, isOwn, isLightMode) {
    const amount = parseFloat(transferData.amount || 0).toFixed(2);
    const status = transferData.status || 'pending';
    const note = transferData.note || '';
    const time = transferData.time || formatMessageTime(transferData.timestamp);

    // 判斷是否是商業轉帳
    const isBusiness = transferData.isBusiness === true;
    const businessData = isBusiness ? transferData : null;

    const isPending = status === 'pending';
    const canUserAction = !isOwn && isPending; // 只有收到的待處理轉帳可以操作

    // 商業轉帳：計算期限剩餘時間
    let deadlineText = '';
    let isExpired = false;
    if (isBusiness && businessData.taskDeadline) {
      const deadline = new Date(businessData.taskDeadline);
      const now = new Date();
      const remainingMs = deadline.getTime() - now.getTime();

      if (remainingMs > 0) {
        const hours = Math.floor(remainingMs / (1000 * 60 * 60));
        const minutes = Math.floor((remainingMs % (1000 * 60 * 60)) / (1000 * 60));
        deadlineText = hours > 0 ? `${hours}小時${minutes}分鐘` : `${minutes}分鐘`;
      } else {
        deadlineText = '已過期';
        isExpired = true;
      }
    }

    // 商業轉帳：顯示定金金額而不是總金額
    const displayAmount = isBusiness ? parseFloat(businessData.depositAmount || 0).toFixed(2) : amount;

    return `
      <div style="
        background-color: ${isLightMode ? '#ffffff' : '#1f1f1f'};
        position: relative;
        overflow: hidden;
        max-height: 80vh;
        display: flex;
        flex-direction: column;
      ">
        <!-- 可滾動內容區域 -->
        <div style="
          flex: 1;
          overflow-y: auto;
          overflow-x: hidden;
      ">
        <!-- 票根上半部分 -->
        <div style="
          padding: 24px 20px 16px;
          background-color: ${isLightMode ? '#ffffff' : '#1f1f1f'};
          position: relative;
        ">
          <!-- 關閉按鈕 -->
          <div onclick="closeTransferDetails()" style="
            position: absolute;
            top: 16px;
            right: 16px;
            cursor: pointer;
            padding: 4px;
            border-radius: 50%;
            transition: background-color 0.2s;
              z-index: 10;
          " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
             onmouseout="this.style.backgroundColor='transparent'">
            <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-text-primary);">
              <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
            </svg>
          </div>

          <!-- 轉帳標題 -->
          <div style="
            text-align: center;
            font-size: 18px;
            font-weight: 700;
            color: ${isLightMode ? '#1a1a1a' : '#e5e5e5'};
            margin-bottom: 8px;
            ">${isBusiness ? '商業轉帳詳情' : '轉帳詳情'}</div>
            
            <!-- 商業轉帳標識 -->
            ${
              isBusiness
                ? `
            <div style="
              text-align: center;
              margin-bottom: 12px;
            ">
              <span style="
                display: inline-block;
                padding: 4px 12px;
                background: linear-gradient(135deg, ${
                  isLightMode ? 'rgba(0, 0, 0, 0.1)' : 'rgba(255, 255, 255, 0.15)'
                } 0%, ${isLightMode ? 'rgba(0, 0, 0, 0.05)' : 'rgba(255, 255, 255, 0.08)'} 100%);
                color: ${isLightMode ? '#1a1a1a' : '#e5e5e5'};
                font-size: 11px;
                font-weight: 600;
                border-radius: 12px;
                letter-spacing: 0.5px;
                border: 1px solid ${isLightMode ? 'rgba(0, 0, 0, 0.15)' : 'rgba(255, 255, 255, 0.2)'};
              ">BUSINESS</span>
            </div>
            `
                : ''
            }
          
          <div style="
            text-align: center;
            font-size: 12px;
            color: ${isLightMode ? '#888888' : '#aaaaaa'};
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 20px;
          ">${getTransferStatusText(status, isOwn)}</div>

          <!-- 轉帳金額 -->
          <div style="
            text-align: center;
            font-size: 32px;
            font-weight: 700;
            color: ${isLightMode ? '#1a1a1a' : '#e5e5e5'};
              margin-bottom: ${isBusiness ? '8px' : '16px'};
          ">
              ${getTransferAmountText(status, isOwn, displayAmount)}
          </div>
            
            <!-- 商業轉帳：定金提示 -->
            ${
              isBusiness
                ? `
            <div style="
              text-align: center;
              font-size: 12px;
              color: ${isLightMode ? '#888888' : '#aaaaaa'};
              margin-bottom: 16px;
            ">定金 ${businessData.depositRatio}%</div>
            `
                : ''
            }

          <!-- 轉帳備註 -->
          ${
            note
              ? `
            <div style="
              text-align: center;
              font-size: 14px;
              color: ${isLightMode ? '#666666' : '#999999'};
              margin-bottom: 16px;
              padding: 8px 16px;
              background-color: ${isLightMode ? '#f5f5f5' : '#2d2d2d'};
              border-radius: 8px;
            ">"${note}"</div>
          `
              : ''
          }

          <!-- Valid Ticket 浮水印 -->
          <div style="
            position: absolute;
            top: 50%;
            right: -40px;
            transform: translateY(-50%) rotate(15deg);
            font-size: 48px;
            color: ${isLightMode ? 'rgba(0, 0, 0, 0.05)' : 'rgba(255, 255, 255, 0.05)'};
            font-weight: 700;
            pointer-events: none;
            white-space: nowrap;
            ">${isBusiness ? 'BUSINESS' : 'TRANSFER'}</div>
        </div>

        <!-- 鋸齒分割線 -->
        <div style="
          height: 20px;
          background: linear-gradient(90deg, 
            ${isLightMode ? '#ffffff' : '#1f1f1f'} 10px,
            transparent 10px,
            transparent 20px,
            ${isLightMode ? '#ffffff' : '#1f1f1f'} 20px
          );
          background-size: 20px 100%;
          position: relative;
        ">
          <div style="
            position: absolute;
            left: -10px;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: rgba(0, 0, 0, 0.5);
          "></div>
          <div style="
            position: absolute;
            right: -10px;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: rgba(0, 0, 0, 0.5);
          "></div>
        </div>

        <!-- 票根下半部分 -->
        <div style="
          padding: 16px 20px 20px;
          background-color: ${isLightMode ? '#ffffff' : '#1f1f1f'};
        ">
            <!-- 商業轉帳：任務資訊區域 -->
            ${
              isBusiness
                ? `
            <div style="
              margin-bottom: 16px;
              padding: 12px;
              background-color: ${isLightMode ? '#f8f9fa' : '#2a2a2a'};
              border: 1px solid ${isLightMode ? '#e1e8ed' : '#38444d'};
              border-radius: 8px;
            ">
              <div style="
                font-size: 12px;
                font-weight: 600;
                color: ${isLightMode ? '#666666' : '#999999'};
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                display: flex;
                align-items: center;
                gap: 6px;
              ">
                <svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: currentColor;">
                  <g><path d="M19 3h-4.18C14.4 1.84 13.3 1 12 1c-1.3 0-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm2 14H7v-2h7v2zm3-4H7v-2h10v2zm0-4H7V7h10v2z"></path></g>
                </svg>
                任務要求
              </div>
              
              <div style="
                font-size: 14px;
                color: ${isLightMode ? '#1a1a1a' : '#e5e5e5'};
                line-height: 1.5;
                margin-bottom: 12px;
                white-space: pre-wrap;
                word-wrap: break-word;
              ">${businessData.taskDescription}</div>
              
              <div style="
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding-top: 8px;
                border-top: 1px solid ${isLightMode ? '#e1e8ed' : '#38444d'};
              ">
                <span style="
                  font-size: 12px;
                  color: ${isLightMode ? '#666666' : '#999999'};
                  display: flex;
                  align-items: center;
                  gap: 4px;
                ">
                  <svg viewBox="0 0 24 24" style="width: 12px; height: 12px; fill: currentColor;">
                    <g><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm.5-13H11v6l5.2 3.2.8-1.3-4.5-2.7V7z"></path></g>
                  </svg>
                  任務期限
                </span>
                <span style="
                  font-size: 13px;
                  font-weight: 600;
                  color: ${isExpired ? '#dc2626' : isLightMode ? '#1a1a1a' : '#e5e5e5'};
                ">${deadlineText}</span>
              </div>
            </div>
            
            <!-- 商業轉帳：金額明細 -->
            <div style="
              margin-bottom: 16px;
              padding: 12px;
              background-color: ${isLightMode ? '#f8f9fa' : '#2a2a2a'};
              border: 1px solid ${isLightMode ? '#e1e8ed' : '#38444d'};
              border-radius: 8px;
            ">
              <div style="
                font-size: 12px;
                font-weight: 600;
                color: ${isLightMode ? '#666666' : '#999999'};
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                display: flex;
                align-items: center;
                gap: 6px;
              ">
                <svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: currentColor;">
                  <g><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm.31-8.86c-1.77-.45-2.34-.94-2.34-1.67 0-.84.79-1.43 2.1-1.43 1.38 0 1.9.66 1.94 1.64h1.71c-.05-1.34-.87-2.57-2.49-2.97V5H10.9v1.69c-1.51.32-2.72 1.3-2.72 2.81 0 1.79 1.49 2.69 3.66 3.21 1.95.46 2.34 1.15 2.34 1.87 0 .53-.39 1.39-2.1 1.39-1.6 0-2.23-.72-2.32-1.64H8.04c.1 1.7 1.36 2.66 2.86 2.97V19h2.34v-1.67c1.52-.29 2.72-1.16 2.73-2.77-.01-2.2-1.9-2.96-3.66-3.42z"></path></g>
                </svg>
                金額明細
              </div>
              
              <div style="
                display: flex;
                justify-content: space-between;
                margin-bottom: 6px;
              ">
                <span style="font-size: 13px; color: ${isLightMode ? '#666666' : '#999999'};">總金額</span>
                <span style="font-size: 13px; color: ${
                  isLightMode ? '#1a1a1a' : '#e5e5e5'
                }; font-weight: 600;">$${amount}</span>
              </div>
              
              <div style="
                display: flex;
                justify-content: space-between;
                margin-bottom: 6px;
              ">
                <span style="font-size: 13px; color: ${isLightMode ? '#666666' : '#999999'};">定金 (${
                    businessData.depositRatio || 0
                  }%)</span>
                <span style="font-size: 13px; color: var(--x-accent); font-weight: 600;">$${parseFloat(
                  businessData.depositAmount || 0,
                ).toFixed(2)}</span>
              </div>
              
              <div style="
                display: flex;
                justify-content: space-between;
                padding-top: 6px;
                border-top: 1px solid ${isLightMode ? '#e1e8ed' : '#38444d'};
              ">
                <span style="font-size: 13px; color: ${isLightMode ? '#666666' : '#999999'};">尾款</span>
                <span style="font-size: 13px; color: ${
                  isLightMode ? '#1a1a1a' : '#e5e5e5'
                }; font-weight: 600;">$${parseFloat(businessData.remainingAmount || 0).toFixed(2)}</span>
              </div>
            </div>
            `
                : ''
            }
            
          <!-- 轉帳信息 -->
          <div style="
            display: flex;
            justify-content: space-between;
            margin-bottom: 12px;
          ">
            <span style="color: ${isLightMode ? '#666666' : '#999999'}; font-size: 13px;">轉帳時間</span>
            <span style="color: ${isLightMode ? '#1a1a1a' : '#e5e5e5'}; font-size: 13px;">${time}</span>
          </div>
          
          <div style="
            display: flex;
            justify-content: space-between;
            margin-bottom: 12px;
          ">
              <span style="color: ${isLightMode ? '#666666' : '#999999'}; font-size: 13px;">${
      isBusiness ? '任務狀態' : '轉帳狀態'
    }</span>
            <span style="color: ${isLightMode ? '#1a1a1a' : '#e5e5e5'}; font-size: 13px;">
              ${status === 'pending' ? '待處理' : status === 'accepted' ? '已完成' : '已拒絕'}
            </span>
          </div>

          <!-- 條碼區域 -->
          <div style="
            text-align: center;
            margin: 16px 0;
            padding: 8px 0;
            border-top: 1px solid ${isLightMode ? '#eeeeee' : '#333333'};
          ">
            <div style="
              font-family: monospace;
              font-size: 24px;
              color: ${isLightMode ? '#1a1a1a' : '#e5e5e5'};
              letter-spacing: 2px;
              margin-bottom: 4px;
            ">||||||||||||| ${Math.random().toString().slice(2, 13)}</div>
            <div style="
              font-size: 11px;
              color: ${isLightMode ? '#888888' : '#aaaaaa'};
              ">${isBusiness ? 'BUSINESS' : 'TRANSFER'} ID: ${
      transferData.timestamp ? new Date(transferData.timestamp).getTime() : Date.now()
    }</div>
            </div>
          </div>
          </div>

        <!-- 操作按鈕（固定在底部） -->
          ${
            canUserAction
              ? `
        <div style="
          padding: 16px 20px;
          background-color: ${isLightMode ? '#ffffff' : '#1f1f1f'};
          border-top: 1px solid ${isLightMode ? '#eeeeee' : '#333333'};
        ">
          ${
            isBusiness
              ? `
          <div style="
            font-size: 12px;
            color: ${isLightMode ? '#888888' : '#aaaaaa'};
            text-align: center;
            margin-bottom: 12px;
            line-height: 1.4;
          ">接收此商業轉帳即表示同意完成任務要求</div>
          `
              : ''
          }
            <div style="
              display: flex;
              gap: 12px;
            ">
              <button id="reject-transfer-btn" style="
                flex: 1;
                padding: 12px;
                border: 1px solid ${isLightMode ? '#dc2626' : '#ef4444'};
                color: ${isLightMode ? '#dc2626' : '#ef4444'};
                background: transparent;
                border-radius: 8px;
                font-size: 14px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.2s;
              " onmouseover="this.style.backgroundColor='${isLightMode ? '#fef2f2' : '#1f1416'}'"
                 onmouseout="this.style.backgroundColor='transparent'">
                拒絕
              </button>
              <button id="accept-transfer-btn" style="
                flex: 1;
                padding: 12px;
                border: none;
                color: #ffffff;
                background: var(--x-accent);
                border-radius: 8px;
                font-size: 14px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.2s;
              " onmouseover="this.style.opacity='0.9'"
                 onmouseout="this.style.opacity='1'">
              ${isBusiness ? '接受任務' : '接收'}
              </button>
          </div>
            </div>
          `
              : ''
          }
        
        ${
          // 用戶發出的已接受商業轉帳：顯示"確認完成任務"按鈕
          isOwn && isBusiness && status === 'accepted' && businessData.taskStatus === 'in_progress'
            ? `
        <div style="
          padding: 16px 20px;
          background-color: ${isLightMode ? '#ffffff' : '#1f1f1f'};
          border-top: 1px solid ${isLightMode ? '#eeeeee' : '#333333'};
        ">
          <div style="
            font-size: 12px;
            color: ${isLightMode ? '#888888' : '#aaaaaa'};
            text-align: center;
            margin-bottom: 12px;
            line-height: 1.4;
          ">驗收任務完成情況，確認後將支付剩餘尾款</div>
          <button id="complete-task-btn" style="
            width: 100%;
            padding: 12px;
            border: 1px solid ${isLightMode ? 'rgba(0, 0, 0, 0.2)' : 'rgba(255, 255, 255, 0.2)'};
            color: ${isLightMode ? '#0f1419' : '#ffffff'};
            background: linear-gradient(135deg, ${
              isLightMode ? 'rgba(0, 0, 0, 0.08)' : 'rgba(255, 255, 255, 0.12)'
            } 0%, ${isLightMode ? 'rgba(0, 0, 0, 0.04)' : 'rgba(255, 255, 255, 0.06)'} 100%);
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
          " onmouseover="this.style.backgroundColor='${
            isLightMode ? 'rgba(0, 0, 0, 0.12)' : 'rgba(255, 255, 255, 0.15)'
          }'"
             onmouseout="this.style.backgroundColor='transparent'">
            <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: currentColor;">
              <g><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"></path></g>
            </svg>
            確認完成任務並支付尾款 ($${businessData.remainingAmount})
          </button>
        </div>
        `
            : ''
        }
      </div>
    `;
  }

  // 接收轉帳
  window.acceptTransfer = async function (transferId) {
    try {
      // 查找轉帳消息並更新狀態
      const xDb = getXDB();
      const conversationId = `messageConversation_${currentAccountId || 'main'}_${currentMessageConversation.id}`;
      const savedConversation = await xDb.xAccountProfiles.get(conversationId);

      if (savedConversation && savedConversation.data && savedConversation.data.messages) {
        const transferMessage = savedConversation.data.messages.find(
          msg => msg.type === 'transfer' && msg.timestamp === transferId,
        );

        if (transferMessage) {
          const totalAmount = parseFloat(transferMessage.amount);
          const isBusiness = transferMessage.isBusiness === true;

          // 商業轉帳：計算定金金額
          let receivedAmount = totalAmount;
          if (isBusiness) {
            // 如果有depositAmount欄位，使用它；否則根據depositRatio計算
            if (transferMessage.depositAmount !== undefined) {
              receivedAmount = parseFloat(transferMessage.depositAmount);
            } else {
              const depositRatio = parseFloat(transferMessage.depositRatio) || 20;
              receivedAmount = (totalAmount * depositRatio) / 100;
              // 計算並保存到消息物件中
              transferMessage.depositAmount = receivedAmount.toFixed(2);
              transferMessage.remainingAmount = (totalAmount - receivedAmount).toFixed(2);
            }
          }

          // 更新轉帳狀態
          transferMessage.status = 'accepted';

          // 商業轉帳：更新任務狀態
          if (isBusiness) {
            transferMessage.taskStatus = 'in_progress'; // 任務進行中
            const acceptedTime = new Date();
            transferMessage.acceptedAt = acceptedTime.toISOString();

            // 計算任務截止時間
            const deadlineHours = parseFloat(transferMessage.taskDeadlineHours) || 24;
            const deadlineTime = new Date(acceptedTime.getTime() + deadlineHours * 60 * 60 * 1000);
            transferMessage.taskDeadline = deadlineTime.toISOString();

            console.log('⏰ [接收商業轉帳] 設置任務截止時間:', {
              acceptedAt: transferMessage.acceptedAt,
              deadlineHours: deadlineHours,
              taskDeadline: transferMessage.taskDeadline,
            });
          }

          // 添加系統通知到對話
          const systemNotification = {
            type: 'system',
            systemType: 'transferAccepted',
            content: isBusiness
              ? `你接收了商業轉帳（定金 $${receivedAmount.toFixed(2)}），請在 ${
                  transferMessage.taskDeadlineHours
                } 小時內完成任務`
              : `你接收了 $${totalAmount.toFixed(2)} 的轉帳`,
            timestamp: new Date().toISOString(),
            time: '剛剛',
          };
          savedConversation.data.messages.push(systemNotification);

          // 保存更新
          await xDb.xAccountProfiles.put(savedConversation);

          // 更新錢包餘額（收定金）
          await loadWalletData();
          const currentBalance = parseFloat(walletData.balance) || 0;
          walletData.balance = currentBalance + receivedAmount;

          // 添加交易記錄
          const senderName = currentMessageConversation?.user?.name || '對方';
          const transaction = {
            id: 'transfer_in_' + Date.now(),
            description: isBusiness
              ? `商業轉帳收款（定金）- ${senderName}${transferMessage.note ? ` - ${transferMessage.note}` : ''}`
              : `收款自 ${senderName}${transferMessage.note ? ` - ${transferMessage.note}` : ''}`,
            amount: receivedAmount,
            timestamp: new Date().toISOString(),
            type: isBusiness ? 'business_transfer_deposit_in' : 'transfer_in',
          };
          walletData.transactions.unshift(transaction);

          // 保存錢包資料
          await saveWalletData();

          // 商業轉帳：保存到商業轉帳資料庫
          if (isBusiness && currentMessageConversation) {
            const businessTransferRecord = {
              ...transferMessage,
              transferId: transferId,
              conversationId: currentMessageConversation.id,
              senderName: senderName,
              senderHandle: currentMessageConversation.user?.handle || 'unknown',
              senderAvatar:
                currentMessageConversation.user?.avatar || 'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg',
              direction: 'received', // 接收的商業轉帳
              createdAt: transferMessage.timestamp,
              acceptedAt: new Date().toISOString(),
            };

            console.log('💼 [保存商業轉帳] 準備保存:', businessTransferRecord);
            console.log('💼 [保存商業轉帳] taskDeadline:', businessTransferRecord.taskDeadline);
            console.log('💼 [保存商業轉帳] taskStatus:', businessTransferRecord.taskStatus);

            await saveBusinessTransfer(businessTransferRecord);

            console.log('💼 商業轉帳已記錄到資料庫');
          }

          // 顯示手機樣式通知
          showPhoneNotification({
            title: 'X Wallet',
            message: isBusiness
              ? `已收定金 $${receivedAmount.toFixed(2)}，請完成任務以獲得尾款`
              : `已收款 $${totalAmount.toFixed(2)}, 當前餘額 $${walletData.balance.toFixed(2)}`,
            avatar: window.userProfileData?.avatar,
            leftIcon: 'x',
          });

          // 關閉彈窗並刷新消息顯示
          closeTransferDetails();

          // 刷新私信詳情頁
          if (currentMessageConversation && currentMessageConversation.user) {
            const profileData = {
              name: currentMessageConversation.user.name,
              handle: currentMessageConversation.user.handle,
              avatar: currentMessageConversation.user.avatar,
            };
            await loadCharacterMessageDetail(currentMessageConversation, profileData);
          }

          console.log('✅ 轉帳已接收:', receivedAmount, '新餘額:', walletData.balance);

          // 商業轉帳：觸發任務檢測
          if (isBusiness) {
            setTimeout(() => {
              handleBusinessTransferTask(transferMessage, currentMessageConversation);
            }, 1000);
          }

          // 💼 檢查是否是商業任務尾款（AI發來的普通轉帳，但有進行中的商業任務）
          if (!isBusiness && !transferMessage.isOwn) {
            // 查找進行中的商業轉帳（用戶接收的）
            const ongoingBusinessTransfer = savedConversation.data.messages
              .filter(
                msg => msg.type === 'transfer' && msg.isBusiness && msg.taskStatus === 'in_progress' && !msg.isOwn,
              )
              .pop(); // 取最新的

            if (ongoingBusinessTransfer) {
              console.log('💼 [商業任務尾款] 檢測到進行中的商業任務，將此轉帳視為尾款');

              // 更新商業轉帳狀態為completed
              ongoingBusinessTransfer.taskStatus = 'completed';
              ongoingBusinessTransfer.completedAt = new Date().toISOString();
              await xDb.xAccountProfiles.put(savedConversation);

              // 更新商業轉帳資料庫狀態
              await updateBusinessTransferStatus(ongoingBusinessTransfer.timestamp, 'completed');

              console.log('✅ [商業任務尾款] 商業任務已完成，狀態已更新');

              // 更新通知消息
              showPhoneNotification({
                title: 'X Wallet',
                message: `任務已完成，已收尾款 $${receivedAmount.toFixed(2)}, 當前餘額 $${walletData.balance.toFixed(
                  2,
                )}`,
                avatar: window.userProfileData?.avatar,
                leftIcon: 'x',
              });
            }
          }
        }
      }
    } catch (error) {
      console.error('接收轉帳失敗:', error);
      showXToast('接收轉帳失敗', 'error');
    }
  };

  // 拒絕轉帳
  window.rejectTransfer = async function (transferId) {
    try {
      // 查找轉帳消息並更新狀態
      const xDb = getXDB();
      const conversationId = `messageConversation_${currentAccountId || 'main'}_${currentMessageConversation.id}`;
      const savedConversation = await xDb.xAccountProfiles.get(conversationId);

      if (savedConversation && savedConversation.data && savedConversation.data.messages) {
        const transferMessage = savedConversation.data.messages.find(
          msg => msg.type === 'transfer' && msg.timestamp === transferId,
        );

        if (transferMessage) {
          const amount = parseFloat(transferMessage.amount);

          // 更新轉帳狀態
          transferMessage.status = 'rejected';

          // 添加系統通知到對話
          const systemNotification = {
            type: 'system',
            systemType: 'transferRejected',
            content: `你拒絕了 $${amount.toFixed(2)} 的轉帳`,
            timestamp: new Date().toISOString(),
            time: '剛剛',
          };
          savedConversation.data.messages.push(systemNotification);

          // 保存更新
          await xDb.xAccountProfiles.put(savedConversation);

          // 關閉彈窗並刷新消息顯示
          closeTransferDetails();

          // 刷新私信詳情頁
          if (currentMessageConversation && currentMessageConversation.user) {
            const profileData = {
              name: currentMessageConversation.user.name,
              handle: currentMessageConversation.user.handle,
              avatar: currentMessageConversation.user.avatar,
            };
            await loadCharacterMessageDetail(currentMessageConversation, profileData);
          }

          console.log('❌ 轉帳已拒絕:', amount);
        }
      }
    } catch (error) {
      console.error('拒絕轉帳失敗:', error);
      showXToast('拒絕轉帳失敗', 'error');
    }
  };

  // 確認完成商業任務並支付尾款
  window.completeBusinessTask = async function (transferId) {
    try {
      if (!currentMessageConversation) {
        showXToast('無法找到當前對話', 'error');
        return;
      }

      // 查找轉帳消息並更新狀態
      const xDb = getXDB();
      const conversationId = `messageConversation_${currentAccountId || 'main'}_${currentMessageConversation.id}`;
      const savedConversation = await xDb.xAccountProfiles.get(conversationId);

      if (savedConversation && savedConversation.data && savedConversation.data.messages) {
        const transferMessage = savedConversation.data.messages.find(
          msg => msg.type === 'transfer' && msg.timestamp === transferId,
        );

        if (transferMessage && transferMessage.isBusiness) {
          const remainingAmount = parseFloat(transferMessage.remainingAmount);

          // 檢查錢包餘額
          await loadWalletData();
          if (walletData.balance < remainingAmount) {
            showXToast('錢包餘額不足，無法支付尾款', 'error');
            return;
          }

          // 更新轉帳狀態
          transferMessage.taskStatus = 'completed';
          transferMessage.completedAt = new Date().toISOString();

          // 扣除尾款
          walletData.balance -= remainingAmount;

          // 從商業轉帳資料庫或對話資訊中獲取接收者名稱
          const businessTransfersId = `businessTransfers_${currentAccountId || 'main'}`;
          let recipientName = '對方';

          const businessData = await xDb.xAccountProfiles.get(businessTransfersId);
          if (businessData && businessData.data) {
            const businessTransfer = businessData.data.find(t => t.transferId === transferId);
            if (businessTransfer && businessTransfer.senderName) {
              recipientName = businessTransfer.senderName;
            }
          }

          // 如果還是找不到，嘗試從currentMessageConversation獲取
          if (recipientName === '對方' && currentMessageConversation?.user?.name) {
            recipientName = currentMessageConversation.user.name;
          }

          const transaction = {
            id: 'business_remaining_' + Date.now(),
            description: `商業轉帳尾款 - ${recipientName}${transferMessage.note ? ` - ${transferMessage.note}` : ''}`,
            amount: -remainingAmount,
            timestamp: new Date().toISOString(),
            type: 'business_transfer_remaining',
          };
          walletData.transactions.unshift(transaction);

          // 保存錢包資料
          await saveWalletData();

          // 添加系統通知到對話
          const systemNotification = {
            type: 'system',
            systemType: 'businessTaskCompleted',
            content: `你已確認任務完成並支付尾款 $${remainingAmount.toFixed(2)}`,
            timestamp: new Date().toISOString(),
            time: '剛剛',
          };
          savedConversation.data.messages.push(systemNotification);

          // 保存更新
          await xDb.xAccountProfiles.put(savedConversation);

          // 更新商業轉帳資料庫狀態
          await updateBusinessTransferStatus(transferId, 'completed');

          // 顯示手機樣式通知
          showPhoneNotification({
            title: 'X Wallet',
            message: `任務已完成，已支付尾款 $${remainingAmount.toFixed(2)}`,
            avatar: window.userProfileData?.avatar,
            leftIcon: 'x',
          });

          // 關閉彈窗並刷新消息顯示
          closeTransferDetails();

          // 刷新私信詳情頁
          if (currentMessageConversation && currentMessageConversation.user) {
            const profileData = {
              name: currentMessageConversation.user.name,
              handle: currentMessageConversation.user.handle,
              avatar: currentMessageConversation.user.avatar,
            };
            await loadCharacterMessageDetail(currentMessageConversation, profileData);
          }

          console.log('✅ 商業任務已完成，尾款已支付:', remainingAmount);
        }
      }
    } catch (error) {
      console.error('完成任務失敗:', error);
      showXToast('完成任務失敗', 'error');
    }
  };

  // 更新商業轉帳資料庫狀態
  async function updateBusinessTransferStatus(transferId, newStatus) {
    try {
      const xDb = getXDB();
      const businessTransfersId = `businessTransfers_${currentAccountId || 'main'}`;
      let savedData = await xDb.xAccountProfiles.get(businessTransfersId);

      if (savedData && savedData.data) {
        const transfer = savedData.data.find(t => t.transferId === transferId);
        if (transfer) {
          transfer.taskStatus = newStatus;

          // 根據狀態更新時間戳記
          if (newStatus === 'in_progress' && !transfer.acceptedAt) {
            transfer.acceptedAt = new Date().toISOString();
          } else if (newStatus === 'completed') {
            transfer.completedAt = new Date().toISOString();
          }

          await xDb.xAccountProfiles.put(savedData);
          console.log('✅ 商業轉帳狀態已更新:', newStatus);
        }
      }
    } catch (error) {
      console.error('❌ 更新商業轉帳狀態失敗:', error);
    }
  }

  // 打開商業轉帳管理中心
  window.openBusinessTransferManager = async function () {
    const xSocialScreen = document.getElementById('x-social-screen');
    const isLightMode = xSocialScreen && xSocialScreen.classList.contains('x-theme-light');

    // 獲取所有商業轉帳記錄
    const xDb = getXDB();
    const businessTransfersId = `businessTransfers_${currentAccountId || 'main'}`;
    let savedData = await xDb.xAccountProfiles.get(businessTransfersId);
    const businessTransfers = savedData?.data || [];

    // 分類：已發出的和已接收的
    const sentTransfers = businessTransfers.filter(t => t.direction === 'sent');
    const receivedTransfers = businessTransfers.filter(t => t.direction === 'received');

    // 創建彈窗遮罩
    const modal = document.createElement('div');
    modal.id = 'business-transfer-manager-modal';
    modal.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: ${isLightMode ? 'rgba(255, 255, 255, 0.85)' : 'rgba(0, 0, 0, 0.85)'};
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 26;
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
    `;

    modal.innerHTML = `
      <div style="
        background-color: ${isLightMode ? 'rgba(255, 255, 255, 0.95)' : 'rgba(0, 0, 0, 0.95)'};
        backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px);
        border-radius: 24px;
        width: 90%;
        max-width: 500px;
        max-height: 80vh;
        position: relative;
        overflow: hidden;
        box-shadow: ${
          isLightMode
            ? '0 20px 60px rgba(0, 0, 0, 0.15), 0 8px 32px rgba(0, 0, 0, 0.1)'
            : '0 20px 60px rgba(0, 0, 0, 0.8), 0 8px 32px rgba(255, 255, 255, 0.05)'
        };
        border: 2px solid ${isLightMode ? 'rgba(0, 0, 0, 0.1)' : 'rgba(255, 255, 255, 0.1)'};
      " onclick="event.stopPropagation()">
        
        <!-- 頭部 -->
        <div style="
          background: linear-gradient(135deg, ${
            isLightMode ? 'rgba(248, 250, 252, 0.8)' : 'rgba(22, 24, 28, 0.8)'
          } 0%, ${isLightMode ? 'rgba(255, 255, 255, 0.6)' : 'rgba(0, 0, 0, 0.6)'} 100%);
          padding: 24px;
          text-align: center;
          border-bottom: 2px solid ${isLightMode ? 'rgba(0, 0, 0, 0.08)' : 'rgba(255, 255, 255, 0.08)'};
          position: relative;
        ">
          <!-- 關閉按鈕 -->
          <button onclick="closeBusinessTransferManager()" style="
            position: absolute;
            top: 16px;
            right: 16px;
            background: transparent;
            border: none;
            color: ${isLightMode ? '#536471' : '#71767b'};
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            transition: all 0.2s;
          " onmouseover="this.style.backgroundColor='${
            isLightMode ? 'rgba(0, 0, 0, 0.05)' : 'rgba(255, 255, 255, 0.05)'
          }';"
             onmouseout="this.style.backgroundColor='transparent'">
            <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: currentColor;">
              <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
            </svg>
          </button>

          <!-- 標題 -->
          <div style="
            color: ${isLightMode ? '#0f1419' : '#ffffff'};
            font-size: 20px;
            font-weight: 700;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
          ">
            <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: currentColor;">
              <g><path d="M20 6h-3V4c0-1.1-.9-2-2-2H9c-1.1 0-2 .9-2 2v2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zM9 4h6v2H9V4zm11 16H4V8h16v12z"></path></g>
            </svg>
            商業轉帳管理
          </div>
          
          <div style="
            color: ${isLightMode ? '#536471' : '#71767b'};
            font-size: 14px;
          ">管理所有商業合作訂單</div>
        </div>

        <!-- 內容區域 -->
        <div style="
          max-height: 60vh;
          overflow-y: auto;
          padding: 16px 20px;
        ">
          <!-- 發出的商業轉帳 -->
          <div style="margin-bottom: 24px;">
            <div style="
              color: ${isLightMode ? '#0f1419' : '#ffffff'};
              font-size: 16px;
              font-weight: 700;
              margin-bottom: 12px;
              padding-bottom: 8px;
              border-bottom: 2px solid ${isLightMode ? '#e1e8ed' : '#38444d'};
              display: flex;
              align-items: center;
              gap: 6px;
            ">
              <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: currentColor;">
                <g><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"></path></g>
              </svg>
              已發出 (${sentTransfers.length})
            </div>
            ${
              sentTransfers.length > 0
                ? renderBusinessTransferList(sentTransfers, 'sent', isLightMode)
                : renderNoBusinessTransfers('sent', isLightMode)
            }
          </div>
          
          <!-- 接收的商業轉帳 -->
          <div>
            <div style="
              color: ${isLightMode ? '#0f1419' : '#ffffff'};
              font-size: 16px;
              font-weight: 700;
              margin-bottom: 12px;
              padding-bottom: 8px;
              border-bottom: 2px solid ${isLightMode ? '#e1e8ed' : '#38444d'};
              display: flex;
              align-items: center;
              gap: 6px;
            ">
              <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: currentColor;">
                <g><path d="M20 8l-8 5-8-5V6l8 5 8-5m0-2H4c-1.11 0-2 .89-2 2v12a2 2 0 002 2h16a2 2 0 002-2V6a2 2 0 00-2-2z"></path></g>
              </svg>
              已接收 (${receivedTransfers.length})
            </div>
            ${
              receivedTransfers.length > 0
                ? renderBusinessTransferList(receivedTransfers, 'received', isLightMode)
                : renderNoBusinessTransfers('received', isLightMode)
            }
          </div>
        </div>
      </div>
    `;

    document.body.appendChild(modal);
    document.body.style.overflow = 'hidden';

    // 點擊背景關閉彈窗
    modal.addEventListener('click', e => {
      if (e.target === modal) {
        closeBusinessTransferManager();
      }
    });

    // 添加入場動畫
    const managerCard = modal.querySelector('div');
    managerCard.style.transform = 'scale(0.8) translateY(20px)';
    managerCard.style.opacity = '0';

    requestAnimationFrame(() => {
      managerCard.style.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
      managerCard.style.transform = 'scale(1) translateY(0)';
      managerCard.style.opacity = '1';
    });
  };

  // 渲染商業轉帳列表
  function renderBusinessTransferList(transfers, type, isLightMode) {
    return transfers
      .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt))
      .map(transfer => {
        const now = new Date();

        // 獲取或計算截止時間
        let deadline;
        if (transfer.taskDeadline) {
          deadline = new Date(transfer.taskDeadline);
        } else if (transfer.acceptedAt && transfer.taskDeadlineHours) {
          // 動態計算截止時間
          const acceptedTime = new Date(transfer.acceptedAt);
          const deadlineHours = parseFloat(transfer.taskDeadlineHours) || 24;
          deadline = new Date(acceptedTime.getTime() + deadlineHours * 60 * 60 * 1000);
        } else if (transfer.createdAt && transfer.taskDeadlineHours) {
          // 如果沒有acceptedAt，使用createdAt
          const createdTime = new Date(transfer.createdAt);
          const deadlineHours = parseFloat(transfer.taskDeadlineHours) || 24;
          deadline = new Date(createdTime.getTime() + deadlineHours * 60 * 60 * 1000);
        } else {
          // 無法計算截止時間，使用默認24小時
          deadline = new Date(now.getTime() + 24 * 60 * 60 * 1000);
        }

        const remainingMs = deadline.getTime() - now.getTime();
        const isExpired = remainingMs <= 0;

        let deadlineText = '';
        if (remainingMs > 0) {
          const hours = Math.floor(remainingMs / (1000 * 60 * 60));
          const minutes = Math.floor((remainingMs % (1000 * 60 * 60)) / (1000 * 60));
          deadlineText = hours > 0 ? `${hours}小時${minutes}分鐘` : `${minutes}分鐘`;
        } else {
          deadlineText = '已過期';
        }

        const statusMap = {
          pending: '待接收',
          in_progress: '進行中',
          completed: '已完成',
          failed: '已失敗',
        };

        const statusColorMap = {
          pending: '#f59e0b',
          in_progress: 'var(--x-accent)',
          completed: '#22c55e',
          failed: '#ef4444',
        };

        return `
          <div style="
            margin-bottom: 12px;
            background: linear-gradient(135deg, ${
              isLightMode ? 'rgba(0, 0, 0, 0.02)' : 'rgba(255, 255, 255, 0.03)'
            } 0%, ${isLightMode ? 'rgba(0, 0, 0, 0.01)' : 'rgba(255, 255, 255, 0.01)'} 100%);
            border: 1px solid ${isLightMode ? 'rgba(0, 0, 0, 0.1)' : 'rgba(255, 255, 255, 0.1)'};
            border-radius: 12px;
            transition: all 0.2s;
            position: relative;
            overflow: hidden;
          ">
            <!-- 票券浮水印 -->
            <div style="
              position: absolute;
              top: 50%;
              right: -20px;
              transform: translateY(-50%) rotate(15deg);
              font-size: 32px;
              color: ${isLightMode ? 'rgba(0, 0, 0, 0.02)' : 'rgba(255, 255, 255, 0.02)'};
              font-weight: 700;
              pointer-events: none;
            ">TICKET</div>
            
            <div style="padding: 16px;">
              <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 12px;">
                <div style="flex: 1;">
                  <div style="
                    color: ${isLightMode ? '#0f1419' : '#ffffff'};
                    font-size: 15px;
                    font-weight: 600;
                    margin-bottom: 4px;
                  ">${type === 'sent' ? `發給 ${transfer.senderName}` : `來自 ${transfer.senderName}`}</div>
                  <div style="
                    color: ${isLightMode ? '#536471' : '#71767b'};
                    font-size: 11px;
                    font-family: monospace;
                    letter-spacing: 0.5px;
                  ">${new Date(transfer.createdAt).toLocaleString('zh-CN')}</div>
                </div>
                <div style="
                  display: inline-block;
                  padding: 4px 10px;
                  background: linear-gradient(135deg, ${
                    isLightMode ? 'rgba(0, 0, 0, 0.08)' : 'rgba(255, 255, 255, 0.12)'
                  } 0%, ${isLightMode ? 'rgba(0, 0, 0, 0.04)' : 'rgba(255, 255, 255, 0.06)'} 100%);
                  color: ${isLightMode ? '#0f1419' : '#ffffff'};
                  font-size: 10px;
                  font-weight: 600;
                  border-radius: 10px;
                  margin-left: 12px;
                  border: 1px solid ${isLightMode ? 'rgba(0, 0, 0, 0.15)' : 'rgba(255, 255, 255, 0.2)'};
                  letter-spacing: 0.5px;
                ">${statusMap[transfer.taskStatus || 'pending']}</div>
              </div>
              
              <!-- 任務描述 -->
              <div style="
                color: ${isLightMode ? '#0f1419' : '#e5e5e5'};
                font-size: 13px;
                line-height: 1.4;
                margin-bottom: 12px;
                padding: 10px;
                background: ${isLightMode ? 'rgba(0, 0, 0, 0.02)' : 'rgba(255, 255, 255, 0.02)'};
                border-left: 2px solid ${isLightMode ? 'rgba(0, 0, 0, 0.15)' : 'rgba(255, 255, 255, 0.15)'};
                border-radius: 4px;
              ">${transfer.taskDescription}</div>
              
              <!-- 底部資訊 -->
              <div style="
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding-top: 12px;
                border-top: 1px dashed ${isLightMode ? 'rgba(0, 0, 0, 0.1)' : 'rgba(255, 255, 255, 0.1)'};
              ">
                <div style="
                  color: ${isExpired ? '#dc2626' : isLightMode ? '#536471' : '#71767b'};
                  font-size: 11px;
                  display: flex;
                  align-items: center;
                  gap: 4px;
                ">
                  <svg viewBox="0 0 24 24" style="width: 11px; height: 11px; fill: currentColor;">
                    <g><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm.5-13H11v6l5.2 3.2.8-1.3-4.5-2.7V7z"></path></g>
                  </svg>
                  ${deadlineText}
                </div>
                <div style="
                  color: ${isLightMode ? '#0f1419' : '#ffffff'};
                  font-size: 13px;
                  font-weight: 700;
                  font-family: monospace;
                ">$${transfer.amount} <span style="opacity: 0.6; font-size: 11px;">(定金 $${
          transfer.depositAmount
        })</span></div>
              </div>
              
              <!-- 刪除按鈕 -->
              <div style="margin-top: 12px; text-align: right;">
                <button onclick="deleteBusinessTransfer('${transfer.transferId}', event)" style="
                  background: linear-gradient(135deg, ${
                    isLightMode ? 'rgba(0, 0, 0, 0.08)' : 'rgba(255, 255, 255, 0.12)'
                  } 0%, ${isLightMode ? 'rgba(0, 0, 0, 0.04)' : 'rgba(255, 255, 255, 0.06)'} 100%);
                  color: ${isLightMode ? '#0f1419' : '#ffffff'};
                  border: 1px dashed ${isLightMode ? 'rgba(0, 0, 0, 0.2)' : 'rgba(255, 255, 255, 0.2)'};
                  border-radius: 8px;
                  padding: 6px 12px;
                  font-size: 11px;
                  font-weight: 600;
                  cursor: pointer;
                  transition: all 0.2s;
                  display: inline-flex;
                  align-items: center;
                  gap: 4px;
                  position: relative;
                  overflow: hidden;
                " onmouseover="this.style.background='linear-gradient(135deg, ${
                  isLightMode ? 'rgba(0, 0, 0, 0.12)' : 'rgba(255, 255, 255, 0.15)'
                } 0%, ${
          isLightMode ? 'rgba(0, 0, 0, 0.06)' : 'rgba(255, 255, 255, 0.08)'
        } 100%)'; this.style.transform='scale(1.02)'"
                   onmouseout="this.style.background='linear-gradient(135deg, ${
                     isLightMode ? 'rgba(0, 0, 0, 0.08)' : 'rgba(255, 255, 255, 0.12)'
                   } 0%, ${
          isLightMode ? 'rgba(0, 0, 0, 0.04)' : 'rgba(255, 255, 255, 0.06)'
        } 100%)'; this.style.transform='scale(1)'">
                  <svg viewBox="0 0 24 24" style="width: 12px; height: 12px; fill: currentColor; opacity: 0.7;">
                    <g><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"></path></g>
                  </svg>
                  刪除任務
                </button>
              </div>
            </div>
          </div>
        `;
      })
      .join('');
  }

  // 渲染無商業轉帳狀態
  function renderNoBusinessTransfers(type, isLightMode) {
    return `
      <div style="
        text-align: center;
        padding: 32px 20px;
        color: ${isLightMode ? '#6b7280' : '#9ca3af'};
        font-size: 14px;
      ">
        <svg viewBox="0 0 24 24" style="width: 48px; height: 48px; fill: currentColor; opacity: 0.3; margin: 0 auto 12px;">
          <g><path d="M20 6h-3V4c0-1.1-.9-2-2-2H9c-1.1 0-2 .9-2 2v2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zM9 4h6v2H9V4zm11 16H4V8h16v12z"></path></g>
        </svg>
        <div>暫無${type === 'sent' ? '發出的' : '接收的'}商業轉帳</div>
      </div>
    `;
  }

  // 關閉商業轉帳管理彈窗
  window.closeBusinessTransferManager = function () {
    const modal = document.getElementById('business-transfer-manager-modal');
    if (modal) {
      const managerCard = modal.querySelector('div');
      managerCard.style.transform = 'scale(0.9) translateY(20px)';
      managerCard.style.opacity = '0';

      setTimeout(() => {
        modal.remove();
        document.body.style.overflow = 'auto';
      }, 200);
    }
  };

  // 刪除商業轉帳任務
  window.deleteBusinessTransfer = async function (transferId, event) {
    event.stopPropagation();

    try {
      const xDb = getXDB();
      const businessTransfersId = `businessTransfers_${currentAccountId || 'main'}`;
      const savedData = await xDb.xAccountProfiles.get(businessTransfersId);

      if (!savedData || !savedData.data) {
        showXToast('無法找到商業轉帳資料', 'error');
        return;
      }

      const transfer = savedData.data.find(t => t.transferId === transferId);
      if (!transfer) {
        showXToast('無法找到該任務', 'error');
        return;
      }

      // 計算違約費
      const depositAmount = parseFloat(transfer.depositAmount) || 0;
      const totalAmount = parseFloat(transfer.amount) || 0;
      const penaltyAmount = depositAmount + totalAmount; // 定金 + 全款

      // 確認刪除
      const confirmMessage = `刪除此任務將扣除違約費 $${penaltyAmount.toFixed(2)}\n（定金 $${depositAmount.toFixed(
        2,
      )} + 全款 $${totalAmount.toFixed(2)}）\n並降低信用值\n\n是否確認刪除？`;

      if (!confirm(confirmMessage)) {
        return;
      }

      // 找到對應的卡片元素並播放撕碎動畫
      const cardElement = event.target.closest('div[style*="margin-bottom: 12px"]');
      if (cardElement) {
        // 添加撕碎動畫
        cardElement.style.animation = 'crumple-tear 0.6s cubic-bezier(0.4, 0, 1, 1) forwards';
        cardElement.style.transformOrigin = 'center center';

        // 注入CSS動畫（如果還沒有注入）
        if (!document.getElementById('business-transfer-animations')) {
          const style = document.createElement('style');
          style.id = 'business-transfer-animations';
          style.textContent = `
            @keyframes crumple-tear {
              0% {
                transform: scale(1) rotate(0deg);
                opacity: 1;
              }
              20% {
                transform: scale(0.95) rotate(-2deg);
              }
              40% {
                transform: scale(0.9) rotate(2deg) translateY(-5px);
                filter: blur(0px);
              }
              60% {
                transform: scale(0.7) rotate(-5deg) translateY(-10px);
                filter: blur(1px);
                opacity: 0.8;
              }
              80% {
                transform: scale(0.4) rotate(8deg) translateY(-15px);
                filter: blur(3px);
                opacity: 0.4;
              }
              100% {
                transform: scale(0.1) rotate(15deg) translateY(-20px);
                filter: blur(5px);
                opacity: 0;
              }
            }
          `;
          document.head.appendChild(style);
        }

        // 等待動畫完成
        await new Promise(resolve => setTimeout(resolve, 600));
      }

      // 載入錢包數據
      await loadWalletData();

      // 扣除違約費
      walletData.balance -= penaltyAmount;

      // 降低信用值（根據任務金額，金額越大扣得越多）
      const creditPenalty = Math.min(20, Math.floor(totalAmount / 10)); // 最多扣20，按金額/10計算
      walletData.creditScore = Math.max(0, walletData.creditScore - creditPenalty);

      // 添加違約費交易記錄
      const penaltyTransaction = {
        id: 'penalty_' + Date.now(),
        description: `刪除商業任務違約費 - ${transfer.taskDescription.substring(0, 30)}...`,
        amount: -penaltyAmount,
        timestamp: new Date().toISOString(),
        type: 'penalty',
      };
      walletData.transactions.unshift(penaltyTransaction);

      // 保存錢包資料
      await saveWalletData();

      // 刪除商業轉帳記錄
      savedData.data = savedData.data.filter(t => t.transferId !== transferId);
      await xDb.xAccountProfiles.put(savedData);

      // 顯示通知
      showPhoneNotification({
        title: 'X Wallet',
        message: `任務已刪除，扣除違約費 $${penaltyAmount.toFixed(2)}，信用值 -${creditPenalty}`,
        avatar: window.userProfileData?.avatar,
        leftIcon: 'custom',
        leftIconHtml: `
          <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: #71767b;">
            <g><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"></path></g>
          </svg>
        `,
        duration: 5000,
      });

      console.log(`🗑️ 商業任務已刪除，扣除違約費 $${penaltyAmount.toFixed(2)}，信用值 -${creditPenalty}`);

      // 刷新商業轉帳管理視窗
      closeBusinessTransferManager();
      setTimeout(() => {
        openBusinessTransferManager();
      }, 300);
    } catch (error) {
      console.error('刪除商業轉帳失敗:', error);
      showXToast('刪除失敗', 'error');
    }
  };

  // 商業轉帳狀態檢查計時器
  let businessTransferCheckInterval = null;

  // 啟動商業轉帳狀態檢查
  function startBusinessTransferCheck() {
    // 如果已有計時器，先清除
    if (businessTransferCheckInterval) {
      clearInterval(businessTransferCheckInterval);
    }

    // 立即執行一次檢查
    checkBusinessTransfersStatus();

    // 每分鐘檢查一次
    businessTransferCheckInterval = setInterval(() => {
      checkBusinessTransfersStatus();
    }, 60000); // 60秒

    console.log('✅ 商業轉帳狀態檢查已啟動');
  }

  // 檢查商業轉帳狀態（提醒、清理）
  async function checkBusinessTransfersStatus() {
    try {
      const xDb = getXDB();
      const businessTransfersId = `businessTransfers_${currentAccountId || 'main'}`;
      const savedData = await xDb.xAccountProfiles.get(businessTransfersId);

      if (!savedData || !savedData.data || savedData.data.length === 0) return;

      const businessTransfers = savedData.data;
      const now = new Date();
      let needsUpdate = false;
      const transfersToKeep = [];

      for (const transfer of businessTransfers) {
        // 獲取或計算截止時間
        let deadline;
        if (transfer.taskDeadline) {
          deadline = new Date(transfer.taskDeadline);
        } else if (transfer.acceptedAt && transfer.taskDeadlineHours) {
          // 動態計算截止時間
          const acceptedTime = new Date(transfer.acceptedAt);
          const deadlineHours = parseFloat(transfer.taskDeadlineHours) || 24;
          deadline = new Date(acceptedTime.getTime() + deadlineHours * 60 * 60 * 1000);
        } else if (transfer.createdAt && transfer.taskDeadlineHours) {
          // 如果沒有acceptedAt，使用createdAt
          const createdTime = new Date(transfer.createdAt);
          const deadlineHours = parseFloat(transfer.taskDeadlineHours) || 24;
          deadline = new Date(createdTime.getTime() + deadlineHours * 60 * 60 * 1000);
        } else {
          // 無法計算截止時間，跳過此任務
          console.warn('⚠️ 商業轉帳缺少截止時間資訊，跳過:', transfer.transferId);
          transfersToKeep.push(transfer);
          continue;
        }

        const completedAt = transfer.completedAt ? new Date(transfer.completedAt) : null;
        const timeToDeadline = deadline.getTime() - now.getTime();

        // 1. 檢查是否需要發送即將到期提醒（剩餘1小時，且進行中的任務）
        if (
          transfer.taskStatus === 'in_progress' &&
          timeToDeadline > 0 &&
          timeToDeadline <= 3600000 && // 1小時 = 3600000毫秒
          !transfer.reminderSent
        ) {
          // 發送提醒
          const hours = Math.floor(timeToDeadline / (1000 * 60 * 60));
          const minutes = Math.floor((timeToDeadline % (1000 * 60 * 60)) / (1000 * 60));
          const timeText = hours > 0 ? `${hours}小時${minutes}分鐘` : `${minutes}分鐘`;

          showPhoneNotification({
            title: '商業轉帳提醒',
            message: `任務"${transfer.taskDescription.substring(0, 20)}..."還剩${timeText}截止，請及時完成！`,
            avatar: window.userProfileData?.avatar,
            leftIcon: 'custom',
            leftIconHtml: `
              <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: #f59e0b;">
                <g><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm.5-13H11v6l5.2 3.2.8-1.3-4.5-2.7V7z"></path></g>
              </svg>
            `,
            duration: 5000,
          });

          // 標記已提醒
          transfer.reminderSent = true;
          needsUpdate = true;

          console.log(`⏰ 已發送任務即將到期提醒: ${transfer.taskDescription.substring(0, 30)}`);
        }

        // 2. 檢查是否需要刪除（過期超過1小時 或 完成超過3小時）
        let shouldDelete = false;
        let isExpiredPenalty = false;

        // 過期超過1小時（進行中的任務才扣違約費）
        if (timeToDeadline < 0 && Math.abs(timeToDeadline) > 3600000) {
          shouldDelete = true;
          if (transfer.taskStatus === 'in_progress') {
            isExpiredPenalty = true; // 標記需要扣除違約費
          }
          console.log(`🗑️ 刪除過期任務: ${transfer.taskDescription.substring(0, 30)}`);
        }

        // 完成超過3小時
        if (transfer.taskStatus === 'completed' && completedAt) {
          const timeSinceCompletion = now.getTime() - completedAt.getTime();
          if (timeSinceCompletion > 10800000) {
            // 3小時 = 10800000毫秒
            shouldDelete = true;
            console.log(`🗑️ 刪除已完成任務: ${transfer.taskDescription.substring(0, 30)}`);
          }
        }

        // 保留不需要刪除的任務
        if (!shouldDelete) {
          transfersToKeep.push(transfer);
        } else {
          // 如果是過期未完成的任務，扣除違約費
          if (isExpiredPenalty) {
            const totalAmount = parseFloat(transfer.amount) || 0;
            const penaltyAmount = totalAmount; // 過期任務只扣全款

            // 載入錢包數據
            await loadWalletData();

            // 扣除違約費
            walletData.balance -= penaltyAmount;

            // 降低信用值
            const creditPenalty = Math.min(15, Math.floor(totalAmount / 15)); // 過期扣得少一些，最多扣15
            walletData.creditScore = Math.max(0, walletData.creditScore - creditPenalty);

            // 添加違約費交易記錄
            const penaltyTransaction = {
              id: 'penalty_expired_' + Date.now(),
              description: `任務過期違約費 - ${transfer.taskDescription.substring(0, 30)}...`,
              amount: -penaltyAmount,
              timestamp: new Date().toISOString(),
              type: 'penalty',
            };
            walletData.transactions.unshift(penaltyTransaction);

            // 保存錢包資料
            await saveWalletData();

            // 顯示通知
            showPhoneNotification({
              title: 'X Wallet',
              message: `任務已過期，扣除違約費 $${penaltyAmount.toFixed(2)}，信用值 -${creditPenalty}`,
              avatar: window.userProfileData?.avatar,
              leftIcon: 'custom',
              leftIconHtml: `
                <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: #71767b;">
                  <g><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm.5-13H11v6l5.2 3.2.8-1.3-4.5-2.7V7z"></path></g>
                </svg>
              `,
              duration: 5000,
            });

            console.log(`💸 任務過期違約費 $${penaltyAmount.toFixed(2)}，信用值 -${creditPenalty}`);
          }

          needsUpdate = true;
        }
      }

      // 如果有任何變化，更新資料庫
      if (needsUpdate) {
        await xDb.xAccountProfiles.put({
          handle: businessTransfersId,
          name: 'businessTransfers',
          accountId: currentAccountId || 'main',
          data: transfersToKeep,
          updatedAt: new Date().toISOString(),
        });

        console.log(`✅ 商業轉帳資料已更新，保留 ${transfersToKeep.length}/${businessTransfers.length} 條記錄`);

        // 如果商業轉帳管理視窗正在打開，刷新顯示
        const managerModal = document.getElementById('business-transfer-manager-modal');
        if (managerModal) {
          closeBusinessTransferManager();
          setTimeout(() => {
            openBusinessTransferManager();
          }, 300);
        }
      }
    } catch (error) {
      console.error('檢查商業轉帳狀態失敗:', error);
    }
  }

  // 處理 AI 對用戶轉帳的回應
  async function handleAITransferResponse(aiMessages, conversationRef) {
    try {
      // 檢查 AI 回復中是否有轉帳消息
      const aiTransfer = aiMessages.find(msg => msg.type === 'transfer' && msg.status && msg.status !== 'pending');

      if (!aiTransfer) return;

      const xDb = getXDB();
      const conversationId = `messageConversation_${currentAccountId || 'main'}_${conversationRef.id}`;
      const savedConversation = await xDb.xAccountProfiles.get(conversationId);

      if (!savedConversation || !savedConversation.data || !savedConversation.data.messages) return;

      // 查找用戶之前發送的待處理轉帳
      const userTransfer = savedConversation.data.messages.find(
        msg => msg.type === 'transfer' && msg.isOwn && msg.status === 'pending',
      );

      if (!userTransfer) return;

      const amount = parseFloat(userTransfer.amount);
      const isBusiness = userTransfer.isBusiness === true;

      if (aiTransfer.status === 'accepted') {
        // AI 接收了轉帳
        userTransfer.status = 'accepted';

        // 商業轉帳：更新任務狀態
        if (isBusiness) {
          userTransfer.taskStatus = 'in_progress';
          userTransfer.acceptedAt = new Date().toISOString();
        }

        // 添加系統通知
        const systemNotification = {
          type: 'system',
          systemType: 'transferAccepted',
          content: isBusiness
            ? `對方接收了商業轉帳（定金 $${parseFloat(userTransfer.depositAmount).toFixed(2)}），已開始執行任務`
            : `對方接收了你的 $${amount.toFixed(2)} 轉帳`,
          timestamp: new Date().toISOString(),
          time: '剛剛',
        };
        savedConversation.data.messages.push(systemNotification);

        // 更新錢包交易記錄狀態
        await loadWalletData();
        const recipientName = conversationRef?.user?.name || '對方';
        const transactionType = isBusiness ? 'business_transfer_deposit' : 'transfer_out';
        const actualAmount = isBusiness ? parseFloat(userTransfer.depositAmount) : amount;

        const transaction = walletData.transactions.find(
          t => t.type === transactionType && Math.abs(t.amount + actualAmount) < 0.01,
        );
        if (transaction) {
          transaction.description = isBusiness
            ? `商業轉帳給 ${recipientName}（定金已接收）${userTransfer.note ? ` - ${userTransfer.note}` : ''}`
            : `轉帳給 ${recipientName}（已接收）${userTransfer.note ? ` - ${userTransfer.note}` : ''}`;
        }
        await saveWalletData();

        // 保存更新
        await xDb.xAccountProfiles.put(savedConversation);

        // 商業轉帳：更新商業轉帳資料庫狀態並觸發任務檢測
        if (isBusiness && conversationRef) {
          // 更新現有的商業轉帳記錄狀態，而不是新增
          await updateBusinessTransferStatus(userTransfer.timestamp, 'in_progress');

          console.log('💼 AI接收的商業轉帳狀態已更新為進行中');

          // 觸發AI任務處理（AI接收後自動處理任務）
          setTimeout(() => {
            handleBusinessTransferTask(userTransfer, conversationRef);
          }, 1000);
        }

        // 延遲3秒顯示手機樣式通知，避免被AI消息通知掩蓋
        setTimeout(() => {
          showPhoneNotification({
            title: 'X Wallet',
            message: isBusiness
              ? `對方已接受任務，定金 $${actualAmount.toFixed(2)} 已支付`
              : `已付款 $${amount.toFixed(2)}, 當前餘額 $${walletData.balance.toFixed(2)}`,
            avatar: window.userProfileData?.avatar,
            leftIcon: 'x',
          });
        }, 3000);

        console.log('✅ AI 接收了轉帳:', isBusiness ? `商業轉帳，定金 ${actualAmount}` : amount);
      } else if (aiTransfer.status === 'rejected') {
        // AI 拒絕了轉帳
        userTransfer.status = 'rejected';

        // 商業轉帳：更新任務狀態
        if (isBusiness) {
          userTransfer.taskStatus = 'rejected';
        }

        // 添加系統通知
        const systemNotification = {
          type: 'system',
          systemType: 'transferRejected',
          content: isBusiness
            ? `對方拒絕了商業轉帳，定金 $${parseFloat(userTransfer.depositAmount).toFixed(2)} 已退回`
            : `對方拒絕了你的 $${amount.toFixed(2)} 轉帳`,
          timestamp: new Date().toISOString(),
          time: '剛剛',
        };
        savedConversation.data.messages.push(systemNotification);

        // 退回錢包餘額
        await loadWalletData();
        const actualAmount = isBusiness ? parseFloat(userTransfer.depositAmount) : amount;
        walletData.balance += actualAmount;

        // 更新交易記錄
        const recipientName = conversationRef?.user?.name || '對方';
        const transactionType = isBusiness ? 'business_transfer_deposit' : 'transfer_out';

        const transaction = walletData.transactions.find(
          t => t.type === transactionType && Math.abs(t.amount + actualAmount) < 0.01,
        );
        if (transaction) {
          transaction.description = isBusiness
            ? `商業轉帳給 ${recipientName}（已拒絕，定金已退回）${userTransfer.note ? ` - ${userTransfer.note}` : ''}`
            : `轉帳給 ${recipientName}（已拒絕，已退回）${userTransfer.note ? ` - ${userTransfer.note}` : ''}`;
          transaction.amount = 0; // 標記為已退回
        }

        // 添加退款記錄
        const refundTransaction = {
          id: 'refund_' + Date.now(),
          description: isBusiness
            ? `${recipientName} 拒絕商業轉帳，定金已退回${userTransfer.note ? ` - ${userTransfer.note}` : ''}`
            : `${recipientName} 拒絕轉帳，已退回${userTransfer.note ? ` - ${userTransfer.note}` : ''}`,
          amount: actualAmount,
          timestamp: new Date().toISOString(),
          type: 'refund',
        };
        walletData.transactions.unshift(refundTransaction);

        await saveWalletData();

        // 保存更新
        await xDb.xAccountProfiles.put(savedConversation);

        // 延遲4秒顯示退款通知，避免被AI消息通知掩蓋
        setTimeout(() => {
          showPhoneNotification({
            title: 'X Wallet',
            message: isBusiness
              ? `商業轉帳被拒絕，定金 $${actualAmount.toFixed(2)} 已退回，當前餘額 $${walletData.balance.toFixed(2)}`
              : `轉帳被拒絕，已退回 $${actualAmount.toFixed(2)}, 當前餘額 $${walletData.balance.toFixed(2)}`,
            avatar: window.userProfileData?.avatar,
            leftIcon: 'x',
          });
        }, 4000);

        console.log('❌ AI 拒絕了轉帳，已退回:', isBusiness ? `商業轉帳定金 ${actualAmount}` : amount);
      }

      // 刷新私信詳情頁（如果用戶還在詳情頁）
      if (currentMessageConversation && currentMessageConversation.id === conversationRef.id) {
        const profileData = {
          name: conversationRef.user.name,
          handle: conversationRef.user.handle,
          avatar: conversationRef.user.avatar,
        };
        await loadCharacterMessageDetail(currentMessageConversation, profileData);
      }
    } catch (error) {
      console.error('處理 AI 轉帳回應失敗:', error);
    }
  }

  // 載入角色私信詳情（已綁定角色）
  async function loadCharacterMessageDetail(messageData, profileData) {
    const contentContainer = document.getElementById('message-detail-content');
    if (!contentContainer) return;

    // 清空現有內容
    contentContainer.innerHTML = '';

    // 更新頂部欄小頭像和昵稱
    const topAvatar = document.getElementById('message-detail-top-avatar');
    const topName = document.getElementById('message-detail-top-name');
    if (topAvatar) topAvatar.src = profileData.avatar;
    if (topName) topName.textContent = profileData.name;

    // 🆕 為非綁定角色的小頭像添加點擊事件（添加到私信列表）
    if (topAvatar) {
      // 判斷是否是綁定角色
      const isCharacter =
        messageData.id.startsWith('msg_') && messageData.id !== 'msg_001' && !messageData.id.startsWith('msg_account_');

      if (!isCharacter) {
        // 非綁定角色：帳戶或陌生人，可以點擊添加到私信列表
        topAvatar.onclick = () => {
          openMessageContactSettings(messageData, profileData);
        };
        topAvatar.style.cursor = 'pointer';
      } else {
        // 綁定角色：移除點擊事件
        topAvatar.onclick = null;
        topAvatar.style.cursor = 'default';
      }
    }

    // 更新中間詳細資訊區域
    const detailAvatar = document.getElementById('message-detail-avatar');
    const detailName = document.getElementById('message-detail-name');
    const detailHandle = document.getElementById('message-detail-handle');

    if (detailAvatar) {
      detailAvatar.src = profileData.avatar;
      // 添加點擊事件，進入對方主頁
      detailAvatar.style.cursor = 'pointer';
      detailAvatar.onclick = () => {
        openAccountProfile(profileData.name, profileData.handle, profileData.avatar);
      };
    }

    if (detailName) detailName.textContent = profileData.name;
    if (detailHandle) detailHandle.textContent = profileData.handle;

    // 顯示簡介
    const bioEl = document.getElementById('message-detail-bio');
    if (profileData.bio && bioEl) {
      bioEl.textContent = profileData.bio;
      bioEl.style.display = 'block';
    } else if (bioEl) {
      bioEl.style.display = 'none';
    }

    // 顯示關注者數量
    const followersCount = profileData.followersCount || '0';
    const config = languageConfig[currentLanguage] || languageConfig.zh;
    const followersEl = document.getElementById('message-detail-followers');
    if (followersEl) {
      if (currentLanguage === 'en') {
        followersEl.textContent = `${followersCount} ${config.messageFollowers}`;
      } else {
        followersEl.textContent = `${followersCount} ${config.messageFollowers}`;
      }
    }

    // 檢查是否已有對話記錄
    try {
      const xDb = getXDB();
      // 🔧 多帳戶隔離：包含帳戶ID
      const conversationId = `messageConversation_${currentAccountId || 'main'}_${messageData.id}`;
      const savedConversation = await xDb.xAccountProfiles.get(conversationId);

      if (
        savedConversation &&
        savedConversation.data &&
        savedConversation.data.messages &&
        savedConversation.data.messages.length > 0
      ) {
        // 已有對話記錄，渲染消息
        console.log('✅ 載入已有對話記錄');

        // 渲染日期分隔符號
        const today = new Date();
        const dateStr =
          currentLanguage === 'en'
            ? today.toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' })
            : `${today.getFullYear()}年${today.getMonth() + 1}月${String(today.getDate()).padStart(2, '0')}日`;
        contentContainer.appendChild(renderDateSeparator(dateStr));

        // 使用分組渲染消息
        const groups = groupMessagesBySender(savedConversation.data.messages);
        const allMessageElements = [];

        groups.forEach(group => {
          const isOwn = group[0].message.isOwn === true;
          group.forEach((item, indexInGroup) => {
            const isLastInGroup = indexInGroup === group.length - 1;
            const messageEl = renderMessageItem(item.message, isOwn, item.index, isLastInGroup);
            contentContainer.appendChild(messageEl);
            allMessageElements.push(messageEl);
          });
        });

        // 立即顯示所有消息（歷史消息不需要動畫）
        allMessageElements.forEach(el => {
          el.style.opacity = '1';
          el.style.transform = 'translateY(0)';
        });

        // 恢復等待AI回復的消息到佇列
        try {
          // 從對話記錄中找出所有等待AI回復的使用者消息
          const waitingMessages = savedConversation.data.messages.filter(
            msg => msg.isOwn && msg.waitingForAIResponse === true,
          );

          if (waitingMessages.length > 0) {
            userMessageQueue = waitingMessages;
            console.log(`✅ 恢復了 ${userMessageQueue.length} 條等待AI回復的消息到佇列`);
          } else {
            console.log('📝 所有消息都已得到AI回復');
          }
        } catch (error) {
          console.error('恢復訊息佇列失敗:', error);
        }

        // 滾動到底部（使用外層可滾動容器）
        setTimeout(() => {
          const scrollable = document.getElementById('message-detail-scrollable');
          if (scrollable) {
            scrollable.scrollTop = scrollable.scrollHeight;
          }
        }, 100);

        return;
      }
    } catch (error) {
      console.warn('檢查對話記錄失敗:', error);
    }

    // 沒有對話記錄，顯示歡迎狀態
    contentContainer.innerHTML = `
      <div style="flex: 1; display: flex; align-items: center; justify-content: center; padding: 32px;">
        <div style="text-align: center; max-width: 300px;">
          <!-- 頭像 -->
          <img src="${profileData.avatar}" 
            style="
              width: 64px; 
              height: 64px; 
              border-radius: 50%; 
              margin-bottom: 16px;
              object-fit: cover;
            ">
          
          <!-- 歡迎文字 -->
          <div style="
            font-size: 28px;
            font-weight: 700;
            color: var(--x-text-primary);
            margin-bottom: 8px;
          ">開始對話</div>
          
          <div style="
            font-size: 14px;
            color: var(--x-text-secondary);
            line-height: 1.4;
          ">向 ${profileData.name} 發送消息開始聊天</div>
        </div>
      </div>
    `;

    console.log('✅ 角色私信詳情頁已載入（首次對話）');
  }

  // 載入粉絲群私信詳情
  async function loadFanGroupMessageDetail(messageData) {
    const contentContainer = document.getElementById('message-detail-content');
    if (!contentContainer) return;

    // 清空現有內容
    contentContainer.innerHTML = '';

    // 更新頂部欄小頭像和昵稱
    const topAvatar = document.getElementById('message-detail-top-avatar');
    const topName = document.getElementById('message-detail-top-name');
    if (topAvatar) topAvatar.src = messageData.userAvatar || messageData.groupAvatar;
    if (topName) topName.textContent = messageData.userName || messageData.groupName;

    // 隱藏中間的詳細資訊區域（大頭像和使用者資訊）
    const scrollableContainer = document.getElementById('message-detail-scrollable');
    if (scrollableContainer) {
      const userInfoSection = scrollableContainer.querySelector('[style*="padding: 24px"]');
      if (userInfoSection) {
        userInfoSection.style.display = 'none';
      }
    }

    // 檢查是否已有對話記錄
    try {
      const xDb = getXDB();
      const conversationId = `messageConversation_${currentAccountId || 'main'}_${messageData.id}`;
      const savedConversation = await xDb.xAccountProfiles.get(conversationId);

      if (
        savedConversation &&
        savedConversation.data &&
        savedConversation.data.messages &&
        savedConversation.data.messages.length > 0
      ) {
        // 已有對話記錄，渲染消息
        console.log('✅ 載入已有粉絲群對話記錄');

        // 渲染日期分隔符號
        const today = new Date();
        const dateStr =
          currentLanguage === 'en'
            ? today.toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' })
            : `${today.getFullYear()}年${today.getMonth() + 1}月${String(today.getDate()).padStart(2, '0')}日`;
        contentContainer.appendChild(renderDateSeparator(dateStr));

        // 使用分組渲染消息
        const groups = groupMessagesBySender(savedConversation.data.messages);
        const allMessageElements = [];

        groups.forEach(group => {
          const isOwn = group[0].message.isOwn === true;
          group.forEach((item, indexInGroup) => {
            const isLastInGroup = indexInGroup === group.length - 1;
            const messageEl = renderMessageItem(item.message, isOwn, item.index, isLastInGroup);
            contentContainer.appendChild(messageEl);
            allMessageElements.push(messageEl);
          });
        });

        // 立即顯示所有消息（歷史消息不需要動畫）
        allMessageElements.forEach(el => {
          el.style.opacity = '1';
          el.style.transform = 'translateY(0)';
        });

        // 恢復等待AI回復的消息到佇列
        try {
          const waitingMessages = savedConversation.data.messages.filter(
            msg => msg.isOwn && msg.waitingForAIResponse === true,
          );

          if (waitingMessages.length > 0) {
            userMessageQueue = waitingMessages;
            console.log(`✅ 恢復了 ${userMessageQueue.length} 條等待AI回復的消息到佇列`);
          }
        } catch (error) {
          console.error('恢復訊息佇列失敗:', error);
        }

        // 滾動到底部
        setTimeout(() => {
          const scrollable = document.getElementById('message-detail-scrollable');
          if (scrollable) {
            scrollable.scrollTop = scrollable.scrollHeight;
          }
        }, 100);

        return;
      }
    } catch (error) {
      console.warn('檢查粉絲群對話記錄失敗:', error);
    }

    // 沒有對話記錄，顯示空狀態（粉絲群不顯示歡迎詞）
    contentContainer.innerHTML = `
      <div style="flex: 1; display: flex; align-items: center; justify-content: center; padding: 32px;">
        <div style="text-align: center; max-width: 300px;">
          <!-- 頭像 -->
          <img src="${messageData.userAvatar || messageData.groupAvatar}" 
            style="
              width: 64px; 
              height: 64px; 
              border-radius: 50%; 
              margin-bottom: 16px;
              object-fit: cover;
            ">
          
          <!-- 提示文字 -->
          <div style="
            font-size: 28px;
            font-weight: 700;
            color: var(--x-text-primary);
            margin-bottom: 8px;
          ">粉絲群聊天</div>
          
          <div style="
            font-size: 14px;
            color: var(--x-text-secondary);
            line-height: 1.4;
          ">向粉絲群發送消息開始互動</div>
        </div>
      </div>
    `;

    console.log('✅ 粉絲群私信詳情頁已載入（首次對話）');
  }

  // 載入私信會話內容
  function loadMessageConversation(messageData, conversationData) {
    const contentContainer = document.getElementById('message-detail-content');
    if (!contentContainer) return;

    // 清空現有內容
    contentContainer.innerHTML = '';

    // 🔧 檢測並設置帳戶類型（如果未設置）
    if (!messageData._accountType && messageData.id) {
      if (messageData.id.startsWith('msg_account_')) {
        messageData._accountType = 'account';
      } else if (messageData.id.startsWith('msg_npc_')) {
        messageData._accountType = 'npc';
      } else if (messageData.id.startsWith('msg_relationship_')) {
        messageData._accountType = 'relationshipNpc';
      } else if (!messageData.id.startsWith('msg_')) {
        // 其他非角色消息預設為陌生人
        messageData._accountType = 'stranger';
      }
      console.log('🔍 [類型檢測] 設置消息類型為:', messageData._accountType);
    }

    // 更新頂部欄小頭像和昵稱
    const topAvatar = document.getElementById('message-detail-top-avatar');
    const topName = document.getElementById('message-detail-top-name');
    if (topAvatar) topAvatar.src = messageData.user.avatar;
    if (topName) topName.textContent = messageData.user.name;

    // 為非綁定角色的小頭像添加點擊事件（打開設置）
    const isCharacterMessage =
      messageData.id &&
      messageData.id.startsWith('msg_') &&
      messageData.id !== 'msg_001' &&
      !messageData.id.startsWith('msg_account_');
    if (topAvatar && !isCharacterMessage) {
      topAvatar.style.cursor = 'pointer';
      topAvatar.onclick = e => {
        e.stopPropagation();
        // 使用通用連絡人設置彈窗（支持帳戶/NPC/關係NPC/陌生人）
        console.log('📱 [小頭像點擊] 打開連絡人設置，類型:', messageData._accountType);
        openMessageContactSettings(messageData, conversationData);
      };
    } else if (topAvatar) {
      topAvatar.style.cursor = 'default';
      topAvatar.onclick = null;
    }

    // 更新中間詳細資訊區域
    const detailAvatar = document.getElementById('message-detail-avatar');
    const detailName = document.getElementById('message-detail-name');
    const detailHandle = document.getElementById('message-detail-handle');

    if (detailAvatar) {
      detailAvatar.src = messageData.user.avatar;
      // 添加點擊事件，進入對方主頁
      detailAvatar.style.cursor = 'pointer';
      detailAvatar.onclick = () => {
        openAccountProfileFromDM(messageData, conversationData);
      };
    }

    if (detailName) detailName.textContent = messageData.user.name;
    if (detailHandle) detailHandle.textContent = messageData.user.handle;

    // 使用AI生成的簡介
    const bioEl = document.getElementById('message-detail-bio');
    if (conversationData?.senderProfile?.bio && bioEl) {
      bioEl.textContent = conversationData.senderProfile.bio;
      bioEl.style.display = 'block';
    } else if (bioEl) {
      bioEl.style.display = 'none';
    }

    // 使用AI生成的關注者數量
    const followersCount = conversationData?.senderProfile?.followers || Math.floor(Math.random() * 1000) + 100;
    const config = languageConfig[currentLanguage] || languageConfig.zh;
    if (currentLanguage === 'en') {
      document.getElementById('message-detail-followers').textContent = `${followersCount} ${config.messageFollowers}`;
    } else {
      document.getElementById('message-detail-followers').textContent = `${followersCount} ${config.messageFollowers}`;
    }

    // 渲染日期分隔符號（示例：當前日期）
    const today = new Date();
    const dateStr =
      currentLanguage === 'en'
        ? today.toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' })
        : `${today.getFullYear()}年${today.getMonth() + 1}月${String(today.getDate()).padStart(2, '0')}日`;
    contentContainer.appendChild(renderDateSeparator(dateStr));

    // 渲染消息記錄（使用消息本身的isOwn屬性判斷位置）
    if (conversationData && conversationData.messages && conversationData.messages.length > 0) {
      // 使用分組渲染消息
      const groups = groupMessagesBySender(conversationData.messages);
      const allMessageElements = [];

      groups.forEach(group => {
        const isOwn = group[0].message.isOwn === true;
        group.forEach((item, indexInGroup) => {
          const isLastInGroup = indexInGroup === group.length - 1;
          const messageEl = renderMessageItem(item.message, isOwn, item.index, isLastInGroup);
          contentContainer.appendChild(messageEl);
          allMessageElements.push(messageEl);
        });
      });

      // 立即顯示所有消息（歷史消息不需要動畫）
      allMessageElements.forEach(el => {
        el.style.opacity = '1';
        el.style.transform = 'translateY(0)';
      });
    } else {
      // 如果沒有生成資料，顯示預覽消息
      const messageEl = renderMessageItem(
        {
          type: 'text',
          content: messageData.preview,
          time: '剛剛',
        },
        false,
        0,
        true,
      );
      contentContainer.appendChild(messageEl);
      // 立即顯示
      messageEl.style.opacity = '1';
      messageEl.style.transform = 'translateY(0)';
    }

    // 滾動到底部（使用外層可滾動容器）
    setTimeout(() => {
      const scrollable = document.getElementById('message-detail-scrollable');
      if (scrollable) {
        scrollable.scrollTop = scrollable.scrollHeight;
      }
    }, 100);
  }

  // 打開私信詳情頁面
  window.openMessageDetail = async function (messageData) {
    // 🔧 檢測並設置帳戶類型（如果未設置）
    if (!messageData._accountType && messageData.id) {
      if (messageData.id.startsWith('msg_account_')) {
        messageData._accountType = 'account';
      } else if (messageData.id.startsWith('msg_npc_')) {
        messageData._accountType = 'npc';
      } else if (messageData.id.startsWith('msg_relationship_')) {
        messageData._accountType = 'relationshipNpc';
      } else if (!messageData.id.startsWith('msg_') || messageData.id === 'msg_001') {
        // 其他非角色消息預設為陌生人
        messageData._accountType = 'stranger';
      }
      console.log('🔍 [打開私信] 檢測到類型:', messageData._accountType, '| ID:', messageData.id);
    }

    currentMessageConversation = messageData;
    userMessageQueue = [];

    // 檢測來源頁面
    const messagesPage = document.getElementById('x-messages-page');
    const notificationsPage = document.getElementById('x-notifications-page');
    const isFromNotifications = notificationsPage && notificationsPage.style.display === 'flex';

    // 隱藏私信清單頁面和浮動按鈕
    messagesPage.style.display = 'none';
    const composeBtn = document.getElementById('compose-message-btn');
    if (composeBtn) composeBtn.style.display = 'none';

    // 如果是從通知頁面打開的，也要隱藏通知頁面
    if (isFromNotifications) {
      notificationsPage.style.display = 'none';
    }

    // 隱藏羽毛筆按鈕（刷新陌生人私信按鈕）
    const refreshMessagesBtn = document.getElementById('refresh-messages-btn');
    if (refreshMessagesBtn) refreshMessagesBtn.style.display = 'none';

    // 顯示私信詳情頁面
    const detailPage = document.getElementById('x-message-detail-page');
    detailPage.style.display = 'flex';
    // 保存當前對話ID，用於文章轉發時判斷是否需要刷新頁面
    detailPage.dataset.conversationId = messageData.id;
    // 保存來源頁面標記
    detailPage.dataset.fromNotifications = isFromNotifications ? 'true' : 'false';

    // 🔧 初始化輸入框狀態為啟用（防止之前被拉黑的對話影響）
    setTimeout(() => {
      const messageInput = document.getElementById('message-input');
      const sendBtn = document.getElementById('message-send-btn');
      if (messageInput) {
        messageInput.disabled = false;
        messageInput.placeholder = '發送私信';
      }
      if (sendBtn) {
        sendBtn.disabled = false;
      }
    }, 50);

    const xDb = getXDB();

    // 清除未讀標記
    try {
      const dataId = `messagesList_${currentAccountId || 'main'}`;
      const savedData = await xDb.xAccountProfiles.get(dataId);

      if (savedData && savedData.data) {
        const messagesList = savedData.data;
        const messageIndex = messagesList.findIndex(msg => msg.id === messageData.id);

        if (messageIndex !== -1 && messagesList[messageIndex].unread) {
          // 清除未讀標記
          messagesList[messageIndex].unread = false;
          messagesList[messageIndex].unreadCount = 0;

          // 保存回資料庫
          await xDb.xAccountProfiles.put({
            handle: dataId,
            name: 'messagesList',
            data: messagesList,
            updatedAt: new Date().toISOString(),
          });

          // 同步更新全域資料
          sampleMessagesData = messagesList;

          console.log('✅ 已清除未讀標記');
        }
      }
    } catch (error) {
      console.error('清除未讀標記失敗:', error);
    }

    // 檢查是否是粉絲群
    const isFanGroup = messageData.type === 'fangroup' || (messageData.id && messageData.id.startsWith('fangroup_'));

    if (isFanGroup) {
      // 粉絲群，直接載入粉絲群詳情頁（不觸發 AI 生成）
      console.log('👥 檢測到粉絲群，載入粉絲群詳情頁');
      loadFanGroupMessageDetail(messageData);
      return;
    }

    // 檢查是否是已綁定角色的私信（id格式為 msg_characterId）
    const isCharacterMessage = messageData.id && messageData.id.startsWith('msg_') && messageData.id !== 'msg_001';

    if (isCharacterMessage) {
      // 已綁定角色，嘗試從帳戶主頁數據中讀取資料
      console.log('📨 檢測到已綁定角色私信，從帳戶主頁數據讀取資料');

      const characterId = messageData.id.replace('msg_', '');

      try {
        // 從 xCharacterProfiles 獲取角色的X資料
        const xProfile = await xDb.xCharacterProfiles.get(characterId);

        if (xProfile) {
          // 嘗試從 xAccountProfiles 讀取該角色的帳戶主頁數據
          const cleanHandle = xProfile.xHandle.replace('@', '');
          const accountProfile = await xDb.xAccountProfiles.get(cleanHandle);

          if (accountProfile && accountProfile.accountInfo) {
            console.log('✅ 找到角色的帳戶主頁數據');
            // 使用帳戶主頁數據，但用最新的X資料頭像覆蓋
            const updatedAccountInfo = {
              ...accountProfile.accountInfo,
              avatar: xProfile.xAvatar, // 使用最新的X資料頭像
              name: xProfile.xName, // 同時更新名稱
              handle: xProfile.xHandle, // 同時更新控制碼
            };
            loadCharacterMessageDetail(messageData, updatedAccountInfo);
            return;
          }
        }

        console.log('⚠️ 未找到角色的帳戶主頁數據，使用基本資料');
        // 如果沒有帳戶主頁數據，使用X資料
        if (xProfile) {
          const basicProfile = {
            name: xProfile.xName,
            handle: xProfile.xHandle,
            avatar: xProfile.xAvatar,
            bio: xProfile.xBio || '',
            followersCount: xProfile.followersCount || '0',
            verified: xProfile.xVerified || false,
          };
          loadCharacterMessageDetail(messageData, basicProfile);
          return;
        }
      } catch (error) {
        console.error('讀取角色資料失敗:', error);
      }
    }

    // 陌生人私信，走原來的生成流程
    // 標準化messageData格式（相容兩種格式）
    if (!messageData.user && messageData.userName) {
      messageData.user = {
        name: messageData.userName,
        handle: messageData.userHandle,
        avatar: messageData.userAvatar,
        verified: messageData.verified || false,
      };
    }

    // 🔧 多帳戶隔離：包含帳戶ID
    const conversationId = `messageConversation_${currentAccountId || 'main'}_${messageData.id}`;
    let conversationData = null;

    try {
      const savedConversation = await xDb.xAccountProfiles.get(conversationId);
      if (savedConversation && savedConversation.data) {
        conversationData = savedConversation.data;
        console.log('✅ 從資料庫載入私信對話資料');

        // 🔍 檢查拉黑狀態
        if (savedConversation.isBlocked) {
          console.log('⚠️ [拉黑] 該用戶已被拉黑');
          // 載入會話內容
          loadMessageConversation(messageData, conversationData);

          // 禁用輸入框和發送按鈕
          setTimeout(() => {
            const messageInput = document.getElementById('message-input');
            const sendBtn = document.getElementById('message-send-btn');
            if (messageInput) {
              messageInput.disabled = true;
              messageInput.placeholder = '對方已將你拉黑';
            }
            if (sendBtn) {
              sendBtn.disabled = true;
            }
          }, 100);
          return;
        }

        // 載入已有的會話內容
        loadMessageConversation(messageData, conversationData);
      }
    } catch (error) {
      console.error('載入私信對話資料失敗:', error);
    }

    // 如果沒有已有資料，生成新的對話內容
    if (!conversationData) {
      // 先顯示載入狀態
      const contentContainer = document.getElementById('message-detail-content');
      if (contentContainer) {
        contentContainer.innerHTML = `
          <div style="flex: 1; display: flex; align-items: center; justify-content: center;">
            <div style="text-align: center;">
              <div style="margin-bottom: 12px;">
                <svg viewBox="0 0 24 24" style="width: 48px; height: 48px; fill: var(--x-accent); animation: spin 1s linear infinite;">
                  <g><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-1-13h2v6h-2zm0 8h2v2h-2z"></path></g>
                </svg>
              </div>
              <div style="color: var(--x-text-primary); font-size: 16px; font-weight: 600;">正在生成對話詳情...</div>
            </div>
          </div>
        `;
      }

      // 生成新的對話內容
      conversationData = await generateMessageConversation(messageData);

      // 載入生成的會話內容
      if (conversationData) {
        loadMessageConversation(messageData, conversationData);
      } else {
        // 生成失敗，顯示預覽內容
        loadMessageConversation(messageData, null);
      }
    }
  };

  // 關閉私信詳情頁面
  window.closeMessageDetail = async function () {
    // 清空輸入框
    const input = document.getElementById('message-input');
    if (input) {
      input.value = '';
      autoResizeMessageInput(input);
    }

    // 獲取私信詳情頁面
    const detailPage = document.getElementById('x-message-detail-page');
    const isFromNotifications = detailPage.dataset.fromNotifications === 'true';

    // 隱藏私信詳情頁面
    detailPage.style.display = 'none';

    // 判斷是從哪裡打開的私信詳情頁
    // 如果messageData的id以msg_account_開頭，說明是從帳戶主頁打開的
    // 或者如果 _accountType 為 'account'/'npc'/'relationshipNpc'，也說明可能來自帳戶主頁
    const isFromAccountProfile =
      currentMessageConversation &&
      currentMessageConversation.id &&
      (currentMessageConversation.id.startsWith('msg_account_') ||
        currentMessageConversation._accountType === 'account' ||
        currentMessageConversation._accountType === 'npc' ||
        currentMessageConversation._accountType === 'relationshipNpc');

    if (isFromAccountProfile) {
      console.log('📖 [返回] 從私信詳情頁返回帳戶主頁');
      // 檢查帳戶主頁是否正在顯示
      const accountProfilePage = document.getElementById('account-profile-page');
      if (accountProfilePage && accountProfilePage.style.display !== 'none') {
        // 返回帳戶主頁
        accountProfilePage.style.display = 'flex';
      } else {
        // 如果帳戶主頁沒有顯示，返回私信清單
        console.log('📖 [返回] 帳戶主頁未顯示，返回私信清單');
        document.getElementById('x-messages-page').style.display = 'flex';
        const composeBtn = document.getElementById('compose-message-btn');
        if (composeBtn) composeBtn.style.display = 'flex';
        if (typeof renderMessagesList === 'function') {
          renderMessagesList(sampleMessagesData);
        }
      }
    } else if (isFromNotifications) {
      console.log('📖 [返回] 從私信詳情頁返回通知頁面');
      // 返回通知頁面
      document.getElementById('x-notifications-page').style.display = 'flex';

      // 重新顯示羽毛筆按鈕（如果當前在All標籤）
      const refreshMessagesBtn = document.getElementById('refresh-messages-btn');
      const isAllTab =
        document.querySelector('.notification-tab.active')?.textContent.includes('全部') ||
        document.querySelector('.notification-tab.active')?.textContent.includes('All');
      if (refreshMessagesBtn && isAllTab) {
        refreshMessagesBtn.style.display = 'flex';
      }

      // 重新載入通知以顯示更新後的未讀狀態
      if (typeof loadNotifications === 'function') {
        await loadNotifications();
      }
    } else {
      console.log('📖 [返回] 從私信詳情頁返回私信列表');
      // 返回私信清單頁面
      document.getElementById('x-messages-page').style.display = 'flex';

      // 顯示浮動按鈕
      const composeBtn = document.getElementById('compose-message-btn');
      if (composeBtn) composeBtn.style.display = 'flex';

      // 重新渲染私信清單以顯示更新後的未讀狀態
      if (typeof renderMessagesList === 'function') {
        renderMessagesList(sampleMessagesData);
      }
    }

    // 清空狀態
    currentMessageConversation = null;
    userMessageQueue = [];
  };

  // 自動調整輸入框高度
  window.autoResizeMessageInput = function (textarea) {
    textarea.style.height = '36px';
    const scrollHeight = textarea.scrollHeight;
    if (scrollHeight > 36) {
      textarea.style.height = Math.min(scrollHeight, 100) + 'px';
    }
  };

  // 處理輸入框回車鍵
  window.handleMessageInputKeydown = function (event) {
    if (event.key === 'Enter' && !event.shiftKey) {
      event.preventDefault();
      sendMessageContent();
    }
  };

  // 切換私信功能功能表顯示/隱藏
  window.toggleMessageFunctionMenu = function () {
    const menu = document.getElementById('message-function-menu');
    const addBtn = document.getElementById('message-add-btn');

    if (!menu || !addBtn) return;

    const isVisible = menu.style.display === 'flex';

    if (isVisible) {
      menu.style.display = 'none';
      // 旋轉加號回原位
      const svg = addBtn.querySelector('svg');
      if (svg) svg.style.transform = 'rotate(0deg)';
    } else {
      menu.style.display = 'flex';
      // 旋轉加號45度變成X
      const svg = addBtn.querySelector('svg');
      if (svg) svg.style.transform = 'rotate(45deg)';
    }
  };

  // 點擊頁面其他地方關閉功能功能表
  document.addEventListener('click', function (e) {
    const menu = document.getElementById('message-function-menu');
    const addBtn = document.getElementById('message-add-btn');

    if (!menu || !addBtn) return;

    // 如果點擊的不是功能表或加號按鈕，關閉功能表
    if (!menu.contains(e.target) && !addBtn.contains(e.target)) {
      menu.style.display = 'none';
      const svg = addBtn.querySelector('svg');
      if (svg) svg.style.transform = 'rotate(0deg)';
    }
  });

  // 打開圖片類型選擇器
  window.openImageTypeSelector = function () {
    const dialog = document.getElementById('image-type-selector-dialog');
    if (dialog) {
      dialog.style.display = 'flex';
    }
  };

  // 關閉圖片類型選擇器
  window.closeImageTypeSelector = function () {
    const dialog = document.getElementById('image-type-selector-dialog');
    if (dialog) {
      dialog.style.display = 'none';
    }
  };

  // 選擇圖片類型
  window.selectImageType = function (type) {
    closeImageTypeSelector();

    if (type === 'real') {
      // 上傳真實圖片
      triggerMessageImageUpload();
    } else if (type === 'text') {
      // 打開文字圖片輸入框
      openTextImageDialog();
    }
  };

  // 打開文字圖片對話方塊
  function openTextImageDialog() {
    const dialog = document.getElementById('text-image-dialog');
    const input = document.getElementById('text-image-description-input');
    const counter = document.getElementById('text-image-counter');

    if (dialog) {
      dialog.style.display = 'flex';
    }

    if (input) {
      input.value = '';
    }

    if (counter) {
      counter.textContent = '0 / 500';
    }

    // 聚焦到輸入框
    setTimeout(() => {
      if (input) input.focus();
    }, 100);
  }

  // 關閉文字圖片對話方塊
  window.closeTextImageDialog = function () {
    const dialog = document.getElementById('text-image-dialog');
    if (dialog) {
      dialog.style.display = 'none';
    }
  };

  // 更新文字圖片字元計數
  window.updateTextImageCounter = function () {
    const input = document.getElementById('text-image-description-input');
    const counter = document.getElementById('text-image-counter');

    if (input && counter) {
      counter.textContent = `${input.value.length} / 500`;
    }
  };

  // 發送文字圖片
  window.sendTextImage = async function () {
    const input = document.getElementById('text-image-description-input');

    if (!input) return;

    const description = input.value.trim();

    if (!description) {
      showXToast('請輸入圖片描述', 'error');
      return;
    }

    // 關閉對話方塊
    closeTextImageDialog();

    // 獲取當前時間
    const now = new Date();
    const hours = now.getHours();
    const minutes = String(now.getMinutes()).padStart(2, '0');
    const timeStr = `${hours}:${minutes}`;

    // 創建文字圖片消息物件
    const textImageMessage = {
      type: 'image',
      imageDescription: description,
      sensitive: false,
      time: timeStr,
      timestamp: now.toISOString(),
      isOwn: true,
    };

    // 添加到訊息佇列
    userMessageQueue.push(textImageMessage);

    // 渲染新消息
    const contentContainer = document.getElementById('message-detail-content');
    if (contentContainer) {
      const currentMessageCount = contentContainer.querySelectorAll('.message-item').length;
      const newMessage = renderMessageItem(textImageMessage, true, currentMessageCount);
      contentContainer.appendChild(newMessage);

      // 立即顯示動畫
      setTimeout(() => {
        newMessage.style.transition = 'all 0.3s ease';
        newMessage.style.opacity = '1';
        newMessage.style.transform = 'translateY(0)';
      }, 10);

      // 滾動到底部
      setTimeout(() => {
        const scrollable = document.getElementById('message-detail-scrollable');
        if (scrollable) {
          scrollable.scrollTo({
            top: scrollable.scrollHeight,
            behavior: 'smooth',
          });
        }
      }, 100);
    }

    // 保存到資料庫
    await saveUserMessageToDB(textImageMessage);

    console.log('✅ 文字圖片消息已添加到佇列，等待發送');
  };

  // 觸發圖片上傳
  window.triggerMessageImageUpload = function () {
    const input = document.getElementById('message-image-input');
    if (input) input.click();
  };

  // 存儲待發送的圖片資料
  let pendingMessageImages = [];

  // 處理圖片上傳（支援多圖）
  window.handleMessageImageUpload = async function (event) {
    const files = event.target.files;
    if (!files || files.length === 0) return;

    // 驗證圖片數量（最多4張）
    if (pendingMessageImages.length + files.length > 4) {
      showXToast('最多只能上傳4張圖片', 'error');
      return;
    }

    for (let i = 0; i < files.length; i++) {
      const file = files[i];

      // 驗證檔案類型
      if (!file.type.startsWith('image/')) {
        showXToast('請選擇圖片檔', 'error');
        continue;
      }

      // 驗證文件大小
      if (file.size > 5 * 1024 * 1024) {
        showXToast('圖片檔不能超過5MB', 'error');
        continue;
      }

      const reader = new FileReader();
      reader.onload = function (e) {
        const base64Data = e.target.result;

        // 添加到待發送列表
        pendingMessageImages.push({
          content: base64Data,
          fileName: file.name,
        });

        // 立即發送圖片消息
        sendImageMessage(base64Data, file.name);

        console.log(`✅ 圖片 ${file.name} 已添加並發送`);
      };

      reader.readAsDataURL(file);
    }

    // 清空輸入框，允許重新選擇相同檔
    event.target.value = '';
  };

  // 發送圖片消息（立即顯示，但不觸發AI回復）
  async function sendImageMessage(base64Data, fileName) {
    // 獲取當前時間
    const now = new Date();
    const hours = now.getHours();
    const minutes = String(now.getMinutes()).padStart(2, '0');
    const period = hours >= 12 ? '下午' : '上午';
    const timeStr = `${hours > 12 ? hours - 12 : hours}:${minutes} ${period}`;

    // 創建圖片消息物件
    const imageMessage = {
      type: 'image',
      imageData: base64Data,
      fileName: fileName,
      time: timeStr,
      timestamp: now.toISOString(),
      isOwn: true,
    };

    // 添加到訊息佇列
    userMessageQueue.push(imageMessage);

    // 渲染新消息
    const contentContainer = document.getElementById('message-detail-content');
    if (contentContainer) {
      const currentMessageCount = contentContainer.querySelectorAll('.message-item:not(#typing-indicator)').length;
      const newMessage = renderMessageItem(imageMessage, true, currentMessageCount, true);
      contentContainer.appendChild(newMessage);

      // 立即顯示動畫
      setTimeout(() => {
        newMessage.style.transition = 'all 0.3s ease';
        newMessage.style.opacity = '1';
        newMessage.style.transform = 'translateY(0)';
      }, 10);

      // 滾動到底部
      setTimeout(() => {
        const scrollable = document.getElementById('message-detail-scrollable');
        if (scrollable) {
          scrollable.scrollTo({
            top: scrollable.scrollHeight,
            behavior: 'smooth',
          });
        }
      }, 100);
    }

    // 保存到資料庫
    await saveUserMessageToDB(imageMessage);

    console.log('✅ 圖片消息已添加到佇列，等待發送');
  }

  // 用戶已發送的訊息佇列（等待AI回復）
  let userMessageQueue = [];

  // 表情包管理
  let userStickers = [];
  let currentStickerTab = 'frequent'; // 'frequent' | 'all'

  // 載入用戶表情包
  async function loadUserStickers() {
    try {
      const xDb = getXDB();
      const accountId = currentAccountId || 'main';
      const stickerDataId = `userStickers_${accountId}`;
      const stickerData = await xDb.xUserTweets.get(stickerDataId);

      if (stickerData && stickerData.stickers) {
        userStickers = stickerData.stickers;
        // 確保每個表情包都有使用統計
        userStickers = userStickers.map(sticker => ({
          ...sticker,
          useCount: sticker.useCount || 0,
          lastUsedAt: sticker.lastUsedAt || null,
        }));
      } else {
        userStickers = [];
      }
    } catch (error) {
      console.error('載入表情包失敗:', error);
      userStickers = [];
    }
  }

  // 保存用戶表情包
  async function saveUserStickers() {
    try {
      const xDb = getXDB();
      const accountId = currentAccountId || 'main';
      const stickerDataId = `userStickers_${accountId}`;

      await xDb.xUserTweets.put({
        id: stickerDataId,
        stickers: userStickers,
        updatedAt: new Date().toISOString(),
      });

      console.log('✅ 表情包已保存');
    } catch (error) {
      console.error('保存表情包失敗:', error);
    }
  }

  // 打開表情包選擇器
  window.openStickerPicker = async function () {
    await loadUserStickers();
    currentStickerTab = 'frequent';
    updateStickerTabUI();
    renderStickerList();

    const modal = document.getElementById('sticker-picker-modal');
    if (modal) {
      modal.style.display = 'flex';
    }
  };

  // 切換表情包標籤
  window.switchStickerTab = function (tab) {
    currentStickerTab = tab;
    updateStickerTabUI();
    renderStickerList();
  };

  // 更新標籤UI
  function updateStickerTabUI() {
    const frequentTab = document.getElementById('sticker-tab-frequent');
    const allTab = document.getElementById('sticker-tab-all');

    if (currentStickerTab === 'frequent') {
      frequentTab.style.borderBottomColor = 'var(--x-accent)';
      frequentTab.style.color = 'var(--x-text-primary)';
      allTab.style.borderBottomColor = 'transparent';
      allTab.style.color = 'var(--x-text-secondary)';
    } else {
      frequentTab.style.borderBottomColor = 'transparent';
      frequentTab.style.color = 'var(--x-text-secondary)';
      allTab.style.borderBottomColor = 'var(--x-accent)';
      allTab.style.color = 'var(--x-text-primary)';
    }
  }

  // 關閉表情包選擇器
  window.closeStickerPicker = function () {
    const modal = document.getElementById('sticker-picker-modal');
    if (modal) {
      modal.style.display = 'none';
    }
  };

  // 渲染表情包列表
  function renderStickerList() {
    const listContainer = document.getElementById('sticker-list');
    if (!listContainer) return;

    // 根據螢幕寬度動態調整網格列寬
    const screenWidth = window.innerWidth;
    let minColumnWidth = '80px';
    if (screenWidth < 400) {
      minColumnWidth = '70px'; // 小螢幕
    } else if (screenWidth < 500) {
      minColumnWidth = '75px'; // 中等螢幕
    }
    listContainer.style.gridTemplateColumns = `repeat(auto-fill, minmax(${minColumnWidth}, 1fr))`;

    listContainer.innerHTML = '';

    // 獲取要顯示的表情包
    let displayStickers = [];

    if (currentStickerTab === 'frequent') {
      // 常用：取使用次數 > 0 的，按使用次數和最近使用時間排序
      const frequentStickers = userStickers
        .filter(s => s.useCount > 0)
        .sort((a, b) => {
          // 優先按使用次數排序
          if (b.useCount !== a.useCount) {
            return b.useCount - a.useCount;
          }
          // 使用次數相同，按最近使用時間排序
          if (a.lastUsedAt && b.lastUsedAt) {
            return new Date(b.lastUsedAt) - new Date(a.lastUsedAt);
          }
          return 0;
        })
        .slice(0, 20); // 最多顯示20個常用表情包

      displayStickers = frequentStickers;

      if (frequentStickers.length === 0) {
        listContainer.style.display = 'flex';
        listContainer.innerHTML = `
          <div style="
            width: 100%;
            text-align: center;
            padding: 60px 20px;
            color: var(--x-text-secondary);
          ">
            <div style="font-size: 48px; margin-bottom: 12px;">😊</div>
            <div style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">暫無常用表情包</div>
            <div style="font-size: 13px;">使用過的表情包會出現在這裡</div>
          </div>
        `;
        return;
      } else {
        listContainer.style.display = 'grid';
      }
    } else {
      // 全部：按添加時間倒序
      displayStickers = [...userStickers].reverse();

      if (userStickers.length === 0) {
        listContainer.style.display = 'flex';
        listContainer.innerHTML = `
          <div style="
            width: 100%;
            text-align: center;
            padding: 60px 20px;
            color: var(--x-text-secondary);
          ">
            <div style="font-size: 48px; margin-bottom: 12px;">📦</div>
            <div style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">暫無表情包</div>
            <div style="font-size: 13px;">點擊下方"導入表情包"添加</div>
          </div>
        `;
        return;
      } else {
        listContainer.style.display = 'grid';
      }
    }

    displayStickers.forEach((sticker, displayIndex) => {
      // 找到原始索引
      const originalIndex = userStickers.findIndex(s => s.url === sticker.url && s.description === sticker.description);
      const stickerEl = document.createElement('div');
      stickerEl.style.cssText = `
        position: relative;
        cursor: pointer;
        border-radius: 8px;
        overflow: hidden;
        transition: transform 0.2s;
        width: 100%;
        padding-bottom: 100%;
        background-color: var(--x-bg-secondary);
      `;
      stickerEl.onmouseover = () => {
        stickerEl.style.transform = 'scale(1.05)';
      };
      stickerEl.onmouseout = () => {
        stickerEl.style.transform = 'scale(1)';
      };
      stickerEl.onclick = () => {
        sendStickerMessage(sticker);
        closeStickerPicker();
      };

      stickerEl.innerHTML = `
        <div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center;">
          <img src="${sticker.url}" alt="${sticker.description}" 
            style="width: 100%; height: 100%; object-fit: cover; display: block;"
            onerror="this.parentElement.innerHTML='<div style=\\'display: flex; flex-direction: column; align-items: center; justify-content: center; width: 100%; height: 100%; background-color: var(--x-bg-secondary); color: var(--x-text-secondary); font-size: 11px; padding: 4px; text-align: center;\\'>❌<br>載入失敗<br><button onclick=\\'deleteSticker(${originalIndex})\\' style=\\'margin-top: 4px; padding: 2px 6px; font-size: 10px; background: var(--x-accent); color: white; border: none; border-radius: 4px; cursor: pointer;\\'>刪除</button></div>';">
        </div>
        <button onclick="deleteSticker(${originalIndex}); event.stopPropagation();" 
          ontouchstart="this.style.opacity='1'" 
          style="
          position: absolute;
          top: 4px;
          right: 4px;
          background: rgba(0,0,0,0.7);
          border: none;
          border-radius: 50%;
          width: 24px;
          height: 24px;
          color: #fff;
          cursor: pointer;
          display: flex;
          align-items: center;
          justify-content: center;
          padding: 0;
          opacity: 0;
          transition: opacity 0.2s;
          z-index: 2;
        " onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0'">
          <svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: #fff;">
            <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
          </svg>
        </button>
      `;

      listContainer.appendChild(stickerEl);
    });
  }

  // 刪除表情包
  window.deleteSticker = async function (index) {
    if (confirm('確定要刪除這個表情包嗎？')) {
      userStickers.splice(index, 1);
      await saveUserStickers();

      // 如果管理器打開，更新管理器
      const managerDialog = document.getElementById('sticker-manager-dialog');
      if (managerDialog && managerDialog.style.display === 'flex') {
        renderStickerManager();
      }

      // 如果選擇器打開，更新選擇器
      const pickerModal = document.getElementById('sticker-picker-modal');
      if (pickerModal && pickerModal.style.display === 'flex') {
        renderStickerList();
      }

      showXToast('已刪除', 'success');
    }
  };

  // 打開添加表情包對話方塊
  window.openAddStickerDialog = function () {
    const dialog = document.getElementById('add-sticker-dialog');
    if (dialog) {
      dialog.style.display = 'flex';
      // 清空輸入框
      const batchInput = document.getElementById('sticker-batch-input');
      if (batchInput) {
        batchInput.value = '';
      }
    }
  };

  // 關閉添加表情包對話方塊
  window.closeAddStickerDialog = function () {
    const dialog = document.getElementById('add-sticker-dialog');
    if (dialog) {
      dialog.style.display = 'none';
    }
  };

  // ============================================
  // 語音訊息功能
  // ============================================

  // 打開語音訊息對話方塊
  window.openVoiceMessageDialog = function () {
    const dialog = document.getElementById('voice-message-dialog');
    if (dialog) {
      dialog.style.display = 'flex';
      // 清空輸入框
      const textInput = document.getElementById('voice-message-text-input');
      if (textInput) {
        textInput.value = '';
        textInput.focus();
      }
    }
  };

  // 關閉語音訊息對話方塊
  window.closeVoiceMessageDialog = function () {
    const dialog = document.getElementById('voice-message-dialog');
    if (dialog) {
      dialog.style.display = 'none';
    }
  };

  // 發送語音訊息
  window.sendVoiceMessage = function () {
    const textInput = document.getElementById('voice-message-text-input');
    if (!textInput) return;

    const voiceText = textInput.value.trim();
    if (!voiceText) {
      showXToast('請輸入語音內容', 'error');
      return;
    }

    // 估算語音時長（假設每10個字元約1秒）
    const estimatedDuration = Math.max(5, Math.ceil(voiceText.length / 10));
    const minutes = Math.floor(estimatedDuration / 60);
    const seconds = estimatedDuration % 60;
    const durationStr =
      minutes > 0 ? `${minutes}:${String(seconds).padStart(2, '0')}` : `0:${String(seconds).padStart(2, '0')}`;

    // 創建語音訊息對象
    const now = new Date();
    const hours = now.getHours();
    const minutesNow = String(now.getMinutes()).padStart(2, '0');
    const period = hours >= 12 ? '下午' : '上午';
    const timeStr = `${hours > 12 ? hours - 12 : hours}:${minutesNow} ${period}`;

    const voiceMessage = {
      type: 'voice',
      voiceText: voiceText,
      duration: durationStr,
      time: timeStr,
      timestamp: now.toISOString(),
      isOwn: true,
    };

    // 添加到訊息佇列
    userMessageQueue.push(voiceMessage);

    // 渲染到介面
    const contentContainer = document.getElementById('message-detail-content');
    if (contentContainer) {
      const messageEl = renderMessageItem(voiceMessage, true, undefined, true, true);
      contentContainer.appendChild(messageEl);

      // 動畫顯示
      requestAnimationFrame(() => {
        messageEl.style.opacity = '1';
        messageEl.style.transform = 'translateY(0)';
      });

      // 滾動到底部
      setTimeout(() => {
        const scrollable = document.getElementById('message-detail-scrollable');
        if (scrollable) {
          scrollable.scrollTop = scrollable.scrollHeight;
        }
      }, 100);
    }

    // 保存到資料庫
    saveUserMessageToDB(voiceMessage);

    // 關閉對話方塊
    closeVoiceMessageDialog();

    console.log('✅ [語音訊息] 已添加到佇列:', voiceMessage);
  };

  // 打開表情包管理器
  window.openStickerManager = async function () {
    await loadUserStickers();
    renderStickerManager();

    const dialog = document.getElementById('sticker-manager-dialog');
    if (dialog) {
      dialog.style.display = 'flex';
    }
  };

  // 關閉表情包管理器
  window.closeStickerManager = function () {
    const dialog = document.getElementById('sticker-manager-dialog');
    if (dialog) {
      dialog.style.display = 'none';
    }
  };

  // 渲染表情包管理器列表
  function renderStickerManager() {
    const listContainer = document.getElementById('sticker-manager-list');
    if (!listContainer) return;

    listContainer.innerHTML = '';

    if (userStickers.length === 0) {
      listContainer.innerHTML = `
        <div style="text-align: center; padding: 40px 20px; color: var(--x-text-secondary);">
          <div style="font-size: 14px;">暫無表情包</div>
        </div>
      `;
      return;
    }

    userStickers.forEach((sticker, index) => {
      const itemEl = document.createElement('div');
      itemEl.style.cssText = `
        padding: 12px;
        margin-bottom: 8px;
        background-color: var(--x-bg-secondary);
        border-radius: 8px;
        display: flex;
        gap: 12px;
        align-items: flex-start;
      `;

      itemEl.innerHTML = `
        <img src="${sticker.url}" 
          style="width: 60px; height: 60px; object-fit: cover; border-radius: 6px; flex-shrink: 0;"
          onerror="this.src=''; this.style.background='var(--x-bg-hover)'; this.style.display='flex'; this.style.alignItems='center'; this.style.justifyContent='center';">
        <div style="flex: 1; min-width: 0;">
          <div style="font-size: 14px; font-weight: 600; color: var(--x-text-primary); margin-bottom: 4px;">
            ${sticker.description}
          </div>
          <div style="font-size: 12px; color: var(--x-text-secondary); word-break: break-all; margin-bottom: 4px;">
            ${sticker.url}
          </div>
          <div style="font-size: 11px; color: var(--x-text-secondary);">
            使用次數: ${sticker.useCount || 0} 
            ${sticker.lastUsedAt ? `· 最後使用: ${new Date(sticker.lastUsedAt).toLocaleString('zh-CN')}` : ''}
          </div>
        </div>
        <button onclick="editSticker(${index}); event.stopPropagation();" style="
          background-color: var(--x-bg-hover);
          color: var(--x-text-primary);
          border: none;
          border-radius: 6px;
          padding: 6px 12px;
          font-size: 12px;
          cursor: pointer;
          flex-shrink: 0;
        ">編輯</button>
        <button onclick="deleteSticker(${index}); event.stopPropagation();" style="
          background-color: rgba(239, 68, 68, 0.1);
          color: rgb(239, 68, 68);
          border: none;
          border-radius: 6px;
          padding: 6px 12px;
          font-size: 12px;
          cursor: pointer;
          flex-shrink: 0;
        ">刪除</button>
      `;

      listContainer.appendChild(itemEl);
    });
  }

  // 編輯表情包
  window.editSticker = function (index) {
    const sticker = userStickers[index];
    if (!sticker) return;

    const newDescription = prompt('修改描述:', sticker.description);
    if (newDescription === null) return;

    const newUrl = prompt('修改連結:', sticker.url);
    if (newUrl === null) return;

    // 驗證URL
    try {
      const urlObj = new URL(newUrl.trim());
      userStickers[index].description = newDescription.trim();
      userStickers[index].url = urlObj.href;

      saveUserStickers().then(() => {
        renderStickerManager();
        showXToast('修改成功', 'success');
      });
    } catch (e) {
      showXToast('連結格式無效', 'error');
    }
  };

  // 清空所有表情包
  window.clearAllStickers = async function () {
    if (!confirm(`確定要清空所有 ${userStickers.length} 個表情包嗎？此操作不可恢復！`)) {
      return;
    }

    userStickers = [];
    await saveUserStickers();
    renderStickerManager();
    renderStickerList();
    showXToast('已清空所有表情包', 'success');
  };

  // 批量添加表情包
  window.batchAddStickers = async function () {
    const batchInput = document.getElementById('sticker-batch-input');
    const text = batchInput ? batchInput.value.trim() : '';

    if (!text) {
      showXToast('請輸入表情包資訊', 'error');
      return;
    }

    // 解析每一行
    const lines = text.split('\n').filter(line => line.trim());
    const newStickers = [];
    const errors = [];

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();

      // 使用更嚴格的正則匹配：描述 + 連結
      // 匹配完整的URL，包括協定、功能變數名稱、路徑
      const urlMatch = line.match(/(https?:\/\/[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}(?:\/[^\s]*)?)/);

      if (!urlMatch) {
        errors.push(`第${i + 1}行：未找到有效連結`);
        continue;
      }

      let url = urlMatch[0].trim();
      const description = line.substring(0, urlMatch.index).trim();

      if (!description) {
        errors.push(`第${i + 1}行：缺少描述`);
        continue;
      }

      // 驗證URL格式
      try {
        const urlObj = new URL(url);
        // 確保URL包含協定和主機
        if (!urlObj.protocol || !urlObj.host) {
          errors.push(`第${i + 1}行：連結格式無效`);
          continue;
        }
        // 使用標準化的URL
        url = urlObj.href;
      } catch (e) {
        errors.push(`第${i + 1}行：連結格式無效 - ${e.message}`);
        continue;
      }

      // 驗證是否為圖片連結（可選）
      const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp', '.svg'];
      const hasImageExtension = imageExtensions.some(ext => url.toLowerCase().includes(ext));
      if (!hasImageExtension) {
        // 警告但不阻止
        console.warn(`第${i + 1}行：連結可能不是圖片格式，但仍會導入`);
      }

      // 檢查是否重複
      const isDuplicate = userStickers.some(s => s.url === url);
      if (isDuplicate) {
        errors.push(`第${i + 1}行：該表情包已存在`);
        continue;
      }

      newStickers.push({
        description,
        url,
        useCount: 0,
        lastUsedAt: null,
        createdAt: new Date().toISOString(),
      });
    }

    if (newStickers.length === 0) {
      if (errors.length > 0) {
        showXToast(errors.join('\n'), 'error');
      } else {
        showXToast('沒有可導入的表情包', 'error');
      }
      return;
    }

    // 添加到表情包列表
    userStickers.push(...newStickers);
    await saveUserStickers();
    renderStickerList();
    closeAddStickerDialog();

    let message = `成功導入${newStickers.length}個表情包`;
    if (errors.length > 0) {
      message += `，${errors.length}個失敗`;
    }
    showXToast(message, 'success');
  };

  // 發送表情包消息（立即顯示，但不觸發AI回復）
  async function sendStickerMessage(sticker) {
    // 🔒 檢查拉黑狀態
    const blockCheck = await checkIfBlocked();
    if (blockCheck.isBlocked) {
      showXToast('對方已將你拉黑，無法發送消息', 'error');
      return;
    }
    if (blockCheck.error) {
      showXToast(blockCheck.error, 'error');
      return;
    }

    // 更新使用統計
    const stickerIndex = userStickers.findIndex(s => s.url === sticker.url && s.description === sticker.description);

    if (stickerIndex !== -1) {
      userStickers[stickerIndex].useCount = (userStickers[stickerIndex].useCount || 0) + 1;
      userStickers[stickerIndex].lastUsedAt = new Date().toISOString();
      await saveUserStickers();
    }

    // 獲取當前時間
    const now = new Date();
    const hours = now.getHours();
    const minutes = String(now.getMinutes()).padStart(2, '0');
    const period = hours >= 12 ? '下午' : '上午';
    const timeStr = `${hours > 12 ? hours - 12 : hours}:${minutes} ${period}`;

    // 創建表情包消息物件（發送描述給AI）
    const stickerMessage = {
      type: 'sticker',
      stickerDescription: sticker.description, // 描述給AI識別
      stickerUrl: sticker.url, // URL用於顯示
      time: timeStr,
      timestamp: now.toISOString(),
      isOwn: true,
    };

    // 添加到訊息佇列
    userMessageQueue.push(stickerMessage);

    // 渲染新消息
    const contentContainer = document.getElementById('message-detail-content');
    if (contentContainer) {
      const currentMessageCount = contentContainer.querySelectorAll('.message-item:not(#typing-indicator)').length;
      const newMessage = renderMessageItem(stickerMessage, true, currentMessageCount, true);
      contentContainer.appendChild(newMessage);

      // 立即顯示動畫
      setTimeout(() => {
        newMessage.style.transition = 'all 0.3s ease';
        newMessage.style.opacity = '1';
        newMessage.style.transform = 'translateY(0)';
      }, 10);

      // 滾動到底部
      setTimeout(() => {
        const scrollable = document.getElementById('message-detail-scrollable');
        if (scrollable) {
          scrollable.scrollTo({
            top: scrollable.scrollHeight,
            behavior: 'smooth',
          });
        }
      }, 100);
    }

    // 保存到資料庫
    await saveUserMessageToDB(stickerMessage);

    console.log('✅ 表情包消息已添加到佇列，等待發送');
  }

  // 🔒 檢查拉黑狀態（通用函數）
  async function checkIfBlocked() {
    if (!currentMessageConversation) {
      return { isBlocked: false, error: '會話資料丟失' };
    }

    try {
      const xDb = getXDB();
      const conversationId = `messageConversation_${currentAccountId || 'main'}_${currentMessageConversation.id}`;
      const savedConversation = await xDb.xAccountProfiles.get(conversationId);

      if (savedConversation && savedConversation.isBlocked) {
        console.log('⚠️ [拉黑] 對方已拉黑使用者，禁止發送消息');

        // 確保輸入框被禁用
        const input = document.getElementById('message-input');
        const sendBtn = document.getElementById('message-send-btn');
        if (input) {
          input.disabled = true;
          input.placeholder = '對方已將你拉黑';
        }
        if (sendBtn) {
          sendBtn.disabled = true;
        }

        return { isBlocked: true };
      }

      return { isBlocked: false };
    } catch (error) {
      console.error('檢查拉黑狀態失敗:', error);
      return { isBlocked: false, error: error.message };
    }
  }

  // 發送使用者消息
  window.sendMessageContent = async function () {
    const input = document.getElementById('message-input');
    if (!input) return;

    const content = input.value.trim();
    if (!content) return;

    // 🔒 檢查拉黑狀態
    const blockCheck = await checkIfBlocked();
    if (blockCheck.isBlocked) {
      showXToast('對方已將你拉黑，無法發送消息', 'error');
      return;
    }
    if (blockCheck.error) {
      showXToast(blockCheck.error, 'error');
      return;
    }

    // 獲取當前時間
    const now = new Date();
    const hours = now.getHours();
    const minutes = String(now.getMinutes()).padStart(2, '0');
    const period = hours >= 12 ? '下午' : '上午';
    const timeStr = `${hours > 12 ? hours - 12 : hours}:${minutes} ${period}`;

    // 創建使用者消息物件
    const userMessage = {
      type: 'text',
      content: content,
      time: timeStr,
      timestamp: now.toISOString(),
      isOwn: true,
    };

    // 添加到訊息佇列
    userMessageQueue.push(userMessage);

    // 渲染新消息
    const contentContainer = document.getElementById('message-detail-content');
    if (contentContainer) {
      // 獲取當前消息總數作為新消息的索引（排除typing-indicator）
      const currentMessageCount = contentContainer.querySelectorAll('.message-item:not(#typing-indicator)').length;

      // 檢查最後一條消息是否也是使用者發送的
      const allMessages = Array.from(contentContainer.querySelectorAll('.message-item:not(#typing-indicator)'));
      const lastMessage = allMessages[allMessages.length - 1];
      const isLastMessageOwn =
        lastMessage?.querySelector('[data-message-index]')?.closest('.message-item')?.style.alignItems === 'flex-end';

      // 如果最後一條也是使用者消息，則當前消息不是最後一條（需要去掉尾巴）
      const newMessage = renderMessageItem(userMessage, true, currentMessageCount, true);
      contentContainer.appendChild(newMessage);

      // 立即顯示動畫
      setTimeout(() => {
        newMessage.style.transition = 'all 0.3s ease';
        newMessage.style.opacity = '1';
        newMessage.style.transform = 'translateY(0)';
      }, 10);

      // 滾動到底部（使用外層可滾動容器）
      setTimeout(() => {
        const scrollable = document.getElementById('message-detail-scrollable');
        if (scrollable) {
          scrollable.scrollTo({
            top: scrollable.scrollHeight,
            behavior: 'smooth',
          });
        }
      }, 100);
    }

    // 清空輸入框
    input.value = '';
    autoResizeMessageInput(input);

    // 保存到資料庫
    await saveUserMessageToDB(userMessage);

    console.log('✅ 使用者消息已發送並保存:', content);
  };

  // 保存使用者消息到資料庫
  async function saveUserMessageToDB(userMessage) {
    if (!currentMessageConversation) return;

    try {
      const xDb = getXDB();
      // 🔧 多帳戶隔離：包含帳戶ID
      const conversationId = `messageConversation_${currentAccountId || 'main'}_${currentMessageConversation.id}`;

      // 讀取現有對話資料
      let savedConversation = await xDb.xAccountProfiles.get(conversationId);

      if (savedConversation && savedConversation.data) {
        // 添加使用者消息到messages陣列
        if (!savedConversation.data.messages) {
          savedConversation.data.messages = [];
        }
        // 標記消息為等待AI回復狀態
        userMessage.waitingForAIResponse = true;
        savedConversation.data.messages.push(userMessage);

        // 更新資料庫
        savedConversation.updatedAt = new Date().toISOString();
        await xDb.xAccountProfiles.put(savedConversation);

        console.log('✅ 使用者消息已保存到資料庫（更新）');

        // 重置該角色的自動發消息觸發記錄
        const messageId = currentMessageConversation.id;
        if (messageId && messageId.startsWith('msg_') && !messageId.startsWith('msg_account_')) {
          const characterId = messageId.replace('msg_', '');
          if (typeof window.resetAutoMessageTrigger === 'function') {
            window.resetAutoMessageTrigger(characterId);
          }
        }

        // 清除該私信的未讀標記（使用者回復了）
        try {
          const dataId = `messagesList_${currentAccountId || 'main'}`;
          const messagesListData = await xDb.xAccountProfiles.get(dataId);

          if (messagesListData && messagesListData.data) {
            const messagesList = messagesListData.data;
            const msgIndex = messagesList.findIndex(msg => msg.id === messageId);

            if (msgIndex !== -1 && messagesList[msgIndex].unread) {
              messagesList[msgIndex].unread = false;
              messagesList[msgIndex].unreadCount = 0;

              await xDb.xAccountProfiles.put({
                handle: dataId,
                name: 'messagesList',
                data: messagesList,
                updatedAt: new Date().toISOString(),
              });

              // 同步更新全域資料
              sampleMessagesData = messagesList;

              console.log('✅ 已清除未讀標記（使用者回復）');
            }
          }
        } catch (error) {
          console.error('清除未讀標記失敗:', error);
        }
      } else {
        // 首次發送消息，創建新的對話記錄
        console.log('📨 創建新的對話記錄');

        const newConversation = {
          handle: conversationId,
          name: 'messageConversation',
          data: {
            messages: [userMessage],
          },
          messageId: currentMessageConversation.id,
          updatedAt: new Date().toISOString(),
        };

        await xDb.xAccountProfiles.put(newConversation);
        console.log('✅ 使用者消息已保存到資料庫（新建）');

        // 重置該角色的自動發消息觸發記錄
        const messageId = currentMessageConversation.id;
        if (messageId && messageId.startsWith('msg_') && !messageId.startsWith('msg_account_')) {
          const characterId = messageId.replace('msg_', '');
          if (typeof window.resetAutoMessageTrigger === 'function') {
            window.resetAutoMessageTrigger(characterId);
          }
        }
      }
    } catch (error) {
      console.error('保存使用者消息失敗:', error);
    }
  }

  // 獲取AI回復
  // 重新生成AI回復
  window.regenerateAIResponse = async function () {
    if (!currentMessageConversation) {
      showXToast('會話資料丟失', 'error');
      return;
    }

    try {
      const xDb = getXDB();
      // 🔧 多帳戶隔離：包含帳戶ID
      const conversationId = `messageConversation_${currentAccountId || 'main'}_${currentMessageConversation.id}`;
      const savedConversation = await xDb.xAccountProfiles.get(conversationId);

      if (!savedConversation || !savedConversation.data || !savedConversation.data.messages) {
        showXToast('沒有對話記錄', 'error');
        return;
      }

      const messages = savedConversation.data.messages;

      // 找到最後一個使用者消息的索引
      let lastUserMessageIndex = -1;
      for (let i = messages.length - 1; i >= 0; i--) {
        if (messages[i].isOwn === true) {
          lastUserMessageIndex = i;
          break;
        }
      }

      if (lastUserMessageIndex === -1) {
        showXToast('沒有找到使用者消息', 'error');
        return;
      }

      // 獲取使用者發送的消息（用於重新生成）
      const userMessages = [];
      for (let i = lastUserMessageIndex; i < messages.length && messages[i].isOwn === true; i++) {
        userMessages.push(messages[i]);
      }

      // 刪除最後一批AI回復
      const newMessages = messages.slice(0, lastUserMessageIndex + userMessages.length);
      savedConversation.data.messages = newMessages;

      // 保存更新後的對話
      await xDb.xAccountProfiles.put(savedConversation);

      // 重新渲染消息清單
      const contentContainer = document.getElementById('message-detail-content');
      if (contentContainer) {
        contentContainer.innerHTML = '';

        // 渲染日期分隔符號
        const today = new Date();
        const dateStr =
          currentLanguage === 'en'
            ? today.toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' })
            : `${today.getFullYear()}年${today.getMonth() + 1}月${String(today.getDate()).padStart(2, '0')}日`;
        contentContainer.appendChild(renderDateSeparator(dateStr));

        // 使用分組渲染消息
        const groups = groupMessagesBySender(newMessages);
        const allMessageElements = [];

        groups.forEach(group => {
          const isOwn = group[0].message.isOwn === true;
          group.forEach((item, indexInGroup) => {
            const isLastInGroup = indexInGroup === group.length - 1;
            const messageEl = renderMessageItem(item.message, isOwn, item.index, isLastInGroup);
            contentContainer.appendChild(messageEl);
            allMessageElements.push(messageEl);
          });
        });

        // 立即顯示所有消息（歷史消息不需要動畫）
        allMessageElements.forEach(el => {
          el.style.opacity = '1';
          el.style.transform = 'translateY(0)';
        });

        // 滾動到底部
        setTimeout(() => {
          const scrollable = document.getElementById('message-detail-scrollable');
          if (scrollable) {
            scrollable.scrollTop = scrollable.scrollHeight;
          }
        }, 100);
      }

      // 設置用戶訊息佇列
      userMessageQueue = userMessages;

      // 自動觸發AI回復
      setTimeout(() => {
        getAIResponse();
      }, 500);
    } catch (error) {
      console.error('重新生成失敗:', error);
      showXToast('重新生成失敗', 'error');
    }
  };

  window.getAIResponse = async function () {
    // 檢查是否有待回復的使用者消息
    if (userMessageQueue.length === 0) {
      showXToast('請先發送消息', 'info');
      return;
    }

    if (!currentMessageConversation) {
      showXToast('會話資料丟失', 'error');
      return;
    }

    // 保存當前會話引用，防止使用者關閉頁面後丟失
    const conversationRef = currentMessageConversation;

    // 禁用發送按鈕
    const sendBtn = document.getElementById('message-send-btn');
    if (sendBtn) {
      sendBtn.disabled = true;
      sendBtn.style.opacity = '0.5';
    }

    try {
      // 顯示"正在輸入中"氣泡
      console.log('📤 [AI回復] 準備顯示正在輸入氣泡');
      showTypingIndicator();

      // 調用AI生成回復（續寫模式，傳遞使用者訊息佇列用於識圖）
      console.log('📤 [AI回復] 開始請求AI生成回復');
      const aiMessages = await generateMessageConversation(conversationRef, true, {
        userMessages: userMessageQueue,
      });
      console.log('📥 [AI回復] AI回復已返回');

      // 隱藏"正在輸入中"氣泡
      hideTypingIndicator();

      // 🔍 檢查特殊系統提示
      const hasBlockedMessage =
        aiMessages && aiMessages.some(msg => msg.type === 'system' && msg.systemType === 'blocked');
      const hasUnblockedMessage =
        aiMessages && aiMessages.some(msg => msg.type === 'system' && msg.systemType === 'unblocked');
      const hasAwayMessage = aiMessages && aiMessages.some(msg => msg.type === 'system' && msg.systemType === 'away');

      // 🎉 處理解除拉黑情況
      if (hasUnblockedMessage) {
        console.log('🎉 [拉黑解除] 對方已解除拉黑');

        // 解除拉黑狀態
        try {
          const xDb = getXDB();
          const conversationId = `messageConversation_${currentAccountId || 'main'}_${conversationRef.id}`;
          const savedConversation = await xDb.xAccountProfiles.get(conversationId);

          if (savedConversation) {
            savedConversation.isBlocked = false;
            delete savedConversation.blockedAt;
            await xDb.xAccountProfiles.put(savedConversation);
            console.log('✅ [拉黑解除] 拉黑狀態已解除');
          }
        } catch (error) {
          console.error('❌ [拉黑解除] 解除拉黑狀態失敗:', error);
        }

        // 啟用輸入框和發送按鈕
        const messageInput = document.getElementById('message-input');
        const sendBtn = document.getElementById('message-send-btn');
        if (messageInput) {
          messageInput.disabled = false;
          messageInput.placeholder = '發送私信';
        }
        if (sendBtn) {
          sendBtn.disabled = false;
        }

        // 顯示解除拉黑系統消息
        const unblockedMessage = aiMessages.find(msg => msg.type === 'system' && msg.systemType === 'unblocked');
        if (unblockedMessage) {
          const contentContainer = document.getElementById('message-detail-content');
          if (contentContainer) {
            const currentMessageCount = contentContainer.querySelectorAll(
              '.message-item:not(#typing-indicator)',
            ).length;
            const messageEl = renderMessageItem(unblockedMessage, false, currentMessageCount, true);
            contentContainer.appendChild(messageEl);
            requestAnimationFrame(() => {
              messageEl.style.opacity = '1';
              messageEl.style.transform = 'translateY(0)';
            });
          }
        }

        // 顯示其他AI消息（解除拉黑後可能跟隨的文本消息）
        const otherMessages = aiMessages.filter(msg => msg.type !== 'system' || msg.systemType !== 'unblocked');
        if (otherMessages.length > 0) {
          const contentContainer = document.getElementById('message-detail-content');
          if (contentContainer) {
            let currentMessageCount = contentContainer.querySelectorAll('.message-item:not(#typing-indicator)').length;

            otherMessages.forEach((msg, index) => {
              const messageEl = renderMessageItem(
                msg,
                false,
                currentMessageCount + index,
                index === otherMessages.length - 1,
              );
              contentContainer.appendChild(messageEl);
              requestAnimationFrame(() => {
                messageEl.style.opacity = '1';
                messageEl.style.transform = 'translateY(0)';
              });
            });
          }
          await saveAIMessagesToDB(aiMessages, conversationRef);
        } else {
          // 只有系統提示，也要保存
          await saveAIMessagesToDB(aiMessages, conversationRef);
        }

        // 顯示解除拉黑通知
        const isEnglish = currentLanguage === 'en';
        showPhoneNotification({
          title: conversationRef.userName || conversationRef.user?.name || '未知用戶',
          message: isEnglish ? 'Has unblocked you' : '已解除拉黑',
          avatar:
            conversationRef.userAvatar ||
            conversationRef.user?.avatar ||
            'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg',
          leftIcon: 'x',
          duration: 3000,
        });

        userMessageQueue = [];

        // 滾動到底部
        const scrollable = document.getElementById('message-detail-scrollable');
        if (scrollable) {
          setTimeout(() => {
            scrollable.scrollTop = scrollable.scrollHeight;
          }, 100);
        }

        return;
      }

      // ⚠️ 處理拉黑情況
      if (hasBlockedMessage) {
        console.log('⚠️ [拉黑] 對方已將用戶拉黑');

        // 保存拉黑狀態到對話資料
        try {
          const xDb = getXDB();
          const conversationId = `messageConversation_${currentAccountId || 'main'}_${conversationRef.id}`;
          const savedConversation = await xDb.xAccountProfiles.get(conversationId);

          if (savedConversation) {
            savedConversation.isBlocked = true;
            savedConversation.blockedAt = new Date().toISOString();
            await xDb.xAccountProfiles.put(savedConversation);
            console.log('✅ [拉黑] 拉黑狀態已保存');
          }
        } catch (error) {
          console.error('❌ [拉黑] 保存拉黑狀態失敗:', error);
        }

        // 禁用輸入框和發送按鈕
        const messageInput = document.getElementById('message-input');
        const sendBtn = document.getElementById('message-send-btn');
        if (messageInput) {
          messageInput.disabled = true;
          messageInput.placeholder = '對方已將你拉黑';
        }
        if (sendBtn) {
          sendBtn.disabled = true;
        }

        // 顯示拉黑消息並保存
        if (aiMessages && aiMessages.length > 0) {
          const contentContainer = document.getElementById('message-detail-content');
          if (contentContainer) {
            const currentMessageCount = contentContainer.querySelectorAll(
              '.message-item:not(#typing-indicator)',
            ).length;
            const messageEl = renderMessageItem(aiMessages[0], false, currentMessageCount, true);
            contentContainer.appendChild(messageEl);
            requestAnimationFrame(() => {
              messageEl.style.opacity = '1';
              messageEl.style.transform = 'translateY(0)';
            });
          }
          await saveAIMessagesToDB(aiMessages, conversationRef);
        }

        // 顯示拉黑通知
        const isEnglish = currentLanguage === 'en';
        showPhoneNotification({
          title: 'X',
          message: isEnglish ? 'You have been blocked by this user' : '對方已將你拉黑',
          leftIcon: 'x',
          duration: 3000,
        });

        userMessageQueue = [];

        // 啟用發送按鈕（雖然已禁用輸入框）
        if (sendBtn) {
          sendBtn.disabled = false;
          sendBtn.style.opacity = '1';
        }
        return;
      }

      // ⏰ 處理暫時離開情況
      if (hasAwayMessage) {
        console.log('⏰ [離開] 對方暫時離開');

        const awayMessage = aiMessages.find(msg => msg.type === 'system' && msg.systemType === 'away');
        const awayDuration = awayMessage.awayDuration || 60; // 默認60分鐘

        // 保存離開狀態到對話資料
        try {
          const xDb = getXDB();
          const conversationId = `messageConversation_${currentAccountId || 'main'}_${conversationRef.id}`;
          const savedConversation = await xDb.xAccountProfiles.get(conversationId);

          if (savedConversation) {
            savedConversation.isAway = true;
            savedConversation.awayUntil = new Date(Date.now() + awayDuration * 60 * 1000).toISOString();
            savedConversation.awayDuration = awayDuration;
            await xDb.xAccountProfiles.put(savedConversation);
            console.log(`✅ [離開] 離開狀態已保存，將在${awayDuration}分鐘後恢復`);
          }
        } catch (error) {
          console.error('❌ [離開] 保存離開狀態失敗:', error);
        }

        // 顯示離開消息並保存
        if (aiMessages && aiMessages.length > 0) {
          const contentContainer = document.getElementById('message-detail-content');
          if (contentContainer) {
            const currentMessageCount = contentContainer.querySelectorAll(
              '.message-item:not(#typing-indicator)',
            ).length;
            const messageEl = renderMessageItem(aiMessages[0], false, currentMessageCount, true);
            contentContainer.appendChild(messageEl);
            requestAnimationFrame(() => {
              messageEl.style.opacity = '1';
              messageEl.style.transform = 'translateY(0)';
            });
          }
          await saveAIMessagesToDB(aiMessages, conversationRef);
        }

        // 設置計時器，離開時間結束後觸發自動消息
        setTimeout(() => {
          console.log(`⏰ [離開] 離開時間結束，準備觸發自動消息`);
          // 觸發自動消息機制
          if (typeof triggerAutoMessageAfterAway === 'function') {
            triggerAutoMessageAfterAway(conversationRef.id);
          }
        }, awayDuration * 60 * 1000);

        // 顯示離開通知
        const isEnglish = currentLanguage === 'en';
        showPhoneNotification({
          title: 'X',
          message: awayMessage.content,
          leftIcon: 'x',
          duration: 3000,
        });

        userMessageQueue = [];

        // 恢復發送按鈕
        const sendBtn = document.getElementById('message-send-btn');
        if (sendBtn) {
          sendBtn.disabled = false;
          sendBtn.style.opacity = '1';
        }
        return;
      }

      if (aiMessages && aiMessages.length > 0) {
        // 渲染AI回復（只有在用戶還在詳情頁時才渲染）
        const contentContainer = document.getElementById('message-detail-content');
        if (contentContainer) {
          // 獲取當前消息總數（排除typing-indicator）
          let currentMessageCount = contentContainer.querySelectorAll('.message-item:not(#typing-indicator)').length;

          // 將AI消息分組並標記最後一條
          const messageElements = [];
          const aiMessagesCount = aiMessages.length;

          aiMessages.forEach((message, index) => {
            const isLastMessage = index === aiMessagesCount - 1;
            const messageEl = renderMessageItem(message, false, currentMessageCount, isLastMessage);
            contentContainer.appendChild(messageEl);
            messageElements.push(messageEl);
            currentMessageCount++;
          });

          // 逐條彈出動畫
          await animateMessagesOneByOne(messageElements, 400);
        }

        // 保存AI回復到資料庫（使用保存的引用，即使使用者已離開頁面也能保存）
        await saveAIMessagesToDB(aiMessages, conversationRef);

        // 處理 AI 對用戶轉帳的回應
        await handleAITransferResponse(aiMessages, conversationRef);

        // 清空用戶訊息佇列
        userMessageQueue = [];

        // 立即顯示私信回復通知（不等待New Tweet檢測）
        if (document.getElementById('x-message-detail-page')?.style.display !== 'none') {
          // 在詳情頁內也顯示手機樣式通知
          showMessageNotification(conversationRef.user.name, conversationRef.user.avatar, aiMessages.length);
        } else {
          console.log('✅ AI回復已保存（用戶已離開詳情頁）');

          // 如果使用者不在詳情頁，標記為未讀並顯示提醒
          try {
            const xDb = getXDB();
            const dataId = `messagesList_${currentAccountId || 'main'}`;
            const savedData = await xDb.xAccountProfiles.get(dataId);

            if (savedData && savedData.data) {
              const messagesList = savedData.data;
              const messageIndex = messagesList.findIndex(msg => msg.id === conversationRef.id);

              if (messageIndex !== -1) {
                // 標記為未讀
                messagesList[messageIndex].unread = true;
                messagesList[messageIndex].unreadCount =
                  (messagesList[messageIndex].unreadCount || 0) + aiMessages.length;

                // 保存回資料庫
                await xDb.xAccountProfiles.put({
                  handle: dataId,
                  name: 'messagesList',
                  data: messagesList,
                  updatedAt: new Date().toISOString(),
                });

                // 同步更新全域資料
                sampleMessagesData = messagesList;

                // 顯示手機樣式通知
                showMessageNotification(conversationRef.user.name, conversationRef.user.avatar, aiMessages.length);

                // 顯示私信提醒點
                showNavNotificationDot('messages');

                console.log('✅ 已標記為未讀並顯示提醒');
              }
            }
          } catch (error) {
            console.error('標記未讀失敗:', error);
          }
        }

        // 在所有通知顯示完成後，非同步檢測New Tweet（不阻塞）
        (async () => {
          try {
            const xDb = getXDB();
            // 🔧 多帳戶隔離：包含帳戶ID
            const conversationId = `messageConversation_${currentAccountId || 'main'}_${conversationRef.id}`;
            const savedConversation = await xDb.xAccountProfiles.get(conversationId);

            if (savedConversation && savedConversation.data && savedConversation.data.messages) {
              // 檢測並生成 New Tweet 通知（非同步執行，不阻塞主流程）
              await detectAndGenerateNewTweetNotification(conversationRef, savedConversation.data.messages);
            }
          } catch (error) {
            console.error('New Tweet 檢測失敗:', error);
          }
        })();
      } else {
        // 📭 AI決定不回復（返回空陣列）
        console.log('📭 [不回復] AI決定不回復使用者消息');

        // 顯示發送成功提示
        const isEnglish = currentLanguage === 'en';
        showPhoneNotification({
          title: 'X',
          message: isEnglish ? 'Message delivered' : '消息已送達',
          leftIcon: 'x',
          duration: 2000,
        });

        // 清空用戶訊息佇列
        userMessageQueue = [];
      }
    } catch (error) {
      console.error('獲取AI回復失敗:', error);
      // 隱藏"正在輸入中"氣泡
      hideTypingIndicator();
      if (document.getElementById('x-message-detail-page')?.style.display !== 'none') {
        showXToast(`獲取回復失敗: ${error.message}`, 'error');
      }
    } finally {
      // 恢復發送按鈕（只有在按鈕還存在時）
      if (sendBtn) {
        sendBtn.disabled = false;
        sendBtn.style.opacity = '1';
      }
    }
  };

  // 保存AI回復到資料庫
  async function saveAIMessagesToDB(aiMessages, conversationRef = null) {
    // 使用傳入的引用或全域變數
    const conversation = conversationRef || currentMessageConversation;

    if (!conversation || !aiMessages || aiMessages.length === 0) return;

    try {
      const xDb = getXDB();
      // 🔧 多帳戶隔離：包含帳戶ID
      const conversationId = `messageConversation_${currentAccountId || 'main'}_${conversation.id}`;

      // 讀取現有對話資料
      const savedConversation = await xDb.xAccountProfiles.get(conversationId);

      if (savedConversation && savedConversation.data) {
        // 添加AI消息到messages陣列（添加時間戳記）
        if (!savedConversation.data.messages) {
          savedConversation.data.messages = [];
        }

        // 將所有等待AI回復的使用者消息標記為已回復
        savedConversation.data.messages.forEach(msg => {
          if (msg.isOwn && msg.waitingForAIResponse) {
            msg.waitingForAIResponse = false;
          }
        });

        // 為每條AI消息添加timestamp（如果沒有的話）
        aiMessages.forEach(msg => {
          if (!msg.timestamp) {
            msg.timestamp = new Date().toISOString();
          }
        });

        savedConversation.data.messages.push(...aiMessages);

        // 更新資料庫
        savedConversation.updatedAt = new Date().toISOString();
        await xDb.xAccountProfiles.put(savedConversation);

        console.log('✅ AI回復已保存到資料庫');
      }
    } catch (error) {
      console.error('保存AI回復失敗:', error);
    }
  }

  // 從私信詳情頁打開帳戶主頁
  window.openAccountProfileFromDM = async function (messageData, conversationData) {
    try {
      console.log('🔍 從私信詳情頁打開帳戶主頁:', messageData.user.name);

      // 收集現有資料
      const existingInfo = {
        name: messageData.user.name,
        handle: messageData.user.handle,
        avatar: messageData.user.avatar,
        verified: messageData.user.verified || false,
      };

      // 從conversationData中獲取額外資訊
      if (conversationData && conversationData.senderProfile) {
        if (conversationData.senderProfile.bio) {
          existingInfo.bio = conversationData.senderProfile.bio;
        }
        if (conversationData.senderProfile.followers) {
          existingInfo.followersCount = conversationData.senderProfile.followers.toString();
        }
        if (conversationData.senderProfile.verified !== undefined) {
          existingInfo.verified = conversationData.senderProfile.verified;
        }
      }

      console.log('📋 現有資料:', existingInfo);

      // 切換到帳戶主頁，調用第七個情景
      await openAccountProfile(existingInfo.name, existingInfo.handle, existingInfo.avatar, {
        source: 'dm',
        existingInfo: existingInfo,
        messagePreview: messageData.preview,
      });
    } catch (error) {
      console.error('從私信詳情頁打開帳戶主頁失敗:', error);
      showXToast(`打開主頁失敗: ${error.message}`, 'error');
    }
  };

  // 從轉發的帳戶名片打開帳戶主頁
  window.openAccountProfileFromQuoteProfile = async function (profileData) {
    try {
      console.log('🔍 從帳戶名片打開主頁:', profileData.name);

      // 收集現有資料
      const existingInfo = {
        name: profileData.name,
        handle: profileData.handle,
        avatar: profileData.avatar,
        verified: profileData.verified || false,
      };

      if (profileData.bio) {
        existingInfo.bio = profileData.bio;
      }
      if (profileData.followers) {
        existingInfo.followersCount = profileData.followers.toString();
      }

      console.log('📋 現有資料:', existingInfo);

      // 切換到帳戶主頁，調用第七個情景
      await openAccountProfile(existingInfo.name, existingInfo.handle, existingInfo.avatar, {
        source: 'dm_quote_profile',
        existingInfo: existingInfo,
      });
    } catch (error) {
      console.error('從帳戶名片打開主頁失敗:', error);
      showXToast(`打開主頁失敗: ${error.message}`, 'error');
    }
  };

  // ============================================
  // 私信列表功能
  // ============================================

  // 私信資料（動態管理）
  let sampleMessagesData = [];

  // 載入私信列表
  async function loadMessagesList() {
    console.log('📨 載入私信列表');

    try {
      // 從資料庫載入私信清單
      const xDb = getXDB();
      const dataId = `messagesList_${currentAccountId || 'main'}`;
      const savedData = await xDb.xAccountProfiles.get(dataId);

      if (savedData && savedData.data) {
        sampleMessagesData = savedData.data;
        console.log('✅ 從資料庫載入私信清單，共', sampleMessagesData.length, '條');
      } else {
        console.log('📨 資料庫中沒有私信清單資料，使用空清單');
        sampleMessagesData = [];
      }

      // 渲染私信列表
      renderMessagesList(sampleMessagesData);
    } catch (error) {
      console.error('載入私信列表失敗:', error);
      showXToast('載入私信失敗', 'error');
    }
  }

  // 渲染私信列表
  async function renderMessagesList(messages) {
    const container = document.getElementById('messages-list-container');
    if (!container) {
      console.error('私信列表容器不存在');
      return;
    }

    // 清空容器
    container.innerHTML = '';

    // 如果沒有消息,顯示空狀態
    if (!messages || messages.length === 0) {
      container.innerHTML = `
        <div style="
          flex: 1;
          display: flex;
          flex-direction: column;
          justify-content: center;
          align-items: center;
          padding: 32px;
          text-align: center;
        ">
          <svg viewBox="0 0 24 24" style="width: 56px; height: 56px; fill: var(--x-text-secondary); margin-bottom: 16px;">
            <g><path d="M1.998 5.5c0-1.381 1.119-2.5 2.5-2.5h15c1.381 0 2.5 1.119 2.5 2.5v13c0 1.381-1.119 2.5-2.5 2.5h-15c-1.381 0-2.5-1.119-2.5-2.5v-13zm2.5-.5c-.276 0-.5.224-.5.5v2.764l8 3.638 8-3.636V5.5c0-.276-.224-.5-.5-.5h-15zm15.5 5.463l-8 3.636-8-3.638V18.5c0 .276.224.5.5.5h15c.276 0 .5-.224.5-.5v-8.037z"></path></g>
          </svg>
          <div style="
            font-size: 28px;
            font-weight: 700;
            color: var(--x-text-primary);
            margin-bottom: 8px;
          " data-i18n="messagesEmpty">暫無私信</div>
          <div style="
            font-size: 14px;
            color: var(--x-text-secondary);
            max-width: 320px;
          " data-i18n="messagesEmptyDesc">發送私信與朋友保持聯繫</div>
        </div>
      `;
      return;
    }

    // 渲染每條私信（非同步創建）
    for (const message of messages) {
      const messageItem = await createMessageItem(message);
      container.appendChild(messageItem);
    }
  }

  // 創建私信列表項
  async function createMessageItem(message) {
    const messageDiv = document.createElement('div');
    messageDiv.className = 'message-item';
    messageDiv.style.cssText = `
      display: flex;
      align-items: center;
      padding: 16px;
      border-bottom: 1px solid var(--x-border-color);
      cursor: pointer;
      transition: background-color 0.2s;
    `;

    // 獲取最新頭像（對於綁定角色，從X資料讀取）
    let currentAvatar = message.userAvatar;
    const isCharacterMessage = message.id && message.id.startsWith('msg_') && message.id !== 'msg_001';

    if (isCharacterMessage) {
      try {
        const xDb = getXDB();
        const characterId = message.id.replace('msg_', '');
        const xProfile = await xDb.xCharacterProfiles.get(characterId);
        if (xProfile && xProfile.xAvatar) {
          currentAvatar = xProfile.xAvatar;
        }
      } catch (error) {
        console.warn('讀取角色頭像失敗:', error);
      }
    }

    // 獲取最新消息內容
    let lastMessageText = message.lastMessage || '';
    let lastMessageTime = message.timestamp;

    // 嘗試從資料庫獲取最新消息
    try {
      const xDb = getXDB();
      // 🔧 多帳戶隔離：包含帳戶ID
      const conversationId = `messageConversation_${currentAccountId || 'main'}_${message.id}`;
      const savedConversation = await xDb.xAccountProfiles.get(conversationId);

      if (savedConversation && savedConversation.data && savedConversation.data.messages) {
        const messages = savedConversation.data.messages;
        if (messages.length > 0) {
          const latestMsg = messages[messages.length - 1];
          // 根據消息類型顯示不同的預覽文本
          if (latestMsg.type === 'text') {
            lastMessageText = latestMsg.content;
          } else if (latestMsg.type === 'image') {
            lastMessageText = '[圖片]';
          } else if (latestMsg.type === 'voice') {
            lastMessageText = '[語音]';
          } else if (latestMsg.type === 'link') {
            lastMessageText = '[連結]';
          } else if (latestMsg.type === 'quoteTweet') {
            lastMessageText = '[轉發推文]';
          } else if (latestMsg.type === 'quoteProfile') {
            lastMessageText = '[轉發主頁]';
          }

          // 如果有時間戳記，使用最新的時間
          if (latestMsg.timestamp) {
            lastMessageTime = latestMsg.timestamp;
          }
        }
      }
    } catch (error) {
      console.warn('獲取最新消息失敗:', error);
    }

    // 格式化時間
    const timeStr = formatMessageTime(lastMessageTime);

    messageDiv.innerHTML = `
      <!-- 頭像容器（帶未讀提醒點） -->
      <div style="position: relative; flex-shrink: 0; margin-right: 12px;">
        <!-- 頭像 -->
        <img src="${currentAvatar}" 
          alt="${message.userName}" 
          style="
            width: 48px;
            height: 48px;
            border-radius: 50%;
            object-fit: cover;
          ">
        <!-- 未讀提醒點 -->
        ${
          message.unread
            ? `
          <div style="
            position: absolute;
            top: -2px;
            right: -2px;
            width: 12px;
            height: 12px;
            background-color: var(--x-accent);
            border: 2px solid var(--x-bg-primary);
            border-radius: 50%;
          "></div>
        `
            : ''
        }
      </div>
      
      <!-- 消息內容 -->
      <div style="flex: 1; min-width: 0;">
        <!-- 使用者資訊行 -->
        <div style="display: flex; align-items: center; margin-bottom: 4px;">
          <span style="
            font-size: 15px;
            font-weight: ${message.unread ? '700' : '700'};
            color: var(--x-text-primary);
            margin-right: 4px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
          ">${message.userName}</span>
          <span style="
            font-size: 15px;
            color: var(--x-text-secondary);
            margin-right: 4px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
          ">@${message.userHandle}</span>
          <span style="
            font-size: 15px;
            color: var(--x-text-secondary);
            margin-left: auto;
            flex-shrink: 0;
          ">· ${timeStr}</span>
        </div>
        
        <!-- 最後一條消息 -->
        <div style="
          font-size: 15px;
          color: ${message.unread ? 'var(--x-text-primary)' : 'var(--x-text-secondary)'};
          font-weight: ${message.unread ? '600' : 'normal'};
          overflow: hidden;
          text-overflow: ellipsis;
          white-space: nowrap;
        ">${lastMessageText || '開始對話'}</div>
      </div>
    `;

    // 添加懸停效果
    messageDiv.addEventListener('mouseenter', () => {
      messageDiv.style.backgroundColor = 'var(--x-bg-hover)';
    });
    messageDiv.addEventListener('mouseleave', () => {
      messageDiv.style.backgroundColor = 'transparent';
    });

    // 點擊打開私信詳情
    messageDiv.addEventListener('click', () => {
      window.openMessageDetail(message);
    });

    return messageDiv;
  }

  // 格式化消息時間
  function formatMessageTime(timestamp) {
    const now = new Date();
    const time = new Date(timestamp);
    const diff = now - time;
    const seconds = Math.floor(diff / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);

    const isEnglish = currentLanguage === 'en';

    if (seconds < 60) {
      return isEnglish ? 'now' : '剛剛';
    } else if (minutes < 60) {
      return isEnglish ? `${minutes}m` : `${minutes}分鐘`;
    } else if (hours < 24) {
      return isEnglish ? `${hours}h` : `${hours}小時`;
    } else if (days < 7) {
      return isEnglish ? `${days}d` : `${days}天`;
    } else {
      // 顯示具體日期
      if (isEnglish) {
        const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        return `${months[time.getMonth()]} ${time.getDate()}`;
      } else {
        const month = time.getMonth() + 1;
        const day = time.getDate();
        return `${month}月${day}日`;
      }
    }
  }

  // 打開新建私信彈窗
  async function openNewMessageModal() {
    console.log('📨 打開新建私信彈窗');

    try {
      // 獲取已綁定的角色列表
      const db = getDB();
      const xDb = getXDB();

      // 獲取X設置中的綁定角色（使用當前帳號的設置）
      const settingsId = `xSettings_${currentAccountId || 'main'}`;
      const xSettings = await xDb.xSettings.get(settingsId);
      const boundCharacters = xSettings?.boundCharacters || [];

      console.log(`📨 綁定角色數: ${boundCharacters.length}`);

      // 獲取所有聊天角色
      const allChats = await db.chats.toArray();
      const characters = allChats.filter(chat => !chat.isGroup && boundCharacters.includes(chat.id));

      // 篩選出已綁定X資料的角色
      const charactersWithXProfile = [];
      for (const character of characters) {
        const xProfile = await xDb.xCharacterProfiles.get(character.id);
        if (xProfile) {
          charactersWithXProfile.push({
            id: character.id,
            name: character.name,
            xProfile: xProfile,
          });
        }
      }

      console.log(`📨 可選擇角色數: ${charactersWithXProfile.length}`);

      // 顯示選擇角色彈窗（即使沒有角色也可以創建粉絲群）
      showNewMessageModal(charactersWithXProfile);
    } catch (error) {
      console.error('打開新建私信彈窗失敗:', error);
      showXToast('打開彈窗失敗', 'error');
    }
  }

  // 顯示新建私信選擇角色彈窗
  function showNewMessageModal(characters) {
    // 創建彈窗
    const modal = document.createElement('div');
    modal.id = 'new-message-modal';
    modal.style.cssText = `
      display: flex;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: var(--x-modal-overlay);
      z-index: 1000;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(4px);
    `;

    modal.innerHTML = `
      <div class="modal-content" onclick="event.stopPropagation()" style="
        background-color: var(--x-bg-primary);
        border-radius: 16px;
        width: 90%;
        max-width: 500px;
        max-height: 70vh;
        overflow: hidden;
        border: 1px solid var(--x-border-color);
      ">
        <!-- 彈窗頂部欄 -->
        <div class="modal-header" style="
          display: flex;
          align-items: center;
          justify-content: space-between;
          padding: 16px 20px;
          border-bottom: 1px solid var(--x-border-color);
          background-color: var(--x-bg-primary);
        ">
          <div style="display: flex; align-items: center; gap: 20px;">
            <!-- 關閉按鈕 -->
            <div class="modal-close-btn" onclick="closeNewMessageModal()" style="
              cursor: pointer;
              padding: 8px;
              border-radius: 50%;
              transition: background-color 0.2s;
            " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
               onmouseout="this.style.backgroundColor='transparent'">
              <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);">
                <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
              </svg>
            </div>
            <!-- 標題 -->
            <h2 style="
              color: var(--x-text-primary);
              font-size: 20px;
              font-weight: 700;
              margin: 0;
            ">新建私信</h2>
          </div>
        </div>

        <!-- 彈窗內容區域 -->
        <div class="modal-body" style="
          padding: 16px 20px;
          overflow-y: auto;
          max-height: calc(70vh - 80px);
        ">
          <!-- 說明文字 -->
          <div style="
            color: var(--x-text-secondary);
            font-size: 14px;
            margin-bottom: ${characters.length > 0 ? '16px' : '8px'};
            line-height: 1.4;
          ">
            ${characters.length > 0 ? '選擇要發送私信的角色' : '暫無可用角色，可以創建粉絲群'}
          </div>

          <!-- 角色列表 -->
          <div id="new-message-characters-list" style="
            display: flex;
            flex-direction: column;
            gap: 0;
          ">
            ${characters
              .map(
                character => `
              <div class="character-select-item" data-character-id="${
                character.id
              }" onclick="selectCharacterForMessage('${character.id}')" style="
                display: flex;
                align-items: center;
                gap: 12px;
                padding: 12px;
                border-radius: 8px;
                cursor: pointer;
                transition: background-color 0.2s;
              " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
                 onmouseout="this.style.backgroundColor='transparent'">
                
                <!-- 角色頭像 -->
                <img src="${character.xProfile.xAvatar}" 
                  alt="${character.xProfile.xName}" 
                  style="
                    width: 40px;
                    height: 40px;
                    border-radius: 50%;
                    flex-shrink: 0;
                    object-fit: cover;
                  ">
                
                <!-- 角色信息 -->
                <div style="flex: 1; min-width: 0;">
                  <div style="
                    display: flex;
                    align-items: center;
                    gap: 4px;
                    margin-bottom: 2px;
                  ">
                    <span style="
                      font-size: 15px;
                      font-weight: 700;
                      color: var(--x-text-primary);
                    ">${character.xProfile.xName}</span>
                    ${
                      character.xProfile.xVerified
                        ? `
                      <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-accent);">
                        <path d="M22.5 12.5c0-1.58-.875-2.95-2.148-3.6.154-.435.238-.905.238-1.4 0-2.21-1.71-3.998-3.818-3.998-.47 0-.92.084-1.336.25C14.818 2.415 13.51 1.5 12 1.5s-2.816.917-3.437 2.25c-.415-.165-.866-.25-1.336-.25-2.11 0-3.818 1.79-3.818 4 0 .494.083.964.237 1.4-1.272.65-2.147 2.018-2.147 3.6 0 1.495.782 2.798 1.942 3.486-.02.17-.032.34-.032.514 0 2.21 1.708 4 3.818 4 .47 0 .92-.086 1.335-.25.62 1.334 1.926 2.25 3.437 2.25 1.512 0 2.818-.916 3.437-2.25.415.163.865.248 1.336.248 2.11 0 3.818-1.79 3.818-4 0-.174-.012-.344-.033-.513 1.158-.687 1.943-1.99 1.943-3.484zm-6.616-3.334l-4.334 6.5c-.145.217-.382.334-.625.334-.143 0-.288-.04-.416-.126l-2.5-1.668c-.326-.217-.413-.656-.196-.982.217-.326.656-.414.982-.196l1.875 1.25 3.75-5.625c.22-.33.66-.418.99-.196.33.22.418.66.196.99z"/>
                      </svg>
                    `
                        : ''
                    }
                  </div>
                  <div style="
                    font-size: 15px;
                    color: var(--x-text-secondary);
                  ">@${character.xProfile.xHandle}</div>
                </div>
              </div>
            `,
              )
              .join('')}
          </div>
          
          ${
            characters.length > 0
              ? `
          <!-- 分隔線 -->
          <div style="
            height: 1px;
            background-color: var(--x-border-color);
            margin: 16px 0;
          "></div>
          `
              : ''
          }

          <!-- 創建粉絲群選項 -->
          <div onclick="createFanGroup()" style="
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s;
            border: 2px dashed var(--x-border-color);
          " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'; this.style.borderColor='var(--x-accent)'"
             onmouseout="this.style.backgroundColor='transparent'; this.style.borderColor='var(--x-border-color)'">
            
            <!-- 圖示 -->
            <div style="
              width: 40px;
              height: 40px;
              border-radius: 50%;
              background-color: var(--x-bg-secondary);
              display: flex;
              align-items: center;
              justify-content: center;
              flex-shrink: 0;
            ">
              <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-accent);">
                <g><path d="M16 11c1.66 0 2.99-1.34 2.99-3S17.66 5 16 5c-1.66 0-3 1.34-3 3s1.34 3 3 3zm-8 0c1.66 0 2.99-1.34 2.99-3S9.66 5 8 5C6.34 5 5 6.34 5 8s1.34 3 3 3zm0 2c-2.33 0-7 1.17-7 3.5V19h14v-2.5c0-2.33-4.67-3.5-7-3.5zm8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.97 1.97 3.45V19h6v-2.5c0-2.33-4.67-3.5-7-3.5z"></path></g>
              </svg>
            </div>
            
            <!-- 文字 -->
            <div style="flex: 1; min-width: 0;">
              <div style="
                font-size: 15px;
                font-weight: 700;
                color: var(--x-text-primary);
                margin-bottom: 2px;
              ">創建粉絲群</div>
              <div style="
                font-size: 13px;
                color: var(--x-text-secondary);
              ">與你的粉絲群組互動</div>
            </div>
          </div>
        </div>
      </div>
    `;

    // 將彈窗添加到X應用容器內，以便繼承CSS變數
    const xSocialScreen = document.getElementById('x-social-screen');
    if (xSocialScreen) {
      xSocialScreen.appendChild(modal);
    } else {
      document.body.appendChild(modal);
    }

    // 點擊背景關閉彈窗
    modal.addEventListener('click', e => {
      if (e.target === modal) {
        closeNewMessageModal();
      }
    });
  }

  // 關閉新建私信彈窗
  function closeNewMessageModal() {
    const modal = document.getElementById('new-message-modal');
    if (modal) {
      modal.remove();
    }
  }

  // 選擇角色創建私信
  async function selectCharacterForMessage(characterId) {
    console.log('📨 選擇角色創建私信:', characterId);

    try {
      const db = getDB();
      const xDb = getXDB();

      // 獲取角色資訊
      const character = await db.chats.get(characterId);
      const xProfile = await xDb.xCharacterProfiles.get(characterId);

      if (!character || !xProfile) {
        showXToast('無法獲取角色資訊', 'error');
        return;
      }

      // 檢查是否已存在該角色的私信
      const existingIndex = sampleMessagesData.findIndex(msg => msg.id === `msg_${characterId}`);

      if (existingIndex === -1) {
        // 添加新私信到列表
        const newMessage = {
          id: `msg_${characterId}`,
          userName: xProfile.xName,
          userHandle: xProfile.xHandle,
          userAvatar: xProfile.xAvatar,
          lastMessage: '',
          timestamp: new Date().toISOString(),
          unread: false,
        };

        // 添加到陣列開頭
        sampleMessagesData.unshift(newMessage);

        console.log('✅ 已添加新私信:', newMessage);

        // 保存到資料庫
        try {
          const dataId = `messagesList_${currentAccountId || 'main'}`;
          await xDb.xAccountProfiles.put({
            handle: dataId,
            name: 'messagesList',
            data: sampleMessagesData,
            updatedAt: new Date().toISOString(),
          });
          console.log('✅ 私信清單已保存到資料庫');
        } catch (saveError) {
          console.error('保存私信列表失敗:', saveError);
        }
      } else {
        console.log('⚠️ 該角色的私信已存在');
      }

      // 關閉彈窗
      closeNewMessageModal();

      // 重新渲染私信列表
      renderMessagesList(sampleMessagesData);

      showXToast(`已添加與 ${xProfile.xName} 的私信`, 'success');
    } catch (error) {
      console.error('選擇角色失敗:', error);
      showXToast('操作失敗', 'error');
    }
  }

  // ============================================
  // 陌生人私信設置功能
  // ============================================

  // 打開消息連絡人設置彈窗（通用版本，適配帳戶/陌生人）
  async function openMessageContactSettings(messageData, profileData) {
    // 檢查是否已添加到連絡人
    const isInContactList = sampleMessagesData.some(msg => msg.id === messageData.id);

    // 檢查是否啟用了自動發資訊
    let autoMessageEnabled = false;
    let autoMessageInterval = 60; // 默認60秒
    let customAvatar = messageData.user.avatar;

    try {
      const xDb = getXDB();
      const settingsId = `strangerSettings_${currentAccountId || 'main'}_${messageData.id}`;
      const settings = await xDb.xAccountProfiles.get(settingsId);
      if (settings) {
        autoMessageEnabled = settings.autoMessageEnabled || false;
        autoMessageInterval = settings.autoMessageInterval || 60;
        customAvatar = settings.customAvatar || messageData.user.avatar;
      }
    } catch (error) {
      console.error('讀取設置失敗:', error);
    }

    // 創建設置彈窗
    const modal = document.createElement('div');
    modal.id = 'stranger-message-settings-modal';
    modal.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 25;
      backdrop-filter: blur(4px);
    `;

    modal.innerHTML = `
      <div style="
        background-color: var(--x-bg-primary);
        border-radius: 16px;
        width: 90%;
        max-width: 500px;
        max-height: 80vh;
        overflow: hidden;
        border: 1px solid var(--x-border-color);
        display: flex;
        flex-direction: column;
      " onclick="event.stopPropagation()">
        
        <!-- 標題列 -->
        <div style="
          padding: 16px 20px;
          border-bottom: 1px solid var(--x-border-color);
          display: flex;
          align-items: center;
          justify-content: space-between;
        ">
          <div style="display: flex; align-items: center; gap: 12px;">
            <img src="${messageData.user.avatar}" style="width: 40px; height: 40px; border-radius: 50%;">
            <div>
              <div style="font-size: 18px; font-weight: 700; color: var(--x-text-primary);">${
                messageData.user.name
              }</div>
              <div style="font-size: 14px; color: var(--x-text-secondary);">${messageData.user.handle}</div>
            </div>
          </div>
          <div onclick="closeStrangerMessageSettings()" style="
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            transition: background-color 0.2s;
          " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
             onmouseout="this.style.backgroundColor='transparent'">
            <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);">
              <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
            </svg>
          </div>
        </div>

        <!-- 設置內容 -->
        <div style="
          flex: 1;
          overflow-y: auto;
          padding: 20px;
        ">
          
          <!-- 添加到連絡人 -->
          <div style="margin-bottom: 24px;">
            <div style="
              display: flex;
              align-items: center;
              justify-content: space-between;
              margin-bottom: 8px;
            ">
              <div>
                <div style="font-size: 16px; font-weight: 600; color: var(--x-text-primary); margin-bottom: 4px;">
                  添加到連絡人
                </div>
                <div style="font-size: 13px; color: var(--x-text-secondary);">
                  添加後可在私信列表中快速找到
                </div>
              </div>
              <div class="x-toggle" id="contact-toggle" onclick="toggleStrangerContact('${
                messageData.id
              }')" style="cursor: pointer;">
                <div class="toggle-switch" style="
                  width: 50px;
                  height: 30px;
                  background-color: ${isInContactList ? 'var(--x-accent)' : '#333'};
                  border-radius: 15px;
                  position: relative;
                  transition: all 0.3s ease;
                ">
                  <div class="toggle-circle" style="
                    width: 26px;
                    height: 26px;
                    background-color: #fff;
                    border-radius: 50%;
                    position: absolute;
                    top: 2px;
                    left: ${isInContactList ? '22px' : '2px'};
                    transition: all 0.3s ease;
                  "></div>
                </div>
              </div>
            </div>
          </div>

          <!-- 更換頭像 -->
          <div style="margin-bottom: 24px;">
            <div style="font-size: 16px; font-weight: 600; color: var(--x-text-primary); margin-bottom: 12px;">
              更換頭像
            </div>
            <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
              <img id="stranger-avatar-preview" src="${customAvatar}" style="
                width: 64px;
                height: 64px;
                border-radius: 50%;
                object-fit: cover;
              ">
            </div>
            <div style="display: flex; gap: 8px;">
              <input 
                type="text" 
                id="stranger-avatar-url-input" 
                placeholder="輸入圖片連結位址"
                value="${customAvatar}"
                style="
                  flex: 1;
                  background-color: var(--x-bg-secondary);
                  border: 1px solid var(--x-border-color);
                  border-radius: 20px;
                  padding: 10px 16px;
                  font-size: 14px;
                  color: var(--x-text-primary);
                  outline: none;
                "
                onfocus="this.style.borderColor='var(--x-accent)'"
                onblur="this.style.borderColor='var(--x-border-color)'"
              >
              <button onclick="updateStrangerAvatar('${messageData.id}')" style="
                background-color: var(--x-accent);
                color: #fff;
                border: none;
                border-radius: 20px;
                padding: 10px 20px;
                font-size: 14px;
                font-weight: 600;
                cursor: pointer;
                transition: opacity 0.2s;
                white-space: nowrap;
              " onmouseover="this.style.opacity='0.9'" onmouseout="this.style.opacity='1'">
                更新
              </button>
            </div>
          </div>

          <!-- 自動發資訊 -->
          <div style="margin-bottom: 24px;">
            <div style="
              display: flex;
              align-items: center;
              justify-content: space-between;
              margin-bottom: 8px;
            ">
              <div>
                <div style="font-size: 16px; font-weight: 600; color: var(--x-text-primary); margin-bottom: 4px;">
                  自動發資訊
                </div>
                <div style="font-size: 13px; color: var(--x-text-secondary);">
                  ${isInContactList ? '啟用後該帳戶會自動發送私信和推文' : '需先添加到連絡人後才能啟用'}
                </div>
              </div>
              <div class="x-toggle" id="auto-message-toggle" onclick="${
                isInContactList
                  ? `toggleStrangerAutoMessage('${messageData.id}')`
                  : "showXToast('請先添加到連絡人', 'warning')"
              }" style="cursor: ${isInContactList ? 'pointer' : 'not-allowed'}; opacity: ${
      isInContactList ? '1' : '0.5'
    };">
                <div class="toggle-switch" style="
                  width: 50px;
                  height: 30px;
                  background-color: ${autoMessageEnabled ? 'var(--x-accent)' : '#333'};
                  border-radius: 15px;
                  position: relative;
                  transition: all 0.3s ease;
                ">
                  <div class="toggle-circle" style="
                    width: 26px;
                    height: 26px;
                    background-color: #fff;
                    border-radius: 50%;
                    position: absolute;
                    top: 2px;
                    left: ${autoMessageEnabled ? '22px' : '2px'};
                    transition: all 0.3s ease;
                  "></div>
                </div>
              </div>
            </div>
            
            <!-- 時間間隔設置 -->
            ${
              isInContactList
                ? `
            <div style="margin-top: 12px;">
              <div style="font-size: 14px; color: var(--x-text-secondary); margin-bottom: 8px;">
                發送間隔（秒）
              </div>
              <input 
                type="number" 
                id="stranger-interval-input" 
                min="10" 
                max="3600" 
                value="${autoMessageInterval}"
                style="
                  width: 100%;
                  background-color: var(--x-bg-secondary);
                  border: 1px solid var(--x-border-color);
                  border-radius: 8px;
                  padding: 10px 12px;
                  font-size: 14px;
                  color: var(--x-text-primary);
                  outline: none;
                "
                onfocus="this.style.borderColor='var(--x-accent)'"
                onblur="this.style.borderColor='var(--x-border-color)'"
                onchange="updateStrangerInterval('${messageData.id}', this.value)"
              >
              <div style="font-size: 12px; color: var(--x-text-secondary); margin-top: 4px;">
                建議：60-300秒之間
              </div>
            </div>
            `
                : ''
            }
          </div>

        </div>

      </div>
    `;

    // 添加到DOM
    const xSocialScreen = document.getElementById('x-social-screen');
    if (xSocialScreen) {
      xSocialScreen.appendChild(modal);
    } else {
      document.body.appendChild(modal);
    }

    // 點擊背景關閉
    modal.onclick = e => {
      if (e.target === modal) {
        closeStrangerMessageSettings();
      }
    };

    // 保存當前設置資料到全域，供其他函數使用
    window.currentStrangerSettings = {
      messageData: messageData,
      conversationData: profileData,
    };
  }

  // 打開陌生人私信設置彈窗
  async function openStrangerMessageSettings(messageData, conversationData) {
    // 檢查是否已添加到連絡人
    const isInContactList = sampleMessagesData.some(msg => msg.id === messageData.id);

    // 檢查是否啟用了自動發資訊
    let autoMessageEnabled = false;
    let autoMessageInterval = 60; // 默認60秒
    let customAvatar = messageData.user.avatar;

    try {
      const xDb = getXDB();
      const settingsId = `strangerSettings_${currentAccountId || 'main'}_${messageData.id}`;
      const settings = await xDb.xAccountProfiles.get(settingsId);
      if (settings) {
        autoMessageEnabled = settings.autoMessageEnabled || false;
        autoMessageInterval = settings.autoMessageInterval || 60;
        customAvatar = settings.customAvatar || messageData.user.avatar;
      }
    } catch (error) {
      console.error('讀取陌生人設置失敗:', error);
    }

    // 創建設置彈窗
    const modal = document.createElement('div');
    modal.id = 'stranger-message-settings-modal';
    modal.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 25;
      backdrop-filter: blur(4px);
    `;

    modal.innerHTML = `
      <div style="
        background-color: var(--x-bg-primary);
        border-radius: 16px;
        width: 90%;
        max-width: 500px;
        max-height: 80vh;
        overflow: hidden;
        border: 1px solid var(--x-border-color);
        display: flex;
        flex-direction: column;
      " onclick="event.stopPropagation()">
        
        <!-- 標題列 -->
        <div style="
          padding: 16px 20px;
          border-bottom: 1px solid var(--x-border-color);
          display: flex;
          align-items: center;
          justify-content: space-between;
        ">
          <div style="display: flex; align-items: center; gap: 12px;">
            <img src="${messageData.user.avatar}" style="width: 40px; height: 40px; border-radius: 50%;">
            <div>
              <div style="font-size: 18px; font-weight: 700; color: var(--x-text-primary);">${
                messageData.user.name
              }</div>
              <div style="font-size: 14px; color: var(--x-text-secondary);">${messageData.user.handle}</div>
            </div>
          </div>
          <div onclick="closeStrangerMessageSettings()" style="
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            transition: background-color 0.2s;
          " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
             onmouseout="this.style.backgroundColor='transparent'">
            <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);">
              <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
            </svg>
          </div>
        </div>

        <!-- 設置內容 -->
        <div style="
          flex: 1;
          overflow-y: auto;
          padding: 20px;
        ">
          
          <!-- 添加到連絡人 -->
          <div style="margin-bottom: 24px;">
            <div style="
              display: flex;
              align-items: center;
              justify-content: space-between;
              margin-bottom: 8px;
            ">
              <div>
                <div style="font-size: 16px; font-weight: 600; color: var(--x-text-primary); margin-bottom: 4px;">
                  添加到連絡人
                </div>
                <div style="font-size: 13px; color: var(--x-text-secondary);">
                  添加後可在私信列表中快速找到
                </div>
              </div>
              <div class="x-toggle" id="contact-toggle" onclick="toggleStrangerContact('${
                messageData.id
              }')" style="cursor: pointer;">
                <div class="toggle-switch" style="
                  width: 50px;
                  height: 30px;
                  background-color: ${isInContactList ? 'var(--x-accent)' : '#333'};
                  border-radius: 15px;
                  position: relative;
                  transition: all 0.3s ease;
                ">
                  <div class="toggle-circle" style="
                    width: 26px;
                    height: 26px;
                    background-color: #fff;
                    border-radius: 50%;
                    position: absolute;
                    top: 2px;
                    left: ${isInContactList ? '22px' : '2px'};
                    transition: all 0.3s ease;
                  "></div>
                </div>
              </div>
            </div>
          </div>

          <!-- 更換頭像 -->
          <div style="margin-bottom: 24px;">
            <div style="font-size: 16px; font-weight: 600; color: var(--x-text-primary); margin-bottom: 12px;">
              更換頭像
            </div>
            <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
              <img id="stranger-avatar-preview" src="${customAvatar}" style="
                width: 64px;
                height: 64px;
                border-radius: 50%;
                object-fit: cover;
              ">
            </div>
            <div style="display: flex; gap: 8px;">
              <input 
                type="text" 
                id="stranger-avatar-url-input" 
                placeholder="輸入圖片連結位址"
                value="${customAvatar}"
                style="
                  flex: 1;
                  background-color: var(--x-bg-secondary);
                  border: 1px solid var(--x-border-color);
                  border-radius: 20px;
                  padding: 10px 16px;
                  font-size: 14px;
                  color: var(--x-text-primary);
                  outline: none;
                "
                onfocus="this.style.borderColor='var(--x-accent)'"
                onblur="this.style.borderColor='var(--x-border-color)'"
              >
              <button onclick="updateStrangerAvatar('${messageData.id}')" style="
                background-color: var(--x-accent);
                color: #fff;
                border: none;
                border-radius: 20px;
                padding: 10px 20px;
                font-size: 14px;
                font-weight: 600;
                cursor: pointer;
                transition: opacity 0.2s;
                white-space: nowrap;
              " onmouseover="this.style.opacity='0.9'" onmouseout="this.style.opacity='1'">
                更新
              </button>
            </div>
          </div>

          <!-- 自動發資訊 -->
          <div style="margin-bottom: 24px;">
            <div style="
              display: flex;
              align-items: center;
              justify-content: space-between;
              margin-bottom: 8px;
            ">
              <div>
                <div style="font-size: 16px; font-weight: 600; color: var(--x-text-primary); margin-bottom: 4px;">
                  自動發資訊
                </div>
                <div style="font-size: 13px; color: var(--x-text-secondary);">
                  ${isInContactList ? '啟用後該帳戶會自動發送私信' : '需先添加到連絡人後才能啟用'}
                </div>
              </div>
              <div class="x-toggle" id="auto-message-toggle" onclick="${
                isInContactList
                  ? `toggleStrangerAutoMessage('${messageData.id}')`
                  : "showXToast('請先添加到連絡人', 'warning')"
              }" style="cursor: ${isInContactList ? 'pointer' : 'not-allowed'}; opacity: ${
      isInContactList ? '1' : '0.5'
    };">
                <div class="toggle-switch" style="
                  width: 50px;
                  height: 30px;
                  background-color: ${autoMessageEnabled ? 'var(--x-accent)' : '#333'};
                  border-radius: 15px;
                  position: relative;
                  transition: all 0.3s ease;
                ">
                  <div class="toggle-circle" style="
                    width: 26px;
                    height: 26px;
                    background-color: #fff;
                    border-radius: 50%;
                    position: absolute;
                    top: 2px;
                    left: ${autoMessageEnabled ? '22px' : '2px'};
                    transition: all 0.3s ease;
                  "></div>
                </div>
              </div>
            </div>
            
            <!-- 時間間隔設置 -->
            ${
              isInContactList
                ? `
            <div style="margin-top: 12px;">
              <div style="font-size: 14px; color: var(--x-text-secondary); margin-bottom: 8px;">
                發送間隔（秒）
              </div>
              <input 
                type="number" 
                id="stranger-interval-input" 
                min="10" 
                max="3600" 
                value="${autoMessageInterval}"
                style="
                  width: 100%;
                  background-color: var(--x-bg-secondary);
                  border: 1px solid var(--x-border-color);
                  border-radius: 8px;
                  padding: 10px 12px;
                  font-size: 14px;
                  color: var(--x-text-primary);
                  outline: none;
                "
                onfocus="this.style.borderColor='var(--x-accent)'"
                onblur="this.style.borderColor='var(--x-border-color)'"
                onchange="updateStrangerInterval('${messageData.id}', this.value)"
              >
              <div style="font-size: 12px; color: var(--x-text-secondary); margin-top: 4px;">
                建議：60-300秒之間
              </div>
            </div>
            `
                : ''
            }
          </div>

        </div>

      </div>
    `;

    // 添加到DOM
    const xSocialScreen = document.getElementById('x-social-screen');
    if (xSocialScreen) {
      xSocialScreen.appendChild(modal);
    } else {
      document.body.appendChild(modal);
    }

    // 點擊背景關閉
    modal.onclick = e => {
      if (e.target === modal) {
        closeStrangerMessageSettings();
      }
    };

    // 保存當前設置資料到全域，供其他函數使用
    window.currentStrangerSettings = {
      messageData: messageData,
      conversationData: conversationData,
    };
  }

  // 關閉設置彈窗
  function closeStrangerMessageSettings() {
    const modal = document.getElementById('stranger-message-settings-modal');
    if (modal) {
      modal.remove();
    }
    window.currentStrangerSettings = null;
  }

  // 切換連絡人狀態
  async function toggleStrangerContact(messageId) {
    try {
      const xDb = getXDB();
      const dataId = `messagesList_${currentAccountId || 'main'}`;

      // 🔧 重要：先從資料庫載入最新的私信清單，避免覆蓋現有資料
      const savedData = await xDb.xAccountProfiles.get(dataId);
      let messagesList = savedData?.data || [];

      console.log('📝 [連絡人] 當前私信列表數量:', messagesList.length);

      // 查找是否已存在
      const existingIndex = messagesList.findIndex(msg => msg.id === messageId);

      const toggle = document.getElementById('contact-toggle');
      const toggleSwitch = toggle.querySelector('.toggle-switch');
      const toggleCircle = toggle.querySelector('.toggle-circle');

      if (existingIndex !== -1) {
        // 已存在，移除
        messagesList.splice(existingIndex, 1);
        console.log('📝 [連絡人] 移除後私信列表數量:', messagesList.length);

        // 更新UI
        toggleSwitch.style.backgroundColor = '#333';
        toggleCircle.style.left = '2px';

        // 同時禁用自動發資訊
        const settingsId = `strangerSettings_${currentAccountId || 'main'}_${messageId}`;
        await xDb.xAccountProfiles.delete(settingsId);

        // 更新自動發資訊開關UI
        const autoToggle = document.getElementById('auto-message-toggle');
        if (autoToggle) {
          const autoSwitch = autoToggle.querySelector('.toggle-switch');
          const autoCircle = autoToggle.querySelector('.toggle-circle');
          autoSwitch.style.backgroundColor = '#333';
          autoCircle.style.left = '2px';
          autoToggle.style.opacity = '0.5';
          autoToggle.style.cursor = 'not-allowed';
          autoToggle.onclick = () => showXToast('請先添加到連絡人', 'warning');
        }

        showXToast('已從連絡人移除', 'success');
      } else {
        // 不存在，添加
        const messageData = window.currentStrangerSettings.messageData;
        const newMessage = {
          id: messageId,
          userName: messageData.user.name,
          userHandle: messageData.user.handle.replace('@', ''),
          userAvatar: messageData.user.avatar,
          lastMessage: messageData.preview || '',
          timestamp: new Date().toISOString(),
          unread: false,
        };

        messagesList.unshift(newMessage);
        console.log('📝 [連絡人] 添加後私信列表數量:', messagesList.length);

        // 更新UI
        toggleSwitch.style.backgroundColor = 'var(--x-accent)';
        toggleCircle.style.left = '22px';

        // 更新自動發資訊開關UI（變為可用）
        const autoToggle = document.getElementById('auto-message-toggle');
        if (autoToggle) {
          autoToggle.style.opacity = '1';
          autoToggle.style.cursor = 'pointer';
          autoToggle.onclick = () => toggleStrangerAutoMessage(messageId);
        }

        showXToast('已添加到連絡人', 'success');
      }

      // 保存到資料庫
      await xDb.xAccountProfiles.put({
        handle: dataId,
        name: 'messagesList',
        data: messagesList,
        updatedAt: new Date().toISOString(),
      });

      console.log('✅ [連絡人] 已保存到資料庫，清單數量:', messagesList.length);

      // 同步更新全域變數
      sampleMessagesData = messagesList;

      // 如果當前在私信清單頁面，刷新顯示
      const messagesPage = document.getElementById('x-messages-page');
      if (messagesPage && messagesPage.style.display === 'flex') {
        await loadMessagesList();
      }
    } catch (error) {
      console.error('切換連絡人狀態失敗:', error);
      showXToast('操作失敗', 'error');
    }
  }

  // 更新陌生人頭像（使用連結）
  async function updateStrangerAvatar(messageId) {
    const input = document.getElementById('stranger-avatar-url-input');
    if (!input) return;

    const newAvatarUrl = input.value.trim();
    if (!newAvatarUrl) {
      showXToast('請輸入頭像連結', 'warning');
      return;
    }

    try {
      // 更新預覽
      const preview = document.getElementById('stranger-avatar-preview');
      if (preview) preview.src = newAvatarUrl;

      // 更新頂部小頭像
      const topAvatar = document.getElementById('message-detail-top-avatar');
      if (topAvatar) topAvatar.src = newAvatarUrl;

      // 更新大頭像
      const detailAvatar = document.getElementById('message-detail-avatar');
      if (detailAvatar) detailAvatar.src = newAvatarUrl;

      // 保存到資料庫
      const xDb = getXDB();

      // 保存到陌生人設置
      const settingsId = `strangerSettings_${currentAccountId || 'main'}_${messageId}`;
      const settings = (await xDb.xAccountProfiles.get(settingsId)) || {
        handle: settingsId,
        id: settingsId,
        messageId: messageId,
      };

      settings.customAvatar = newAvatarUrl;
      settings.updatedAt = new Date().toISOString();
      await xDb.xAccountProfiles.put(settings);

      // 更新私信列表中的頭像
      const messageIndex = sampleMessagesData.findIndex(msg => msg.id === messageId);
      if (messageIndex !== -1) {
        sampleMessagesData[messageIndex].userAvatar = newAvatarUrl;

        const dataId = `messagesList_${currentAccountId || 'main'}`;
        await xDb.xAccountProfiles.put({
          handle: dataId,
          name: 'messagesList',
          data: sampleMessagesData,
          updatedAt: new Date().toISOString(),
        });

        // 刷新私信清單顯示
        const messagesPage = document.getElementById('x-messages-page');
        if (messagesPage && messagesPage.style.display === 'flex') {
          await loadMessagesList();
        }
      }

      // 更新當前設置資料
      if (window.currentStrangerSettings && window.currentStrangerSettings.messageData) {
        window.currentStrangerSettings.messageData.user.avatar = newAvatarUrl;
      }

      showXToast('頭像已更新', 'success');
    } catch (error) {
      console.error('更新頭像失敗:', error);
      showXToast('更新失敗', 'error');
    }
  }

  // 更新時間間隔
  async function updateStrangerInterval(messageId, interval) {
    try {
      const intervalNum = parseInt(interval);
      if (isNaN(intervalNum) || intervalNum < 10 || intervalNum > 3600) {
        showXToast('時間間隔必須在10-3600秒之間', 'warning');
        return;
      }

      const xDb = getXDB();
      const settingsId = `strangerSettings_${currentAccountId || 'main'}_${messageId}`;
      const settings = (await xDb.xAccountProfiles.get(settingsId)) || {
        handle: settingsId,
        id: settingsId,
        messageId: messageId,
      };

      settings.autoMessageInterval = intervalNum;
      settings.updatedAt = new Date().toISOString();
      await xDb.xAccountProfiles.put(settings);

      showXToast(`已設置間隔為 ${intervalNum} 秒`, 'success');
    } catch (error) {
      console.error('更新時間間隔失敗:', error);
      showXToast('更新失敗', 'error');
    }
  }

  // 切換自動發資訊
  async function toggleStrangerAutoMessage(messageId) {
    try {
      const xDb = getXDB();
      const settingsId = `strangerSettings_${currentAccountId || 'main'}_${messageId}`;

      // 讀取當前狀態
      const settings = await xDb.xAccountProfiles.get(settingsId);
      const currentEnabled = settings && settings.autoMessageEnabled;

      const toggle = document.getElementById('auto-message-toggle');
      const toggleSwitch = toggle.querySelector('.toggle-switch');
      const toggleCircle = toggle.querySelector('.toggle-circle');

      if (currentEnabled) {
        // 當前已啟用，禁用
        settings.autoMessageEnabled = false;
        await xDb.xAccountProfiles.put(settings);

        toggleSwitch.style.backgroundColor = '#333';
        toggleCircle.style.left = '2px';

        showXToast('已關閉自動發資訊', 'success');
      } else {
        // 當前未啟用，啟用
        const newSettings = settings || {
          handle: settingsId,
          id: settingsId,
          messageId: messageId,
          autoMessageInterval: 60, // 默認60秒
        };

        newSettings.autoMessageEnabled = true;
        newSettings.updatedAt = new Date().toISOString();
        await xDb.xAccountProfiles.put(newSettings);

        toggleSwitch.style.backgroundColor = 'var(--x-accent)';
        toggleCircle.style.left = '22px';

        showXToast('已開啟自動發資訊', 'success');
      }
    } catch (error) {
      console.error('切換自動發資訊失敗:', error);
      showXToast('操作失敗', 'error');
    }
  }

  // 暴露函數到全域
  window.closeStrangerMessageSettings = closeStrangerMessageSettings;
  window.toggleStrangerContact = toggleStrangerContact;
  window.updateStrangerAvatar = updateStrangerAvatar;
  window.updateStrangerInterval = updateStrangerInterval;
  window.toggleStrangerAutoMessage = toggleStrangerAutoMessage;

  // ============================================
  // 粉絲群功能
  // ============================================

  // 創建粉絲群
  async function createFanGroup() {
    try {
      const xDb = getXDB();
      const dataId = `messagesList_${currentAccountId || 'main'}`;

      // 從資料庫載入最新的私信清單
      const savedData = await xDb.xAccountProfiles.get(dataId);
      let messagesList = savedData?.data || [];

      // 生成唯一ID
      const groupId = `fangroup_${Date.now()}`;

      // 創建新粉絲群資料
      const newFanGroup = {
        id: groupId,
        type: 'fangroup',
        userName: '我的粉絲群',
        userHandle: 'fangroup',
        userAvatar: 'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg', // 默認頭像
        lastMessage: '',
        timestamp: new Date().toISOString(),
        unread: false,
        // 粉絲群特有屬性
        groupName: '我的粉絲群',
        groupThreshold: '', // 入群門檻
        memberCount: 0, // 成員數量
      };

      // 添加到列表開頭
      messagesList.unshift(newFanGroup);

      // 保存到資料庫
      await xDb.xAccountProfiles.put({
        handle: dataId,
        name: 'messagesList',
        data: messagesList,
        updatedAt: new Date().toISOString(),
      });

      console.log('✅ [粉絲群] 已創建新粉絲群:', groupId);

      // 關閉彈窗
      closeNewMessageModal();

      // 更新全域變數
      sampleMessagesData = messagesList;

      // 刷新私信列表
      await loadMessagesList();

      showXToast('已創建粉絲群', 'success');

      // 自動打開粉絲群私信
      setTimeout(() => {
        window.openMessageDetail(newFanGroup);
      }, 300);
    } catch (error) {
      console.error('❌ [粉絲群] 創建失敗:', error);
      showXToast('創建粉絲群失敗', 'error');
    }
  }

  // 打開粉絲群設置彈窗
  async function openFanGroupSettings(groupData) {
    console.log('🎯 [粉絲群] 打開設置彈窗', groupData);

    try {
      const xDb = getXDB();
      const dataId = `messagesList_${currentAccountId || 'main'}`;
      const savedData = await xDb.xAccountProfiles.get(dataId);
      const messagesList = savedData?.data || [];

      // 找到當前粉絲群資料
      const fanGroup = messagesList.find(msg => msg.id === groupData.id);
      if (!fanGroup) {
        showXToast('未找到粉絲群數據', 'error');
        return;
      }

      // 創建設置彈窗
      const modal = document.createElement('div');
      modal.id = 'fangroup-settings-modal';
      modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 25;
        backdrop-filter: blur(4px);
      `;

      modal.innerHTML = `
        <div style="
          background-color: var(--x-bg-primary);
          border-radius: 16px;
          width: 90%;
          max-width: 500px;
          max-height: 80vh;
          overflow: hidden;
          border: 1px solid var(--x-border-color);
          display: flex;
          flex-direction: column;
        " onclick="event.stopPropagation()">
          
          <!-- 標題列 -->
          <div style="
            padding: 16px 20px;
            border-bottom: 1px solid var(--x-border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
          ">
            <div style="font-size: 18px; font-weight: 700; color: var(--x-text-primary);">粉絲群設置</div>
            <div onclick="closeFanGroupSettings()" style="
              cursor: pointer;
              padding: 8px;
              border-radius: 50%;
              transition: background-color 0.2s;
            " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
               onmouseout="this.style.backgroundColor='transparent'">
              <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);">
                <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
              </svg>
            </div>
          </div>

          <!-- 設置內容 -->
          <div style="
            flex: 1;
            overflow-y: auto;
            padding: 20px;
          ">
            
            <!-- 群頭像設置 -->
            <div style="margin-bottom: 24px;">
              <div style="font-size: 16px; font-weight: 600; color: var(--x-text-primary); margin-bottom: 12px;">
                群頭像
              </div>
              <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
                <img id="fangroup-avatar-preview" src="${
                  fanGroup.userAvatar ||
                  fanGroup.groupAvatar ||
                  'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg'
                }" style="
                  width: 64px;
                  height: 64px;
                  border-radius: 50%;
                  object-fit: cover;
                ">
              </div>
              <div style="display: flex; gap: 8px;">
                <input 
                  type="text" 
                  id="fangroup-avatar-input" 
                  placeholder="輸入圖片連結位址"
                  value="${fanGroup.userAvatar || fanGroup.groupAvatar || ''}"
                  style="
                    flex: 1;
                    background-color: var(--x-bg-secondary);
                    border: 1px solid var(--x-border-color);
                    border-radius: 20px;
                    padding: 10px 16px;
                    font-size: 14px;
                    color: var(--x-text-primary);
                    outline: none;
                  "
                  onfocus="this.style.borderColor='var(--x-accent)'"
                  onblur="this.style.borderColor='var(--x-border-color)'"
                  oninput="updateFanGroupAvatarPreview(this.value)"
                >
                <button onclick="saveFanGroupAvatar('${groupData.id}')" style="
                  background-color: var(--x-accent);
                  color: #fff;
                  border: none;
                  border-radius: 20px;
                  padding: 10px 20px;
                  font-size: 14px;
                  font-weight: 600;
                  cursor: pointer;
                  transition: opacity 0.2s;
                  white-space: nowrap;
                " onmouseover="this.style.opacity='0.9'" onmouseout="this.style.opacity='1'">
                  更新
                </button>
              </div>
            </div>

            <!-- 群名稱設置 -->
            <div style="margin-bottom: 24px;">
              <div style="font-size: 16px; font-weight: 600; color: var(--x-text-primary); margin-bottom: 12px;">
                群名稱
              </div>
              <input 
                type="text" 
                id="fangroup-name-input" 
                placeholder="輸入群名稱"
                value="${fanGroup.userName || fanGroup.groupName || '我的粉絲群'}"
                maxlength="30"
                style="
                  width: 100%;
                  background-color: var(--x-bg-secondary);
                  border: 1px solid var(--x-border-color);
                  border-radius: 8px;
                  padding: 12px;
                  font-size: 14px;
                  color: var(--x-text-primary);
                  outline: none;
                "
                onfocus="this.style.borderColor='var(--x-accent)'"
                onblur="this.style.borderColor='var(--x-border-color)'"
              >
            </div>

            <!-- 入群門檻設置 -->
            <div style="margin-bottom: 24px;">
              <div style="font-size: 16px; font-weight: 600; color: var(--x-text-primary); margin-bottom: 12px;">
                入群門檻
              </div>
              <textarea 
                id="fangroup-threshold-input" 
                placeholder="例如：關注滿30天、互動次數達到10次等..."
                maxlength="200"
                style="
                  width: 100%;
                  min-height: 100px;
                  background-color: var(--x-bg-secondary);
                  border: 1px solid var(--x-border-color);
                  border-radius: 8px;
                  padding: 12px;
                  font-size: 14px;
                  color: var(--x-text-primary);
                  outline: none;
                  resize: vertical;
                  font-family: inherit;
                  line-height: 1.5;
                "
                onfocus="this.style.borderColor='var(--x-accent)'"
                onblur="this.style.borderColor='var(--x-border-color)'"
              >${fanGroup.groupThreshold || ''}</textarea>
              <div style="text-align: right; margin-top: 4px;">
                <span style="font-size: 12px; color: var(--x-text-secondary);">設置粉絲需要滿足的條件才能進群</span>
              </div>
            </div>

          </div>

          <!-- 底部按鈕 -->
          <div style="padding: 16px 20px; border-top: 1px solid var(--x-border-color);">
            <div style="display: flex; gap: 8px; justify-content: flex-end;">
              <button onclick="closeFanGroupSettings()" style="
                background-color: var(--x-bg-secondary);
                color: var(--x-text-primary);
                border: none;
                border-radius: 20px;
                padding: 10px 20px;
                font-size: 14px;
                font-weight: 600;
                cursor: pointer;
              ">取消</button>
              <button onclick="saveFanGroupSettings('${groupData.id}')" style="
                background-color: var(--x-accent);
                color: #fff;
                border: none;
                border-radius: 20px;
                padding: 10px 20px;
                font-size: 14px;
                font-weight: 600;
                cursor: pointer;
              ">保存設置</button>
            </div>
          </div>
        </div>
      `;

      // 添加到DOM
      const xSocialScreen = document.getElementById('x-social-screen');
      if (xSocialScreen) {
        xSocialScreen.appendChild(modal);
      } else {
        document.body.appendChild(modal);
      }

      // 點擊背景關閉
      modal.onclick = e => {
        if (e.target === modal) {
          closeFanGroupSettings();
        }
      };
    } catch (error) {
      console.error('❌ [粉絲群] 打開設置失敗:', error);
      showXToast('打開設置失敗', 'error');
    }
  }

  // 關閉粉絲群設置彈窗
  function closeFanGroupSettings() {
    const modal = document.getElementById('fangroup-settings-modal');
    if (modal) {
      modal.remove();
    }
  }

  // 更新粉絲群頭像預覽
  function updateFanGroupAvatarPreview(avatarUrl) {
    const preview = document.getElementById('fangroup-avatar-preview');
    if (preview && avatarUrl) {
      preview.src = avatarUrl;
    }
  }

  // 保存粉絲群頭像
  async function saveFanGroupAvatar(groupId) {
    const avatarInput = document.getElementById('fangroup-avatar-input');
    if (!avatarInput) return;

    const newAvatar = avatarInput.value.trim();
    if (!newAvatar) {
      showXToast('請輸入頭像連結', 'warning');
      return;
    }

    try {
      const xDb = getXDB();
      const dataId = `messagesList_${currentAccountId || 'main'}`;
      const savedData = await xDb.xAccountProfiles.get(dataId);
      let messagesList = savedData?.data || [];

      // 找到並更新粉絲群
      const groupIndex = messagesList.findIndex(msg => msg.id === groupId);
      if (groupIndex !== -1) {
        messagesList[groupIndex].userAvatar = newAvatar;
        messagesList[groupIndex].groupAvatar = newAvatar;

        // 保存到資料庫
        await xDb.xAccountProfiles.put({
          handle: dataId,
          name: 'messagesList',
          data: messagesList,
          updatedAt: new Date().toISOString(),
        });

        // 更新全域變數
        sampleMessagesData = messagesList;

        // 更新私信詳情頁的頭像（如果正在查看）
        const topAvatar = document.getElementById('message-detail-top-avatar');
        if (topAvatar && currentMessageConversation?.id === groupId) {
          topAvatar.src = newAvatar;
        }

        // 刷新私信列表
        await loadMessagesList();

        showXToast('頭像已更新', 'success');
      }
    } catch (error) {
      console.error('❌ [粉絲群] 保存頭像失敗:', error);
      showXToast('保存失敗', 'error');
    }
  }

  // 保存粉絲群設置
  async function saveFanGroupSettings(groupId) {
    try {
      const nameInput = document.getElementById('fangroup-name-input');
      const thresholdInput = document.getElementById('fangroup-threshold-input');

      if (!nameInput) return;

      const newName = nameInput.value.trim();
      const newThreshold = thresholdInput ? thresholdInput.value.trim() : '';

      if (!newName) {
        showXToast('請輸入群名稱', 'warning');
        return;
      }

      const xDb = getXDB();
      const dataId = `messagesList_${currentAccountId || 'main'}`;
      const savedData = await xDb.xAccountProfiles.get(dataId);
      let messagesList = savedData?.data || [];

      // 找到並更新粉絲群
      const groupIndex = messagesList.findIndex(msg => msg.id === groupId);
      if (groupIndex !== -1) {
        messagesList[groupIndex].userName = newName;
        messagesList[groupIndex].groupName = newName;
        messagesList[groupIndex].groupThreshold = newThreshold;

        // 保存到資料庫
        await xDb.xAccountProfiles.put({
          handle: dataId,
          name: 'messagesList',
          data: messagesList,
          updatedAt: new Date().toISOString(),
        });

        // 更新全域變數
        sampleMessagesData = messagesList;

        // 更新私信詳情頁的名稱（如果正在查看）
        const topName = document.getElementById('message-detail-top-name');
        if (topName && currentMessageConversation?.id === groupId) {
          topName.textContent = newName;
        }

        // 刷新私信列表
        await loadMessagesList();

        showXToast('設置已保存', 'success');
        closeFanGroupSettings();
      }
    } catch (error) {
      console.error('❌ [粉絲群] 保存設置失敗:', error);
      showXToast('保存失敗', 'error');
    }
  }

  // 處理私信詳情頁小頭像點擊
  function handleMessageDetailAvatarClick() {
    if (!currentMessageConversation) return;

    // 檢查是否為粉絲群
    if (currentMessageConversation.type === 'fangroup') {
      // 打開粉絲群設置
      openFanGroupSettings(currentMessageConversation);
      return;
    }

    // 檢查是否為角色私信（角色私信不支援設置功能）
    const isCharacterMessage =
      currentMessageConversation.id &&
      currentMessageConversation.id.startsWith('msg_') &&
      currentMessageConversation.id !== 'msg_001';

    if (isCharacterMessage) {
      console.log('點擊了角色對話頭像（角色對話不支援設置）');
      return;
    }

    // 其他類型（帳戶/NPC/關係NPC/陌生人）：打開連絡人設置
    console.log('打開連絡人設置，類型:', currentMessageConversation._accountType || 'stranger');

    // 構建標準的 messageData 格式
    const messageData = {
      id: currentMessageConversation.id,
      user: {
        name: currentMessageConversation.userName || currentMessageConversation.name,
        handle: currentMessageConversation.userHandle || currentMessageConversation.handle,
        avatar: currentMessageConversation.userAvatar || currentMessageConversation.avatar,
      },
      preview: currentMessageConversation.lastMessage || '',
      _accountType: currentMessageConversation._accountType || 'stranger',
    };

    // 打開通用連絡人設置彈窗
    openMessageContactSettings(messageData, null);
  }

  // 調整粉絲群詳情頁顯示（隱藏大頭像和詳細資訊區域）
  function adjustFanGroupDetailPage(isFanGroup) {
    const scrollableContainer = document.getElementById('message-detail-scrollable');
    if (!scrollableContainer) return;

    // 找到使用者詳細資訊區域（第一個子元素）
    const userInfoSection = scrollableContainer.children[0];
    if (!userInfoSection) return;

    if (isFanGroup) {
      // 粉絲群：隱藏使用者詳細資訊區域
      userInfoSection.style.display = 'none';
      console.log('🎯 [粉絲群] 已隱藏詳細資訊區域');
    } else {
      // 普通對話：顯示使用者詳細資訊區域
      userInfoSection.style.display = 'flex';
    }
  }

  // 暴露粉絲群函數到全域
  window.createFanGroup = createFanGroup;
  window.openFanGroupSettings = openFanGroupSettings;
  window.closeFanGroupSettings = closeFanGroupSettings;
  window.updateFanGroupAvatarPreview = updateFanGroupAvatarPreview;
  window.saveFanGroupAvatar = saveFanGroupAvatar;
  window.saveFanGroupSettings = saveFanGroupSettings;
  window.handleMessageDetailAvatarClick = handleMessageDetailAvatarClick;

  // 包裝原始的 openMessageDetail 函數，添加粉絲群特殊處理
  const originalOpenMessageDetail = window.openMessageDetail;
  window.openMessageDetail = async function (messageData, isFromNotifications) {
    console.log('🎯 [粉絲群] 攔截器：檢測消息類型', messageData);

    // 調用原始函數
    if (originalOpenMessageDetail) {
      await originalOpenMessageDetail(messageData, isFromNotifications);
    }

    // 延遲執行以確保頁面已渲染
    setTimeout(() => {
      const isFanGroup = messageData.type === 'fangroup';
      adjustFanGroupDetailPage(isFanGroup);
    }, 100);
  };

  // ============================================
  // 私信多選刪除功能
  // ============================================

  // 切換消息選擇狀態
  function toggleMessageSelection(messageId) {
    if (selectedMessages.has(messageId)) {
      selectedMessages.delete(messageId);
    } else {
      selectedMessages.add(messageId);
    }
    updateMessageSelectionUI();
    updateMessageDeleteUI();
  }

  // 進入多選模式
  function enterMessageMultiSelectMode() {
    messageMultiSelectMode = true;
    selectedMessages.clear();
    showMessageDeleteToolbar();
    reloadMessageDetailView();
  }

  // 退出多選模式
  window.exitMessageMultiSelectMode = function () {
    messageMultiSelectMode = false;
    selectedMessages.clear();
    hideMessageDeleteToolbar();
    reloadMessageDetailView();
  };

  // 重新載入消息詳情視圖
  async function reloadMessageDetailView() {
    if (!currentMessageConversation) return;

    try {
      const xDb = getXDB();
      // 🔧 多帳戶隔離：包含帳戶ID
      const conversationId = `messageConversation_${currentAccountId || 'main'}_${currentMessageConversation.id}`;
      const savedConversation = await xDb.xAccountProfiles.get(conversationId);

      if (savedConversation && savedConversation.data && savedConversation.data.messages) {
        const contentContainer = document.getElementById('message-detail-content');
        if (!contentContainer) return;

        // 清空並重新渲染所有消息
        const dateElements = contentContainer.querySelectorAll('.message-item, div[style*="text-align: center"]');
        dateElements.forEach(el => {
          // 只移除消息項，保留日期分隔符號
          if (el.classList.contains('message-item')) {
            el.remove();
          }
        });

        // 使用分組渲染消息
        const messages = savedConversation.data.messages;
        const groups = groupMessagesBySender(messages);
        const allMessageElements = [];

        groups.forEach(group => {
          const isOwn = group[0].message.isOwn === true;
          group.forEach((item, indexInGroup) => {
            const isLastInGroup = indexInGroup === group.length - 1;
            const messageEl = renderMessageItem(item.message, isOwn, item.index, isLastInGroup);
            contentContainer.appendChild(messageEl);
            allMessageElements.push(messageEl);
          });
        });

        // 立即顯示所有消息（不需要動畫）
        allMessageElements.forEach(el => {
          el.style.opacity = '1';
          el.style.transform = 'translateY(0)';
        });
      }
    } catch (error) {
      console.error('重新載入消息視圖失敗:', error);
    }
  }

  // 更新消息選擇UI
  function updateMessageSelectionUI() {
    selectedMessages.forEach(messageId => {
      const messageEl = document.querySelector(`[data-message-id="${messageId}"]`);
      if (messageEl) {
        messageEl.style.opacity = selectedMessages.has(messageId) ? '0.7' : '1';

        const indicator = messageEl.querySelector('.message-select-indicator');
        if (indicator) {
          const isSelected = selectedMessages.has(messageId);
          indicator.style.borderColor = isSelected ? 'var(--x-accent)' : 'var(--x-border-color)';
          indicator.style.backgroundColor = isSelected ? 'var(--x-accent)' : 'var(--x-bg-primary)';

          if (isSelected) {
            indicator.innerHTML = `
              <svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: #fff;">
                <g><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"></path></g>
              </svg>
            `;
          } else {
            indicator.innerHTML = '';
          }
        }
      }
    });
  }

  // 顯示刪除工具列
  function showMessageDeleteToolbar() {
    // 隱藏底部輸入欄
    const inputToolbar = document.getElementById('message-input-toolbar');
    if (inputToolbar) {
      inputToolbar.style.display = 'none';
    }

    // 創建刪除工具列
    let deleteToolbar = document.getElementById('message-delete-toolbar');
    if (!deleteToolbar) {
      deleteToolbar = document.createElement('div');
      deleteToolbar.id = 'message-delete-toolbar';
      deleteToolbar.style.cssText = `
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        height: 56px;
        background-color: var(--x-bg-primary);
        border-top: 1px solid var(--x-border-color);
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 16px;
        z-index: 100;
      `;

      deleteToolbar.innerHTML = `
        <div style="display: flex; align-items: center; gap: 16px;">
          <button onclick="exitMessageMultiSelectMode()" style="
            background: none;
            border: none;
            color: var(--x-accent);
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            padding: 8px 0;
          ">取消</button>
          <button onclick="selectAllMessages()" style="
            background: none;
            border: none;
            color: var(--x-accent);
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            padding: 8px 0;
          ">全選</button>
        </div>
        <div style="
          color: var(--x-text-secondary);
          font-size: 14px;
        ">
          已選擇 <span id="message-selected-count">0</span> 條
        </div>
        <button onclick="deleteSelectedMessages()" id="message-delete-btn" style="
          background-color: #f4212e;
          border: none;
          color: #fff;
          font-size: 15px;
          font-weight: 600;
          cursor: pointer;
          padding: 8px 16px;
          border-radius: 18px;
          opacity: 0.5;
          pointer-events: none;
        ">刪除</button>
      `;

      const detailPage = document.getElementById('x-message-detail-page');
      if (detailPage) {
        detailPage.appendChild(deleteToolbar);
      }
    }

    deleteToolbar.style.display = 'flex';
  }

  // 隱藏刪除工具列
  function hideMessageDeleteToolbar() {
    const deleteToolbar = document.getElementById('message-delete-toolbar');
    if (deleteToolbar) {
      deleteToolbar.remove();
    }

    // 顯示輸入欄
    const inputToolbar = document.getElementById('message-input-toolbar');
    if (inputToolbar) {
      inputToolbar.style.display = 'flex';
    }
  }

  // 更新刪除UI
  function updateMessageDeleteUI() {
    const countEl = document.getElementById('message-selected-count');
    const deleteBtn = document.getElementById('message-delete-btn');

    if (countEl) {
      countEl.textContent = selectedMessages.size;
    }

    if (deleteBtn) {
      if (selectedMessages.size > 0) {
        deleteBtn.style.opacity = '1';
        deleteBtn.style.pointerEvents = 'auto';
      } else {
        deleteBtn.style.opacity = '0.5';
        deleteBtn.style.pointerEvents = 'none';
      }
    }
  }

  // 全選消息
  window.selectAllMessages = function () {
    const messageElements = document.querySelectorAll('.message-item[data-message-id]');
    messageElements.forEach(el => {
      const messageId = el.getAttribute('data-message-id');
      if (messageId) {
        selectedMessages.add(messageId);
      }
    });
    updateMessageSelectionUI();
    updateMessageDeleteUI();
  };

  // 刪除選中的消息
  window.deleteSelectedMessages = async function () {
    if (selectedMessages.size === 0) {
      showXToast('請先選擇要刪除的消息', 'error');
      return;
    }

    const isEnglish = currentLanguage === 'en';
    const confirmMessage = isEnglish
      ? `Delete ${selectedMessages.size} message(s)?`
      : `確定刪除選中的 ${selectedMessages.size} 條消息嗎？`;

    if (!confirm(confirmMessage)) {
      return;
    }

    try {
      const xDb = getXDB();
      // 🔧 多帳戶隔離：包含帳戶ID
      const conversationId = `messageConversation_${currentAccountId || 'main'}_${currentMessageConversation.id}`;
      const savedConversation = await xDb.xAccountProfiles.get(conversationId);

      if (savedConversation && savedConversation.data && savedConversation.data.messages) {
        // 收集要刪除的消息索引
        const indicesToDelete = new Set();
        selectedMessages.forEach(messageId => {
          // 從 messageId 中提取索引（格式：msg_idx_0, msg_idx_1, etc.）
          const match = messageId.match(/^msg_idx_(\d+)$/);
          if (match) {
            indicesToDelete.add(parseInt(match[1], 10));
          }
        });

        // 過濾掉選中的消息
        const updatedMessages = savedConversation.data.messages.filter((msg, index) => {
          return !indicesToDelete.has(index);
        });

        console.log(`🗑️ 準備刪除索引: ${Array.from(indicesToDelete).join(', ')}`);
        console.log(`📝 刪除前消息數: ${savedConversation.data.messages.length}, 刪除後: ${updatedMessages.length}`);

        // 更新資料庫
        savedConversation.data.messages = updatedMessages;
        savedConversation.updatedAt = new Date().toISOString();
        await xDb.xAccountProfiles.put(savedConversation);

        console.log(`✅ 已刪除 ${indicesToDelete.size} 條消息`);

        // 退出多選模式
        exitMessageMultiSelectMode();

        // 刷新視圖
        const contentContainer = document.getElementById('message-detail-content');
        if (contentContainer) {
          // 清空並重新渲染
          contentContainer.innerHTML = '';

          // 添加日期分隔符號
          const today = new Date();
          const dateStr =
            currentLanguage === 'en'
              ? today.toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' })
              : `${today.getFullYear()}年${today.getMonth() + 1}月${String(today.getDate()).padStart(2, '0')}日`;
          contentContainer.appendChild(renderDateSeparator(dateStr));

          // 使用分組渲染消息
          const groups = groupMessagesBySender(updatedMessages);
          const allMessageElements = [];

          groups.forEach(group => {
            const isOwn = group[0].message.isOwn === true;
            group.forEach((item, indexInGroup) => {
              const isLastInGroup = indexInGroup === group.length - 1;
              const messageEl = renderMessageItem(item.message, isOwn, item.index, isLastInGroup);
              contentContainer.appendChild(messageEl);
              allMessageElements.push(messageEl);
            });
          });

          // 立即顯示所有消息（不需要動畫）
          allMessageElements.forEach(el => {
            el.style.opacity = '1';
            el.style.transform = 'translateY(0)';
          });

          // 滾動到底部
          setTimeout(() => {
            const scrollable = document.getElementById('message-detail-scrollable');
            if (scrollable) {
              scrollable.scrollTop = scrollable.scrollHeight;
            }
          }, 100);
        }

        const successMessage = isEnglish
          ? `Deleted ${indicesToDelete.size} message(s)`
          : `已刪除 ${indicesToDelete.size} 條消息`;
        showXToast(successMessage, 'success');
      }
    } catch (error) {
      console.error('刪除消息失敗:', error);
      const errorMessage = isEnglish ? 'Failed to delete messages' : '刪除消息失敗';
      showXToast(errorMessage, 'error');
    }
  };

  // ============================================
  // 拉黑解除檢測系統
  // ============================================

  /**
   * 檢測用戶是否通過@或評論觸發拉黑解除
   * @param {string} userHandle - 用戶控制碼
   * @param {string} targetHandle - 被拉黑對方的控制碼
   * @param {string} triggerSource - 觸發來源：'mention' | 'comment'
   * @param {string} content - 觸發內容（推文內容或評論內容）
   */
  async function checkUnblockTrigger(userHandle, targetHandle, triggerSource, content) {
    try {
      const xDb = getXDB();

      // 清理控制碼
      const cleanUserHandle = userHandle.replace('@', '').toLowerCase();
      const cleanTargetHandle = targetHandle.replace('@', '').toLowerCase();

      console.log(`🔓 [拉黑解除] 檢測觸發: 用戶=${cleanUserHandle}, 對方=${cleanTargetHandle}, 來源=${triggerSource}`);

      // 查找對方的資料，確定消息ID
      let messageId = null;
      let messageData = null;

      // 嘗試查找角色
      const allXProfiles = await xDb.xCharacterProfiles.toArray();
      const targetProfile = allXProfiles.find(
        p => p.xHandle && p.xHandle.replace('@', '').toLowerCase() === cleanTargetHandle,
      );

      if (targetProfile) {
        messageId = `msg_${targetProfile.characterId}`;
        const messagesListId = `messagesList_${currentAccountId || 'main'}`;
        const messagesListData = await xDb.xAccountProfiles.get(messagesListId);
        if (messagesListData && messagesListData.data) {
          messageData = messagesListData.data.find(m => m.id === messageId);
        }
      } else {
        // 嘗試查找帳戶
        const accountProfile = await xDb.xAccountProfiles.get(cleanTargetHandle);
        if (accountProfile) {
          messageId = `msg_account_${cleanTargetHandle}`;
          const messagesListId = `messagesList_${currentAccountId || 'main'}`;
          const messagesListData = await xDb.xAccountProfiles.get(messagesListId);
          if (messagesListData && messagesListData.data) {
            messageData = messagesListData.data.find(m => m.id === messageId);
          }
        } else {
          // 陌生人
          const messagesListId = `messagesList_${currentAccountId || 'main'}`;
          const messagesListData = await xDb.xAccountProfiles.get(messagesListId);
          if (messagesListData && messagesListData.data) {
            messageData = messagesListData.data.find(
              m => m.userHandle && m.userHandle.replace('@', '').toLowerCase() === cleanTargetHandle,
            );
            if (messageData) {
              messageId = messageData.id;
            }
          }
        }
      }

      if (!messageId || !messageData) {
        console.log(`⚠️ [拉黑解除] 未找到對應的私信記錄`);
        return;
      }

      // 檢查是否被拉黑
      const conversationId = `messageConversation_${currentAccountId || 'main'}_${messageId}`;
      const savedConversation = await xDb.xAccountProfiles.get(conversationId);

      if (!savedConversation || !savedConversation.isBlocked) {
        console.log(`ℹ️ [拉黑解除] 對方並未拉黑用戶，無需解除`);
        return;
      }

      console.log(`✅ [拉黑解除] 檢測到拉黑狀態，準備生成AI回復評估是否解除`);

      // 使用統一AI回復生成器，傳入特殊上下文
      const unblockContext = {
        triggerSource: triggerSource, // 'mention' | 'comment'
        triggerContent: content,
        isUnblockTrigger: true, // 標記為拉黑解除觸發
      };

      // 生成AI回復（帶拉黑解除上下文）
      const aiMessages = await generateMessageConversation(messageData, true, {
        isUnblockRequest: true,
        unblockContext: unblockContext,
      });

      // 檢查是否包含解除拉黑系統提示
      const hasUnblockedMessage =
        aiMessages && aiMessages.some(msg => msg.type === 'system' && msg.systemType === 'unblocked');

      if (hasUnblockedMessage) {
        console.log(`🎉 [拉黑解除] AI決定解除拉黑！`);

        // 解除拉黑狀態
        savedConversation.isBlocked = false;
        delete savedConversation.blockedAt;
        savedConversation.updatedAt = new Date().toISOString();

        // 添加AI回復到對話記錄
        if (!savedConversation.data) {
          savedConversation.data = { messages: [] };
        }
        if (!savedConversation.data.messages) {
          savedConversation.data.messages = [];
        }

        // 添加上下文系統通知（說明使用者通過何種方式觸發）
        const contextNotification = {
          type: 'system',
          systemType: 'unblockContext',
          content:
            triggerSource === 'mention'
              ? `用戶在推文中@了你: "${content.substring(0, 100)}..."`
              : `用戶在評論區提到了你: "${content.substring(0, 100)}..."`,
          timestamp: new Date().toISOString(),
          time: '剛剛',
        };

        savedConversation.data.messages.push(contextNotification);

        // 添加AI消息
        aiMessages.forEach(msg => {
          if (!msg.timestamp) {
            msg.timestamp = new Date().toISOString();
          }
          if (!msg.time) {
            msg.time = '剛剛';
          }
          savedConversation.data.messages.push(msg);
        });

        // 保存到資料庫
        await xDb.xAccountProfiles.put(savedConversation);

        // 🔔 顯示手機樣式通知
        showPhoneNotification({
          title: messageData.userName || messageData.user?.name || '未知用戶',
          message: '已解除拉黑',
          avatar:
            messageData.userAvatar ||
            messageData.user?.avatar ||
            'https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg',
          onClick: () => {
            // 點擊通知打開私信詳情
            openMessageDetail(messageData);
          },
        });

        // 如果當前正在查看該私信詳情，刷新介面
        const detailPage = document.getElementById('x-message-detail-page');
        if (detailPage && detailPage.style.display === 'flex') {
          const currentMessageData = window.currentViewingMessage;
          if (currentMessageData && currentMessageData.id === messageId) {
            console.log(`🔄 [拉黑解除] 刷新當前私信詳情頁`);

            // 解除輸入框禁用
            const messageInput = document.getElementById('message-input');
            const sendBtn = document.getElementById('message-send-btn');
            if (messageInput) {
              messageInput.disabled = false;
              messageInput.placeholder = '發送私信';
            }
            if (sendBtn) {
              sendBtn.disabled = false;
            }

            // 重新載入對話
            loadMessageConversation(messageData, savedConversation.data);
          }
        }

        console.log(`✅ [拉黑解除] 拉黑已解除，AI消息已發送`);
      } else {
        console.log(`❌ [拉黑解除] AI決定不解除拉黑`);
      }
    } catch (error) {
      console.error('❌ [拉黑解除] 檢測失敗:', error);
    }
  }

  // ============================================
  // 後臺自動發消息系統
  // ============================================

  let autoMessageCheckInterval = null;
  const AUTO_MESSAGE_CHECK_FREQUENCY = 5000; // 每5秒檢查一次
  const lastAutoMessageTrigger = {}; // 記錄每個角色上次觸發時間，防止重複觸發

  // 暴露到window以便其他函數訪問
  window.resetAutoMessageTrigger = function (characterId) {
    if (characterId && lastAutoMessageTrigger[characterId]) {
      delete lastAutoMessageTrigger[characterId];
      console.log(`🔄 已重置角色 ${characterId} 的自動發消息觸發記錄`);
    }
  };

  // 啟動後臺自動發消息檢查
  function startAutoMessageSystem() {
    if (autoMessageCheckInterval) {
      clearInterval(autoMessageCheckInterval);
    }

    console.log('🤖 啟動後臺自動發消息系統');

    autoMessageCheckInterval = setInterval(async () => {
      await checkAndTriggerAutoMessages();
    }, AUTO_MESSAGE_CHECK_FREQUENCY);
  }

  // 停止後臺自動發消息檢查
  function stopAutoMessageSystem() {
    if (autoMessageCheckInterval) {
      clearInterval(autoMessageCheckInterval);
      autoMessageCheckInterval = null;
      console.log('🤖 停止後臺自動發消息系統');
    }
  }

  // 檢查並觸發自動發消息
  async function checkAndTriggerAutoMessages() {
    try {
      const db = getDB();
      const xDb = getXDB();

      // 獲取私信清單資料
      const dataId = `messagesList_${currentAccountId || 'main'}`;
      const savedData = await xDb.xAccountProfiles.get(dataId);
      const messagesList = savedData?.data || [];

      const now = Date.now();

      // === 第一部分：檢查綁定角色 ===
      const settingsId = `xSettings_${currentAccountId || 'main'}`;
      const xSettings = await xDb.xSettings.get(settingsId);
      const boundCharacters = xSettings?.boundCharacters || [];

      // 獲取所有角色的X資料
      const characterProfiles = await Promise.all(boundCharacters.map(id => xDb.xCharacterProfiles.get(id)));

      // 遍歷每個啟用了自動發消息的角色
      for (const profile of characterProfiles) {
        if (!profile || !profile.autoMessageEnabled) {
          continue;
        }

        // 檢查該角色是否在私信列表中
        const characterId = profile.characterId;
        const messageId = `msg_${characterId}`;
        const messageItem = messagesList.find(msg => msg.id === messageId);

        if (!messageItem) {
          continue; // 角色不在私信列表，跳過
        }

        // 檢查最後一次互動時間
        // 🔧 多帳戶隔離：包含帳戶ID
        const conversationId = `messageConversation_${currentAccountId || 'main'}_${messageId}`;
        const savedConversation = await xDb.xAccountProfiles.get(conversationId);

        if (!savedConversation || !savedConversation.data || !savedConversation.data.messages) {
          continue;
        }

        const messages = savedConversation.data.messages;
        const intervalSeconds = profile.autoMessageInterval || 60;

        // 檢查是否最近已經觸發過（防止重複觸發）
        const lastTriggerTime = lastAutoMessageTrigger[characterId] || 0;
        const timeSinceLastTrigger = (now - lastTriggerTime) / 1000;

        // 情況1：沒有任何聊天記錄，觸發初次主動消息
        if (messages.length === 0) {
          // 檢查距離上次觸發的時間，防止頻繁觸發
          if (timeSinceLastTrigger >= intervalSeconds) {
            console.log(`🤖 觸發自動發消息（無聊天記錄）: ${profile.xName}`);

            // 記錄觸發時間
            lastAutoMessageTrigger[characterId] = now;

            // 觸發自動發消息
            await triggerAutoMessage(messageItem, profile, 0);
          }
          continue;
        }

        // 獲取最後一條消息
        const lastMessage = messages[messages.length - 1];
        const lastMessageTime = lastMessage.timestamp ? new Date(lastMessage.timestamp).getTime() : 0;
        const timeSinceLastMessage = (now - lastMessageTime) / 1000; // 轉換為秒

        // 情況2：最後一條消息是角色發送的（用戶沒有回復），且超過設定時間
        // 如果最後一條消息不是使用者發的（!isOwn），說明是角色發的，用戶還沒回復
        if (
          timeSinceLastMessage >= intervalSeconds &&
          !lastMessage.isOwn &&
          timeSinceLastTrigger >= intervalSeconds / 2
        ) {
          console.log(
            `🤖 觸發自動發消息（使用者未回復）: ${profile.xName}, 距離上次互動 ${Math.floor(timeSinceLastMessage)}秒`,
          );

          // 記錄觸發時間
          lastAutoMessageTrigger[characterId] = now;

          // 觸發自動發消息
          await triggerAutoMessage(messageItem, profile, timeSinceLastMessage);
        }

        // 🎲 隨機觸發自動發推（20%概率）
        if (messages.length > 0 && Math.random() < 0.2) {
          const lastMessageTime = lastMessage.timestamp ? new Date(lastMessage.timestamp).getTime() : 0;
          const timeSinceLastMsg = (now - lastMessageTime) / 1000;

          // 只有在有聊天記錄且距離上次聊天超過間隔時間才觸發
          if (timeSinceLastMsg >= intervalSeconds) {
            console.log(`🎲 [角色自動發推] 觸發: ${profile.xName}, 距離上次聊天 ${Math.floor(timeSinceLastMsg)}秒`);
            await triggerAutoTweet(messageItem, profile, timeSinceLastMsg, 'character');
          }
        }
      }

      // === 第二部分：檢查帳戶/NPC/陌生人 ===
      for (const messageItem of messagesList) {
        // 🔧 只跳過綁定角色（msg_xxx格式但不是 msg_account_/msg_npc_/msg_relationship_ 等）
        // 綁定角色的ID格式：msg_chatId（純數位或字母組合，不帶底線首碼）
        const isCharacterMessage =
          messageItem.id.startsWith('msg_') &&
          messageItem.id !== 'msg_001' &&
          !messageItem.id.startsWith('msg_account_') &&
          !messageItem.id.startsWith('msg_npc_') &&
          !messageItem.id.startsWith('msg_relationship_');

        if (isCharacterMessage) {
          continue; // 跳過綁定角色（它們在第一部分已經處理了）
        }

        // 檢查該帳戶/NPC/陌生人是否啟用了自動發消息
        const strangerSettingsId = `strangerSettings_${currentAccountId || 'main'}_${messageItem.id}`;
        const strangerSettings = await xDb.xAccountProfiles.get(strangerSettingsId);

        if (!strangerSettings || !strangerSettings.autoMessageEnabled) {
          continue;
        }

        // 獲取自訂的時間間隔（默認60秒）
        const intervalSeconds = strangerSettings.autoMessageInterval || 60;

        // 確定帳戶類型用於日誌
        const accountType =
          messageItem._accountType ||
          (messageItem.id.startsWith('msg_account_')
            ? '帳戶'
            : messageItem.id.startsWith('msg_npc_')
            ? 'NPC'
            : messageItem.id.startsWith('msg_relationship_')
            ? '關係NPC'
            : '陌生人');

        console.log(
          `⏰ [${accountType}自動發消息] ${messageItem.userName || messageItem.user?.name} 間隔: ${intervalSeconds}秒`,
        );

        // 檢查最後一次互動時間
        const conversationId = `messageConversation_${currentAccountId || 'main'}_${messageItem.id}`;
        const savedConversation = await xDb.xAccountProfiles.get(conversationId);

        if (!savedConversation || !savedConversation.data || !savedConversation.data.messages) {
          continue;
        }

        const messages = savedConversation.data.messages;

        // 檢查是否最近已經觸發過
        const lastTriggerTime = lastAutoMessageTrigger[messageItem.id] || 0;
        const timeSinceLastTrigger = (now - lastTriggerTime) / 1000;

        // 情況1：沒有任何聊天記錄，觸發初次主動消息
        if (messages.length === 0) {
          if (timeSinceLastTrigger >= intervalSeconds) {
            console.log(
              `🤖 觸發${accountType}自動發消息（無聊天記錄）: ${messageItem.userName || messageItem.user?.name}`,
            );
            lastAutoMessageTrigger[messageItem.id] = now;
            await triggerStrangerAutoMessage(messageItem, strangerSettings, 0);
          }
          continue;
        }

        // 獲取最後一條消息
        const lastMessage = messages[messages.length - 1];
        const lastMessageTime = lastMessage.timestamp ? new Date(lastMessage.timestamp).getTime() : 0;
        const timeSinceLastMessage = (now - lastMessageTime) / 1000;

        // 情況2：最後一條消息是對方發送的，且超過設定時間
        if (
          timeSinceLastMessage >= intervalSeconds &&
          !lastMessage.isOwn &&
          timeSinceLastTrigger >= intervalSeconds / 2
        ) {
          console.log(
            `🤖 觸發${accountType}自動發消息（使用者未回復）: ${
              messageItem.userName || messageItem.user?.name
            }, 距離上次互動 ${Math.floor(timeSinceLastMessage)}秒`,
          );
          lastAutoMessageTrigger[messageItem.id] = now;
          await triggerStrangerAutoMessage(messageItem, strangerSettings, timeSinceLastMessage);
        }

        // 🎲 隨機觸發自動發推（10%概率）
        if (messages.length > 0 && Math.random() < 0.1) {
          const lastMessageTime = lastMessage.timestamp ? new Date(lastMessage.timestamp).getTime() : 0;
          const timeSinceLastMsg = (now - lastMessageTime) / 1000;

          // 只有在有聊天記錄且距離上次聊天超過間隔時間才觸發
          if (timeSinceLastMsg >= intervalSeconds) {
            console.log(
              `🎲 [${accountType}自動發推] 觸發: ${
                messageItem.userName || messageItem.user?.name
              }, 距離上次聊天 ${Math.floor(timeSinceLastMsg)}秒`,
            );
            await triggerAutoTweet(messageItem, strangerSettings, timeSinceLastMsg, 'stranger');
          }
        }
      }
    } catch (error) {
      console.error('❌ 檢查自動發消息失敗:', error);
    }
  }

  // 觸發自動發推（角色/帳戶/NPC/關係NPC/陌生人）
  async function triggerAutoTweet(messageData, settings, timeSinceLastMessage, type = 'character') {
    try {
      // 確定帳戶類型和名稱
      let accountType, accountName, accountHandle, accountAvatar;

      if (type === 'character') {
        accountType = '角色';
        accountName = settings.xName;
        accountHandle = settings.xHandle;
        accountAvatar = settings.xAvatar;
      } else {
        // 非角色：帳戶/NPC/關係NPC/陌生人
        accountType =
          messageData._accountType ||
          (messageData.id.startsWith('msg_account_')
            ? '帳戶'
            : messageData.id.startsWith('msg_npc_')
            ? 'NPC'
            : messageData.id.startsWith('msg_relationship_')
            ? '關係NPC'
            : '陌生人');
        accountName = messageData.userName || messageData.user?.name || messageData.name;
        accountHandle = messageData.userHandle || messageData.user?.handle || messageData.handle;
        accountAvatar = messageData.userAvatar || messageData.user?.avatar || messageData.avatar;
      }

      console.log(`📨 ${accountType} ${accountName} 正在自動發推...`);

      // 獲取聊天記錄
      const xDb = getXDB();
      const conversationId = `messageConversation_${currentAccountId || 'main'}_${messageData.id}`;
      const savedConversation = await xDb.xAccountProfiles.get(conversationId);

      if (!savedConversation || !savedConversation.data || !savedConversation.data.messages) {
        console.warn('自動發推失敗，無聊天記錄');
        return;
      }

      const messages = savedConversation.data.messages;
      const contextMessages = messages.slice(-20); // 最近20條消息

      // 調用新推生成器，傳入時間資訊
      const tweetData = await generateTweetFromConversation(messageData, contextMessages, {
        isAutoTweet: true,
        timeSinceLastMessage: Math.floor(timeSinceLastMessage),
        type: type,
      });

      if (!tweetData) {
        console.warn('自動發推生成失敗，無推文內容');
        return;
      }

      // 創建 New Tweet 通知
      const timestamp = Date.now();
      const newTweetNotification = {
        id: `mention_newtweet_auto_${timestamp}`,
        type: 'newTweet',
        user: {
          name: accountName,
          handle: accountHandle,
          avatar: accountAvatar,
        },
        content: `New Tweet from ${accountName}`,
        time: '剛剛',
        timestamp: timestamp,
        tweet: tweetData,
      };

      // 保存到 Mentions 資料庫
      const mentionsDataId = `mentions_${currentAccountId || 'main'}`;
      let savedMentions = await xDb.xAccountProfiles.get(mentionsDataId);

      if (!savedMentions) {
        savedMentions = {
          handle: mentionsDataId,
          id: mentionsDataId,
          data: [],
        };
      }

      savedMentions.data.unshift(newTweetNotification);
      await xDb.xAccountProfiles.put(savedMentions);

      console.log(`✅ ${accountType}自動發推成功: ${accountName}`);

      // 將推文添加到發推者的帳戶主頁
      await addTweetToAccountProfile(accountHandle, tweetData);

      // 顯示手機樣式通知
      const isEnglish = currentLanguage === 'en';
      showPhoneNotification({
        title: 'X',
        message: isEnglish ? `${accountName} posted a new tweet!` : `${accountName} 發佈了新推文！`,
        avatar: accountAvatar,
        leftIcon: 'x',
      });

      // 如果當前在 Mentions 頁面，刷新顯示
      const mentionsPage = document.getElementById('x-notifications-page');
      if (mentionsPage && mentionsPage.style.display === 'flex') {
        await loadNotifications();
      } else {
        showNavNotificationDot('notifications');
      }
    } catch (error) {
      console.error('❌ 觸發自動發推失敗:', error);
    }
  }

  // 觸發非角色帳戶自動發消息（帳戶/NPC/關係NPC/陌生人）
  async function triggerStrangerAutoMessage(messageData, strangerSettings, timeSinceLastMessage) {
    try {
      // 確定帳戶類型用於日誌
      const accountType =
        messageData._accountType ||
        (messageData.id.startsWith('msg_account_')
          ? '帳戶'
          : messageData.id.startsWith('msg_npc_')
          ? 'NPC'
          : messageData.id.startsWith('msg_relationship_')
          ? '關係NPC'
          : '陌生人');

      const accountName = messageData.userName || messageData.user?.name || messageData.name;
      console.log(`📨 ${accountType} ${accountName} 正在自動發消息...`);

      // 調用生成器，使用自動模式
      const newMessages = await generateMessageConversation(messageData, true, {
        isAutoMessage: true,
        timeSinceLastMessage: Math.floor(timeSinceLastMessage),
      });

      if (!newMessages || newMessages.length === 0) {
        console.warn(`${accountType}自動發消息生成失敗，無新消息`);
        return;
      }

      // 保存自動發送的消息到資料庫
      const xDb = getXDB();
      const conversationId = `messageConversation_${currentAccountId || 'main'}_${messageData.id}`;
      const savedConversation = await xDb.xAccountProfiles.get(conversationId);

      if (savedConversation && savedConversation.data) {
        // 添加自動消息（添加時間戳記）
        newMessages.forEach(msg => {
          if (!msg.timestamp) {
            msg.timestamp = new Date().toISOString();
          }
        });

        savedConversation.data.messages.push(...newMessages);
        savedConversation.updatedAt = new Date().toISOString();

        await xDb.xAccountProfiles.put(savedConversation);

        console.log(`✅ ${accountType}自動消息已保存: ${newMessages.length}條`);

        // 顯示頂部提醒
        const isEnglish = currentLanguage === 'en';
        const toastMessage = isEnglish
          ? `${accountName} sent you ${newMessages.length} message(s)`
          : `${accountName} 向你發送了 ${newMessages.length} 條私信`;
        showXToast(toastMessage, 'info');

        // 如果當前正在查看該私信詳情，刷新顯示
        if (currentMessageConversation && currentMessageConversation.id === messageData.id) {
          const contentContainer = document.getElementById('message-detail-content');
          if (contentContainer) {
            let currentMessageCount = contentContainer.querySelectorAll('.message-item').length;
            newMessages.forEach(msg => {
              const msgElement = renderMessageItem(msg, false, currentMessageCount);
              contentContainer.appendChild(msgElement);
              currentMessageCount++;
            });
          }
        }

        // 更新私信清單中該陌生人的未讀狀態
        try {
          const dataId = `messagesList_${currentAccountId || 'main'}`;
          const savedData = await xDb.xAccountProfiles.get(dataId);

          if (savedData && savedData.data) {
            const messagesList = savedData.data;
            const messageIndex = messagesList.findIndex(msg => msg.id === messageData.id);

            if (messageIndex !== -1) {
              messagesList[messageIndex].unread = true;
              messagesList[messageIndex].unreadCount =
                (messagesList[messageIndex].unreadCount || 0) + newMessages.length;

              await xDb.xAccountProfiles.put({
                handle: dataId,
                name: 'messagesList',
                data: messagesList,
                updatedAt: new Date().toISOString(),
              });

              sampleMessagesData = messagesList;
              console.log(`✅ 已標記${accountType}私信為未讀`);
            }
          }
        } catch (error) {
          console.error('更新未讀狀態失敗:', error);
        }

        // 更新私信列表
        const messagesPage = document.getElementById('x-messages-page');
        if (messagesPage && messagesPage.style.display !== 'none') {
          await loadMessagesList();
        } else {
          showNavNotificationDot('messages');
        }
      }
    } catch (error) {
      console.error('❌ 觸發陌生人自動發消息失敗:', error);
    }
  }

  // 觸發自動發消息
  async function triggerAutoMessage(messageData, characterProfile, timeSinceLastMessage) {
    try {
      console.log(`📨 角色 ${characterProfile.xName} 正在自動發消息...`);

      // 調用生成器，使用自動模式
      const newMessages = await generateMessageConversation(messageData, true, {
        isAutoMessage: true,
        timeSinceLastMessage: Math.floor(timeSinceLastMessage),
      });

      if (!newMessages || newMessages.length === 0) {
        console.warn('自動發消息生成失敗，無新消息');
        return;
      }

      // 保存自動發送的消息到資料庫
      const xDb = getXDB();
      // 🔧 多帳戶隔離：包含帳戶ID
      const conversationId = `messageConversation_${currentAccountId || 'main'}_${messageData.id}`;
      const savedConversation = await xDb.xAccountProfiles.get(conversationId);

      if (savedConversation && savedConversation.data) {
        // 添加自動消息（添加時間戳記）
        newMessages.forEach(msg => {
          if (!msg.timestamp) {
            msg.timestamp = new Date().toISOString();
          }
        });

        savedConversation.data.messages.push(...newMessages);
        savedConversation.updatedAt = new Date().toISOString();

        await xDb.xAccountProfiles.put(savedConversation);

        console.log(`✅ 自動消息已保存: ${newMessages.length}條`);

        // 智慧檢測是否需要生成 New Tweet 通知
        try {
          await detectAndGenerateNewTweetNotification(messageData, savedConversation.data.messages);
        } catch (error) {
          console.error('New Tweet 檢測失敗:', error);
        }

        // 顯示頂部提醒
        const isEnglish = currentLanguage === 'en';
        const toastMessage = isEnglish
          ? `${characterProfile.xName} sent you ${newMessages.length} message(s)`
          : `${characterProfile.xName} 向你發送了 ${newMessages.length} 條私信`;
        showXToast(toastMessage, 'info');

        // 如果當前正在查看該私信詳情，刷新顯示
        if (currentMessageConversation && currentMessageConversation.id === messageData.id) {
          const contentContainer = document.getElementById('message-detail-content');
          if (contentContainer) {
            // 獲取當前消息總數
            let currentMessageCount = contentContainer.querySelectorAll('.message-item').length;

            newMessages.forEach(msg => {
              const msgElement = renderMessageItem(msg, false, currentMessageCount);
              contentContainer.appendChild(msgElement);
              currentMessageCount++;
            });
          }
        }

        // 更新私信清單中該角色的未讀狀態
        try {
          const xDb = getXDB();
          const dataId = `messagesList_${currentAccountId || 'main'}`;
          const savedData = await xDb.xAccountProfiles.get(dataId);

          if (savedData && savedData.data) {
            const messagesList = savedData.data;
            const messageIndex = messagesList.findIndex(msg => msg.id === messageData.id);

            if (messageIndex !== -1) {
              // 標記為未讀
              messagesList[messageIndex].unread = true;
              messagesList[messageIndex].unreadCount =
                (messagesList[messageIndex].unreadCount || 0) + newMessages.length;

              // 保存回資料庫
              await xDb.xAccountProfiles.put({
                handle: dataId,
                name: 'messagesList',
                data: messagesList,
                updatedAt: new Date().toISOString(),
              });

              // 同步更新全域資料
              sampleMessagesData = messagesList;

              console.log('✅ 已標記私信為未讀');
            }
          }
        } catch (error) {
          console.error('更新未讀狀態失敗:', error);
        }

        // 更新私信清單的最後一條消息預覽（如果在私信清單頁面）
        const messagesPage = document.getElementById('x-messages-page');
        if (messagesPage && messagesPage.style.display !== 'none') {
          // 重新載入私信清單以顯示最新消息
          await loadMessagesList();
        } else {
          // 如果不在私信頁面，顯示提醒點
          showNavNotificationDot('messages');
        }
      }
    } catch (error) {
      console.error('❌ 觸發自動發消息失敗:', error);
    }
  }

  // 暴露私信相關函數到全域
  window.loadMessagesList = loadMessagesList;
  window.openNewMessageModal = openNewMessageModal;
  window.startAutoMessageSystem = startAutoMessageSystem;
  window.stopAutoMessageSystem = stopAutoMessageSystem;
  window.closeNewMessageModal = closeNewMessageModal;
  window.selectCharacterForMessage = selectCharacterForMessage;

  console.log('✅ 全域介面已暴露');

  // ============================================
  // 文章查看頁面功能
  // ============================================

  // 封面圖連結陣列
  const articleCoverImages = [
    'https://i.postimg.cc/CLJM9Wgg/4af1071dfec6baab460e61e9eeb280f2.jpg',
    'https://i.postimg.cc/fyNThsyJ/ff606a3597bbf3eaab3f0dbc4366cfac.jpg',
    'https://i.postimg.cc/C5LX8r6c/90502cdcef619816182a5e03e7de5592.jpg',
    'https://i.postimg.cc/QxCvxPTn/53551999bb82fecf909ea84947dd008c.jpg',
    'https://i.postimg.cc/y8S50Znm/f26c037c7785d0cdd3e371ebdce85df7.jpg',
    'https://i.postimg.cc/sDKfbtrD/4e7fc081056f2f475ed481e27ddfcd4a.jpg',
    'https://i.postimg.cc/65z6FDX6/27fce0a614e984e577264e58b25b0da5.jpg',
    'https://i.postimg.cc/65z6FDXp/931f9cc4c1bf7a0f1ee7b4fdfa334c5d.jpg',
    'https://i.postimg.cc/hPM4NHBS/5747a13122e4366828c95e673bcefba6.jpg',
    'https://i.postimg.cc/yYn62wHN/8700fba519fec2eccbeaa00e3b8996a9.jpg',
  ];

  // 打開文章查看頁面
  window.openArticlePage = function (articleData) {
    console.log('📰 [文章查看] 打開文章頁面', articleData);

    // 保存當前文章資料供轉發使用
    currentArticleData = articleData;

    // 設置封面圖（隨機選擇）
    const randomCover = articleCoverImages[Math.floor(Math.random() * articleCoverImages.length)];
    document.getElementById('article-cover').style.backgroundImage = `url('${randomCover}')`;

    // 設置標題
    const titleEl = document.getElementById('article-title');
    titleEl.textContent = articleData.title || '無標題';

    // 檢測標題是否包含英文（簡單判斷：是否有英文字母）
    const hasEnglish = /[a-zA-Z]/.test(articleData.title);
    if (hasEnglish) {
      titleEl.classList.add('article-title-en');
    } else {
      titleEl.classList.remove('article-title-en');
    }

    // 設置作者
    document.getElementById('article-author').textContent = articleData.author || '佚名';

    // 設置來源
    document.getElementById('article-source').textContent = articleData.source || '未知來源';

    // 設置正文（處理強調和底線）
    const bodyEl = document.getElementById('article-body');
    let bodyHtml = articleData.body || articleData.description || '';

    // 將**text**轉換為<strong>
    bodyHtml = bodyHtml.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
    // 將__text__轉換為<em>（底線重點）
    bodyHtml = bodyHtml.replace(/__(.*?)__/g, '<em>$1</em>');

    bodyEl.innerHTML = bodyHtml;

    // 顯示文章頁面
    document.getElementById('x-article-page').style.display = 'flex';

    console.log('✅ [文章查看] 文章頁面已打開');
  };

  // 關閉文章查看頁面
  window.closeArticlePage = function () {
    document.getElementById('x-article-page').style.display = 'none';
    console.log('✅ [文章查看] 文章頁面已關閉');
  };

  // 當前正在查看的文章資料
  let currentArticleData = null;

  // 轉發文章
  window.shareArticle = function () {
    console.log('📤 [文章轉發] 打開轉發彈窗');

    if (!currentArticleData) {
      showXToast('無法獲取文章資訊', 'error');
      return;
    }

    showShareArticleModal();
  };

  // 顯示轉發文章彈窗
  async function showShareArticleModal() {
    try {
      // 獲取私信列表
      const xDb = getXDB();
      const dataId = `messagesList_${currentAccountId || 'main'}`;
      const savedData = await xDb.xAccountProfiles.get(dataId);

      const messagesList = savedData?.data || [];

      if (messagesList.length === 0) {
        showXToast('暫無私信連絡人', 'info');
        return;
      }

      // 創建彈窗
      const modal = document.createElement('div');
      modal.id = 'share-article-modal';
      modal.style.cssText = `
        display: flex;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: var(--x-modal-overlay);
        z-index: 22;
        align-items: center;
        justify-content: center;
        backdrop-filter: blur(4px);
      `;

      modal.innerHTML = `
        <div class="modal-content" onclick="event.stopPropagation()" style="
          background-color: var(--x-bg-primary);
          border-radius: 16px;
          width: 90%;
          max-width: 500px;
          max-height: 80vh;
          overflow: hidden;
          border: 1px solid var(--x-border-color);
          display: flex;
          flex-direction: column;
        ">
          <!-- 彈窗頂部欄 -->
          <div class="modal-header" style="
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 20px;
            border-bottom: 1px solid var(--x-border-color);
            background-color: var(--x-bg-primary);
          ">
            <div style="display: flex; align-items: center; gap: 20px;">
              <!-- 關閉按鈕 -->
              <div class="modal-close-btn" onclick="closeShareArticleModal()" style="
                cursor: pointer;
                padding: 8px;
                border-radius: 50%;
                transition: background-color 0.2s;
              " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
                 onmouseout="this.style.backgroundColor='transparent'">
                <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);">
                  <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
                </svg>
              </div>
              <!-- 標題 -->
              <h2 style="
                color: var(--x-text-primary);
                font-size: 20px;
                font-weight: 700;
                margin: 0;
              ">轉發文章</h2>
            </div>
          </div>

          <!-- 彈窗內容區域 -->
          <div class="modal-body" style="
            padding: 16px 20px;
            overflow-y: auto;
            flex: 1;
          ">
            <!-- 文章預覽 -->
            <div style="
              padding: 12px;
              background-color: var(--x-bg-secondary);
              border-radius: 12px;
              margin-bottom: 16px;
              border: 1px solid var(--x-border-color);
            ">
              <div style="
                font-size: 15px;
                font-weight: 600;
                color: var(--x-text-primary);
                margin-bottom: 4px;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
              ">${currentArticleData?.title || '無標題'}</div>
              <div style="
                font-size: 13px;
                color: var(--x-text-secondary);
                overflow: hidden;
                text-overflow: ellipsis;
                display: -webkit-box;
                -webkit-line-clamp: 2;
                -webkit-box-orient: vertical;
              ">${currentArticleData?.description || ''}</div>
            </div>

            <!-- 附加文字輸入框 -->
            <div style="margin-bottom: 16px;">
              <label style="
                display: block;
                color: var(--x-text-secondary);
                font-size: 13px;
                margin-bottom: 8px;
              ">附加文字（可選）</label>
              <textarea id="share-article-message" placeholder="添加一些說明..." style="
                width: 100%;
                min-height: 80px;
                background-color: var(--x-bg-secondary);
                border: 1px solid var(--x-border-color);
                border-radius: 12px;
                color: var(--x-text-primary);
                padding: 12px;
                font-size: 15px;
                resize: vertical;
                outline: none;
                box-sizing: border-box;
                font-family: inherit;
              " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='var(--x-border-color)'"></textarea>
            </div>

            <!-- 說明文字 -->
            <div style="
              color: var(--x-text-secondary);
              font-size: 13px;
              margin-bottom: 12px;
            ">選擇要轉發到的連絡人</div>

            <!-- 連絡人列表 -->
            <div id="share-article-contacts-list" style="
              display: flex;
              flex-direction: column;
              gap: 0;
            ">
              ${messagesList
                .map(
                  contact => `
                <div class="contact-select-item" data-contact-id="${contact.id}" onclick="selectContactForShare('${contact.id}')" style="
                  display: flex;
                  align-items: center;
                  gap: 12px;
                  padding: 12px;
                  border-radius: 8px;
                  cursor: pointer;
                  transition: background-color 0.2s;
                " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
                   onmouseout="this.style.backgroundColor='transparent'">
                  <!-- 連絡人頭像 -->
                  <img src="${contact.userAvatar}" 
                    alt="${contact.userName}" 
                    style="
                      width: 40px;
                      height: 40px;
                      border-radius: 50%;
                      flex-shrink: 0;
                      object-fit: cover;
                    ">
                  <!-- 連絡人信息 -->
                  <div style="flex: 1; min-width: 0;">
                    <div style="
                      font-size: 15px;
                      font-weight: 700;
                      color: var(--x-text-primary);
                      overflow: hidden;
                      text-overflow: ellipsis;
                      white-space: nowrap;
                    ">${contact.userName}</div>
                    <div style="
                      font-size: 13px;
                      color: var(--x-text-secondary);
                      overflow: hidden;
                      text-overflow: ellipsis;
                      white-space: nowrap;
                    ">@${contact.userHandle}</div>
                  </div>
                </div>
              `,
                )
                .join('')}
            </div>
          </div>
        </div>
      `;

      // 將彈窗添加到X應用容器內
      const xSocialScreen = document.getElementById('x-social-screen');
      if (xSocialScreen) {
        xSocialScreen.appendChild(modal);
      } else {
        document.body.appendChild(modal);
      }

      // 點擊背景關閉彈窗
      modal.addEventListener('click', e => {
        if (e.target === modal) {
          closeShareArticleModal();
        }
      });
    } catch (error) {
      console.error('顯示轉發彈窗失敗:', error);
      showXToast('打開轉發失敗', 'error');
    }
  }

  // 關閉轉發文章彈窗
  window.closeShareArticleModal = function () {
    const modal = document.getElementById('share-article-modal');
    if (modal) {
      modal.remove();
    }
  };

  // 選擇連絡人轉發文章
  window.selectContactForShare = async function (contactId) {
    console.log('📤 [文章轉發] 轉發到連絡人:', contactId);

    try {
      const xDb = getXDB();

      // 獲取附加文字
      const messageInput = document.getElementById('share-article-message');
      const additionalMessage = messageInput ? messageInput.value.trim() : '';

      // 獲取當前時間
      const now = new Date();
      const hours = now.getHours();
      const minutes = String(now.getMinutes()).padStart(2, '0');
      const period = hours >= 12 ? '下午' : '上午';
      const timeStr = `${hours > 12 ? hours - 12 : hours}:${minutes} ${period}`;

      // 創建文章連結消息
      const articleMessage = {
        type: 'link',
        url: currentArticleData.source || '',
        title: currentArticleData.title,
        description: currentArticleData.description || '',
        author: currentArticleData.author,
        source: currentArticleData.source,
        body: currentArticleData.body,
        time: timeStr,
        timestamp: now.toISOString(),
        isOwn: true,
      };

      // 讀取現有對話資料
      // 🔧 多帳戶隔離：包含帳戶ID
      const conversationId = `messageConversation_${currentAccountId || 'main'}_${contactId}`;
      let savedConversation = await xDb.xAccountProfiles.get(conversationId);

      if (!savedConversation) {
        // 創建新的對話記錄
        savedConversation = {
          handle: conversationId,
          name: 'messageConversation',
          data: {
            messages: [],
          },
          messageId: contactId,
          accountId: currentAccountId || 'main', // 添加帳戶ID
          updatedAt: new Date().toISOString(),
        };
      }

      // 確保messages陣列存在
      if (!savedConversation.data.messages) {
        savedConversation.data.messages = [];
      }

      // 添加文章消息
      savedConversation.data.messages.push(articleMessage);

      // 如果有附加文字，也添加文字消息
      if (additionalMessage) {
        const textMessage = {
          type: 'text',
          content: additionalMessage,
          time: timeStr,
          timestamp: now.toISOString(),
          isOwn: true,
        };
        savedConversation.data.messages.push(textMessage);
      }

      // 標記最後一條消息為等待AI回復
      const lastMessageIndex = savedConversation.data.messages.length - 1;
      if (lastMessageIndex >= 0) {
        savedConversation.data.messages[lastMessageIndex].waitingForAIResponse = true;
      }

      // 保存到資料庫
      savedConversation.updatedAt = new Date().toISOString();
      await xDb.xAccountProfiles.put(savedConversation);

      // 更新私信清單的最後消息和時間
      const dataId = `messagesList_${currentAccountId || 'main'}`;
      const savedData = await xDb.xAccountProfiles.get(dataId);

      if (savedData && savedData.data) {
        const messagesList = savedData.data;
        const contactIndex = messagesList.findIndex(msg => msg.id === contactId);

        if (contactIndex !== -1) {
          messagesList[contactIndex].lastMessage = additionalMessage || '[連結]';
          messagesList[contactIndex].timestamp = now.toISOString();

          // 將該連絡人移到列表頂部
          const contact = messagesList.splice(contactIndex, 1)[0];
          messagesList.unshift(contact);

          // 保存更新後的列表
          await xDb.xAccountProfiles.put({
            handle: dataId,
            name: 'messagesList',
            data: messagesList,
            updatedAt: new Date().toISOString(),
          });

          // 更新全域變數
          sampleMessagesData = messagesList;
        }
      }

      // 關閉彈窗
      closeShareArticleModal();

      // 關閉文章查看頁面
      closeArticlePage();

      // 如果用戶當前正在查看這個聊天詳情頁，重新載入頁面
      const detailPage = document.getElementById('x-message-detail-page');
      if (detailPage && detailPage.style.display !== 'none') {
        // 檢查當前打開的是否是這個連絡人的聊天
        const currentConversationId = detailPage.dataset.conversationId;
        if (currentConversationId === contactId) {
          // 重新載入聊天詳情頁
          const dataId = `messagesList_${currentAccountId || 'main'}`;
          const messageData = await xDb.xAccountProfiles.get(dataId);
          if (messageData && messageData.data) {
            const contact = messageData.data.find(msg => msg.id === contactId);
            if (contact) {
              await loadMessageDetail({
                id: contact.id,
                user: {
                  name: contact.userName,
                  handle: contact.userHandle,
                  avatar: contact.userAvatar,
                },
              });
            }
          }
        }
      }

      // 顯示成功提示
      showXToast('文章已轉發', 'success');

      console.log('✅ [文章轉發] 轉發成功');
    } catch (error) {
      console.error('轉發文章失敗:', error);
      showXToast('轉發失敗', 'error');
    }
  };

  // ============================================
  // 推文/評論轉發功能
  // ============================================

  // 當前要轉發的內容資料
  let currentShareContentData = null;

  // 顯示轉發推文/評論彈窗
  window.showShareContentModal = async function (contentData, contentType) {
    console.log('📤 [內容轉發] 準備轉發:', contentType, contentData);

    currentShareContentData = { ...contentData, contentType };

    try {
      // 獲取私信列表
      const xDb = getXDB();
      const dataId = `messagesList_${currentAccountId || 'main'}`;
      const savedData = await xDb.xAccountProfiles.get(dataId);

      const messagesList = savedData?.data || [];

      if (messagesList.length === 0) {
        showXToast('暫無私信連絡人', 'info');
        return;
      }

      // 創建彈窗
      const modal = document.createElement('div');
      modal.id = 'share-content-modal';
      modal.style.cssText = `
        display: flex;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: var(--x-modal-overlay);
        z-index: 22;
        align-items: center;
        justify-content: center;
        backdrop-filter: blur(4px);
      `;

      // 根據內容類別型生成預覽內容
      let previewHTML = '';
      if (contentType === 'tweet') {
        previewHTML = `
          <div style="
            padding: 12px;
            background-color: var(--x-bg-secondary);
            border-radius: 12px;
            margin-bottom: 16px;
            border: 1px solid var(--x-border-color);
          ">
            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
              <img src="${contentData.user.avatar}" style="width: 32px; height: 32px; border-radius: 50%;" alt="${
          contentData.user.name
        }">
              <div>
                <div style="font-size: 14px; font-weight: 600; color: var(--x-text-primary);">${
                  contentData.user.name
                }</div>
                <div style="font-size: 12px; color: var(--x-text-secondary);">${contentData.user.handle}</div>
              </div>
            </div>
            <div style="
              font-size: 14px;
              color: var(--x-text-primary);
              overflow: hidden;
              text-overflow: ellipsis;
              display: -webkit-box;
              -webkit-line-clamp: 3;
              -webkit-box-orient: vertical;
              line-height: 1.4;
            ">${contentData.content || '無內容'}</div>
          </div>
        `;
      } else if (contentType === 'comment') {
        previewHTML = `
          <div style="
            padding: 12px;
            background-color: var(--x-bg-secondary);
            border-radius: 12px;
            margin-bottom: 16px;
            border: 1px solid var(--x-border-color);
          ">
            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
              <img src="${contentData.user.avatar}" style="width: 32px; height: 32px; border-radius: 50%;" alt="${
          contentData.user.name
        }">
              <div>
                <div style="font-size: 14px; font-weight: 600; color: var(--x-text-primary);">${
                  contentData.user.name
                }</div>
                <div style="font-size: 12px; color: var(--x-text-secondary);">${contentData.user.handle}</div>
              </div>
            </div>
            <div style="
              font-size: 14px;
              color: var(--x-text-primary);
              overflow: hidden;
              text-overflow: ellipsis;
              display: -webkit-box;
              -webkit-line-clamp: 3;
              -webkit-box-orient: vertical;
              line-height: 1.4;
            ">${contentData.content || '無內容'}</div>
          </div>
        `;
      }

      modal.innerHTML = `
        <div class="modal-content" onclick="event.stopPropagation()" style="
          background-color: var(--x-bg-primary);
          border-radius: 16px;
          width: 90%;
          max-width: 500px;
          max-height: 80vh;
          overflow: hidden;
          border: 1px solid var(--x-border-color);
          display: flex;
          flex-direction: column;
        ">
          <!-- 彈窗頂部欄 -->
          <div class="modal-header" style="
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 20px;
            border-bottom: 1px solid var(--x-border-color);
            background-color: var(--x-bg-primary);
          ">
            <div style="display: flex; align-items: center; gap: 20px;">
              <!-- 關閉按鈕 -->
              <div class="modal-close-btn" onclick="closeShareContentModal()" style="
                cursor: pointer;
                padding: 8px;
                border-radius: 50%;
                transition: background-color 0.2s;
              " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
                 onmouseout="this.style.backgroundColor='transparent'">
                <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);">
                  <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
                </svg>
              </div>
              <!-- 標題 -->
              <h2 style="
                color: var(--x-text-primary);
                font-size: 20px;
                font-weight: 700;
                margin: 0;
              ">轉發${contentType === 'tweet' ? '推文' : '評論'}</h2>
            </div>
          </div>

          <!-- 彈窗內容區域 -->
          <div class="modal-body" style="
            padding: 16px 20px;
            overflow-y: auto;
            flex: 1;
          ">
            <!-- 內容預覽 -->
            ${previewHTML}

            <!-- 附加文字輸入框 -->
            <div style="margin-bottom: 16px;">
              <label style="
                display: block;
                color: var(--x-text-secondary);
                font-size: 13px;
                margin-bottom: 8px;
              ">附加文字（可選）</label>
              <textarea id="share-content-message" placeholder="添加一些說明..." style="
                width: 100%;
                min-height: 80px;
                background-color: var(--x-bg-secondary);
                border: 1px solid var(--x-border-color);
                border-radius: 12px;
                color: var(--x-text-primary);
                padding: 12px;
                font-size: 15px;
                resize: vertical;
                outline: none;
                box-sizing: border-box;
                font-family: inherit;
              " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='var(--x-border-color)'"></textarea>
            </div>

            <!-- 說明文字 -->
            <div style="
              color: var(--x-text-secondary);
              font-size: 13px;
              margin-bottom: 12px;
            ">選擇要轉發到的連絡人</div>

            <!-- 連絡人列表 -->
            <div id="share-content-contacts-list" style="
              display: flex;
              flex-direction: column;
              gap: 0;
            ">
              ${messagesList
                .map(
                  contact => `
                <div class="contact-select-item" data-contact-id="${contact.id}" onclick="selectContactForContentShare('${contact.id}')" style="
                  display: flex;
                  align-items: center;
                  gap: 12px;
                  padding: 12px;
                  border-radius: 8px;
                  cursor: pointer;
                  transition: background-color 0.2s;
                " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
                   onmouseout="this.style.backgroundColor='transparent'">
                  <!-- 連絡人頭像 -->
                  <img src="${contact.userAvatar}" 
                    alt="${contact.userName}" 
                    style="
                      width: 40px;
                      height: 40px;
                      border-radius: 50%;
                      flex-shrink: 0;
                      object-fit: cover;
                    ">
                  <!-- 連絡人信息 -->
                  <div style="flex: 1; min-width: 0;">
                    <div style="
                      font-size: 15px;
                      font-weight: 700;
                      color: var(--x-text-primary);
                      overflow: hidden;
                      text-overflow: ellipsis;
                      white-space: nowrap;
                    ">${contact.userName}</div>
                    <div style="
                      font-size: 13px;
                      color: var(--x-text-secondary);
                      overflow: hidden;
                      text-overflow: ellipsis;
                      white-space: nowrap;
                    ">@${contact.userHandle}</div>
                  </div>
                </div>
              `,
                )
                .join('')}
            </div>
          </div>
        </div>
      `;

      // 將彈窗添加到X應用容器內
      const xSocialScreen = document.getElementById('x-social-screen');
      if (xSocialScreen) {
        xSocialScreen.appendChild(modal);
      } else {
        document.body.appendChild(modal);
      }

      // 點擊背景關閉彈窗
      modal.addEventListener('click', e => {
        if (e.target === modal) {
          closeShareContentModal();
        }
      });
    } catch (error) {
      console.error('顯示轉發彈窗失敗:', error);
      showXToast('打開轉發失敗', 'error');
    }
  };

  // 關閉轉發推文/評論彈窗
  window.closeShareContentModal = function () {
    const modal = document.getElementById('share-content-modal');
    if (modal) {
      modal.remove();
    }
    currentShareContentData = null;
  };

  // 選擇連絡人轉發推文/評論
  window.selectContactForContentShare = async function (contactId) {
    if (!currentShareContentData) {
      showXToast('轉發資料丟失', 'error');
      return;
    }

    console.log('📤 [內容轉發] 轉發到連絡人:', contactId);

    // 保存資料的本機複本，因為後續會關閉彈窗並清空 currentShareContentData
    const contentData = { ...currentShareContentData };

    try {
      const xDb = getXDB();

      // 獲取附加文字
      const messageInput = document.getElementById('share-content-message');
      const additionalMessage = messageInput ? messageInput.value.trim() : '';

      // 獲取當前時間
      const now = new Date();
      const hours = now.getHours();
      const minutes = String(now.getMinutes()).padStart(2, '0');
      const period = hours >= 12 ? '下午' : '上午';
      const timeStr = `${hours > 12 ? hours - 12 : hours}:${minutes} ${period}`;

      // 創建轉發消息物件
      const forwardMessage = {
        type: 'forward',
        forwardType: contentData.contentType, // 'tweet' 或 'comment'
        forwardContent: {
          user: contentData.user,
          content: contentData.content,
          time: contentData.time,
          image: contentData.image || null,
        },
        // 包含完整上下文資訊
        fullContext: {},
        time: timeStr,
        timestamp: now.toISOString(),
        isOwn: true,
      };

      // 根據類型添加完整上下文
      if (contentData.contentType === 'tweet') {
        // 轉發推文：包含完整推文和所有評論
        forwardMessage.fullContext = {
          tweet: contentData.fullTweet || {
            user: contentData.user,
            content: contentData.content,
            time: contentData.time,
            image: contentData.image,
          },
          comments: contentData.comments || [],
        };
      } else if (contentData.contentType === 'comment') {
        // 轉發評論：包含評論和所屬推文
        forwardMessage.fullContext = {
          comment: {
            user: contentData.user,
            content: contentData.content,
            time: contentData.time,
            image: contentData.image,
          },
          parentTweet: contentData.parentTweet || null,
        };
      }

      // 讀取現有對話資料
      // 🔧 多帳戶隔離：包含帳戶ID
      const conversationId = `messageConversation_${currentAccountId || 'main'}_${contactId}`;
      let savedConversation = await xDb.xAccountProfiles.get(conversationId);

      if (!savedConversation) {
        // 創建新的對話記錄
        savedConversation = {
          handle: conversationId,
          name: 'messageConversation',
          data: {
            messages: [],
          },
          messageId: contactId,
          accountId: currentAccountId || 'main', // 添加帳戶ID
          updatedAt: new Date().toISOString(),
        };
      }

      // 確保messages陣列存在
      if (!savedConversation.data.messages) {
        savedConversation.data.messages = [];
      }

      // 添加轉發消息
      savedConversation.data.messages.push(forwardMessage);

      // 如果有附加文字，也添加文字消息
      if (additionalMessage) {
        const textMessage = {
          type: 'text',
          content: additionalMessage,
          time: timeStr,
          timestamp: now.toISOString(),
          isOwn: true,
        };
        savedConversation.data.messages.push(textMessage);
      }

      // 標記最後一條消息為等待AI回復
      const lastMessageIndex = savedConversation.data.messages.length - 1;
      if (lastMessageIndex >= 0) {
        savedConversation.data.messages[lastMessageIndex].waitingForAIResponse = true;
      }

      // 保存到資料庫
      savedConversation.updatedAt = new Date().toISOString();
      await xDb.xAccountProfiles.put(savedConversation);

      // 更新私信清單的最後消息和時間
      const dataId = `messagesList_${currentAccountId || 'main'}`;
      const savedData = await xDb.xAccountProfiles.get(dataId);

      if (savedData && savedData.data) {
        const messagesList = savedData.data;
        const contactIndex = messagesList.findIndex(msg => msg.id === contactId);

        if (contactIndex !== -1) {
          messagesList[contactIndex].lastMessage =
            additionalMessage || `[轉發了${contentData.contentType === 'tweet' ? '推文' : '評論'}]`;
          messagesList[contactIndex].timestamp = now.toISOString();

          // 將該連絡人移到列表頂部
          const contact = messagesList.splice(contactIndex, 1)[0];
          messagesList.unshift(contact);

          // 保存更新後的列表
          await xDb.xAccountProfiles.put({
            handle: dataId,
            name: 'messagesList',
            data: messagesList,
            updatedAt: new Date().toISOString(),
          });

          // 更新全域變數
          sampleMessagesData = messagesList;
        }
      }

      // 關閉彈窗
      closeShareContentModal();

      // 如果用戶當前正在查看這個聊天詳情頁，重新載入頁面
      const detailPage = document.getElementById('x-message-detail-page');
      if (detailPage && detailPage.style.display !== 'none') {
        // 檢查當前打開的是否是這個連絡人的聊天
        const currentConversationId = detailPage.dataset.conversationId;
        if (currentConversationId === contactId) {
          // 重新載入聊天詳情頁
          const dataId = `messagesList_${currentAccountId || 'main'}`;
          const messageData = await xDb.xAccountProfiles.get(dataId);
          if (messageData && messageData.data) {
            const contact = messageData.data.find(msg => msg.id === contactId);
            if (contact) {
              await loadMessageDetail({
                id: contact.id,
                user: {
                  name: contact.userName,
                  handle: contact.userHandle,
                  avatar: contact.userAvatar,
                },
              });
            }
          }
        }
      }

      // 顯示成功提示
      showXToast(`${contentData.contentType === 'tweet' ? '推文' : '評論'}已轉發`, 'success');

      console.log('✅ [內容轉發] 轉發成功');
    } catch (error) {
      console.error('轉發失敗:', error);
      showXToast('轉發失敗', 'error');
    }
  };

  // ============================================
  // 第五部分: 暴露全域介面
  // ============================================

  // 將必要的函數暴露到全域作用域
  window.renderXSocialScreenProxy = renderXSocialScreen;
  window.switchXPage = switchXPage;
  window.switchHomeTab = switchHomeTab;
  window.refreshXTweets = refreshXTweets;
  window.showTweetComments = showTweetComments;
  window.submitComment = submitComment;
  window.handleCommentInput = handleCommentInput;
  window.autoResize = autoResize;
  window.showReplyInput = showReplyInput;
  window.cancelReply = cancelReply;
  window.submitReply = submitReply;
  window.handleReplyInput = handleReplyInput;
  window.autoResizeReply = autoResizeReply;
  window.toggleLike = toggleLike;
  window.toggleCommentLike = toggleCommentLike;
  window.deleteUserComment = deleteUserComment;
  window.showSensitiveContent = showSensitiveContent;
  window.handleQuotedTweetClick = handleQuotedTweetClick;
  window.handleQuoteRetweetFromData = handleQuoteRetweetFromData;
  window.openComposeTweetModal = openComposeTweetModal;
  window.closeComposeTweetModal = closeComposeTweetModal;
  window.publishTweet = publishTweet;
  window.handleComposeInput = handleComposeInput;
  window.processHashtagsAndMentions = processHashtagsAndMentions;
  window.toggleImageSection = toggleImageSection;
  window.selectImageMethod = selectImageMethod;
  window.triggerImageUpload = triggerImageUpload;
  window.handleImageUpload = handleImageUpload;
  window.saveImageData = saveImageData;
  window.removeImage = removeImage;
  window.toggleLocationSection = toggleLocationSection;
  window.saveLocationData = saveLocationData;
  window.removeLocation = removeLocation;
  window.toggleLinkSection = toggleLinkSection;
  window.saveLinkData = saveLinkData;
  window.removeLink = removeLink;
  window.triggerLinkImageUpload = triggerLinkImageUpload;
  window.handleLinkImageUpload = handleLinkImageUpload;
  window.removeQuoteContent = removeQuoteContent;
  window.togglePrivacySettings = togglePrivacySettings;
  window.editProfile = editProfile;
  window.openEditProfileModal = openEditProfileModal;
  window.closeEditProfileModal = closeEditProfileModal;
  window.saveProfileChanges = saveProfileChanges;
  window.switchProfileTab = switchProfileTab;
  window.toggleProfileMenu = toggleProfileMenu;
  window.openAccountManager = openAccountManager;
  window.openAccountWallet = openAccountWallet;
  window.closeWalletModal = closeWalletModal;
  window.activateWallet = activateWallet;
  window.addFunds = addFunds;
  window.sendMoney = sendMoney;
  window.shareWallet = shareWallet;
  window.exportWallet = exportWallet;
  window.copyWalletInfo = copyWalletInfo;
  window.updateCharacterCounts = updateCharacterCounts;
  window.toggleRealNameInput = toggleRealNameInput;
  window.updateTag1ColorFromText = updateTag1ColorFromText;
  window.updateTag1ColorFromPicker = updateTag1ColorFromPicker;
  window.updateTag2ColorFromText = updateTag2ColorFromText;
  window.updateTag2ColorFromPicker = updateTag2ColorFromPicker;
  window.editCoverImage = editCoverImage;
  window.removeCoverImage = removeCoverImage;
  window.editAvatarImage = editAvatarImage;
  window.updateVerificationTypeUI = updateVerificationTypeUI;
  window.toggleCharacterBinding = toggleCharacterBinding;
  window.toggleCharacterSelection = toggleCharacterSelection;
  window.openCharacterXProfile = openCharacterXProfile;
  window.closeCharacterXProfileModal = closeCharacterXProfileModal;
  window.saveCharacterXProfile = saveCharacterXProfile;
  window.updateCharacterXAvatar = updateCharacterXAvatar;
  window.updateCharacterBioCount = updateCharacterBioCount;
  window.toggleCharacterRealNameInput = toggleCharacterRealNameInput;
  window.openAddRelationshipModal = openAddRelationshipModal;
  window.editRelationship = editRelationship;
  window.deleteRelationship = deleteRelationship;
  window.closeRelationshipModal = closeRelationshipModal;
  window.updateRelationshipDescCount = updateRelationshipDescCount;
  window.saveRelationshipForm = saveRelationshipForm;
  window.saveXSettings = saveXSettings;
  window.saveXPreset = saveXPreset;
  window.loadXPreset = loadXPreset;
  window.deleteXPreset = deleteXPreset;
  window.exportXData = exportXData;
  window.importXData = importXData;
  window.toggleXTheme = toggleXTheme;
  window.showTweetDetail = showTweetDetail;
  window.handleDetailCommentInput = handleDetailCommentInput;
  window.autoResizeDetail = autoResizeDetail;
  window.submitDetailComment = submitDetailComment;
  window.toggleDetailLike = toggleDetailLike;
  window.rerollAIReplies = rerollAIReplies;
  window.toggleTweetSelection = toggleTweetSelection;
  window.enterMultiSelectMode = enterMultiSelectMode;
  window.exitMultiSelectMode = exitMultiSelectMode;
  window.selectAllTweets = selectAllTweets;
  window.deleteSelectedTweets = deleteSelectedTweets;
  window.showXToast = showXToast;
  window.toggleIdentityCharacter = toggleIdentityCharacter;
  window.closeAccountManager = closeAccountManager;
  window.switchAccount = switchAccount;
  window.createNewAccount = createNewAccount;
  window.deleteAccount = deleteAccount;
  window.triggerCommentImageUpload = triggerCommentImageUpload;
  window.handleCommentImageUpload = handleCommentImageUpload;
  window.removeCommentImage = removeCommentImage;
  window.triggerDetailCommentImageUpload = triggerDetailCommentImageUpload;
  window.handleDetailCommentImageUpload = handleDetailCommentImageUpload;
  window.removeDetailCommentImage = removeDetailCommentImage;

  // 角色關係冊相關函數
  window.toggleCharacterRelationship = toggleCharacterRelationship;
  window.openCharacterRelationshipGraph = openCharacterRelationshipGraph;
  window.closeCharacterRelationshipGraph = closeCharacterRelationshipGraph;
  window.addRelationshipLink = addRelationshipLink;
  window.openEditRelationshipDetailModal = openEditRelationshipDetailModal;
  window.closeEditRelationshipDetail = closeEditRelationshipDetail;
  window.saveRelationshipDetail = saveRelationshipDetail;
  window.deleteRelationshipLink = deleteRelationshipLink;
  window.clearAllRelationships = clearAllRelationships;
  window.saveRelationshipGraph = saveRelationshipGraph;
  window.characterRelationshipData = characterRelationshipData;

  // NPC綁定相關函數
  window.toggleNPCBinding = toggleNPCBinding;
  window.openCreateNPCModal = openCreateNPCModal;
  window.editNPC = editNPC;
  window.saveNPC = saveNPC;
  window.deleteNPC = deleteNPC;
  window.closeNPCEditModal = closeNPCEditModal;

  // 提問箱相關函數
  window.loadAskboxData = loadAskboxData;
  window.changeAskboxAvatar = changeAskboxAvatar;
  window.saveAskboxNickname = saveAskboxNickname;
  window.saveAskboxPrompt = saveAskboxPrompt;
  window.openAskboxSettings = openAskboxSettings;
  window.getNewQuestion = getNewQuestion;
  window.saveQuestionAnswer = saveQuestionAnswer;

  // 提問箱多選刪除相關函數
  window.startQuestionLongPress = startQuestionLongPress;
  window.endQuestionLongPress = endQuestionLongPress;
  window.toggleQuestionSelection = toggleQuestionSelection;
  window.enterAskboxMultiSelectMode = enterAskboxMultiSelectMode;
  window.exitAskboxMultiSelectMode = exitAskboxMultiSelectMode;
  window.selectAllQuestions = selectAllQuestions;
  window.deleteSelectedQuestions = deleteSelectedQuestions;

  // 搜尋網頁面相關函數
  window.switchSearchTab = switchSearchTab;
  window.handleTrendingClick = handleTrendingClick;
  window.handleTrendingMore = handleTrendingMore;
  window.openAddCategoryModal = openAddCategoryModal;
  window.closeCategoryModal = closeCategoryModal;
  window.addNewCategory = addNewCategory;
  window.deleteCategory = deleteCategory;
  window.toggleCategory = toggleCategory;
  window.updateCategoryName = updateCategoryName;
  window.updateCategoryDescription = updateCategoryDescription;
  window.saveCustomCategories = saveCustomCategories;
  window.refreshTrends = refreshTrends;
  window.toggleSearchButton = toggleSearchButton;
  window.performSearch = performSearch;
  window.switchSearchResultTab = switchSearchResultTab;
  window.backToTrending = backToTrending;

  // 帳戶主頁相關函數
  window.openAccountProfile = openAccountProfile;
  window.closeAccountProfile = closeAccountProfile;
  window.showAccountTweetDetail = showAccountTweetDetail;
  window.toggleAccountFollow = toggleAccountFollow;
  window.toggleAccountNotifications = toggleAccountNotifications;
  window.sendMessageToAccount = sendMessageToAccount;
  window.switchAccountTab = switchAccountTab;
  window.refreshAccountProfile = refreshAccountProfile;
  window.toggleProgressMode = toggleProgressMode;
  window.handleRefreshButtonMouseDown = handleRefreshButtonMouseDown;
  window.handleRefreshButtonMouseUp = handleRefreshButtonMouseUp;
  window.goBackFromTweetDetail = goBackFromTweetDetail;

  // 主題切換相關函數
  window.toggleXTheme = toggleXTheme;

  // 語言切換相關函數
  window.toggleXLanguage = toggleXLanguage;

  // 創建 XSocialApp 物件以相容HTML檢查
  window.XSocialApp = {
    init: initXSocialApp,
    render: renderXSocialScreen,
    version: '1.0',
    isLoaded: true,
  };

  // 自動初始化（如果DOM已載入）
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initXSocialApp);
  } else {
    // 延遲初始化，確保其他腳本先載入
    setTimeout(initXSocialApp, 100);
  }

  console.log('📦 X Social App 模組已載入，版本: 1.0');
  // 清空當前帳戶的錢包資料（調試用）
  window.clearCurrentWalletData = async function () {
    try {
      const db = getXDB();
      const accountId = currentAccountId || 'main';
      const walletId = `wallet_${accountId}`;

      // 刪除錢包資料
      await db.xAccountProfiles.delete(walletId);

      // 重新載入空的錢包數據
      await loadWalletData();

      console.log('✅ 已清空帳戶錢包資料:', accountId);
      showXToast('錢包數據已清空', 'success');
    } catch (error) {
      console.error('❌ 清空錢包數據失敗:', error);
      showXToast('清空失敗: ' + error.message, 'error');
    }
  };
})(window);

// ==========================================
// 使用說明:
//
// 1. 在HTML中引入此文件:
//    <script src="x-social-app.js" defer></script>
//
// 2. 系統會自動初始化,創建X社交頁面HTML結構
//
// 3. 通過以下方式調用:
//    - 顯示X社交頁面: showScreen('x-social-screen')
//    - 渲染代理: window.renderXSocialScreenProxy()
//
// 4. 需要的依賴:
//    - Dexie.js (資料庫)
//    - 確保有 showScreen() 全域函數
//
// ==========================================

