<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>EPhone</title>
    <!-- ▼▼▼ 【桌面圖示】純HTML單檔方案，請黏貼到 <title> 之後 ▼▼▼ -->
    <!-- 1. (核心) 為蘋果設備設置主螢幕圖示 -->
    <!-- 流覽器會自動選擇最合適的尺寸 -->
    <link rel="apple-touch-icon" href="https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1758510900942_qdqqd_djw0z2.jpeg">

    <link rel="manifest" href="manifest.json">
    <!-- 2. (核心) 告訴蘋果設備，這是一個Web應用，可以全屏顯示 -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <!-- 3. (核心) 設置蘋果設備全屏模式下的狀態列樣式 -->
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- 4. (可選) 設置應用在主螢幕上顯示的標題 -->
    <meta name="apple-mobile-web-app-title" content="EPhone">
    <!-- 5. (相容) 為部分安卓流覽器提供支援 -->
    <meta name="mobile-web-app-capable" content="yes">
    <!-- 6. (備用) 標準流覽器頁簽圖示 -->
    <link rel="icon" type="image/png" href="https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1756312261242_qdqqd_g0eriz.jpeg">
    <!-- ▲▲▲ 黏貼結束 ▲▲▲ -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<script src="https://unpkg.com/dexie/dist/dexie.js" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js" defer></script>
     <script src="https://sssayhi07-gif.github.io/phone/pp.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/streamsaver@2.0.6/StreamSaver.min.js" defer></script>
    <style>
        @font-face { font-family: 'bulangni'; src: url('') format('truetype'); font-weight: normal; font-style: normal; font-display: swap; }
        :root { --screen-width: 350px; --screen-height: 650px; --secondary-bg: #ffffff; --border-color: #e0e0e0; --text-primary: #1f1f1f; --text-secondary: #8a8a8a; --accent-color: #007bff; }
               /* ▼▼▼ Safari鍵盤適配：請用下面這【一整塊】全新的代碼，替換掉你現有的 html, body, 和 #phone-screen 樣式 ▼▼▼ */
        
        /* --- 請用下面這【一整塊】全新的代碼，替換掉你現有的 html, body, 和 #phone-screen 樣式 --- */
        
        /* 1. 重置 html 元素 */
        html {
            -webkit-text-size-adjust: 100%;
            height: 100%; /* 確保html元素也能撐滿 */
        }
        
        /* 2. 設置 body 為全屏畫布 */
        body {
            margin: 0;
            font-family: 'bulangni', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            font-weight: normal;
            background-color: #f0f2f5;
            height: 100%; /* 讓body也撐滿父元素(html) */
            overflow: hidden; /* 防止body本身出現捲軸 */
        }
        
        /* --- Start of Replacement Code --- */
        
        #phone-screen {
            width: 100%;
            /* Use 100vh to ensure it fills the entire screen height */
            height: 100vh; 
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            background-color: #ffffff; /* Your desired white background */
        }
        
        #chat-input-area {
            flex-shrink: 0;
            padding: 8px;
            /* This is the key: adds padding equal to the height of the "black bar" */
            padding-bottom: calc(8px + env(safe-area-inset-bottom)); 
            background-color: rgba(247, 247, 247, 0.8);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-top: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        /* --- End of Replacement Code --- */
/* --- 【核心修改】這是控制狀態列顯隱的新樣式 --- */

/* 1. 預設情況下，狀態列依然是隱藏的 */
#status-bar {
    display: none;
    /* (原有的其他樣式，如顏色、字體等，保持不變即可) */
    padding: 0 20px;
    height: 40px;
    color: white;
    background-color: transparent; /* 背景由父元素控制 */
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    box-sizing: border-box;
    z-index: 100;
    text-shadow: 0 1px 3px rgba(0,0,0,0.4);
    pointer-events: none; /* 讓點擊可以穿透 */
}

/* 2. 當 #phone-screen 元素擁有 .status-bar-visible 這個 class 時，顯示狀態列 */
#phone-screen.status-bar-visible #status-bar {
    display: flex;
    justify-content: space-between;
    align-items: center;
}
        
        .header, .qzone-header {
            position: relative;
            z-index: 15;
            flex-shrink: 0;
            padding: 15px 20px;
            /* 核心：使用 calc() 自動加上頂部的安全距離 */
            padding-top: calc(15px + env(safe-area-inset-top)); 
            background-color: rgba(247, 247, 247, 0.8);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 18px;
            font-weight: 600;
        }
        
        
        #status-bar { 
            display: none; 
        }
        #status-bar-time { font-weight: 600; }
        .battery-container { display: flex; align-items: center; gap: 5px; }
        .battery-icon { width: 25px; height: 12px; border: 1px solid white; border-radius: 3px; position: relative; padding: 1px; }
        .battery-icon::after { content: ''; position: absolute; right: -3px; top: 2px; width: 2px; height: 6px; background-color: white; border-radius: 0 1px 1px 0; }
        .battery-level { height: 100%; background-color: white; border-radius: 1px; transition: width 0.5s ease; }
        .battery-container.charging .battery-level { background-color: #4cd964; animation: charge-breath 2s infinite; }
        .battery-container.charging .battery-text { color: #4cd964; }
        @keyframes charge-breath { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
        .screen { width: 100%; height: 100%; position: absolute; top: 0; left: 0; display: flex; flex-direction: column; overflow: hidden; opacity: 0; visibility: hidden; transition: opacity 0.3s, visibility 0.3s; }
        .screen.active { opacity: 1; visibility: visible; z-index: 1; }
        .header { position: relative; z-index: 15; flex-shrink: 0; padding: 15px 20px; padding-top: 45px; background-color: rgba(247, 247, 247, 0.8); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; font-size: 18px; font-weight: 600; }
        .header .header-actions { display: flex; align-items: center; gap: 15px; }
        .header .back-btn, .header .action-btn { font-size: 24px; cursor: pointer; width: 30px; text-align: center; color: var(--accent-color); display: flex; align-items: center; justify-content: center; }
        
        .header .action-btn {
            font-size: 16px; /* 專門為“上傳”、“+”等文字按鈕縮小字型大小 */
            font-weight: 600; /* 可以加粗一點讓它更清晰 */
        }
        
        .header .action-btn img { height: 26px; }
        .header .save-btn { font-size: 16px; color: var(--accent-color); font-weight: 600; cursor: pointer; }
        /* ▼▼▼ 請用這【一整塊代碼】，完整替換掉您現有的 #home-screen, #clock-container, 和 #app-grid 樣式 ▼▼▼ */
        
        /* --- Start of Replacement Code --- */
        
        #home-screen {
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            box-sizing: border-box;
            background-size: cover;
            background-position: center;
            padding-left: 20px;
            padding-right: 20px;
            /* We remove vertical padding here to rely on margins */
        }
        
        #clock-container {
            text-align: center;
            color: white;
            text-shadow: 0 3px 8px rgba(0,0,0,0.4);
            margin-bottom: 20px;
            flex-shrink: 0;
            /* This is the key: pushes the clock down from the top edge */
            margin-top: calc(60px + env(safe-area-inset-top));
        }
        
        /* --- End of Replacement Code --- */
        
        /* 3. 將App圖示網格作為一個整體，用 margin 從螢幕底部推上來 */
        #app-grid {
            margin-top: auto; /* 自動貼緊底部 */
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            width: 100%;
            padding: 20px;
            /* 關鍵：使用 margin-bottom 抬高圖示，適配底部“小黑條” */
            margin-bottom: calc(30px + env(safe-area-inset-bottom)); 
        }
        /* ▲▲▲ 替換結束 ▲▲▲ */
        #main-time {
            font-size: 88px; /* 推薦：稍微調大一點點，更接近iOS鎖屏的感覺 */
            font-weight: 600; /* 核心修改1：將字體從“纖細(200)”改為“粗體(600)”，這是最關鍵的一步 */
            letter-spacing: -2px; /* 推薦：稍微收緊字間距，讓數字看起來更緊湊 */
            /* 核心修改2：指定字體，優先使用蘋果系統字體 */
            font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei UI", "Microsoft YaHei", Arial, sans-serif;
        }
        #main-date { 
            font-size: 22px; /* 稍微放大一點更協調 */
            font-weight: normal; /* 蘋果風格的常規體日期 */
        }
        
        #app-grid { margin-top: auto; display: flex; flex-direction: column; align-items: center; gap: 20px; width: 100%; padding: 20px; }
        .app-row { display: flex; justify-content: center; gap: 25px; width: 100%; }
        .app-icon { display: flex; flex-direction: column; align-items: center; cursor: pointer; color: white; text-shadow: 0 1px 3px rgba(0,0,0,0.5); font-size: 14px; font-weight: 500; text-align: center; }
        .app-icon .icon-bg { width: 65px; height: 65px; border-radius: 18px; background-color: var(--secondary-bg); display: flex; justify-content: center; align-items: center; font-size: 32px; margin-bottom: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.15); transition: transform 0.2s ease; overflow: hidden; }
        .app-icon:active .icon-bg { transform: scale(0.9); }
        .app-icon .icon-bg img { width: 100%; height: 100%; object-fit: cover; }
        .app-icon .label { color: white; }
        .form-container, .list-container { padding: 20px; overflow-y: auto; flex-grow: 1; display:flex; flex-direction: column; }
        .form-group { margin-bottom: 20px; }
        .form-group label { display: block; margin-bottom: 8px; font-weight: 500; color: var(--text-secondary); }
        .form-group input, .form-group select, .form-group textarea { width: 100%; padding: 12px; border: 1px solid var(--border-color); border-radius: 8px; font-size: 16px; box-sizing: border-box; }
        .form-group textarea { min-height: 80px; resize: vertical; }
        #world-book-content-input { height: calc(100% - 120px); }
        .form-button { width: 100%; padding: 15px; background-color: var(--accent-color); color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; margin-top: 10px; }
        .form-button-secondary { background-color: #f0f0f0; color: var(--text-primary); border: 1px solid var(--border-color); }
        #wallpaper-screen .form-container { align-items: center; }
        #wallpaper-preview { width: 180px; height: 320px; border: 2px dashed var(--border-color); background-color: #f0f2f5; margin-bottom: 20px; background-size: cover; background-position: center; border-radius: 10px; display: flex; justify-content: center; align-items: center; color: var(--text-secondary); }
        #wallpaper-upload-input { display: none; }
        /* 修改後的 #world-book-list 樣式 */
        #world-book-list {
            flex-grow: 1;
            overflow-y: auto;
            background-color: var(--secondary-bg);
            padding-top: 80px;
            margin-top: -80px;
        }
        
        /* 修改後的 #chat-list 樣式，去掉了 padding 和 margin */
        #chat-list {
            flex-grow: 1;
            background-color: var(--secondary-bg);
            padding-top: 80px; 
            padding-bottom: 90px; /* 為底部巡覽列留出空間 */
            box-sizing: border-box;
        }
        
        .list-item { display: flex; flex-direction: column; padding: 12px 20px; cursor: pointer; border-bottom: 1px solid var(--border-color); }
        .list-item:hover { background-color: #f5f5f5; }
        .list-item .item-title { font-weight: 500; font-size: 16px; margin-bottom: 5px; }
        .list-item .item-content { font-size: 14px; color: var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .chat-list-item { display: flex; align-items: center; padding: 10px 15px; cursor: pointer; border-bottom: 1px solid var(--border-color); position: relative; }
        .chat-list-item:hover { background-color: #f5f5f5; }
        .chat-list-item .avatar { width: 45px; height: 45px; border-radius: 50%; margin-right: 12px; object-fit: cover; background-color: #ccc; }
        .chat-list-item .info { flex-grow: 1; overflow: hidden; }
        .chat-list-item .name-line { display: flex; align-items: center; gap: 6px; margin-bottom: 2px; }
        .chat-list-item .name { font-weight: 500; color: var(--text-primary); }
        .chat-list-item .group-tag { font-size: 10px; color: var(--accent-color); background-color: #e7f3ff; padding: 2px 6px; border-radius: 4px; font-weight: bold; flex-shrink: 0; }
        .chat-list-item .last-msg { font-size: 13px; color: var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 180px; }
        #chat-interface-screen { background-size: cover; background-position: center; position: relative; }
        #selection-cancel-btn, #selection-delete-btn { font-size: 16px; color: var(--accent-color); cursor: pointer; padding: 5px; }
        #selection-delete-btn { color: #ff3b30; }
        
        /* ▼▼▼ 用這塊代碼替換掉你原來的 #chat-messages 樣式 ▼▼▼ */
        #chat-messages {
            flex-grow: 1;
            overflow-y: auto;
            overflow-x: hidden; /* 核心修正1: 強制禁止水準滾動/拖動 */
            padding: 10px 15px; /* 核心修正2: 將左右內邊距增加到15px，提供更多呼吸空間 */
            padding-top: 110px;
            margin-top: -80px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            box-sizing: border-box; /* 確保內邊距計算正確 */
        }
        /* ▲▲▲ 替換結束 ▲▲▲ */
        #load-more-btn { text-align: center; padding: 10px; color: var(--accent-color); font-size: 14px; cursor: pointer; background-color: transparent; border: none; width: 100%; }
        #load-more-btn:hover { text-decoration: underline; }
        
        .sender-name { font-size: 11px; color: #666; margin-bottom: 3px; }
        
        .message-wrapper.ai .sender-name {
            margin-left: 50px; /* 稍微調整，與頭像對齊 */
            margin-bottom: 3px;
            position: absolute; /* 讓它脫離流，避免影響氣泡對齊 */
            top: -16px;       /* 定位到氣泡上方 */
            left: 0;
        }
        
        /* === 【全新】消息佈局與時間戳記樣式 === */
        
        /* 1. 消息單元的總容器 (重構) */
        .message-wrapper {
            display: flex;          /* 使用Flex佈局 */
            gap: 8px;               /* 氣泡和時間戳記之間的間距 */
            align-items: flex-end;  /* 核心：讓氣泡和時間戳記底部對齊 */
            position: relative;
            max-width: 90%;         /* 可以稍微放寬一點，因為時間戳記現在在外面了 */
        }
        
        /* 2. AI消息單元靠左 */
        .message-wrapper.ai {
            align-self: flex-start;
            flex-direction: row; /* 頭像、氣泡、時間戳記，從左到右排列 */
        }
        
        /* 3. 使用者消息單元靠右 */
        .message-wrapper.user {
            align-self: flex-end;
            flex-direction: row-reverse; /* 時間戳記、氣泡、頭像，從右到左排列 */
        }
        
        /* 4. 氣泡和頭像的直接容器 (保持不變) */
        .message-bubble {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            max-width: 100%;
            min-width: 0; /* <-- 核心修復：允許氣泡容器自身收縮 */
        }
        
        .timestamp {
            /* 移除舊的 position: absolute */
            font-size: 11px;
            color: #999;
            text-shadow: 0 0 3px rgba(255,255,255,0.6);
            white-space: nowrap; /* 防止時間換行 */
            margin-bottom: 5px;  /* 讓它和氣泡底部有輕微的對齊偏移，更美觀 */
            flex-shrink: 0;      /* 防止被壓縮 */
        }
        
        .message-bubble.selected::after { content: '✔'; position: absolute; left: -10px; top: 50%; transform: translateY(-50%); background-color: var(--accent-color); color: white; width: 20px; height: 20px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 12px; }
        .message-bubble.user.selected::after { left: auto; right: -10px; }
        
        .message-bubble.user { flex-direction: row-reverse; }
        #typing-indicator { align-self: flex-start; display: none; margin: 0 10px 10px; color: var(--text-secondary); }
        
        
        #chat-list-bottom-nav {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            z-index: 15;
            display: flex;
            border-top: 1px solid var(--border-color);
            background-color: rgba(247, 247, 247, 0.9);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            /* 核心：為底部增加安全距離 */
            padding-bottom: env(safe-area-inset-bottom);
        }
        #chat-input-main-row { display: flex; align-items: flex-end; gap: 8px; width: 100%; }
        /* --- 請用這塊新代碼替換舊的 #chat-input 樣式 --- */
#chat-input {
    flex-grow: 1;
    border: none;
    padding: 10px 15px;
    border-radius: 20px;
    background-color: var(--secondary-bg);
    font-size: 16px;
    /* 核心修改 1: 設置一個固定的高度，例如 40px */
    height: 40px; 
    /* 核心修改 2: 移除 max-height 屬性 */
    /* max-height: 100px; */ 
    resize: none;
    /* 核心修改 3: 當內容超出高度時，顯示捲軸 */
    overflow-y: auto; 
    box-sizing: border-box; /* 推薦添加，確保內邊距計算正確 */
}
        .action-button { border: none; color: white; border-radius: 20px; cursor: pointer; font-weight: 600; font-size: 14px; flex-shrink: 0; }
        #send-btn { background-color: var(--accent-color); height: 40px; padding: 0 15px;}
        .modal { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.4); display: none; justify-content: center; align-items: center; z-index: 100; }
        .modal.visible { display: flex; }
        .modal-content { width: 90%; max-height: 90%; background-color: white; border-radius: 15px; display: flex; flex-direction: column; }
        .modal-header { padding: 15px; font-weight: 600; border-bottom: 1px solid var(--border-color); text-align: center; display: flex; justify-content: space-between; align-items: center; }
        .modal-body { padding: 15px; overflow-y: auto; }
        .modal-footer { padding: 15px; border-top: 1px solid var(--border-color); display: flex; justify-content: space-around; }
        .modal-footer button { width: 45%; padding: 12px; border-radius: 8px; border: 1px solid var(--accent-color); cursor: pointer; font-size: 16px; }
        .modal-footer .save { background-color: var(--accent-color); color: white; }
        .modal-footer .cancel { background-color: white; color: var(--accent-color); }
        .avatar-upload { display: flex; align-items: center; gap: 15px; }
        .avatar-upload img { width: 60px; height: 60px; border-radius: 50%; object-fit: cover; background-color: #eee; }
        .avatar-upload button { padding: 8px 12px; border: 1px solid #ccc; background-color: #f0f0f0; border-radius: 5px; cursor: pointer; }
        #open-persona-library-btn { font-size: 14px; padding: 6px 10px; margin-left: 0; }
        .avatar-upload input[type="file"] { display: none; }
        .theme-selector label { display: inline-flex; align-items: center; margin-right: 15px; margin-bottom: 5px; cursor: pointer; }
        #reset-theme-btn { background: none; border: 1px solid #ccc; color: #555; font-size: 12px; padding: 2px 8px; border-radius: 5px; cursor: pointer; margin-left: 10px; }
        #group-members-settings { display: flex; overflow-x: auto; padding-bottom: 10px; gap: 15px; }
        .member-editor { text-align: center; cursor: pointer; }
        .member-editor img { width: 50px; height: 50px; border-radius: 50%; object-fit: cover; background-color: #eee; margin-bottom: 5px; }
        .member-editor .member-name { font-size: 12px; }
        #notification-bar { position: absolute; top: 40px; left: 50%; width: 90%; z-index: 500; background-color: rgba(250, 250, 250, 0.9); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border-radius: 16px; padding: 10px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); display: flex; align-items: center; gap: 12px; cursor: pointer;     transform: translateX(-50%) translateY(-150%); 
            transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            visibility: hidden;
        }
        #notification-bar.visible {
            /* 關鍵：在Y軸回到原位的同時，保持X軸的居中變換 */
            transform: translateX(-50%) translateY(0);
            visibility: visible;
        }
        #notification-avatar { width: 30px; height: 30px; border-radius: 50%; object-fit: cover; }
        #notification-content .name { font-weight: 600; font-size: 15px; color: #000; }
        #notification-content .message { font-size: 14px; color: #555; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 200px; }
        .sticker-image { max-width: 100px; max-height: 100px; display: block; object-fit: contain; }
        
        #chat-input-actions-top { display: flex; gap: 8px; padding: 0 5px; }
        .chat-action-icon-btn { font-size: 24px; padding: 0; width: 38px; height: 38px; line-height: 38px; text-align: center; border-radius: 50%; background-color: rgba(255, 255, 255, 0.5); color: var(--text-primary); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); border: 1px solid rgba(0,0,0,0.05); cursor: pointer; display:flex; justify-content:center; align-items:center; }
        #sticker-panel { position: absolute; bottom: 0; left: 0; width: 100%; height: 50%; background-color: rgba(242, 242, 247, 0.85); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border-top: 1px solid var(--border-color); border-radius: 20px 20px 0 0; z-index: 200; display: flex; flex-direction: column; transform: translateY(100%); transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); visibility: hidden; }
        #sticker-panel.visible { transform: translateY(0); visibility: visible; }
        #sticker-panel-header { padding: 10px 20px; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; border-bottom: 1px solid var(--border-color); }
        #sticker-panel-header .title { font-weight: 600; }
        #sticker-panel-header .panel-btn { font-size: 16px; padding: 5px 10px; cursor: pointer; color: var(--accent-color); }
        #sticker-grid { flex-grow: 1; overflow-y: auto; padding: 15px; display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 15px; }
        /* ▼▼▼ 【表情含義顯示】請用這整塊代碼，替換掉您現有的 .sticker-item 樣式 ▼▼▼ */

/* 1. 表情項的總容器，現在是flex佈局 */
.sticker-item {
    position: relative;
    display: flex;
    flex-direction: column; /* 垂直排列圖片和文字 */
    align-items: center;    /* 水準居中 */
    gap: 6px;               /* 圖片和文字之間的間距 */
    cursor: pointer;
}

/* 2. 表情圖片容器 (這是新增的) */
.sticker-image-container {
    width: 100%;
    aspect-ratio: 1 / 1;    /* 保持正方形 */
    background-color: white;
    border-radius: 10px;
    background-size: contain;
    background-repeat: no-repeat;
    background-position: center;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}

/* 3. 表情含義文本 (這是新增的) */
.sticker-name {
    font-size: 12px;           /* 字體大小 */
    color: var(--text-secondary); /* 使用次要文字顏色 */
    width: 100%;               /* 寬度撐滿，為省略號做準備 */
    text-align: center;        /* 文字居中 */
    
    /* --- 這就是實現“超出省略號”的核心代碼 --- */
    white-space: nowrap;       /* 強制不換行 */
    overflow: hidden;          /* 隱藏超出的部分 */
    text-overflow: ellipsis;   /* 將超出的部分顯示為省略號 */
    /* --- 核心代碼結束 --- */
}

/* ▲▲▲ 替換結束 ▲▲▲ */
        .sticker-item .delete-btn { display: none; position: absolute; top: -5px; right: -5px; width: 20px; height: 20px; background-color: #ff3b30; color: white; border-radius: 50%; text-align: center; line-height: 20px; font-size: 14px; cursor: pointer; border: 2px solid white; }
        #input-actions-wrapper { position: static; display: flex; align-items: flex-end; gap: 8px; flex-shrink: 0; }
        #wait-reply-btn { position: static; bottom: auto; right: auto; width: auto; height: 40px; padding: 0 10px; border-radius: 20px; display: flex; align-items: center; justify-content: center; background-color: rgba(255, 255, 255, 0.6); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); border: 1px solid rgba(0,0,0,0.08); box-shadow: 0 2px 5px rgba(0,0,0,0.1); transition: opacity 0.2s, transform 0.1s; cursor: pointer;}
        #wait-reply-btn:hover { opacity: 0.8; }
        #wait-reply-btn:active { transform: scale(0.9); }
        #wait-reply-btn img { height: 22px; display: block; margin: auto; }
        .chat-image { max-width: 100%; border-radius: 10px; display: block; }
        .message-bubble.has-image .content { padding: 5px; }
        #custom-modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); display: none; align-items: center; justify-content: center; z-index: 1000; opacity: 0; transition: opacity 0.2s ease-in-out; }
        #custom-modal-overlay.visible { display: flex; opacity: 1; }
        #custom-modal { background-color: #fff; width: 280px; border-radius: 14px; box-shadow: 0 4px 20px rgba(0,0,0,0.2); display: flex; flex-direction: column; transform: scale(0.95); transition: transform 0.2s ease-in-out; }
        #custom-modal-overlay.visible #custom-modal { transform: scale(1); }
        .custom-modal-header { padding: 16px; font-size: 17px; font-weight: 600; text-align: center; }
        .custom-modal-body { padding: 0 16px 16px; text-align: center; font-size: 14px; color: #333; line-height: 1.5; }
        .custom-modal-body p { margin: 0; margin-bottom: 12px; }
        /* ▼▼▼ Safari彈窗防放大修正：請用這塊新樣式替換舊的 .custom-modal-body input 樣式 ▼▼▼ */
        
        .custom-modal-body input {
            width: 100%;
            padding: 8px 12px; /* 推薦：稍微增加內邊距，讓輸入框更好看 */
            border-radius: 6px;
            border: 1px solid #ccc;
            font-size: 16px; /* 核心修正：從 14px 提高到 16px 防止自動放大 */
            box-sizing: border-box;
        }
        
        /* ▲▲▲ 替換結束 ▲▲▲ */
        .custom-modal-footer { border-top: 1px solid #dbdbdb; display: flex; }
        .custom-modal-footer button { flex: 1; background: none; border: none; padding: 12px; font-size: 17px; cursor: pointer; color: var(--accent-color); }
        .custom-modal-footer button:first-child { border-right: 1px solid #dbdbdb; }
        .custom-modal-footer .confirm-btn { font-weight: 600; }
        .custom-modal-footer .confirm-btn.btn-danger { color: #ff3b30; }
        #preset-actions-modal .custom-modal-footer { flex-direction: column; }
        #preset-actions-modal .custom-modal-footer button { width: 100%; border: none; border-bottom: 1px solid #dbdbdb; padding: 14px; font-size: 18px; }
        #preset-actions-modal .custom-modal-footer button:last-child { border-bottom: none; }
        .custom-multiselect {
            position: relative;
            -webkit-user-select: none; /* 相容 Safari */
            user-select: none;
        }
        .select-box { display: flex; align-items: center; width: 100%; padding: 12px; border: 1px solid var(--border-color); border-radius: 8px; font-size: 16px; box-sizing: border-box; background-color: #fff; cursor: pointer; }
        .select-box .selected-options-text { flex-grow: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: var(--text-primary); }
        .select-box .arrow-down { margin-left: auto; font-size: 10px; color: var(--text-secondary); transition: transform 0.2s; }
        .select-box.expanded .arrow-down { transform: rotate(180deg); }
        
        .checkboxes-container {
            display: none;
            position: absolute;
            /* 核心修改：不再使用 top，而是用 margin-top 來創造間距，更穩定 */
            top: 100%; 
            margin-top: 5px; /* <-- 新增：向下推開5圖元的距離 */
            left: 0;
            right: 0;
            max-height: 150px;
            overflow-y: auto;
            background-color: #fff;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            z-index: 101;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        .checkboxes-container.visible { display: block; }
        .checkboxes-container label { display: block; padding: 10px 12px; cursor: pointer; font-weight: normal; color: var(--text-primary); }
        
        .checkboxes-container label {
            display: block;
            padding: 12px 15px; /* <-- 修改：增加了上下和左右的內邊距，讓每一行更高更寬 */
            cursor: pointer;
            font-weight: normal;
            color: var(--text-primary);
            font-size: 15px; /* <-- 新增：將字體大小從預設值放大到15px */
        }
        
        .checkboxes-container input { margin-right: 10px; vertical-align: middle; }
        .bg-upload-container { display: flex; align-items: center; gap: 10px; margin-top: 8px; flex-wrap: wrap; }
        .bg-preview-img { max-width: 120px; max-height: 80px; border-radius: 8px; border: 1px solid var(--border-color); object-fit: cover; display: none; }
        #remove-bg-btn { padding: 8px 12px; border: 1px solid #ff3b30; color: #ff3b30; background-color: #fff; border-radius: 5px; cursor: pointer; font-size: 14px; display: none; }
        
        .ai-generated-image { max-width: 180px; border-radius: 12px; display: block; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; }
        .ai-generated-image:hover { transform: scale(1.05); box-shadow: 0 4px 15px rgba(0,0,0,0.2); }
        .voice-message-body { display: flex; align-items: center; cursor: pointer; padding: 8px 12px; min-width: 80px; max-width: 200px; }
        .message-bubble.user .voice-message-body { color: #1a3d00; flex-direction: row-reverse; }
        .message-bubble.ai .voice-message-body { color: var(--text-primary); }
        .voice-waveform { display: flex; align-items: center; height: 20px; gap: 2px; flex-grow: 1; margin: 0 10px; }
        .voice-waveform div { width: 3px; background-color: currentColor; border-radius: 2px; animation: wave-quiet 1.5s ease-in-out infinite; }
        @keyframes wave-quiet { 0%, 100% { height: 2px; } 50% { height: 10px; } }
        .voice-waveform div:nth-child(2) { animation-delay: 0.2s; } .voice-waveform div:nth-child(3) { animation-delay: 0.4s; } .voice-waveform div:nth-child(4) { animation-delay: 0.6s; } .voice-waveform div:nth-child(5) { animation-delay: 0.8s; }
        .voice-duration {
            /* --- 核心修正 --- */
            font-size: var(--chat-font-size, 13px);
            /* --- 修正結束 --- */
            font-weight: 500;
            color: var(--text-secondary);
        }
        .message-bubble.user .voice-duration { color: #3e6224; }
        
        /* ▼▼▼ 用這塊代碼替換掉你原來的 .message-bubble .content 樣式 ▼▼▼ */
        /* 通用內容區樣式，為時間戳記和字體大小做準備 */
        .message-bubble .content {
            position: relative;
            font-size: var(--chat-font-size, 16px);
            padding: 8px 12px;
            line-height: 1.5;
            word-break: break-word; /* 核心修正: 強制長單詞或URL換行，防止撐破氣泡 */
        
        }
        /* ▲▲▲ 替換結束 ▲▲▲ */
        
        /* === 氣泡主題樣式 === */
        .message-bubble.user .content { background-color: rgba(255, 255, 255, 0.75); color: #585858; border-radius: 8px 2px 8px 8px; }
        .message-bubble.ai .content { background-color: rgba(255, 255, 255, 0.7); color: #585858; border-radius: 2px 8px 8px 8px; }
              
        .message-bubble::after {
            content: "";
            position: absolute;
            width: 20px;  
            height: 20px; 
            background-size: contain;
            background-repeat: no-repeat;
            opacity: 1; 
            z-index: 1;
        }
              
        #chat-messages[data-theme="pink_blue"] .message-bubble.user .content { background-color: #fff0f6; color: #432531; }
        #chat-messages[data-theme="pink_blue"] .message-bubble.ai .content { background-color: #eff7ff; color: #263a4e; }
        #chat-messages[data-theme="blue_white"] .message-bubble.user .content { background-color: #eff7ff; color: #263a4e; }
        #chat-messages[data-theme="blue_white"] .message-bubble.ai .content { background-color: #f8f9fa; color: #383d41; }
        #chat-messages[data-theme="purple_yellow"] .message-bubble.user .content { background-color: #faf7ff; color: #827693; }
        #chat-messages[data-theme="purple_yellow"] .message-bubble.ai .content { background-color: #fffde4; color: #5C4033; }
        #chat-messages[data-theme="black_white"] .message-bubble.user .content { background-color: #343a40; color: #f8f9fa; }
        #chat-messages[data-theme="black_white"] .message-bubble.ai .content { background-color: #f8f9fa; color: #343a40; }
        #chat-messages[data-theme="yellow_white"] .message-bubble.user .content { background-color: #FFEB3B; color: #5D4037; }
        #chat-messages[data-theme="yellow_white"] .message-bubble.ai .content { background-color: #f8f9fa; color: #383d41; }
        #chat-messages[data-theme="red_black"] .message-bubble.user .content { background-color: #C62828; color: #FFFFFF; }
        #chat-messages[data-theme="red_black"] .message-bubble.ai .content { background-color: #212121; color: #FFFFFF; }
        #chat-messages[data-theme="blue_yellow"] .message-bubble.user .content { background-color: #A0D2EB; color: #153243; }
        #chat-messages[data-theme="blue_yellow"] .message-bubble.ai .content { background-color: #FEF9E7; color: #5D4037; }
        #chat-messages[data-theme="pink_yellow"] .message-bubble.user .content { background-color: #fff0f6; color: #432531; }
        #chat-messages[data-theme="pink_yellow"] .message-bubble.ai .content { background-color: #FEF9E7; color: #5D4037; }
        #chat-messages[data-theme="pink_purple"] .message-bubble.user .content { background-color: #fff0f6; color: #a78396; }
        #chat-messages[data-theme="pink_purple"] .message-bubble.ai .content { background-color: #faf7ff; color: #827693; }
        #chat-messages[data-theme="gray_white"] .message-bubble.user .content { background-color: #e9ecef; color: #495057; }
        #chat-messages[data-theme="gray_white"] .message-bubble.ai .content { background-color: #f8f9fa; color: #383d41; }
        #chat-messages[data-theme="blue_green"] .message-bubble.user .content { background-color: #d1ecf1; color: #0c5460; }
        #chat-messages[data-theme="blue_green"] .message-bubble.ai .content { background-color: #d4edda; color: #155724; }
        #chat-messages[data-theme="pink_white"] .message-bubble.user .content { background-color: #fff0f6; color: #a78396; }
        #chat-messages[data-theme="pink_white"] .message-bubble.ai .content { background-color: #f8f9fa; color: #383d41; }
        #chat-messages[data-theme="pink_black"] .message-bubble.user .content { background-color: #F8BBD0; color: #5B2C6F; }
        #chat-messages[data-theme="pink_black"] .message-bubble.ai .content { background-color: #343a40; color: #f8f9fa; }
        #chat-messages[data-theme="pink_green"] .message-bubble.user .content { background-color: #F8BBD0; color: #5B2C6F; }
        #chat-messages[data-theme="pink_green"] .message-bubble.ai .content { background-color: #C8E6C9; color: #1B5E20; }
        #chat-messages[data-theme="green_black"] .message-bubble.user .content { background-color: #d4edda; color: #155724; }
        #chat-messages[data-theme="green_black"] .message-bubble.ai .content { background-color: #343a40; color: #f8f9fa; }
        
        #transfer-btn { font-weight: bold; }
        #transfer-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); display: none; align-items: center; justify-content: center; z-index: 1001; }
        #transfer-modal.visible { display: flex; }
        .transfer-content { background-color: #fff0f5; border-radius: 20px; width: 290px; padding: 20px; box-shadow: 0 5px 25px rgba(255, 105, 180, 0.3); text-align: center; background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100" opacity="0.05"><path d="M50,4 C35,4 28,15 28,24 C28,33 35,32 35,40 C35,48 28,49 28,57 C28,65 35,66 35,74 C35,82 28,83 28,91 C28,99 35,100 50,100 C65,100 72,99 72,91 C72,83 65,82 65,74 C65,66 72,65 72,57 C72,49 65,48 65,40 C65,32 72,33 72,24 C72,15 65,4 50,4 Z" fill="%23FF69B4"/></svg>'); background-repeat: no-repeat; background-position: top right; background-size: 80px; }
        .transfer-header { font-size: 20px; font-weight: bold; color: #a35c7b; margin-bottom: 20px; }
        .transfer-input-group { margin-bottom: 15px; text-align: left; }
        .transfer-input-group label { display: block; font-size: 14px; color: #ff85b3; margin-bottom: 5px; font-weight: 500; }
        .transfer-input-group input { width: 100%; padding: 12px; border-radius: 10px; border: 2px solid #ffcce0; background-color: #fff; font-size: 16px; box-sizing: border-box; }
        .transfer-input-group input:focus { border-color: #ff85b3; outline: none; }
        .transfer-actions { display: flex; justify-content: space-between; gap: 10px; }
        .transfer-actions button { flex: 1; padding: 12px; border: none; border-radius: 10px; font-size: 16px; font-weight: bold; cursor: pointer; transition: transform 0.2s; }
        .transfer-actions button:active { transform: scale(0.95); }
        #transfer-cancel-btn { background-color: #ffdde9; color: #a35c7b; }
        #transfer-confirm-btn { background-color: #ff85b3; color: white; }
        
        .transfer-card { width: 200px; border-radius: 12px; padding: 12px; color: white; position: relative; overflow: hidden; }
        .transfer-card::before { content: '🐾'; position: absolute; right: 10px; top: 5px; font-size: 30px; opacity: 0.2; transform: rotate(15deg); }
        .message-bubble.user .transfer-card { background: radial-gradient(circle at top left, #ffc5d5, #ff85b3); }
        .message-bubble.ai .transfer-card { background: radial-gradient(circle at top left, #a1c4fd, #c2e9fb); }
        .transfer-title { font-size: 16px; font-weight: 600; display: flex; align-items: center; gap: 6px; margin-bottom: 8px; }
        .transfer-amount { font-size: 28px; font-weight: bold; margin-bottom: 4px; }
        .transfer-note { font-size: 13px; opacity: 0.9; border-top: 1px solid rgba(255,255,255,0.3); padding-top: 8px; margin-top: 8px; word-break: break-all; }
        
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        #listen-together-btn img.rotating { animation: spin 2s linear infinite; }
        #listen-together-btn img.paused { animation-play-state: paused; }
        #music-player-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 50; display: none; justify-content: center; align-items: center; background-color: rgba(0,0,0,0.3); }
        #music-player-overlay.visible { display: flex; }
        .music-player-window { width: 90%; background-color: rgba(255, 255, 255, 0.6); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); border-radius: 20px; box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37); border: 1px solid rgba(255, 255, 255, 0.18); padding: 25px; display: flex; flex-direction: column; align-items: center; color: #1f1f1f; position: relative; }
        #music-playlist-btn { position: absolute; top: 15px; right: 15px; font-size: 24px; cursor: pointer; color: #333; }
        #music-time-counter { font-size: 12px; color: #555; margin-bottom: 20px; }
        #music-player-song-title { font-size: 20px; font-weight: 600; margin-bottom: 5px; text-align: center; }
        #music-player-artist { font-size: 14px; color: #666; margin-bottom: 25px; }
        .music-controls { display: flex; align-items: center; justify-content: center; gap: 20px; width: 100%; margin-bottom: 30px; }
        .music-controls button { background: none; border: none; font-size: 16px; font-weight: bold; cursor: pointer; color: #333; width: 44px; height: 44px; display: flex; justify-content: center; align-items: center; transition: transform 0.2s; }
        .music-controls button:active { transform: scale(0.9); }
        .music-controls .play-pause-btn { font-size: 24px; width: 60px; height: 60px; border-radius: 50%; background-color: rgba(0,0,0,0.05); }
        .music-bottom-actions { display: flex; justify-content: space-between; width: 100%; }
        .music-bottom-actions button { flex: 1; padding: 12px 0; border: none; border-radius: 10px; font-size: 15px; font-weight: 500; cursor: pointer; }
        #music-exit-btn { background-color: rgba(255, 100, 100, 0.7); color: white; margin-right: 5px; }
        #music-return-btn { background-color: rgba(0, 123, 255, 0.7); color: white; margin-left: 5px; }
        
        #music-playlist-panel { position: absolute; bottom: 0; left: 0; width: 100%; height: 70%; background-color: rgba(242, 242, 247, 0.9); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border-top: 1px solid var(--border-color); border-radius: 20px 20px 0 0; z-index: 210; display: flex; flex-direction: column; transform: translateY(100%); transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); visibility: hidden; }
        #music-playlist-panel.visible { transform: translateY(0); visibility: visible; }
        .playlist-header { padding: 15px 20px; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; border-bottom: 1px solid var(--border-color); font-weight: 600; }
        .playlist-header .panel-btn { font-size: 16px; cursor: pointer; color: var(--accent-color); }
       .playlist-body {
    flex-grow: 1;
    overflow-y: auto;
    /* 核心修復：將 padding-bottom 顯著增大，確保最後一條歌曲不會被遮擋 */
    /* 同時使用 box-sizing 確保內邊距計算正確 */
    padding: 10px 0 80px 0;
    box-sizing: border-box;
}
        .playlist-item { padding: 10px 20px; display: flex; justify-content: space-between; align-items: center; cursor: pointer; border-bottom: 1px solid #eee; }
        .playlist-item.playing { background-color: rgba(0, 123, 255, 0.1); }
        .playlist-item-info .title { font-weight: 500; font-size: 15px; }
        .playlist-item-info .artist { font-size: 12px; color: #666; }
        .playlist-item .delete-track-btn { color: #ff3b30; font-size: 20px; padding: 5px; }
        
        /* Persona Library Styles */
        #persona-library-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; padding: 10px; }
        .persona-preset-item { aspect-ratio: 1 / 1; border-radius: 12px; background-size: cover; background-position: center; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; border: 1px solid rgba(0,0,0,0.1); }
        .persona-preset-item:hover { transform: scale(1.08); box-shadow: 0 4px 10px rgba(0,0,0,0.2); }
        .modal-header .action-button { font-size: 16px; color: var(--accent-color); font-weight: 600; cursor: pointer; background: none; border: none; padding: 5px; }
        
        /* Battery Alert Modal Styles */
        #battery-alert-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.4); display: none; justify-content: center; align-items: center; z-index: 2000; opacity: 0; transition: opacity 0.3s ease; }
        #battery-alert-modal.visible { display: flex; opacity: 1; }
        .battery-alert-content { background-color: rgba(255, 255, 255, 0.9); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); width: 280px; border-radius: 15px; box-shadow: 0 5px 20px rgba(0,0,0,0.2); text-align: center; padding: 20px; cursor: pointer; transform: scale(0.9); transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1); }
        #battery-alert-modal.visible .battery-alert-content { transform: scale(1); }
        #battery-alert-image { max-width: 100px; max-height: 100px; margin-bottom: 15px; }
        #battery-alert-text { font-size: 16px; font-weight: 500; color: #333; margin: 0; line-height: 1.4; }
        
        /* 這是你要添加的新樣式 */
        #font-preview {
            transition: font-family 0.3s ease;}
        
        /* === 聊天清單介面新增樣式 (這是新添加的) === */
        #chat-list-screen {
        }
        
        .chat-list-view {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
            z-index: 1; 
        }
        .chat-list-view.active {
            opacity: 1;
            visibility: visible;
            z-index: 2; 
        }
        
        #messages-view {
            overflow-y: auto; 
        }
        
        
        .nav-item {
            flex: 1;
            text-align: center;
            padding: 12px 0;
            font-size: 14px;
            color: var(--text-secondary);
            cursor: pointer;
            transition: color 0.2s;
        }
        
        .nav-item.active {
            color: var(--accent-color);
            font-weight: 600;
        }
        
        /* === 動態介面 (QZone) 樣式 (這是新添加的) === */
        #qzone-screen {
            background-color: #f0f2f5;
        }
        
        .qzone-header {
            /* position: absolute;  <-- 把這個改成 relative */
            position: relative;
            z-index: 10; /* z-index 保持，或者可以更高 */
            flex-shrink: 0; /* 防止被壓縮 */
            padding: 15px 20px;
            padding-top: 45px;
            background-color: rgba(247, 247, 247, 0.7); 
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 18px;
            font-weight: 600;
            text-align: center;
        }
        
        .qzone-header .back-btn {
            font-size: 24px;
            cursor: pointer;
            color: var(--accent-color);
        }
        
        .qzone-header span:nth-child(2) { /* "好友動態"文字 */
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .qzone-content {
            flex-grow: 1;
            overflow-y: auto;
            /* padding-top: 80px;  <-- 刪除這個，因為header不再是absolute了 */
        }
        
        .qzone-profile-header {
            position: relative;
            margin-bottom: 20px;
        }
        
        .qzone-banner-container {
            width: 100%;
            height: 180px; /* 背景板高度 */
            position: relative;
        }
        
        #qzone-banner-img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .qzone-user-info {
            position: absolute;
            bottom: -30px; /* 讓頭像和昵稱區域向下偏移，一半在背景板內，一半在外 */
            left: 20px;
            display: flex;
            align-items: flex-end; /* 讓昵稱和頭像底部對齊 */
            gap: 10px;
        }
        
        .qzone-avatar-container {
            position: relative;
        }
        
        #qzone-avatar-img {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            border: 3px solid white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            object-fit: cover;
        }
        
        #qzone-nickname {
            font-size: 18px;
            font-weight: 600;
            color: #fff;
            text-shadow: 0 1px 3px rgba(0,0,0,0.5);
            padding-bottom: 5px; /* 微調位置 */
        }
        
        /* 編輯按鈕的通用樣式 */
        .qzone-edit-btn {
            position: absolute;
            background-color: rgba(0,0,0,0.4);
            color: white;
            border: none;
            border-radius: 10px;
            padding: 4px 8px;
            font-size: 12px;
            cursor: pointer;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }
        
        #change-qzone-banner-btn {
            bottom: 10px;
            right: 10px;
        }
        
        #change-qzone-avatar-btn {
            bottom: 5px;
            right: 5px;
        }
        
        #change-qzone-nickname-btn {
            font-size: 14px;
            padding: 2px 6px;
            margin-left: 5px; /* 與昵稱的間距 */
            color: var(--text-primary);
            background-color: rgba(255,255,255,0.7);
            border-radius: 5px;
            position: relative; /* 脫離flex佈局的對齊 */
            bottom: 5px; /* 微調垂直位置 */
        }
        
        /* === 讓編輯功能更“隱形” === */
        #qzone-banner-container,
        #qzone-avatar-container,
        #qzone-nickname {
            cursor: pointer; /* 滑鼠懸停時顯示為可點擊手勢 */
            transition: opacity 0.2s;
        }
        #qzone-banner-container:hover,
        #qzone-avatar-container:hover,
        #qzone-nickname:hover {
            opacity: 0.85; /* 懸停時稍微變暗，給用戶回饋 */
        }
        /* 隱藏掉舊的、獨立的編輯按鈕 */
        .qzone-edit-btn {
            display: none;
        }
        
        /* === 控制 Header 和 Bottom Nav 的顯隱 === */
        /* 預設隱藏動態介面的 Header */
        #qzone-screen .qzone-header {
            display: none;
        }
        /* 當動態視圖啟動時，顯示它的Header */
        #qzone-screen.active .qzone-header {
            display: flex;
        }
        
        /* 當進入動態視圖時，隱藏主Header和底部巡覽列 */
        #chat-list-screen.in-qzone-view > .header,
        #chat-list-screen.in-qzone-view > #chat-list-bottom-nav {
            display: none;
        }
        
        .chat-list-item:first-child,
        .chat-group-container:first-child {
            margin-top: 10px; 
        }
        
        /* ▲▲▲ 新樣式替換結束 ▲▲▲ */
        
        /* ▼▼▼ 把所有這些新樣式黏貼到 <style> 的末尾 ▼▼▼ */
        
        /* === 動態功能欄樣式 === */
        .qzone-actions-bar {
            display: flex;
            justify-content: space-around;
            padding: 10px 0;
            margin: 40px 15px 15px 15px; /* 上邊距更大，為浮動的頭像留出空間 */
            background-color: var(--secondary-bg);
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }
        
        .action-item {
            flex: 1;
            text-align: center;
            font-size: 15px;
            font-weight: 500;
            color: var(--text-primary);
            cursor: pointer;
            padding: 8px 0;
            position: relative;
        }
        
        /* 用偽元素創建分隔線 */
        .action-item:not(:last-child)::after {
            content: '';
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 1px;
            height: 20px;
            background-color: var(--border-color);
        }
        
        /* === 動態帖子清單樣式 === */
        #qzone-posts-list {
            padding: 0 15px 20px 15px; /* 左右和底部留出邊距 */
            display: flex;
            flex-direction: column;
            gap: 20px; /* 帖子之間的間距 */
        }
        
        .qzone-post-item {
            background-color: var(--secondary-bg);
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 1px 4px rgba(0,0,0,0.06);
        }
        
        .post-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
        }
        
        .post-header .post-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
        }
        
        .post-info {
            display: flex;
            flex-direction: column;
        }
        
        .post-info .post-nickname {
            font-weight: 600;
            font-size: 15px;
            color: var(--text-primary);
        }
        
        .post-info .post-timestamp {
            font-size: 12px;
            color: var(--text-secondary);
        }
        
        .post-content {
            font-size: 14px;
            line-height: 1.6;
            color: #333;
            white-space: pre-wrap; /* 讓分行符號生效 */
            word-break: break-word; /* 防止長單詞溢出 */
        }
        
        /* ▲▲▲ 新樣式結束 ▲▲▲ */
        
        /* ▼▼▼ 新樣式黏貼到末尾 ▼▼▼ */
        
        /* === 發佈動態模態框樣式 === */
        #post-public-text {
            min-height: 80px; /* 確保文本域有足夠的高度 */
            resize: vertical;
        }
        
        .post-image-preview-container {
            position: relative;
            width: 100%;
            aspect-ratio: 16 / 9; /* 保持16:9的預覽比例 */
            background-color: #f0f2f5;
            border: 2px dashed var(--border-color);
            border-radius: 8px;
            margin-bottom: 15px;
            display: none; /* 默認隱藏 */
            justify-content: center;
            align-items: center;
        }
        .post-image-preview-container.visible {
            display: flex; /* 上傳後顯示 */
        }
        
        #post-image-preview {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            border-radius: 6px;
        }
        
        #post-remove-image-btn {
            position: absolute;
            top: -10px;
            right: -10px;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background-color: #ff3b30;
            color: white;
            border: 2px solid white;
            font-size: 16px;
            line-height: 20px;
            text-align: center;
            cursor: pointer;
            box-shadow: 0 1px 4px rgba(0,0,0,0.3);
        }
        
        .post-image-upload-options {
            display: flex;
            gap: 10px;
        }
        
        .post-image-upload-options button {
            flex: 1;
            margin-top: 0;
        }
        
        /* ▲▲▲ 新樣式結束 ▲▲▲ */
        
        /* ▼▼▼ 新樣式 ▼▼▼ */
        
        /* === 發佈動態模態框 - 模式切換樣式 === */
        .post-mode-switcher {
            display: flex;
            margin-bottom: 20px;
            background-color: #e9ecef;
            border-radius: 8px;
            padding: 4px;
        }
        
        .mode-btn {
            flex: 1;
            padding: 8px;
            border: none;
            background-color: transparent;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s ease-in-out;
        }
        
        .mode-btn.active {
            background-color: var(--secondary-bg);
            color: var(--text-primary);
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .post-mode-content {
            display: none; /* 默認都隱藏 */
        }
        
        .post-mode-content.active {
            display: block; /* 啟動的才顯示 */
        }
        
        /* ▲▲▲ 新樣式結束 ▲▲▲ */
        
        /* === 相冊頁面背景色 === */
        #album-screen {
            background-color: #f0f2f5; /* 使用一個柔和的淺灰色，比純白更護眼 */
        }
        
        /* === 相冊頁面網格佈局 === */
        #album-grid-page {
            padding: 15px;
            display: grid;
            grid-template-columns: repeat(2, 1fr); /* 每行顯示2個相冊 */
            gap: 15px;
        }
        
        /* === 相冊專案樣式 (美化) === */
        .album-item {
            display: flex;
            flex-direction: column;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            border-radius: 8px; /* 給整個項目也加個圓角 */
        }
        
        .album-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 15px rgba(0,0,0,0.1);
        }
        
        .album-cover {
            aspect-ratio: 1 / 1; /* 保持封面為正方形 */
            background-size: cover;
            background-position: center;
            border-radius: 8px;
            margin-bottom: 8px;
            background-color: #f0f2f5; /* 封面載入前的占位顏色 */
        }
        
        .album-info {
            text-align: center;
        }
        
        .album-name {
            font-weight: 500;
            margin: 0 0 4px 0;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis; /* 防止長名字換行 */
        }
        
        .album-count {
            font-size: 12px;
            color: var(--text-secondary);
            margin: 0;
        }
        
        /* ▲▲▲ 新的 CSS 黏貼結束 ▲▲▲ */
        
        /* ▼▼▼ 請將這些新樣式黏貼到 <style> 的末尾 ▼▼▼ */
        
        /* === 相冊照片詳情頁 === */
        #album-photos-screen {
            background-color: #f0f2f5;
        }
        
        #photos-grid-page {
            padding: 15px;
            display: grid;
            /* 每行顯示3張照片，並保持間距 */
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }
        
        .photo-item {
            position: relative; /* 為了定位刪除按鈕 */
            aspect-ratio: 1 / 1; /* 保持照片為正方形 */
            border-radius: 6px;
            overflow: hidden; /* 防止圖片溢出圓角 */
            background-color: #e9ecef; /* 圖片載入前的預留位置顏色 */
        }
        
        .photo-item .photo-thumb {
            width: 100%;
            height: 100%;
            object-fit: cover; /* 保證圖片填滿容器且不變形 */
            cursor: pointer;
        }
        
        /* 刪除按鈕的樣式 */
        .photo-item .photo-delete-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 22px;
            height: 22px;
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 16px;
            line-height: 22px;
            text-align: center;
            cursor: pointer;
            opacity: 0; /* 默認隱藏 */
            transition: opacity 0.2s ease;
        }
        
        /* 滑鼠懸停在照片上時顯示刪除按鈕 */
        .photo-item:hover .photo-delete-btn {
            opacity: 1;
        }
        
        /* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */
        
        /* === 圖片檢視器模態框樣式 === */
        #photo-viewer-modal {
            background-color: rgba(0, 0, 0, 0.85);
            z-index: 1002;
            -webkit-backdrop-filter: blur(5px);
            backdrop-filter: blur(5px);
        }
        
        .photo-viewer-content {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
        }
        
        #photo-viewer-image {
            max-width: 90vw;  /* 圖片最大寬度為視口的90% */
            max-height: 85vh; /* 圖片最大高度為視口的85% */
            object-fit: contain;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            /* 為圖片的切換添加一點平滑的淡入淡出效果 */
            transition: opacity 0.2s ease-in-out;
        }
        
        /* 關閉按鈕 */
        #photo-viewer-close-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: none;
            border: none;
            color: white;
            font-size: 40px;
            font-weight: 200;
            cursor: pointer;
            line-height: 1;
            text-shadow: 0 0 5px black;
        }
        
        /* 左右導航箭頭 */
        #photo-viewer-modal .nav-arrow {
            position: absolute; /* 現在我們用絕對定位來控制箭頭 */
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            font-size: 50px; /* 在手機螢幕上，可以稍微小一點 */
            font-weight: 100;
            cursor: pointer;
            padding: 10px; /* 調整內邊距 */
        -webkit-user-select: none; /* 相容 Safari */
            user-select: none;
            transition: color 0.2s;
            z-index: 1003; /* 確保箭頭在最上層 */
        }
        
        #photo-viewer-prev-btn {
            left: 5px; /* 定位左箭頭 */
        }
        
        #photo-viewer-next-btn {
            right: 5px; /* 定位右箭頭 */
        }
        
        #photo-viewer-modal .nav-arrow:hover {
            color: white;
        }
        
        /* 當箭頭被禁用時（比如第一張或最後一張） */
        #photo-viewer-modal .nav-arrow:disabled {
            color: rgba(255, 255, 255, 0.2);
            cursor: default;
        }
        
        /* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */
        
        /* ▼▼▼ 請將這些新樣式黏貼到 <style> 的末尾 ▼▼▼ */
        
        /* ▼▼▼ 請用這塊新CSS替換掉上一版的交互區CSS ▼▼▼ */
        
        /* === 帖子內容區 - 相對定位容器 === */
        /* === 帖子內容區 === */
        .post-main-content {
            /* 它現在只是一個普通的內容容器，不再需要特殊樣式了 */
        }
        
        /* === 帖子互動圖示區 (新樣式) === */
        .post-feedback-icons {
            display: flex;
            justify-content: flex-end; /* 讓圖示靠右對齊 */
            align-items: center;
            gap: 12px;
            padding: 8px 0; /* 核心修改：給圖示區域上下各8px的留白 */
        }
        
        .action-icon {
            cursor: pointer;
            color: var(--text-secondary); /* 默認灰色 */
            transition: all 0.2s ease-in-out;
        }
        
        .action-icon svg {
            width: 22px;
            height: 22px;
            fill: none;
            stroke: currentColor;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
        }
        
        /* 圖示啟動(點贊/收藏後)的樣式 */
        .action-icon.active {
            color: #ff5252; /* 啟動後變紅色 */
            transform: scale(1.1); /* 輕微放大 */
        }
        
        .action-icon.active.favorite {
            color: #ffc107; /* 收藏用黃色 */
        }
        
        .action-icon.active svg {
            fill: currentColor; /* 啟動後填充顏色 */
        }
        
        /* 點擊時的動畫效果 */
        .animate-like {
            animation: like-bounce 0.4s ease-in-out;
        }
        
        @keyframes like-bounce {
            0%   { transform: scale(1); }
            25%  { transform: scale(0.8); }
            50%  { transform: scale(1.2); }
            75%  { transform: scale(1.05); }
            100% { transform: scale(1.1); }
        }
        
        
        /* === 帖子底部評論區樣式 (現在是獨立部分) === */
        .post-footer {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid #f0f0f0; /* 用一條淺色線分隔 */
            display: flex;
            align-items: center;
            gap: 8px; /* 調整整體間距 */
        }
        
        /* 評論區容器 */
        .comment-section {
            flex-grow: 1; /* 佔據大部分空間 */
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .comment-section .comment-avatar {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            object-fit: cover;
            flex-shrink: 0;
        }
        /* ▼▼▼ 在這裡添加新樣式 ▼▼▼ */
        .comment-section {
            position: relative; /* 核心修正：為彈窗建立定位的錨點 */
        }
        /* ▲▲▲ 添加結束 ▲▲▲ */
        /* ▼▼▼ Safari防放大修正：請用下面這兩塊新樣式，替換舊的 .comment-input 和 .comment-send-btn 樣式 ▼▼▼ */
        
        .comment-section .comment-input {
            width: 100%;
            padding: 8px 12px;
            border: none;
            background-color: #f0f2f5;
            border-radius: 14px;
            font-size: 16px; /* 核心修正：從 13px 提高到 16px 防止自動放大 */
            outline: none;
        }
        
        /* (推薦) 同時調整發送按鈕，保持視覺統一 */
        .comment-send-btn {
            flex-shrink: 0; /* 防止被壓縮 */
            padding: 8px 15px;
            border: none;
            background-color: var(--accent-color);
            color: white;
            border-radius: 14px;
            font-size: 16px; /* 從 13px 調整為 16px */
            font-weight: 500;
            cursor: pointer;
        }
        
        /* ▲▲▲ 替換結束 ▲▲▲ */
        
        /* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */
        
        /* ▼▼▼ 請將這段新樣式黏貼到 <style> 的末尾 ▼▼▼ */
        
        /* === 未讀消息小紅點通用樣式 === */
        .unread-indicator {
            position: absolute;
            top: -8px;      
            right: -15px;    
            min-width: 18px;
            height: 18px;
            padding: 0 5px;
            background-color: #ff3b30;
            color: white;
            font-size: 11px;
            font-weight: bold;
            line-height: 18px;
            text-align: center;
            border-radius: 9px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
            display: none;
            z-index: 1;
        }
        
        /* 聊天介面返回按鈕上的小紅點 (只顯示點，不顯示數位) */
        .back-btn-indicator {
            top: 0;
            right: -8px; /* 放到返回箭頭右上角 */
            width: 10px;
            height: 10px;
            min-width: 10px;
            padding: 0;
            border-radius: 50%;
        }
        
        /* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */
        
        /* ▼▼▼ 請將這段新樣式黏貼到 <style> 的末尾 ▼▼▼ */
        
        /* === 評論列表容器 === */
        .post-comments-container {
            padding: 10px 0; /* 上下留白 */
            display: flex;
            flex-direction: column;
            gap: 8px; /* 評論之間的間距 */
            font-size: 13px; /* 統一評論區字體大小 */
        }
        
        /* 每一條評論 */
        .comment-item {
            line-height: 1.5;
        }
        
        /* 評論者的名字，加粗並使用主題色 */
        .comment-item .commenter-name {
            font-weight: 600;
            color: var(--accent-color);
            cursor: pointer;
            margin-right: 5px; /* 和評論內容之間留點空隙 */
        }
        
        /* 評論內容 */
        .comment-item .comment-text {
            color: var(--text-primary);
            word-break: break-word;
        }
        /* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */
        
        /* ▼▼▼ 請將這段新樣式黏貼到 <style> 的末尾 ▼▼▼ */
        
        /* === 帖子點贊區域樣式 === */
        .post-likes-section {
            display: flex;
            align-items: center;
            gap: 6px; /* 圖示和文字的間距 */
            padding: 8px 10px; /* 內邊距 */
            font-size: 13px;
            color: var(--accent-color); /* 使用主題藍色 */
            background-color: #f0f5fa; /* 給一個淡淡的背景色 */
            border-top: 1px solid #e9eef3;
            border-bottom: 1px solid #e9eef3;
            margin-top: 5px; /* 和上方的圖示保持一點距離 */
        }
        
        .post-likes-section .like-icon {
            width: 16px;
            height: 16px;
            fill: currentColor; /* 讓SVG圖示繼承父元素的顏色 */
            flex-shrink: 0; /* 防止圖示被壓縮 */
        }
        
        /* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */
        
        
        /* ▼▼▼ 請將這段新樣式黏貼到 <style> 的末尾 ▼▼▼ */
        
        /* === @提及 彈出功能表樣式 === */
        .at-mention-popup {
            position: absolute; /* 相對于父元素定位 */
            bottom: 100%; /* 顯示在輸入框的上方 */
            left: 40px; /* 和輸入框左側對齊 (考慮了頭像寬度) */
            width: calc(100% - 40px); /* 寬度和輸入框差不多 */
            max-height: 120px;
            overflow-y: auto;
            background-color: var(--secondary-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0 -4px 12px rgba(0,0,0,0.1);
            z-index: 10;
            display: none; /* 默認隱藏 */
        }
        
        .at-mention-item {
            padding: 8px 12px;
            font-size: 14px;
            cursor: pointer;
            color: var(--text-primary);
            border-bottom: 1px solid #f0f0f0;
        }
        
        .at-mention-item:last-child {
            border-bottom: none;
        }
        
        .at-mention-item:hover {
            background-color: #f5f5f5;
        }
        /* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */
        
        /* ▼▼▼ 請將這段新樣式黏貼到 <style> 的末尾 ▼▼▼ */
        
        /* ▼▼▼ 請用下面這段【新樣式】替換掉你現有的 #favorites-list 樣式 ▼▼▼ */
        
        /* 讓收藏視圖成為一個flex容器, 從上到下排列 */
        #favorites-view {
            display: flex;
            flex-direction: column;
        }
        
        /* 確保收藏頁的header高度固定，不被壓縮 */
        #favorites-view > .header {
            flex-shrink: 0;
        }
        
        /* === 收藏清單樣式 (修正後) === */
        #favorites-list {
            flex-grow: 1; 
            overflow-y: auto; 
            overflow-x: hidden; /* <-- 新增這行，禁止水準滾動 */
            padding: 15px; 
            display: flex;
            flex-direction: column;
            gap: 15px; 
        }
        
        /* ▲▲▲ 替換結束 ▲▲▲ */
        
        .favorite-item-card {
            background-color: var(--secondary-bg);
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 1px 4px rgba(0,0,0,0.06);
            position: relative; /* 為了定位刪除按鈕 */
        }
        
        /* 卡片頭部，包含頭像、名字和來源 */
        .fav-card-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
        }
        
        .fav-card-header .avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            object-fit: cover;
        }
        
        .fav-card-header .info {
            flex-grow: 1;
        }
        
        .fav-card-header .name {
            font-weight: 600;
            font-size: 15px;
        }
        
        .fav-card-header .source {
            font-size: 12px;
            color: var(--text-secondary);
        }
        
        /* 卡片內容 */
        .fav-card-content {
            font-size: 14px;
            line-height: 1.6;
            color: #333;
            white-space: pre-wrap;
            word-break: break-word;
        }
        
        .fav-card-content .chat-image {
            margin-top: 8px; /* 圖片和文字的間距 */
        }
        
        /* 刪除按鈕 */
        .fav-delete-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 28px;
            height: 28px;
            background: #f0f2f5;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            color: var(--text-secondary);
            line-height: 28px;
            text-align: center;
        }
        
        .fav-delete-btn:hover {
            background-color: #e9ecef;
            color: #ff3b30;
        }
        
        /* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */
        
        /* ▼▼▼ 請將這段新樣式黏貼到 <style> 的末尾 ▼▼▼ */
        
        /* === 搜索欄樣式 === */
        .search-bar-container {
            padding: 10px 15px;
            background-color: #f9f9f9; /* 和列表背景色保持一致 */
            position: relative; /* 為了定位清除按鈕 */
            flex-shrink: 0;
        }
        
        #favorites-search-input {
            width: 100%;
            padding: 10px 30px 10px 15px; /* 右側留出清除按鈕的位置 */
            font-size: 16px;
            border: 1px solid var(--border-color);
            border-radius: 18px; /* 圓角矩形，更現代化 */
            background-color: var(--secondary-bg);
            box-sizing: border-box;
            outline: none;
        }
        #favorites-search-input:focus {
            border-color: var(--accent-color);
        }
        
        .search-clear-btn {
            position: absolute;
            right: 25px;
            top: 50%;
            transform: translateY(-50%);
            background: #ccc;
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            line-height: 20px;
            text-align: center;
            font-size: 16px;
            cursor: pointer;
        }
        
        /* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */
        
        /* === 聊天介面多選操作欄優化 === */
        #chat-interface-screen .header .selection-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }
        
        #chat-interface-screen .selection-controls .action-btn {
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            padding: 5px;
        }
        
        /* === 收藏頁面多選模式樣式 === */
        #favorites-view.selection-mode .favorite-item-card {
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        
        /* 選擇框的樣式 */
        .favorite-item-card::before {
            content: '';
            position: absolute;
            left: -25px; /* 把它放在卡片左邊外面 */
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
            height: 20px;
            border: 2px solid #ccc;
            border-radius: 50%;
            background-color: white;
            transition: all 0.2s ease;
            opacity: 0; /* 默認隱藏 */
        }
        
        /* 進入選擇模式時，卡片向右移動，露出選擇框 */
        #favorites-view.selection-mode .favorite-item-card {
            transform: translateX(35px);
        }
        #favorites-view.selection-mode .favorite-item-card::before {
            opacity: 1;
        }
        
        /* 選中後的樣式 */
        #favorites-view.selection-mode .favorite-item-card.selected::before {
            background-color: var(--accent-color);
            border-color: var(--accent-color);
            content: '✔';
            color: white;
            font-size: 14px;
            text-align: center;
            line-height: 20px;
        }
        
        /* 底部操作欄 (終極修正版) */
        #favorites-action-bar {
            position: absolute; /* ★ 改為 absolute，相對於 #phone-screen 定位 */
            bottom: 0;
            left: 0;
            right: 0;           /* ★ 新增 right: 0，和 left: 0 一起撐滿寬度 */
            width: auto;        /* ★ 改為 auto，讓 left/right 決定寬度 */
            padding: 10px 15px;
            padding-bottom: calc(10px + env(safe-area-inset-bottom)); /* 適配iPhone底部安全區 */
            background-color: rgba(247, 247, 247, 0.9);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-top: 1px solid var(--border-color);
            box-sizing: border-box;
            z-index: 5;
            display: none;
            /* max-width 已經不需要了，因為父元素已經限制了寬度 */
        }
        
        #favorites-action-bar .action-bar-btn {
            width: 100%;
            padding: 12px;
            border-radius: 8px;
            border: none;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            background-color: #ff3b30;
            color: white;
        }
        
        /* === 【修正】聊天介面頭部控制項切換邏輯 === */
        
        /* 預設狀態：隱藏多選控制項 */
        #chat-interface-screen .header .selection-controls {
            display: none;
        }
        
        /* 預設狀態：顯示預設控制項，並讓它撐滿整個頭部 */
        #chat-interface-screen .header .default-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }
        
        /* 當進入多選模式時：隱藏預設控制項 */
        #chat-interface-screen.selection-mode .header .default-controls {
            display: none;
        }
        
        /* 當進入多選模式時：顯示多選控制項，並讓它撐滿整個頭部 */
        #chat-interface-screen.selection-mode .header .selection-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }
        
        /* ▼▼▼ 請將這段新樣式黏貼到 <style> 的末尾 ▼▼▼ */
        
        /* === 修正：放大所有主要的“+”號按鈕 === */
        #add-chat-btn,
        #add-world-book-btn,
        #create-album-btn-page {
            font-size: 28px;   /* 顯著增大字體大小，使其視覺上與旁邊的圖示匹配 */
            font-weight: 300;  /* 使用更細的字重，讓加號看起來更清爽，不顯粗笨 */
            position: relative;/* 允許進行位置微調 */
            top: -1px;         /* 字體放大後，通常需要稍微向上移動一點，使其視覺上更居中 */
        }
        
        /* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */
        
        /* ▼▼▼ 請將這些新樣式黏貼到 <style> 的末尾 ▼▼▼ */
        
        /* 預覽區容器樣式 */
        #settings-preview-area {
            width: 100%;
            height: 180px; /* 給一個固定的高度 */
            background-color: #f0f2f5;
            border-radius: 8px;
            padding: 15px;
            box-sizing: border-box;
            overflow: hidden; /* 防止內容溢出 */
            display: flex;
            flex-direction: column;
            gap: 10px; /* 預覽氣泡之間的間距 */
            border: 1px solid var(--border-color);
            position: relative; /* 為了定位背景 */
        }
        
        /* 預覽區的背景，可以和真實聊天介面同步 */
        #settings-preview-area::before {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-size: cover;
            background-position: center;
            z-index: 1;
            opacity: 0.8;
        }
        
        /* 讓預覽氣泡在背景之上 */
        #settings-preview-area .message-wrapper {
            position: relative;
            z-index: 2;
        }
        
        /* 預覽區內使用的頭像要小一點 */
        #settings-preview-area .message-bubble .avatar {
            width: 30px;
            height: 30px;
        }
        
        #settings-preview-area .message-bubble .timestamp {
            display: none; /* 預覽區不需要顯示時間戳記 */
        }
        
        /* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */
        
        /* ▼▼▼ 請將這段新CSS黏貼到 <style> 的末尾 ▼▼▼ */
        .existing-group-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background-color: #f9f9f9;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }
        
        .existing-group-item .group-name {
            font-weight: 500;
        }
        
        .existing-group-item .delete-group-btn {
            color: #ff3b30;
            font-size: 20px;
            cursor: pointer;
            padding: 5px;
        }
        /* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */
        
        /* ▼▼▼ 請將這段新CSS黏貼到 <style> 的末尾 ▼▼▼ */
        .chat-group-container {
            border-bottom: 1px solid var(--border-color);
        }
        .chat-group-container:first-child {
            border-top: 1px solid var(--border-color);
        }
        
        .chat-group-header {
            display: flex;
            align-items: center;
            padding: 12px 15px;
            cursor: pointer;
            background-color: #f7f7f7;
        }
        
        .chat-group-header .arrow {
            font-size: 14px;
            margin-right: 8px;
            transition: transform 0.2s ease;
        }
        
        .chat-group-header.collapsed .arrow {
            transform: rotate(-90deg);
        }
        
        .chat-group-header .group-name {
            font-weight: 600;
            font-size: 15px;
        }
        
        .chat-group-content {
            max-height: 1000px; /* 一個足夠大的值 */
            overflow: hidden;
            transition: max-height 0.3s ease-in-out;
        }
        
        .chat-group-content.collapsed {
            max-height: 0;
        }
        /* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */
        
        /* ▼▼▼ 請將這段新CSS黏貼到 <style> 的末尾 ▼▼▼ */
        
        /* 格式助手按鈕的容器 */
        .format-helpers {
            display: flex;
            gap: 10px;
            margin-bottom: 15px; /* 與下方的文字方塊拉開距離 */
            flex-wrap: wrap; /* 如果按鈕太多可以換行 */
        }
        
        /* 單個格式助手按鈕的樣式 */
        .format-btn {
            background-color: #e9ecef;
            color: var(--text-primary);
            border: none;
            padding: 6px 12px;
            border-radius: 16px; /* 膠囊形狀，更友好 */
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .format-btn:hover {
            background-color: #dcdfe3;
        }
        
        /* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */
        
        /* ▼▼▼ 請將這段新CSS黏貼到 <style> 的末尾 ▼▼▼ */
        
        /* “…”按鈕的樣式 */
        .post-actions-btn {
            margin-left: auto; /* 關鍵：讓它自動靠到最右邊 */
            padding: 5px 10px;
            font-size: 20px;
            font-weight: bold;
            color: var(--text-secondary);
            cursor: pointer;
            border-radius: 50%;
            line-height: 1;
        }
        .post-actions-btn:hover {
            background-color: #f0f0f0;
        }
        
        /* 動態編輯模態框的樣式 (它將複用現有的操作功能表樣式) */
        #post-actions-modal .custom-modal-footer button {
            width: 100%;
            border: none;
            border-bottom: 1px solid #dbdbdb;
            padding: 14px;
            font-size: 18px;
        }
        #post-actions-modal .custom-modal-footer button:last-child {
            border-bottom: none;
        }
        #post-actions-modal #cancel-post-action-btn {
            margin-top: 8px;
            border-radius: 8px;
            background-color: #f0f0f0;
        }
        
        /* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */
        
        /* 統一重置轉帳卡片內所有文字的特效和顏色 */
        #chat-messages .transfer-card .transfer-title,
        #chat-messages .transfer-card .transfer-amount,
        #chat-messages .transfer-card .transfer-note {
            text-shadow: none !important; /* 強制移除任何發光或陰影效果 */
            color: white !important;      /* 強制鎖定文字顏色為白色 */
        }
        
        /* 分別鎖定各自的字體大小和字重，防止被篡改 */
        #chat-messages .transfer-card .transfer-title {
            font-size: 16px !important;
            font-weight: 600 !important;
        }
        
        #chat-messages .transfer-card .transfer-amount {
            font-size: 28px !important;
            font-weight: bold !important;
        }
        
        #chat-messages .transfer-card .transfer-note {
            font-size: 13px !important;
            opacity: 0.9 !important;
        }
        
        /* ▼▼▼ 這是新增的樣式，用於修正所有頭部標題的居中問題 ▼▼▼ */
        .header > span:nth-child(2),
        #chat-header-title {
            position: absolute;
            left: 50%;
            transform: translateX(calc(-50% - 2px)); /* 在-50%的基礎上，再向左推2圖元 */
            
            /* (可選但推薦) 防止長標題與兩邊按鈕重疊 */
            max-width: 60%;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        /* ▲▲▲ 黏貼結束 ▲▲▲ */
        
        /* ▼▼▼ 【全新】視覺化消息編輯器樣式 ▼▼▼ */
        #message-editor-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .message-editor-block {
            background-color: #f9f9f9;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px;
        }
        
        .message-editor-block textarea {
            width: 100%;
            min-height: 60px;
            resize: vertical;
            border: 1px solid #ccc;
            border-radius: 6px;
            padding: 8px;
            font-size: 16px;
            box-sizing: border-box;
        }
        
        .message-editor-block .format-helpers {
            margin-top: 8px;
            margin-bottom: 0; /* 覆蓋默認的 margin-bottom */
        }
        
        .message-editor-block .delete-block-btn {
            float: right;
            margin-top: -5px;
            background: none;
            border: none;
            color: #ff3b30;
            font-size: 20px;
            cursor: pointer;
        }
        /* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */
        
        /* ▼▼▼ 【全新】連絡人選擇器樣式 ▼▼▼ */
        .contact-picker-item {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            cursor: pointer;
            border-bottom: 1px solid var(--border-color);
        }
        .contact-picker-item .checkbox {
            width: 20px;
            height: 20px;
            border: 2px solid #ccc;
            border-radius: 50%;
            margin-right: 15px;
            transition: all 0.2s ease;
        }
        .contact-picker-item.selected .checkbox {
            background-color: var(--accent-color);
            border-color: var(--accent-color);
            content: '✔';
            color: white;
            font-size: 14px;
            text-align: center;
            line-height: 20px;
        }
        .contact-picker-item .avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            margin-right: 12px;
        }
        .contact-picker-item .name {
            font-weight: 500;
        }
        /* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */
        
        /* ▼▼▼ 【全新】群成員管理介面樣式 ▼▼▼ */
        #member-management-list {
            padding: 0; /* 移除默認padding，讓列表項撐滿 */
        }
        
        .member-management-item {
            display: flex;
            align-items: center;
            padding: 12px 15px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .member-management-item .avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            margin-right: 12px;
        }
        
        .member-management-item .name {
            flex-grow: 1;
            font-weight: 500;
        }
        
        .member-management-item .remove-member-btn {
            background-color: #ff3b30;
            color: white;
            border: none;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            font-size: 20px;
            line-height: 28px;
            text-align: center;
            cursor: pointer;
            flex-shrink: 0;
        }
        
        #member-management-actions {
            flex-shrink: 0;
            padding: 15px;
            border-top: 1px solid var(--border-color);
            background-color: #f7f7f7;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        #member-management-actions button {
            width: 100%;
            padding: 15px;
            background-color: var(--accent-color);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
        }
        #member-management-actions #create-new-member-btn {
            background-color: #4cd964; /* 新建用綠色，以示區分 */
        }
        /* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */
        
        /* ▼▼▼ 【全新】外賣代付卡片樣式 ▼▼▼ */
        
        
        .waimai-card {
            width: 240px;
            border-radius: 12px;
            overflow: hidden;
            background-color: #fff;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        }
        
        .waimai-header {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            border-bottom: 1px solid #f0f0f0;
        }
        
        .waimai-header .icon {
            width: 20px;
            height: 20px;
        }
        
        .waimai-header .title-group {
            display: flex;
            align-items: baseline;
            font-size: 14px;
            color: #8a8a8a;
        }
        .waimai-header .title-group .brand {
            font-weight: 600;
            color: #555;
            margin-right: 5px;
        }
        .waimai-header .title-group .separator {
            margin: 0 5px;
        }
        
        .waimai-catchphrase {
            font-size: 13px;
            color: #1f1f1f;
            padding: 12px;
        }
        
        .waimai-main {
            background-color: #FFD66B; /* 橙黃色背景 */
            padding: 12px;
            text-align: center;
        }
        
        .waimai-main .request-title {
            font-size: 12px;
            color: #856404;
            margin-bottom: 8px;
        }
        
        .waimai-main .payment-box {
            background-color: #fff;
            border-radius: 8px;
            padding: 15px 10px;
        }
        
        .waimai-main .payment-label {
            font-size: 13px;
            color: #8a8a8a;
        }
        
        .waimai-main .amount {
            font-size: 32px;
            font-weight: 700;
            color: #1f1f1f;
            margin: 4px 0 12px 0;
        }
        
        .waimai-main .countdown-label {
            font-size: 13px;
            color: #8a8a8a;
        }
        .waimai-main .countdown-timer {
            display: inline-flex;
            align-items: center;
            gap: 2px;
            margin-left: 5px;
        }
        .waimai-main .countdown-timer span {
            background-color: #333;
            color: white;
            padding: 2px 4px;
            border-radius: 2px;
            font-weight: bold;
            font-size: 12px;
        }
        
        .waimai-details-btn {
            width: 100%;
            padding: 10px 0;
            margin-top: 15px;
            border: none;
            border-radius: 6px;
            background-color: #FFC33A;
            color: #49380a;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
        }
        /* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */
        
        /* ▼▼▼ 【全新】外賣回應狀態樣式 ▼▼▼ */
        
        /* === 同意支付後的樣式 === */
        .message-bubble.status-paid .waimai-card {
            border: 2px solid #28a745; /* 綠色邊框 */
        }
        .message-bubble.status-paid .waimai-main .request-title::before {
            content: '✅  ';
        }
        .message-bubble.status-paid .waimai-main .request-title {
            color: #155724;
            font-weight: 600;
            /* 重寫 request-title 的內容 */
            content: "我已為您買單，請盡情享用吧～" !important;
            display: block;
            margin-bottom: 15px;
        }
        
        .message-bubble.status-paid .payment-box {
            display: none; /* 隱藏支付詳情 */
        }
        .message-bubble.status-paid .waimai-details-btn {
            background-color: #28a745;
            color: white;
        }
        
        /* === 拒絕支付後的樣式 === */
        .message-bubble.status-rejected .waimai-card {
            border: 2px solid #dc3545; /* 紅色邊框 */
            opacity: 0.8;
        }
        .message-bubble.status-rejected .waimai-main {
            background-color: #e9ecef;
        }
        .message-bubble.status-rejected .waimai-main .request-title::before {
            content: '❌ ';
        }
        .message-bubble.status-rejected .waimai-main .request-title {
            color: #721c24;
            font-weight: 600;
            /* 重寫 request-title 的內容 */
            content: "我拒絕了您的代付請求" !important;
            display: block;
            margin-bottom: 15px;
        }
        .message-bubble.status-rejected .payment-box {
            display: none; /* 隱藏支付詳情 */
        }
         .message-bubble.status-rejected .waimai-details-btn {
            background-color: #6c757d;
            color: white;
        }
        
        /* 強制重寫 request-title 內容的技巧 */
        .message-bubble[class*="status-"] .request-title {
            font-size: 0; /* 隱藏原始文本 */
        }
        .message-bubble[class*="status-"] .request-title::after {
            font-size: 14px; /* 讓偽元素顯示新文本 */
        }
        .message-bubble.status-paid .request-title::after {
            content: "我已為您買單，請盡情享用吧～";
        }
        .message-bubble.status-rejected .request-title::after {
            content: "我拒絕了您的代付請求";
        }
        /* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */
        
        /* ▼▼▼ 【全新】外賣請求的使用者操作按鈕樣式 ▼▼▼ */
        .waimai-user-actions {
            display: flex;
            gap: 10px;
            padding: 0 12px 12px 12px; /* 在卡片底部留出空間 */
            background-color: #fff;
        }
        
        .waimai-user-actions button {
            flex: 1;
            padding: 10px;
            border-radius: 8px;
            border: 1.5px solid;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .waimai-pay-btn {
            background-color: #28a745;
            border-color: #1f7a33;
            color: white;
        }
        .waimai-pay-btn:hover {
            background-color: #218838;
        }
        
        .waimai-decline-btn {
            background-color: #f8f9fa;
            border-color: #ced4da;
            color: #495057;
        }
        .waimai-decline-btn:hover {
            background-color: #e2e6ea;
        }
        /* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */
        
        /* === 【新增】統一設置頁面的背景色 (已修正) === */
        #api-settings-screen,
        #font-settings-screen,
        #wallpaper-screen,
        #memories-view,
        #contact-picker-screen,
        #member-management-screen,
        #world-book-editor-screen {  
            background-color: var(--secondary-bg);
        }
        
        /* 確保這些頁面的內容區能正確滾動 */
        #api-settings-screen .form-container,
        #font-settings-screen .form-container,
        #wallpaper-screen .form-container {
            padding-top: 100px;
            margin-top: -80px;
            background-color: var(--secondary-bg);
        }
        
        /* 壁紙設置頁面的預覽區比較特殊，需要額外調整 */
        #wallpaper-screen .form-container {
            align-items: center; /* 保持內容居中 */
        }
        
        /* ▼▼▼ 【全新】來電請求與視頻通話介面樣式 ▼▼▼ */
        
        /* --- 來電請求模態框 --- */
        #incoming-call-modal .incoming-call-content {
            background-color: rgba(40, 40, 40, 0.85);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 20px;
            width: 280px;
            padding: 30px 20px;
            text-align: center;
            color: white;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        
        .caller-avatar {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            object-fit: cover;
            margin-bottom: 12px;
            border: 3px solid rgba(255,255,255,0.5);
        }
        
        .caller-name {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 5px;
        }
        
        .caller-text {
            font-size: 14px;
            color: #ccc;
            margin-bottom: 30px;
        }
        
        .incoming-call-actions {
            display: flex;
            justify-content: space-around;
            align-items: center;
        }
        
        .action-button-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            color: #e0e0e0;
        }
        
        .call-action-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            background-size: 50%;
            background-repeat: no-repeat;
            background-position: center;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }
        .call-action-btn:active {
            transform: scale(0.9);
        }
        
        .call-action-btn.decline {
            background-color: #ff3b30;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13.5 16.5L3 6m18 6l-5.6-5.6a1.2 1.2 0 0 0-1.7 0L3 18.2a1.2 1.2 0 0 0-.3 1.2l1.2 3.6a1.2 1.2 0 0 0 1.2.9h15.6a1.2 1.2 0 0 0 1.2-1.2V7.7a1.2 1.2 0 0 0-.3-1.1z"/></svg>');
        }
        
        .call-action-btn.accept {
            background-color: #4cd964;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"/></svg>');
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(76, 217, 100, 0.7); }
            70% { box-shadow: 0 0 0 15px rgba(76, 217, 100, 0); }
            100% { box-shadow: 0 0 0 0 rgba(76, 217, 100, 0); }
        }
        
        /* --- 視頻通話介面 --- */
        /* ▼▼▼ 請用這一整塊【最終修正版】的代碼，替換所有舊的 video-call 相關CSS ▼▼▼ */
        
        /* 1. 通話螢幕總容器 (保持不變) */
        #video-call-screen {
            background-color: #1c1c1e;
            color: white;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        /* 2. 頂部欄和底部控制欄 (保持不變) */
        .video-call-top-bar {
            position: absolute;
            top: 0; left: 0; width: 100%;
            padding: 15px 20px;
            padding-top: 50px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.5), transparent);
            z-index: 10;
            text-align: center;
            box-sizing: border-box;
            pointer-events: none;
        }
        #call-timer {
            font-size: 16px;
            font-weight: 500;
            letter-spacing: 1px;
        }
        .video-call-controls {
            position: absolute;
            bottom: 0; left: 0; width: 100%;
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 20px;
            padding-bottom: 40px;
            background: linear-gradient(to top, rgba(0,0,0,0.5), transparent);
            z-index: 10;
            box-sizing: border-box;
        }
        
        /* 3. 參與者頭像顯示區 (保持不變) */
        .video-call-avatar-area {
            flex-grow: 1; 
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            padding-top: 80px; /* 確保頂部有足夠空間 */
            box-sizing: border-box;
            overflow-y: auto; /* ★ 新增：如果頭像太多，允許此區域滾動 */
        }
        
        /* 4. 頭像網格容器 (保持不變) */
        #participant-avatars-grid {
            display: flex;
            flex-wrap: wrap; 
            justify-content: center;
            align-items: center;
            gap: 15px; /* ★ 稍微減小頭像間距 */
            max-width: 100%;
        }
        
        /* 5. 單個參與者的頭像容器 (頭像縮小) */
        .participant-avatar-wrapper {
            position: relative;
            text-align: center;
            flex-shrink: 0;
        }
        .participant-avatar {
            width: 70px;   /* ★ 從 80px 縮小到 70px */
            height: 70px;  /* ★ 從 80px 縮小到 70px */
            border-radius: 50%;
            object-fit: cover;
            border: 3px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
        }
        .participant-name {
            margin-top: 8px;
            font-size: 12px;
            color: #ccc;
        }
        
        /* 6. 發言者頭像高亮效果 (保持不變) */
        .participant-avatar.speaking {
            border-color: #4cd964;
            box-shadow: 0 0 20px rgba(76, 217, 100, 0.6);
            transform: scale(1.05);
        }
        
        /* 7. 【最終版】對話方塊區域 */
        #video-call-main {
            flex-shrink: 0; 
            height: 30%;   /* ★ 核心修改：高度從35%減小到30% */
            margin: 15px 15px 130px 15px; /* ★ 核心修改：底部邊距從120px增加到130px，創造明顯空隙 */
            overflow-y: auto;
            padding: 15px;
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            box-sizing: border-box;
        }
        
        /* 8. 控制按鈕樣式 (保持不變) */
        .control-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            background-repeat: no-repeat;
            background-position: center;
            transition: transform 0.2s, background-color 0.2s;
        }
        .control-btn:active {
            transform: scale(0.9);
        }
        .control-btn.speak-btn {
            background-color: rgba(255,255,255,0.2);
            background-size: 55%;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg>');
        }
        .control-btn.hangup-btn {
            background-color: #ff3b30;
            background-size: 50%;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13.5 16.5L3 6m18 6l-5.6-5.6a1.2 1.2 0 0 0-1.7 0L3 18.2a1.2 1.2 0 0 0-.3 1.2l1.2 3.6a1.2 1.2 0 0 0 1.2.9h15.6a1.2 1.2 0 0 0 1.2-1.2V7.7a1.2 1.2 0 0 0-.3-1.1z"/></svg>');
        }
        .control-btn.join-btn {
            background-color: #007bff;
            background-size: 50%;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="20" y1="8" x2="20" y2="14"></line><line x1="17" y1="11" x2="23" y2="11"></line></svg>');
        }
        
        /* ▲▲▲ 新CSS替換結束 ▲▲▲ */
        
        /* ▼▼▼ 【全新】視頻通話對話氣泡樣式 ▼▼▼ */
        .call-message-bubble {
            padding: 10px 15px;
            border-radius: 12px;
            max-width: 85%;
            line-height: 1.6;
            word-break: break-word;
            white-space: pre-wrap;
        }
        
        .call-message-bubble.ai-speech {
            background-color: rgba(255, 255, 255, 0.15);
            align-self: flex-start; /* AI發言靠左 */
        }
        
        .call-message-bubble.user-speech {
            background-color: #4cd964; /* 用戶發言用綠色，類似微信 */
            align-self: flex-end;   /* 用戶發言靠右 */
            text-align: left; /* 確保使用者氣泡內的文字是左對齊的 */
        }
        /* ▲▲▲ 新增CSS結束 ▲▲▲ */
        
        /* ▼▼▼ 【全新添加】正在呼叫介面樣式 ▼▼▼ */
        #outgoing-call-screen {
            background-color: #1c1c1e;
            color: white;
            justify-content: center; /* 垂直居中 */
            align-items: center;   /* 水準居中 */
        }
        
        .outgoing-call-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }
        
        .outgoing-call-actions {
            margin-top: 50px; /* 和上方文字拉開距離 */
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            color: #e0e0e0;
        }
        /* ▲▲▲ 添加結束 ▲▲▲ */
        
        /* 1. 動態帖子的外層容器，我們需要它來定位和裁剪 */
        .qzone-post-container {
            position: relative; /* 讓內部的刪除按鈕可以相對於它定位 */
            overflow: hidden;   /* 隱藏掉超出部分的刪除按鈕 */
            border-radius: 12px;/* 和內部卡片保持一致的圓角 */
        }
        
        /* 2. 可滑動的內容卡片，增加一個平滑的過渡效果 */
        .qzone-post-item {
            transition: transform 0.3s ease;
            background-color: var(--secondary-bg); /* 確保它有背景色，能蓋住下面的刪除按鈕 */
            position: relative; /* 確保它在最上層 */
            z-index: 2;
        }
        
        /* 3. 【核心】這就是那個“刪除”按鈕的樣式！*/
        .qzone-post-delete-action {
            position: absolute; /* 絕對定位，脫離文檔流 */
            top: 0;
            right: 0;
            bottom: 0;
            width: 90px; /* 刪除按鈕的寬度 */
            background-color: #ff3b30; /* 您想要的紅色背景 */
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 500;
            cursor: pointer;
            z-index: 1; /* 確保它在卡片下面 */
        }
        
        /* 4. 當卡片左滑時，把它向左移動，露出刪除按鈕 */
        .qzone-post-item.swiped {
            transform: translateX(-90px); /* 移動的距離和刪除按鈕的寬度一致 */
        }
        
        /* ▲▲▲ 黏貼結束 ▲▲▲ */
        
        /* ▼▼▼ 請將這【一整塊】全新的“拍一拍”樣式，黏貼到 <style> 的末尾 ▼▼▼ */
        
        /* 1. “拍一拍”的螢幕震動動畫 */
        @keyframes pat-shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-3px); }
            20%, 40%, 60%, 80% { transform: translateX(3px); }
        }
        
        .pat-animation {
            animation: pat-shake 0.4s ease-in-out;
        }
        
        /* 2. “拍一拍”系統提示消息的樣式 */
        .system-message {
            align-self: center; /* 居中顯示 */
            padding: 4px 12px;
            margin: 5px 0;
            background-color: rgba(0, 0, 0, 0.1);
            color: var(--text-secondary);
            font-size: 12px;
            border-radius: 10px;
            text-align: center;
            max-width: 80%;
        }
        
        /* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */
        
        /* 讓“拍一拍”類型的 wrapper 居中 */
        .message-wrapper.system-pat {
            justify-content: center;
            align-self: center;
            margin: 5px 0;
            max-width: 80%;
        }
        /* “拍一-拍”消息氣泡的樣式 */
        .message-bubble.system-bubble {
            background-color: rgba(0, 0, 0, 0.1);
            color: var(--text-secondary);
            font-size: 12px;
            padding: 4px 12px;
            border-radius: 10px;
        }
        
        /* ▼▼▼ 請將這段新CSS黏貼到 <style> 的末尾 ▼▼▼ */
        
        /* === 修正：讓頂部操作欄可以橫向滾動 === */
        #chat-input-actions-top {
            display: flex;
            gap: 8px;
            padding: 0 5px;
        
            /* --- 核心代碼開始 --- */
            overflow-x: auto;      
            flex-wrap: nowrap;     
            -webkit-overflow-scrolling: touch; 
        
            scrollbar-width: none; 
            -ms-overflow-style: none;  
        }
        
        #chat-input-actions-top::-webkit-scrollbar {
            display: none; 
        }
        
        /* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */
        
        /* === 【全新】聊天介面頭部狀態列樣式 === */
        
        /* 1. 標題和狀態的總容器，使用flex佈局讓它們垂直排列 */
        #chat-header-title-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center; /* 水準居中 */
            gap: 2px; /* 標題和狀態之間的微小間距 */
            
            /* 為了讓它能在flex佈局中正確居中 */
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            max-width: 60%;
        }
        
        /* 2. 主標題的樣式微調 */
        #chat-header-title {
            font-size: 16px; /* 可以稍微縮小一點，給狀態列留出空間 */
            font-weight: 600;
            position: static; /* 覆蓋掉舊的absolute定位 */
            transform: none;  /* 覆蓋掉舊的transform */
            /* 保證長標題也能正確顯示省略號 */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
        }
        
        /* 3. 狀態列容器 */
        #chat-header-status {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 11px;
            color: var(--text-secondary);
            transition: all 0.3s ease;
        }
        
        /* 4. 狀態小圓點 */
        .status-dot {
            width: 7px;
            height: 7px;
            border-radius: 50%;
            background-color: #4cd964; /* 默認綠色，代表線上 */
            transition: background-color 0.3s ease;
        }
        
        /* 當AI狀態為“忙碌”或“離開”時，讓圓點變灰色 */
        #chat-header-status.busy .status-dot {
            background-color: #cccccc;
        }
        
        /* 5. 狀態文本 */
        .status-text {
            font-weight: 500;
        }
        
        /* === 【全新美化版】回憶卡片樣式 === */
        
        /* 1. 卡片總容器：這裡負責定義整體的背景色和邊框 */
        .memory-card {
            background-color: #fffaf0; /* 統一的、溫暖的米黃色背景 */
            border-radius: 12px;
            padding: 15px; /* 在卡片四周留出內邊距 */
            box-shadow: 0 2px 6px rgba(0,0,0,0.07);
            border-left: 5px solid #ffb74d; 
            display: flex; /* 讓它成為flex容器，方便內部元素排列 */
            flex-direction: column; /* 讓頭部和內容垂直堆疊 */
            gap: 8px; /* 在頭部和內容之間創造一個自然的間距 */
        }
        
        /* 2. 頭部容器：現在只負責佈局和分割線 */
        .memory-card .header {
            border-bottom: 1px solid rgba(217, 129, 0, 0.15); /* 分割線顏色可以稍微加深一點 */
            padding-bottom: 8px; 
        }
        
        /* 3. 日期樣式 (保持不變) */
        .memory-card .header .date {
            font-size: 11px;
            color: #a1887f;
            margin-bottom: 4px; 
        }
        
        /* 4. 作者樣式 (保持不變) */
        .memory-card .header .author {
            font-weight: 600;
            color: #d98100;
            font-size: 15px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        /* 5. 內容區樣式 (保持不變) */
        .memory-card .content {
            font-size: 14px;
            line-height: 1.7;
            color: #5d4037;
            white-space: pre-wrap;
        }
        
        /* === 【全新】約定/倒計時卡片樣式 === */
        .countdown-card {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 15px rgba(118, 75, 162, 0.4);
            text-align: center;
            position: relative;
            overflow: hidden;
            flex-shrink: 0;
        }
        .countdown-card::before {
            content: '✨';
            position: absolute;
            top: -10px;
            left: -10px;
            font-size: 50px;
            opacity: 0.1;
            transform: rotate(-15deg);
        }
        .countdown-card .title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 15px;
        }
        .countdown-card .timer {
            font-size: 28px;
            font-weight: 300;
            letter-spacing: 2px;
            margin-bottom: 15px;
        }
        .countdown-card .target-date {
            font-size: 12px;
            opacity: 0.8;
            border-top: 1px solid rgba(255,255,255,0.2);
            padding-top: 10px;
        }
        
        /* === 【全新】聊天鎖定遮罩層樣式 === */
        #chat-lock-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: rgba(247, 247, 247, 0.9);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            z-index: 150; /* 比輸入框高，比貼紙面板低 */
            display: none; /* 默認隱藏 */
            align-items: center;
            justify-content: center;
            padding: 20px;
            box-sizing: border-box;
            border-top: 1px solid var(--border-color);
            text-align: center;
        }
        #chat-lock-content {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        #chat-lock-content .lock-text {
            color: var(--text-secondary);
            font-size: 14px;
        }
        #chat-lock-content .lock-action-btn {
            padding: 10px 20px;
            border-radius: 20px;
            border: 1px solid var(--accent-color);
            background-color: var(--accent-color);
            color: white;
            cursor: pointer;
        }
        #chat-lock-content .lock-action-btn.secondary {
            background-color: transparent;
            color: var(--accent-color);
        }
        
        /* ▼▼▼ 【全新】紅包卡片樣式 ▼▼▼ */
        
        
        .red-packet-card {
            width: 220px;
            border-radius: 8px;
            background: linear-gradient(160deg, #F96259, #E44D44);
            color: #ffd700; /* 金色文字 */
            padding: 12px;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            position: relative;
            overflow: hidden;
        }
        
        .red-packet-card.opened {
            background: linear-gradient(160deg, #d3c4a0, #c4b693);
            cursor: default;
        }
        
        .red-packet-card::before {
            content: '🧧';
            position: absolute;
            top: -5px;
            left: -5px;
            font-size: 30px;
            opacity: 0.2;
            transform: rotate(-10deg);
        }
        
        .rp-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        
        .rp-icon {
            width: 20px;
            height: 20px;
        }
        
        .rp-greeting {
            font-size: 15px;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .rp-type {
            font-size: 11px;
            color: white;
            opacity: 0.8;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            padding-top: 8px;
            margin-top: 8px;
        }
        
        .rp-claimed-info {
            font-size: 13px;
            color: white;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(255,255,255,0.3);
        }
        /* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */
        
        /* ▼▼▼ 【全新】紅包詳情清單樣式 ▼▼▼ */
        .rp-details-item {
            display: flex;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #eee;
        }
        .rp-details-item:last-child {
            border-bottom: none;
        }
        .rp-details-item .name {
            flex-grow: 1;
            font-weight: 500;
            color: #333;
        }
        .rp-details-item .amount {
            font-weight: 500;
            color: #555;
        }
        .rp-details-item .lucky-king-tag {
            font-size: 10px;
            background-color: #ffd700;
            color: #a67c00;
            padding: 2px 5px;
            border-radius: 4px;
            margin-left: 8px;
            font-weight: bold;
        }
        /* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */
        
        /* ▼▼▼ 【全新】投票功能樣式 ▼▼▼ */
        
        /* 投票卡片在消息氣泡中的樣式 */
        
        /* 投票卡片主體 */
        .poll-card {
            width: 250px;
            background-color: #f9f9f9;
            border-radius: 10px;
            border: 1px solid #e0e0e0;
            padding: 12px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }
        
        .poll-card.closed {
            background-color: #e9ecef; /* 結束後變灰 */
        }
        
        /* 投票問題 */
        .poll-question {
            font-weight: 600;
            font-size: 15px;
            margin-bottom: 12px;
            line-height: 1.4;
            word-break: break-word;
        }
        
        /* 投票選項清單 */
        .poll-options-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        /* 單個投票選項 */
        .poll-option-item {
            background-color: white;
            border: 1px solid #dcdcdc;
            border-radius: 8px;
            padding: 10px;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            transition: background-color 0.2s;
        }
        
        .poll-card:not(.closed) .poll-option-item:hover {
            background-color: #f0f8ff;
        }
        
        /* 使用者已投票的選項樣式 */
        .poll-option-item.voted {
            border-color: var(--accent-color);
            background-color: #e7f3ff;
            font-weight: 500;
        }
        
        /* 投票進度條 */
        .poll-option-bar {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background-color: rgba(0, 123, 255, 0.1);
            z-index: 1;
            transition: width 0.3s ease-in-out;
        }
        
        /* 選項內容（文字和票數），確保在進度條之上 */
        .poll-option-content {
            position: relative;
            z-index: 2;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .poll-option-text {
            font-size: 14px;
        }
        
        .poll-option-votes {
            font-size: 13px;
            color: #8a8a8a;
            font-weight: 500;
        }
        
        /* 投票卡片底部 */
        .poll-footer {
            margin-top: 12px;
            padding-top: 8px;
            border-top: 1px solid #e9e9e9;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            color: var(--text-secondary);
        }
        
        .poll-total-votes {
            font-weight: 500;
        }
        
        .poll-action-btn {
            background: none;
            border: 1px solid var(--accent-color);
            color: var(--accent-color);
            padding: 4px 10px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 12px;
        }
        .poll-card.closed .poll-action-btn {
            background-color: #6c757d;
            color: white;
            border-color: #6c757d;
        }
        
        /* 創建投票模態框的選項輸入 */
        .poll-option-input-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .poll-option-input-wrapper input {
            flex-grow: 1;
        }
        .poll-option-input-wrapper .remove-option-btn {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background-color: #f0f0f0;
            color: #ff3b30;
            border: none;
            cursor: pointer;
            font-size: 18px;
            line-height: 28px;
            text-align: center;
            flex-shrink: 0;
        }
        
        /* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */
        
        /* === 【全新】聊天頭部“正在輸入”狀態樣式 === */
        #chat-header-title.typing-status {
            color: var(--text-secondary);
            animation: typing-pulse 1.5s infinite;
            font-style: italic;
        }
        
        @keyframes typing-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        #chat-header-title {
            transition: opacity 0.2s ease-in-out;
        }
        
        @keyframes message-pop-in {
          from {
            opacity: 0;
            transform: translateY(15px);
          }
          to {
            opacity: 1;
            transform: translateY(0);
          }
        }
        
        .message-wrapper.animate-in {
          animation: message-pop-in 0.3s cubic-bezier(0.25, 0.1, 0.25, 1) forwards;
          }
        
        /* ▼▼▼ 【全新】App圖示設置樣式 ▼▼▼ */
#icon-settings-grid,
#cphone-icon-settings-grid { /* <--- 核心修復：在這裡為兩個容器同時應用樣式 */
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
    gap: 20px;
    width: 100%;
    padding: 0 10px;
    box-sizing: border-box;
}
        
        .icon-setting-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }
        
        .icon-preview {
            width: 60px;
            height: 60px;
            border-radius: 15px;
            background-size: cover;
            background-position: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .change-icon-btn {
            padding: 4px 10px;
            font-size: 12px;
            border: 1px solid #ccc;
            background-color: #f0f0f0;
            border-radius: 5px;
            cursor: pointer;
        }
        /* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */
        
        /* ▼▼▼ 【全新】外觀設置頁面配置修正 ▼▼▼ */
        
        /* 1. 修正滾動問題 */
        #wallpaper-screen .form-container {
            /* 核心修正1: 解決flex佈局下的滾動衝突，讓捲軸能正常出現 */
            min-height: 0; 
        }
        
        /* 2. 修正壁紙預覽被壓扁的問題 */
        #wallpaper-preview {
            /* 核心修正2: 防止預覽框被過多的內容擠壓變形，讓它保持自己的高度 */
            flex-shrink: 0; 
        }
        /* ▲▲▲ 修正結束 ▲▲▲ */
        
        /* ▼▼▼ 【全新】分享連結功能樣式 (無圖版) ▼▼▼ */
        
        /* 1. 流覽器介面背景色和內容區樣式 (保持不變) */
        #browser-screen {
            background-color: #f8f9fa;
        }
        #browser-content {
            padding: 20px;
            font-size: 16px;
            line-height: 1.8;
            color: #333;
            overflow-y: auto;
            background-color: #f8f9fa;
        }
        #browser-content .article-title {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 10px;
        }
        #browser-content .article-meta {
            font-size: 13px;
            color: #8a8a8a;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 1px solid #e0e0e0;
        }
        #browser-content .article-body {
            white-space: pre-wrap;
            word-break: break-word;
        }
        #browser-content .article-body p {
            margin-bottom: 1em;
        }
        
        /* 2. 聊天氣泡中的連結卡片樣式 (無圖版) */
        
        
        .link-share-card {
            width: 210px; 
            background-color: #fff;
            border-radius: 10px;
            border: 1px solid #e0e0e0;
            padding: 12px;
            cursor: pointer;
            transition: background-color 0.2s;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .link-share-card:hover {
            background-color: #f9f9f9;
        }
        
        .link-share-card .title {
            font-weight: 600;
            font-size: 15px;
            line-height: 1.4;
            color: #1f1f1f;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .link-share-card .description {
            font-size: 13px;
            color: #8a8a8a;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .link-share-card .footer {
            display: flex; /* 讓圖示和文字水準對齊 */
            align-items: center;
            gap: 6px; /* 圖示和文字的間距 */
            font-size: 12px;
            color: var(--text-secondary);
            margin-top: 4px; /* 和上面的描述拉開一點距離 */
        }
        .link-share-card .footer-icon{
            width: 14px;
            height: 14px;
            flex-shrink: 0; /* 防止圖示被壓縮 */
        }
        
        /* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */
        
        /* ▼▼▼ 請將這段新樣式黏貼到 <style> 的末尾 ▼▼▼ */
        
        /* 單條評論的容器，現在需要相對定位 */
        .comment-item {
            position: relative;
            padding-right: 25px; /* 在右側留出刪除按鈕的空間 */
        }
        
        /* 評論刪除按鈕的樣式 */
        .comment-delete-btn {
            position: absolute;
            top: 50%;
            right: 0;
            transform: translateY(-50%);
            width: 22px;
            height: 22px;
            line-height: 22px;
            text-align: center;
            border-radius: 50%;
            color: var(--text-secondary);
            font-size: 18px;
            cursor: pointer;
            transition: all 0.2s ease;
            opacity: 0; /* 默認隱藏 */
        }
        
        /* 滑鼠懸停在評論上時，顯示刪除按鈕 */
        .comment-item:hover .comment-delete-btn {
            opacity: 1;
        }
        
        .comment-delete-btn:hover {
            background-color: #f0f0f0;
            color: #ff3b30;
        }
        /* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */
        
        /* ▼▼▼ 把這一整塊全新的CSS，黏貼到 <style> 的末尾 ▼▼▼ */
        
        /* === 【全新】夜間模式樣式 === */
        
        /* 核心：當 #phone-screen 擁有 .dark-mode 類時，啟動以下所有樣式 */
        
        /* 1. 全域背景和文本顏色 */
        #phone-screen.dark-mode {
            --secondary-bg: #1c1c1e; /* 主要卡片背景色 */
            --border-color: #38383a;  /* 邊框顏色 */
            --text-primary: #ffffff;   /* 主要文字顏色 */
            --text-secondary: #8d8d92; /* 次要文字/圖示顏色 */
        }
        
        /* 2. 各個頁面的主背景色 */
        #phone-screen.dark-mode #chat-list-screen,
        #phone-screen.dark-mode #qzone-screen .qzone-content,
        #phone-screen.dark-mode #memories-view {
            background-color: #000000;
        }
        
        /* 3. 聊天列表 */
        #phone-screen.dark-mode #chat-list {
            background-color: #000000;
        }
        #phone-screen.dark-mode .chat-list-item {
            border-bottom-color: rgba(255, 255, 255, 0.15);
        }
        #phone-screen.dark-mode .chat-group-header {
            background-color: #1c1c1e; /* 從白色改為深灰色 */
            border-bottom: 1px solid #38383a; /* 給它一個細微的下邊框 */
        }
        #phone-screen.dark-mode .chat-list-item .name,
        #phone-screen.dark-mode .chat-group-header .group-name {
            color: #ffffff;
        }
        #phone-screen.dark-mode .chat-list-item:hover {
            background-color: #1c1c1e;
        }
        
        /* 4. 頂部/底部巡覽列 */
        #phone-screen.dark-mode .header,
        #phone-screen.dark-mode .qzone-header {
            background-color: rgba(25, 25, 25, 0.9);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border-bottom-color: rgba(255, 255, 255, 0.15);
            color: #ffffff;
        }
        #phone-screen.dark-mode .header .back-btn,
        #phone-screen.dark-mode .header .action-btn,
        #phone-screen.dark-mode .header .save-btn {
            color: #ffffff;
        }
        #phone-screen.dark-mode #chat-list-bottom-nav {
            background-color: rgba(25, 25, 25, 0.9);
            border-top-color: rgba(255, 255, 255, 0.15);
        }
        #phone-screen.dark-mode .nav-item.active {
            color: #ffffff;
        }
        
        /* 5. 聊天介面 */
        #phone-screen.dark-mode #chat-input-area {
            background-color: rgba(5, 5, 5, 0.8);
            border-top: none;
        }
        #phone-screen.dark-mode #chat-input {
            background-color: #3e3e42;
            color: #ffffff;
        }
        #phone-screen.dark-mode #chat-input::placeholder {
            color: #8d8d92;
        }
        #phone-screen.dark-mode .chat-action-icon-btn {
            color: #ffffff;
            background-color: rgba(255, 255, 255, 0.1);
            border: none;
        }
        #phone-screen.dark-mode #send-btn {
            background-color: var(--accent-color);
        }
        
        /* 6. 動態 (QZone) 介面 */
        #phone-screen.dark-mode .qzone-actions-bar,
        #phone-screen.dark-mode .qzone-post-item {
            background-color: #1c1c1e;
            border: 1px solid #333;
            box-shadow: 0 2px 8px rgba(255, 255, 255, 0.05);
        }
        #phone-screen.dark-mode .action-item:not(:last-child)::after {
            background-color: #333;
        }
        #phone-screen.dark-mode .post-footer,
        #phone-screen.dark-mode .post-likes-section {
            border-top-color: #333;
        }
        #phone-screen.dark-mode .post-likes-section {
            background-color: rgba(0, 123, 255, 0.1);
        }
        #phone-screen.dark-mode .comment-input {
            background-color: #333;
            color: #ffffff;
        }
        #phone-screen.dark-mode .comment-input::placeholder {
            color: #8d8d92;
        }
        #phone-screen.dark-mode .post-actions-btn:hover {
            background-color: #333;
        }
        #phone-screen.dark-mode .at-mention-popup {
            background-color: #1c1c1e;
            border-color: #333;
        }
        #phone-screen.dark-mode .at-mention-item {
            border-bottom-color: #333;
        }
        #phone-screen.dark-mode .at-mention-item:hover {
            background-color: #333;
        }
        
        /* 7. 回憶錄介面 */
        #phone-screen.dark-mode .memory-card {
            background-color: #1c1c1e;
            border-left-color: #e6a753;
            box-shadow: 0 4px 12px rgba(255, 255, 255, 0.08);
        }
        #phone-screen.dark-mode .memory-card .header {
            background-color: #2c2c2e;
            border-bottom-color: #38383a;
            margin: -15px -15px 8px -15px;
            padding: 12px 15px;
            border-radius: 12px 12px 0 0;
        }
        #phone-screen.dark-mode .memory-card .header .date,
        #phone-screen.dark-mode .memory-card .header .author,
        #phone-screen.dark-mode .memory-card .content {
            color: #e0e0e0;
        }
        
        /* 8. 其他設置和列表頁 */
        #phone-screen.dark-mode #api-settings-screen,
        #phone-screen.dark-mode #font-settings-screen,
        #phone-screen.dark-mode #wallpaper-screen,
        #phone-screen.dark-mode #contact-picker-screen,
        #phone-screen.dark-mode #member-management-screen,
        #phone-screen.dark-mode #world-book-editor-screen,
        #phone-screen.dark-mode #world-book-list,
        #phone-screen.dark-mode .list-item:hover,
        #phone-screen.dark-mode .list-container,
        #phone-screen.dark-mode .form-container {
            background-color: #000000;
        }
        #phone-screen.dark-mode .form-group input, 
        #phone-screen.dark-mode .form-group select, 
        #phone-screen.dark-mode .form-group textarea {
            background-color: #1c1c1e;
            color: #ffffff;
            border-color: #38383a;
        }
        #phone-screen.dark-mode .form-button-secondary {
            background-color: #333;
            border-color: #555;
            color: #fff;
        }
        #phone-screen.dark-mode #font-preview {
            background-color: #1c1c1e;
            border-color: #38383a;
        }
        #phone-screen.dark-mode #font-preview p {
            color: #ffffff;
        }
        
        /* ▲▲▲ 黏貼結束 ▲▲▲ */
        
        /* ▼▼▼ 把這一整塊【全新的修正CSS】，黏貼到 <style> 的末尾 ▼▼▼ */
        
        /* === 【全新】夜間模式視覺修正 === */
        
        /* 1. 修正動態卡片內的文字顏色 */
        #phone-screen.dark-mode .qzone-post-item .post-nickname,
        #phone-screen.dark-mode .qzone-post-item .post-content {
            color: #f0f0f0; /* 從深灰色改為明亮的淺灰色 */
        }
        
        /* 2. 修正收藏卡片內的文字顏色 */
        #phone-screen.dark-mode .favorite-item-card .fav-card-header .name,
        #phone-screen.dark-mode .favorite-item-card .fav-card-content {
            color: #f0f0f0; /* 同樣改為淺灰色 */
        }
        #phone-screen.dark-mode .favorite-item-card .fav-card-header .source {
            color: #8d8d92; /* 來源文字用次要灰色 */
        }
        
        /* 3. 修正收藏頁的搜索欄背景和輸入框樣式 */
        #phone-screen.dark-mode .search-bar-container {
            background-color: #000000; /* 容器背景變為純黑 */
        }
        #phone-screen.dark-mode #favorites-search-input {
            background-color: #1c1c1e; /* 輸入框背景變為深灰 */
            border-color: #38383a;     /* 邊框顏色變暗 */
            color: #ffffff;            /* 輸入文字變為白色 */
        }
        #phone-screen.dark-mode #favorites-search-input::placeholder {
            color: #8d8d92; /* 預留位置文字顏色變暗 */
        }
        
        /* ▲▲▲ 修正CSS黏貼結束 ▲▲▲ */
        
        /* ▼▼▼ 把這一整塊全新的CSS，黏貼到 <style> 的末尾 ▼▼▼ */
        
        /* === 【全新】iOS風格的Toggle Switch開關樣式 === */
        
        /* 1. 開關的容器 */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 51px;
            height: 31px;
        }
        
        /* 2. 隱藏掉原始的 checkbox 輸入框 */
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        /* 3. 開關的背景（那個橢圓） */
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #e9e9eb; /* 關閉時的背景色 */
            transition: .4s;
            border-radius: 34px;
        }
        
        /* 4. 開關上的圓點 */
        .slider:before {
            position: absolute;
            content: "";
            height: 27px;
            width: 27px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        
        /* 5. 【核心】當 checkbox 被選中時（即開啟狀態） */
        input:checked + .slider {
            background-color: #34c759; /* 開啟時的背景色（iOS綠色）*/
        }
        
        input:checked + .slider:before {
            transform: translateX(20px); /* 讓圓點滑動到右邊 */
        }
        
        /* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */
        
        /* ▼▼▼ 【全新】引用回復功能樣式 ▼▼▼ */
        
        /* ▼▼▼ 【全新】引用回復功能樣式 ▼▼▼ */
        
        /* 1. 輸入框上方的“回復預覽欄” */
        #reply-preview-bar {
            display: none; /* 默認隱藏 */
            padding: 8px 12px;
            margin: 0 8px 8px 8px; /* 和輸入框周圍的邊距保持一致 */
            background-color: rgba(0, 0, 0, 0.05);
            border-left: 3px solid var(--accent-color);
            border-radius: 6px;
            position: relative;
            font-size: 13px;
            color: var(--text-secondary);
        }
        
        #phone-screen.dark-mode #reply-preview-bar {
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        .reply-preview-content .sender {
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .reply-preview-content .text {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            display: block; /* 確保省略號生效 */
            max-width: 95%;
        }
        
        #cancel-reply-btn {
            position: absolute;
            top: 50%;
            right: 8px;
            transform: translateY(-50%);
            width: 20px;
            height: 20px;
            line-height: 20px;
            text-align: center;
            border-radius: 50%;
            background-color: rgba(0,0,0,0.1);
            cursor: pointer;
            font-size: 14px;
        }
        
        /* 2. 消息氣泡內部的“引用消息塊” */
        .quoted-message {
            padding: 6px 10px;
            margin-bottom: 6px;
            background-color: rgba(0, 0, 0, 0.04);
            border-left: 2px solid var(--accent-color);
            border-radius: 4px;
            font-size: 0.9em; /* 字體比正文小一點 */
            opacity: 0.8;
        }
        
        #phone-screen.dark-mode .quoted-message {
            background-color: rgba(255, 255, 255, 0.08);
            border-left-color: #a0cff1;
        }
        
        .quoted-message .quoted-sender {
            font-weight: 600;
            color: var(--accent-color);
        }
        #phone-screen.dark-mode .quoted-message .quoted-sender {
            color: #a0cff1;
        }
        
        .quoted-message .quoted-content {
            color: var(--text-secondary);
            white-space: normal;     /* 核心修正1: 允許文本正常換行 */
            word-break: break-word;  /* 核心修正2: 強制長單詞或連續字元斷開，防止溢出 */
            display: block;
        }
        
        /* === 字體預覽框樣式 (修正後) === */
        
        /* 預設（日間模式）的樣式 */
        #font-preview {
            padding: 20px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background-color: #f9f9f9; /* 日間模式的淺灰色背景 */
            transition: background-color 0.3s, border-color 0.3s;
        }
        
        /* 預覽框裡的文字顏色，預設是黑色 */
        #font-preview p {
            color: var(--text-primary);
        }
        
        /* 夜間模式下的修正樣式 */
        #phone-screen.dark-mode #font-preview {
            background-color: #1c1c1e; /* 深灰色背景 */
            border-color: #38383a;     /* 暗色邊框 */
        }
        
        /* 夜間模式下，預覽框裡的文字變為白色 */
        #phone-screen.dark-mode #font-preview p {
            color: #ffffff;
        }
        
        /* ▼▼▼ 【全新】精緻版轉帳操作彈窗樣式 ▼▼▼ */
        .transfer-actions-content {
            background-color: #fff0f5; /* 粉嫩的背景色 */
            border-radius: 20px;
            width: 290px;
            padding: 20px;
            box-shadow: 0 5px 25px rgba(255, 105, 180, 0.3); /* 粉色陰影 */
            text-align: center;
            position: relative;
            border: 1px solid #ffcce0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }
        
        .transfer-actions-header {
            font-size: 20px;
            font-weight: bold;
            color: #a35c7b; /* 深粉色標題 */
            margin-bottom: 15px;
        }
        
        .transfer-actions-body p {
            font-size: 15px;
            color: #555;
            margin: 0 0 25px 0;
            line-height: 1.5;
        }
        
        .transfer-actions-footer {
            display: flex;
            justify-content: space-between;
            gap: 15px;
        }
        
        .transfer-actions-footer .action-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            color: white;
        }
        
        .transfer-actions-footer .action-btn:active {
            transform: scale(0.95);
        }
        
        .transfer-actions-footer .action-btn.accept {
            background: linear-gradient(135deg, #ff85b3, #ff69b4);
            box-shadow: 0 4px 10px rgba(255, 105, 180, 0.4);
        }
        
        .transfer-actions-footer .action-btn.decline {
            background: linear-gradient(135deg, #c2c2c2, #a0a0a0);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }
        
        .transfer-actions-content .cancel-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: none;
            background-color: rgba(0, 0, 0, 0.1);
            color: #a35c7b;
            font-size: 20px;
            line-height: 28px;
            cursor: pointer;
        }
        /* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */
        
        /* ▼▼▼ 請將這段新樣式黏貼到 <style> 的末尾 ▼▼▼ */
        
        /* === 未讀消息紅點樣式 === */
        .unread-count-wrapper {
            flex-shrink: 0;
            width: 40px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding-top: 20px; /* 讓紅點和名字差不多高 */
        }
        
        .unread-count {
            min-width: 20px;
            height: 20px;
            padding: 0 6px;
            background-color: #ff3b30; /* iOS 風格的紅色 */
            color: white;
            font-size: 13px;
            font-weight: 500;
            line-height: 20px;
            text-align: center;
            border-radius: 10px; /* 圓角矩形 */
            box-shadow: 0 1px 2px rgba(0,0,0,0.15);
            display: none; /* 默認隱藏 */
            justify-content: center;
            align-items: center;
        }
        /* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */
        
        /* ▼▼▼ 【全新】通話記錄頁面與卡片樣式 ▼▼▼ */
        
        /* 確保頁面背景色統一 */
        #call-history-screen {
            background-color: #f0f2f5;
        }
        
        /* 通話記錄卡片樣式 */
        .call-record-card {
            background-color: var(--secondary-bg);
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            border-left: 5px solid var(--accent-color);
        }
        .call-record-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.1);
        }
        
        /* 卡片頭部：包含日期和時長 */
        .call-record-card .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 13px;
            color: var(--text-secondary);
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border-color);
        }
        .call-record-card .card-header .duration {
            font-weight: 500;
            color: var(--text-primary);
        }
        
        /* 卡片主體：參與者頭像 */
        .call-record-card .card-body {
            display: flex;
            align-items: center;
        }
        .call-record-card .participants-avatars {
            display: flex;
            align-items: center;
        }
        .call-record-card .participant-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        /* 讓頭像有一個漂亮的堆疊效果 */
        .call-record-card .participant-avatar:not(:first-child) {
            margin-left: -12px;
        }
        .call-record-card .participants-names {
            margin-left: 12px;
            font-weight: 600;
            color: var(--text-primary);
            font-size: 15px;
        }
        
        /* --- 通話詳情彈窗樣式 --- */
        #transcript-modal-body {
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding: 15px;
        }
        .transcript-entry {
            padding: 8px 12px;
            border-radius: 10px;
            max-width: 85%;
            line-height: 1.5;
            word-break: break-word;
        }
        .transcript-entry.user {
            background-color: #dcf8c6; /* 類似微信的綠色 */
            align-self: flex-end;
        }
        .transcript-entry.assistant {
            background-color: #ffffff;
            align-self: flex-start;
        }
        /* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */
        
        #chat-list-title {
            cursor: pointer;
        }
        
        /* ▼▼▼ 【全新】通話記錄卡片美化樣式 ▼▼▼ */
        
        .call-record-card .card-body {
            /* 將 body 改為 flex 佈局，讓標題和參與者資訊垂直排列 */
            display: flex;
            flex-direction: column;
            gap: 8px; /* 標題和參與者資訊之間的間距 */
        }
        
        .call-record-card .custom-title {
            font-size: 16px;
            font-weight: 600; /* 加粗，讓它像個標題 */
            color: var(--text-primary);
            padding-bottom: 8px; /* 標題下的留白 */
            border-bottom: 1px solid var(--border-color); /* 在標題下加一條分割線 */
            margin-bottom: 4px; /* 和下面的參與者資訊拉開一點距離 */
        }
        
        .call-record-card .participants-info {
            /* 這個新容器讓頭像和“與xx”能水準對齊 */
            display: flex;
            align-items: center;
        }
        
        /* 參與者名字的樣式微調，讓它不那麼突出 */
        .call-record-card .participants-names {
            margin-left: 12px;
            font-weight: 500; /* 不再加粗 */
            font-size: 14px; /* 稍微小一點 */
            color: var(--text-secondary); /* 使用次要文字顏色 */
        }
        
        /* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */
        
        /* ▼▼▼ 【全新】語音轉文字功能樣式 ▼▼▼ */
        
        /* 1. 語音文字內容的樣式 */
        .voice-transcript {
            font-size: 14px;         /* 文字大小 */
            line-height: 1.6;        /* 行高，讓多行文本更易讀 */
            color: var(--text-secondary); /* 使用次要文字顏色，與語音條區分 */
            padding: 8px 12px;       /* 內邊距 */
            margin-top: 6px;         /* 和上方的語音條拉開一點距離 */
            background-color: rgba(0, 0, 0, 0.04); /* 給一個淡淡的背景，更有層次感 */
            border-radius: 6px;      /* 圓角 */
            word-break: break-word;  /* 確保長文本能正常換行 */
            display: none;           /* 默認隱藏 */
        }
        
        #phone-screen.dark-mode .voice-transcript {
            background-color: rgba(255, 255, 255, 0.1); /* 夜間模式下的背景色 */
        }
        
        /* 2. 旋轉載入動畫的樣式 */
        .loading-spinner {
            display: none; /* 默認隱藏 */
            width: 16px;
            height: 16px;
            border: 2px solid rgba(0, 0, 0, 0.2);
            border-top-color: var(--accent-color); /* 旋轉部分的顏色 */
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 8px; /* 和波形圖、時長保持一點間距 */
        }
        
        /* 3. 定義旋轉動畫 */
        @keyframes spin {
            to {
        transform: rotate(360deg);
            }
        }
        /* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */
        
        /* ▼▼▼ 【全新】分享記錄檢視器樣式修正 ▼▼▼ */
        #shared-history-viewer-content {
            display: flex;
            flex-direction: column; /* 讓氣泡垂直排列 */
            gap: 20px; /* 在每個氣泡之間增加20圖元的間距 */
            padding: 15px; /* 在容器四周也增加一些內邊距，避免氣泡貼邊 */
        }
        /* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */
        
        /* ▼▼▼ 【全新】播放機和歌詞樣式 ▼▼▼ */
        #music-player-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 50;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding-top: 60px;
            background-color: rgba(0,0,0,0.3);
            opacity: 0;
            visibility: hidden;
            transform: translateY(-50px);
            transition: opacity 0.4s ease-out, transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        #music-player-overlay.visible {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }
        
        .music-player-window { 
            width: 70%; 
            min-height: 420px;
            background-color: rgba(255, 255, 255, 0.6); 
            backdrop-filter: blur(20px); 
            -webkit-backdrop-filter: blur(20px); 
            border-radius: 25px; 
            box-shadow: 0 8px 32px 0 rgba(25, 25, 25, 0.37); 
            border: 1px solid rgba(255, 255, 255, 0.18); 
            padding: 25px; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            color: #1f1f1f; 
            position: relative;
            justify-content: space-between;
            padding-bottom: 15px;
        }
        
        .music-player-top-actions {
            position: absolute;
            top: 15px;
            left: 15px;
            right: 15px;
            width: calc(100% - 30px);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .top-left-cluster {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        #music-return-btn, #music-exit-btn {
            background: none;
            border: none;
            font-size: 28px;
            font-weight: 300;
            cursor: pointer;
            color: #555;
            padding: 5px;
            line-height: 1;
        }
        #music-exit-btn {
            font-size: 24px;
            font-weight: 400;
        }
        
        .music-progress-bar-container {
            width: 100%;
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 25px;
            margin-bottom: 10px;
        }
        .time-display {
            font-size: 11px;
            color: #888;
            width: 35px;
            text-align: center;
            flex-shrink: 0;
            font-family: 'SF Mono', 'Menlo', monospace;
        }
        .progress-bar {
            flex-grow: 1;
            height: 5px;
            background-color: #e5e5e5;
            border-radius: 2.5px;
            cursor: pointer;
        }
        .progress-bar-fill {
            width: 0%;
            height: 100%;
            background-color: #333;
            border-radius: 2.5px;
        }
        
        #music-lyrics-container {
            width: 100%;
            height: 192px;
            overflow: hidden;
            position: relative;
            -webkit-mask-image: linear-gradient(transparent, black 20%, black 80%, transparent);
            mask-image: linear-gradient(transparent, black 20%, black 80%, transparent);
        }
        
        #music-lyrics-list {
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: transform 0.5s cubic-bezier(0.25, 0.1, 0.25, 1);
        }
        
        .lyric-line {
            padding: 4px 0;
            font-size: 14px;
            color: #666;
            text-align: center;
            line-height: 1.5;
            transition: all 0.5s ease;
            opacity: 0.7;
            transform: scale(0.95);
        }
        
        .lyric-line.active {
            font-size: 16px;
            color: #000;
            opacity: 1;
            transform: scale(1);
        }
        
        .music-player-controls-wrapper {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .music-controls {
            margin-top: 0;
        }
        
        #music-return-btn, #music-exit-btn, #music-playlist-btn {
            position: relative;
        }
        
        #music-return-btn { top: -2px; }
        #music-playlist-btn { top: -3px; }
        
        .playlist-item-actions {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .playlist-action-btn {
            font-size: 18px;
            color: #888;
            cursor: pointer;
            transition: color 0.2s;
        }
        .playlist-action-btn:hover { color: #000; }
        .delete-track-btn { font-size: 24px; color: #ff3b30; }
        .delete-track-btn:hover { color: #c00; }
        .lyrics-btn { font-weight: 500; }
        
        /* --- 【核心修正】確保頭像尺寸 --- */
        .message-bubble .avatar {
            width: 34px;
            height: 34px;
            border-radius: 20%;
            object-fit: cover;
            flex-shrink: 0; /* 防止被壓縮 */
        }
        
        /* ▼▼▼ 【全新】撤回消息樣式 ▼▼▼ */
        
        /* 1. 撤回消息的預留位置樣式 */
        .recalled-message-placeholder {
            align-self: center; /* 居中顯示 */
            padding: 4px 12px;
            margin: 5px 0;
            background-color: rgba(0, 0, 0, 0.1);
            color: var(--text-secondary);
            font-size: 12px;
            border-radius: 10px;
            text-align: center;
            max-width: 80%;
            cursor: pointer; /* 讓它看起來可以點擊 */
        }
        
        /* 2. 夜間模式下的適配 */
        #phone-screen.dark-mode .recalled-message-placeholder {
            background-color: rgba(255, 255, 255, 0.15);
        }
        
        /* 3. AI撤回消息時的動畫效果 */
        @keyframes recall-animation {
          from {
            opacity: 1;
            transform: scale(1);
          }
          to {
            opacity: 0;
            transform: scale(0.8);
          }
        }
        
        .message-wrapper.recalled-animation {
          animation: recall-animation 0.3s ease-out forwards;
        }
        
        /* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */
        
        /* ▼▼▼ 【全新】撤回消息樣式修正 ▼▼▼ */
        
        /* 強制撤回消息的預留位置不換行，並保持內容居中 */
        .recalled-message-placeholder {
            white-space: nowrap; /* 核心：禁止文本換行 */
            display: inline-block; /* 讓背景根據內容自我調整寬度 */
            padding: 4px 12px;
        }
        
        /* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */
        
        /* ▼▼▼ 【全新】世界書分類清單樣式 ▼▼▼ */
        .world-book-group-container {
            border-bottom: 1px solid var(--border-color);
        }
        .world-book-group-container:first-child {
            border-top: 1px solid var(--border-color);
        }
        .world-book-group-header {
            display: flex;
            align-items: center;
            padding: 12px 15px;
            cursor: pointer;
            background-color: #f7f7f7;
        }
        .world-book-group-header .arrow {
            font-size: 14px;
            margin-right: 8px;
            transition: transform 0.2s ease;
        }
        .world-book-group-header.collapsed .arrow {
            transform: rotate(-90deg);
        }
        .world-book-group-header .group-name {
            font-weight: 600;
            font-size: 15px;
        }
        .world-book-group-content {
            max-height: 1000px;
            overflow: hidden;
            transition: max-height 0.3s ease-in-out;
        }
        .world-book-group-content.collapsed {
            max-height: 0;
        }
        #phone-screen.dark-mode .world-book-group-header {
            background-color: #1c1c1e;
        }
        /* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */
        /* ▼▼▼ 【全新】聊天置頂樣式 ▼▼▼ */
        .chat-list-item.pinned {
            background-color: #f0f2f5; /* 給一個淡淡的、不同的背景色 */
        }
        
        #phone-screen.dark-mode .chat-list-item.pinned {
            background-color: #2c2c2e; /* 夜間模式下的置頂背景色 */
        }
        /* ▼▼▼ 修復輸入框遮擋按鈕的佈局問題 ▼▼▼ */
        #chat-input-area {
            display: flex;
            flex-direction: column;
            flex-shrink: 0; /* 防止整個輸入區被意外壓縮 */
            background-color: var(--secondary-bg); /* 確保背景色統一，避免透明重疊 */
        }
        
        #chat-input-actions-top {
            flex-shrink: 0; /* 防止按鈕行被壓縮 */
            padding-bottom: 8px; /* 增加一點和輸入框的間距，改善觀感 */
        }
        
        #chat-input-main-row {
            flex-shrink: 0; /* 防止輸入框行被壓縮 */
        }
        /* ▲▲▲ 修復結束 ▲▲▲ */
        /* ▼▼▼ 【全新】群聊@功能樣式 ▼▼▼ */
        
        /* ▼▼▼ 【核心修復】請用這段代碼替換您現有的 #chat-input-area 樣式 ▼▼▼ */
        #chat-input-area {
            position: relative; /* 保持相對定位，作為彈窗的“錨點” */
            z-index: 20;      /* 【關鍵修復】提升整個輸入區的層級 */
            flex-shrink: 0;
            padding: 8px;
            background-color: rgba(247, 247, 247, 0.8);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-top: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        /* ▲▲▲ 替換結束 ▲▲▲ */
        
        /* 2. 定義聊天@彈窗的具體位置和樣式 */
        #chat-at-mention-popup {
            bottom: 100%; /* 顯示在整個輸入區的上方 */
            left: 8px;    /* 與輸入區左邊內邊距對齊 */
            right: 8px;   /* 與輸入區右邊內邊距對齊 */
            width: auto;  /* 寬度自動撐滿 */
            margin-bottom: 5px; /* 和輸入區拉開一點距離 */
            /* 其他樣式將複用 .at-mention-popup 的現有樣式 */
        }
        /* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */
        /* ▼▼▼ 【全新】群公告板彈窗樣式 ▼▼▼ */
        #announcement-board-modal .modal-content {
            height: 70%;
            background-color: #f0f2f5;
        }
        #announcement-board-content {
            padding: 15px;
            flex-grow: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 15px; /* 公告之間的間距 */
        }
        #announcement-board-content .message-wrapper {
            max-width: 100%; /* 讓公告消息可以撐滿寬度 */
            align-self: center;
        }
        #announcement-board-content .timestamp {
            display: none; /* 公告板內不顯示時間戳記 */
        }
        /* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */
        /* ▼▼▼ 【全新】公告板卡片管理樣式 ▼▼▼ */
        .announcement-item-wrapper {
            position: relative; /* 為了定位操作按鈕 */
            padding: 10px;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        .announcement-item-actions {
            position: absolute;
            top: 15px;
            right: 15px;
            font-size: 20px;
            font-weight: bold;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 5px;
            line-height: 1;
            border-radius: 50%;
        }
        .announcement-item-actions:hover {
            background-color: #f0f0f0;
        }
        .pinned-indicator {
            position: absolute;
            top: -8px;
            left: -8px;
            width: 28px;
            height: 28px;
            background-color: #ffc107;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            border: 2px solid white;
        }
        /* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */
        /* ▼▼▼ 【全新】轉發功能樣式 ▼▼▼ */
        
        /* 1. 轉發後的動態，內嵌的原始內容容器 */
        .reposted-content-wrapper {
            background-color: #f7f7f8;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 10px;
            margin-top: 10px;
        }
        
        /* 在夜間模式下，為內嵌容器提供一個深色背景 */
        #phone-screen.dark-mode .reposted-content-wrapper {
            background-color: #2c2c2e;
            border-color: #38383a;
        }
        
        /* 2. 移除內嵌原始內容的底部互動區，避免混淆 */
        .reposted-content-wrapper .post-footer,
        .reposted-content-wrapper .post-feedback-icons,
        .reposted-content-wrapper .post-likes-section {
            display: none;
        }
        
        /* 3. 讓內嵌內容的頭部資訊稍微緊湊一些 */
        .reposted-content-wrapper .post-header {
            margin-bottom: 8px;
        }
        .reposted-content-wrapper .post-avatar {
            width: 32px;
            height: 32px;
        }
        .reposted-content-wrapper .post-nickname {
            font-size: 14px;
        }
        /* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */

             
        /* ▼▼▼ 【全新】共用位置卡片樣式 (微信風格 V2 - 支援圖片背景) ▼▼▼ */
        
        /* 1. 卡片總容器 (保持不變) */
        .location-share-card {
            width: 230px;
            border-radius: 10px;
            overflow: hidden; 
            background-color: #fff;
            border: 1px solid #f0f0f0;
            box-shadow: 0 1px 4px rgba(0,0,0,0.05);
            cursor: pointer; /* 讓卡片看起來可以點擊 */
        }
        
        /* 2. 上半部分：白色文字區 (保持不變) */
        .card-text-area {
            padding: 12px;
            border-bottom: 1px solid #f0f0f0;
        }
        .card-text-primary {
            font-size: 16px;
            font-weight: 600;
            color: #222;
            margin-bottom: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .card-text-secondary {
            font-size: 12px;
            color: #a0a0a0;
        }
        
        /* 3. 下半部分：【核心修改】地圖/圖片區 */
        .card-map-area {
            height: 100px; /* 增加高度以更好地展示圖片 */
            display: flex;
            justify-content: center;
            align-items: center;
            
            /* 圖片背景的關鍵樣式 */
            background-size: cover;
            background-position: center;
            
            /* 默認的純色背景 (當沒有提供圖片時生效) */
            background-color: #FFF0F5; /* AI的卡片用柔和粉色 */
        }
        
        /* 4. 使用者發送的卡片，地圖區預設用柔和綠色 */
        .message-bubble.user .location-share-card .card-map-area {
            background-color: #F0FFF8;
        }
        
        /* 5. 【核心修改】美化圖釘圖示，增加陰影使其更突出 */
        .card-pin-icon {
            font-size: 40px;
            color: #FF6B6B; /* 【核心修改】將顏色從 white 改為您喜歡的任意顏色 */
        
            text-shadow: 0 2px 5px rgba(0, 0, 0, 0.4); 
        }
        /* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */
        /* ▼▼▼ 【全新】AI 角色行動呼吸燈效果 ▼▼▼ */
        @keyframes breathing-light {
            0% {
        box-shadow: 0 0 6px rgba(0, 123, 255, 0.4);
            }
            50% {
        box-shadow: 0 0 18px 4px rgba(0, 123, 255, 0.8);
            }
            100% {
        box-shadow: 0 0 6px rgba(0, 123, 255, 0.4);
            }
        }
        
        .chat-list-item .avatar.is-acting {
            /* 核心：應用呼吸燈動畫 */
            animation: breathing-light 2s ease-in-out infinite;
            /* (可選) 同時添加一個常亮的邊框，讓效果更明顯 */
            border: 1.5px solid rgba(0, 123, 255, 0.7);
        }
        /* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */
        /* ▼▼▼ 【全新】動態評論區表情功能樣式 ▼▼▼ */
        
        /* === 【全新】評論區表情按鈕樣式 (與action-icon風格統一) === */
        .comment-sticker-btn {
            /* 1. 重新開機按鈕預設樣式 */
            background: none;
            border: none;
            padding: 5px; /* 增加一點可點擊區域 */
            cursor: pointer;
            
            /* 2. 與其他圖示顏色和過渡效果對齊 */
            color: var(--text-secondary);
            transition: all 0.2s ease-in-out;
        
            /* 3. 使用Flex佈局讓內部的SVG完美居中 */
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .comment-sticker-btn:hover {
            color: var(--text-primary); /* 滑鼠懸停時變色，提供回饋 */
        }
        
        /* 4. 定義SVG圖示的樣式，與點贊/轉發圖示完全一致 */
        .comment-sticker-btn svg {
            width: 22px;
            height: 22px;
            fill: none;
            stroke: currentColor;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
        }
        
        /* 2. 評論區表情面板容器 */
        #qzone-sticker-panel {
            position: absolute; /* 使用絕對定位，由JS控制位置 */
            width: 280px;
            height: 200px;
            background-color: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.15);
            z-index: 1010; /* 確保在其他元素之上 */
            display: none; /* 默認隱藏 */
            flex-direction: column;
            overflow: hidden;
        }
        
        /* 3. 面板內的表情網格 (不變) */
        #qzone-sticker-grid {
            flex-grow: 1;
            overflow-y: auto;
            padding: 10px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 10px;
        }
        
        #qzone-sticker-grid .sticker-item {
            position: relative;
            aspect-ratio: 1 / 1;
            background-color: white;
            border-radius: 8px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
        }
        
        
        /* 4. 評論區裡的表情圖片樣式 (尺寸修正後) */
        .comment-text .comment-sticker {
            max-width: 100px;  /* 減小最大寬度 */
            max-height: 100px; /* 減小最大高度 */
            display: block;
            background-color: transparent;
        }
        
        /* 5. 【新增】優化：當評論內容是表情時，調整間距 */
        .comment-item .comment-text:has(.comment-sticker) {
            /* 如果 .comment-text 內部只有表情，就移除文字行高帶來的額外邊距 */
            line-height: 1;
        }
        
        /* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */
        /* === 頭像框選擇模態框樣式 === */
        .change-frame-btn {
            padding: 6px 10px;
            border: 1px solid #ccc;
            background-color: #f0f0f0;
            border-radius: 5px;
            cursor: pointer;
            font-size: 13px;
            margin-left: 10px;
        }
        
        #avatar-frame-modal .modal-content {
            height: 70%;
        }
        
        #avatar-frame-modal .modal-body {
            padding: 0;
            display: flex;
            flex-direction: column;
        }
        
        .frame-tabs {
            display: flex;
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }
        
        .frame-tab {
            flex: 1;
            padding: 12px;
            text-align: center;
            font-weight: 500;
            cursor: pointer;
            color: var(--text-secondary);
            border-bottom: 2px solid transparent;
        }
        
        .frame-tab.active {
            color: var(--accent-color);
            border-bottom-color: var(--accent-color);
        }
        
        .frame-content {
            flex-grow: 1;
            overflow-y: auto;
            padding: 15px;
        }
        
        .frame-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
            gap: 15px;
        }
        
        .frame-item {
            aspect-ratio: 1 / 1;
            border: 2px solid transparent;
            border-radius: 10px;
            cursor: pointer;
            background-color: #f0f0f0;
            background-size: cover;
            background-position: center;
            padding: 5px;
            transition: all 0.2s ease;
            position: relative;
        }
        
        .frame-item.selected {
            border-color: var(--accent-color);
            transform: scale(1.05);
        }
        
        .frame-item .preview-avatar {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            object-fit: cover;
        }
        
        .frame-item .preview-frame {
            position: absolute;
            top: -7px;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        
        /* ▼▼▼ 【最終修復方案】請用這一整塊代碼替換所有舊的頭像相關樣式 ▼▼▼ */
        
        /* 1. 頭像最外層容器，負責占位元和動態變寬 */
        .avatar-group {
            width: 34px;
            flex-shrink: 0; /* 確保在flex佈局中不被壓縮 */
            position: relative;
            transition: width 0.2s ease;
        }
        /* 當佩戴頭像框時，外層容器變寬，為更大的頭像框創造空間 */
        .avatar-group.has-frame {
            width: 42px; 
        }
        
        /* 2. 基礎的、無框的頭像樣式 */
        .message-bubble .avatar {
            width: 34px;
            height: 34px;
            border-radius: 20%; /* 默認的方圓形頭像 */
            object-fit: cover;
        }
        
        /* 3. 帶框頭像的“內部容器” */
        .avatar-with-frame {
            position: relative; /* 關鍵：為內部的頭像和框提供定位錨點 */
            width: 38px;
            height: 38px;
            margin: 0 auto;
            transition: all 0.2s ease;
        }
        /* 【核心】當有框時，這個內部容器也變大，讓裡面的圖片可以更大 */
        .avatar-group.has-frame .avatar-with-frame {
            width: 43px;
            height: 43px;
        }
        
        /* 4. 帶框頭像中的“頭像圖片本身” */
        .avatar-with-frame .avatar-img {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%; /* 寬度撐滿其父容器 (.avatar-with-frame) */
            height: 100%;/* 高度也撐滿 */
            border-radius: 50%; /* 佩戴頭像框時，圖片本身變為圓形以更好地適配 */
            object-fit: cover;
            z-index: 1; /* 確保在頭像框下方 */
        }
        
        /* 5. “頭像框圖片本身” */
        .avatar-with-frame .avatar-frame {
            position: absolute;
            width: 120%;  
            height: 120%; 
        
            /* --- 這就是確保完美包裹和居中的關鍵代碼 --- */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            /* --- 關鍵代碼結束 --- */
            z-index: 2; /* 確保在頭像圖片上方 */
            pointer-events: none; /* 讓滑鼠事件可以穿透頭像框，點到下面的頭像 */
        }
        
        /* ▲▲▲ 替換結束 ▲▲▲ */
/* ▼▼▼ 【最終修復方案】請用這整塊代碼替換所有舊的頭像和氣泡相關樣式 ▼▼▼ */

/* 1. 強制外層氣泡容器(.message-bubble)成為一個真正的“彈性”專案。*/
.message-bubble {
    flex: 1;
    min-width: 0;
    display: flex;
    align-items: flex-start;
    gap: 12px;
    max-width: 100%;
}

.message-bubble.user { 
    flex-direction: row-reverse; 
}

/* 2. 強制內層內容區(.content)也成為一個“彈性”專案。*/
.message-bubble .content {
    flex: 1;
    min-width: 0;
    
    /* --- 核心修復：修改這裡的換行規則 --- */
    overflow-wrap: break-word; /* 使用這個標準屬性來保證單詞完整性 */
    word-wrap: break-word;     /* 相容舊版流覽器 */
    /* --- 修復結束 (已替換舊的 break-all 規則) --- */

    position: relative;
    font-size: var(--chat-font-size, 16px);
    padding: 8px 12px;
    line-height: 1.5;
}

/* 3. 再次確保頭像容器絕對不收縮 (作為最終保險) */
.message-bubble .avatar-group {
    flex-shrink: 0 !important;
}

/* ▲▲▲ 修復方案結束 ▲▲▲ */
        /* ▼▼▼ 【終極強制修正】請將這段代碼黏貼到 <style> 的最末尾 ▼▼▼ */
        
        /* 使用ID選擇器和!important，強制提升這條規則的優先順序到最高，
           以覆蓋任何可能存在的未知衝突樣式。*/
        
        #chat-interface-screen .message-bubble .avatar-group.has-frame .avatar-with-frame {
            width: 43px !important;
            height: 43px !important;
        }
        
        #chat-interface-screen .message-bubble .avatar-with-frame .avatar-img {
            width: 100% !important;
            height: 100% !important;
        }
        /* ▲▲▲ 修正結束 ▲▲▲ */
        /* ▼▼▼ 【全新】卡片/特殊內容居中修正 ▼▼▼ */
        .message-bubble.is-link-share .content,
        .message-bubble.is-transfer .content,
        .message-bubble.is-waimai-request .content,
        .message-bubble.is-red-packet .content,
        .message-bubble.is-poll .content,
        .message-bubble.is-location-share .content,
        .message-bubble.is-sticker .content,
        .message-bubble.is-ai-image .content {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        /* ▲▲▲ 修正結束 ▲▲▲ */
        /* ▼▼▼ 【全新】隱藏聊天列表中的頭像框 (最終修正版) ▼▼▼ */
        
        /* 1. 在聊天清單螢幕中，直接隱藏頭像框圖片 */
        #chat-list-screen .avatar-frame {
            display: none;
        }
        
        /* 2. 強制所有頭像的最外層容器，在列表頁都保持 45px 的正確尺寸 */
        #chat-list-screen .avatar-group {
            width: 45px;
            height: 45px;
        }
        
        /* 3. 如果一個頭像是帶框結構，也強制其內部容器和圖片適應 45px 的尺寸 */
        #chat-list-screen .avatar-group.has-frame .avatar-with-frame,
        #chat-list-screen .avatar-group.has-frame .avatar-img {
            width: 45px;
            height: 45px;
        }
        
        /* 4. 確保所有頭像在列表頁都是圓形的，保持統一 */
        #chat-list-screen .avatar-img,
        #chat-list-screen .avatar {
            border-radius: 50%;
        }
        
        /* ▲▲▲ 新增CSS結束 ▲▲▲ */
        /* ▼▼▼ 【全新】增加聊天清單頭像與文字的間距 ▼▼▼ */
        
        /* 1. 強制為聊天列表中的頭像容器設置右邊距 */
        /*    這將覆蓋任何可能存在的舊樣式，並確保間距生效 */
        #chat-list .chat-list-item .avatar-group {
            margin-right: 15px !important; /* 核心：增加右邊距，將文字推開 */
        }
        
        /* 2. (可選但推薦) 確保舊的頭像樣式不再干擾佈局 */
        #chat-list .chat-list-item .avatar {
            margin-right: 0; /* 移除舊的邊距，防止重複計算 */
        }
        
        /* ▲▲▲ 新增CSS結束 ▲▲▲ */
        /* ▼▼▼ 【全新】動態評論區回復功能樣式 ▼▼▼ */
        
        /* 讓評論項在滑鼠懸停時高亮，並顯示手型游標 */
        .comment-item {
            cursor: pointer;
            transition: background-color 0.2s;
            /* 使用Flex佈局，讓評論內容和刪除按鈕能正確對齊 */
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 8px; /* 內容和刪除按鈕的間距 */
            padding: 4px 6px; /* 增加一點內邊距，方便點擊 */
            margin: 0 -6px; /* 抵消內邊距，保持視覺對齊 */
            border-radius: 4px;
        }
        
        .comment-item:hover {
            background-color: #f0f2f5;
        }
        
        /* 夜間模式下的懸停效果 */
        #phone-screen.dark-mode .comment-item:hover {
            background-color: #2c2c2e;
        }
        
        /* 評論內容文本的容器 */
        .comment-item .comment-text {
            flex-grow: 1; /* 佔據主要空間 */
            word-break: break-word; /* 確保長內容能換行 */
        }
        
        /* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */
        /* ▼▼▼ 【全新】用於相容舊格式評論的樣式 ▼▼▼ */
        .legacy-comment-item {
            line-height: 1.5;
            padding: 4px 6px; /* 和新樣式保持一致的內邊距 */
            color: var(--text-secondary); /* 用次要顏色顯示，以示區別 */
        }
        /* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */
        /* ▼▼▼ 【全新】卡片/特殊內容居中修正 ▼▼▼ */
        .message-bubble.is-link-share .content,
        .message-bubble.is-transfer .content,
        .message-bubble.is-waimai-request .content,
        .message-bubble.is-red-packet .content,
        .message-bubble.is-poll .content,
        .message-bubble.is-location-share .content,
        .message-bubble.is-sticker .content,
        .message-bubble.is-ai-image .content {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        /* ▲▲▲ 修正結束 ▲▲▲ */
        /* ▼▼▼ 【終極強制修正】請將這段代碼黏貼到 <style> 的最末尾 ▼▼▼ */
        
        /* 使用ID選擇器和!important，強制提升這條規則的優先順序到最高，
           以覆蓋任何可能存在的未知衝突樣式。*/
        
        #chat-interface-screen .message-bubble .avatar-group.has-frame .avatar-with-frame {
            width: 43px !important;
            height: 43px !important;
        }
        
        #chat-interface-screen .message-bubble .avatar-with-frame .avatar-img {
            width: 100% !important;
            height: 100% !important;
        }
        /* ▲▲▲ 修正結束 ▲▲▲ */
        /* ▼▼▼ 【Safari/iOS 最終卡片佈局修復】請用這一整塊全新的代碼 ▼▼▼ */
        
        /* 
          第一步：【核心修復】
          這個選擇器會一次性選中所有包含特殊卡片的消息氣泡容器(.message-bubble)。
          我們告訴它不要再強制拉伸，而是根據內部卡片的大小自我調整寬度。
        */
        .message-bubble.is-sticker,
        .message-bubble.is-voice-message,
        .message-bubble.is-transfer,
        .message-bubble.is-ai-image,
        .message-bubble.is-waimai-request,
        .message-bubble.is-red-packet,
        .message-bubble.is-poll,
        .message-bubble.is-link-share,
        .message-bubble.is-location-share {
            flex: initial; /* 覆蓋掉通用的 flex: 1，這是解決問題的關鍵，讓氣泡本身不再拉伸 */
            min-width: auto; /* 同樣重置 min-width，允許其自由收縮 */
        }
        
        /* 
          第二步：保持對卡片內部 .content 區域的樣式重置。
          我們移除它的背景和內邊距，讓卡片自己負責外觀。
        */
        .message-bubble.is-sticker .content,
        .message-bubble.is-voice-message .content,
        .message-bubble.is-transfer .content,
        .message-bubble.is-ai-image .content,
        .message-bubble.is-waimai-request .content,
        .message-bubble.is-red-packet .content,
        .message-bubble.is-poll .content,
        .message-bubble.is-link-share .content,
        .message-bubble.is-location-share .content {
            /* 保持這個好習慣，確保內容區也不拉伸 */
            flex: initial; 
            
            /* 移除所有可能干擾卡片顯示的樣式 */
            padding: 0;
            background: transparent;
            box-shadow: none;
            border: none;
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
        }
        
        /* ▲▲▲ 修復結束 ▲▲▲ */
        /* ▼▼▼ 【終極版】群公告對齊修復 (強制所有內容靠左) ▼▼▼ */
        
        /* 
          第一步：強制所有消息塊（無論是AI還是用戶）都在公告板內靠左對齊。
          這確保了AI和使用者的消息塊在垂直方向上是對齊的。
        */
        #announcement-board-content .message-wrapper {
            align-self: flex-start !important;
        }
        
        /* 
          第二步：這是最關鍵的一步！
          我們專門針對使用者的消息氣泡，強制將其內部的元素順序（頭像和內容）
          從“反向”恢復為“正向”，使其與AI的消息氣泡佈局完全一致。
        */
        #announcement-board-content .message-bubble.user {
            flex-direction: row !important;
        }
        
        /* 
          第三步 (可選但推薦): 
          同時，我們也強制將使用者消息塊外部的時間戳記和氣泡順序恢復正常，
          以防未來可能出現的佈局問題。
        */
        #announcement-board-content .message-wrapper.user {
            flex-direction: row !important;
        }
        
        /* ▲▲▲ 修復結束 ▲▲▲ */
        /* ▼▼▼ 【終極修復】請用這一整塊代碼，替換掉你上一次黏貼的代碼 ▼▼▼ */
        
        /* === 聊天介面頭部浮動與層級終極修復 === */
        
        /* 
          這次的修復有兩個關鍵點：
          1. 依然使用 absolute 定位讓頭部浮動起來。
          2. 額外給它一個非常高的 z-index 並用 !important 標記，
             賦予它“至高無上”的權力，強制它壓制頁面上任何其他元素。
        */
        
        /* 1. 強制聊天介面的頭部變為絕對定位，並賦予一個極高的層級 */
        #chat-interface-screen > .header {
            position: absolute !important; /* 核心修正1: 脫離文檔流，浮動起來 */
            top: 0;
            left: 0;
            width: 100%;
            z-index: 100 !important; /* 核心修正2: 賦予一個非常高的 z-index，壓制一切 */
        }
        
        /* 2. 修正聊天內容區的佈局，移除不再需要的負外邊距，讓為頭部預留的 padding 生效 */
        #chat-interface-screen #chat-messages {
            margin-top: 0 !important; /* 核心修正3: 移除用於“上拉”的負外邊距 */
        }
        
        /* ▲▲▲ 修復代碼黏貼結束 ▲▲▲ */
        /* ▼▼▼ 【最終解決方案】請用這一整塊代碼，替換掉所有舊的修復代碼 ▼▼▼ */
        
        /* === 聊天介面佈局與層級終極修復 === */
        
        /* 
          第一部分：修復音樂播放機被遮擋的問題
          我們給播放機一個比頭部更高的 z-index，讓它能正確地覆蓋所有內容。
        */
        #music-player-overlay {
            z-index: 200 !important;
        }
        
        /* 
          第二部分：徹底重構聊天頁面的佈局，解決寬度和遮擋問題
          我們將採用最穩定、最現代的佈局方式：
          - 頭部和輸入框都使用絕對定位，分別“釘”在螢幕的頂部和底部。
          - 聊天內容區則佔據整個螢幕的高度，並通過內邊距（padding）為頭部和輸入框留出空間。
          這樣可以完美實現內容在透明頂/底部之下滾動的美觀效果，且不會再出現寬度計算錯誤。
        */
        
        /* ▼▼▼ 請用這一整塊全新的代碼，替換所有舊的聊天介面佈局CSS ▼▼▼ */
        
        /* 1. 確保聊天介面容器是可靠的定位錨點 */
        #chat-interface-screen {
            position: relative !important;
            height: 100%;
            width: 100%;
            overflow: hidden; /* 防止任何意外溢出 */
        }
        
        /* 2. 強制【頭部】絕對定位，並“釘”在螢幕頂部 */
        #chat-interface-screen > .header {
            position: absolute !important;
            top: 0;
            left: 0;
            right: 0; /* 使用 left/right 撐滿寬度，比 width:100% 更可靠 */
            width: auto !important; 
            z-index: 100 !important; /* 賦予一個非常高的層級，確保它在最上層 */
        }
        
        /* 3. 強制【輸入框】也絕對定位，並“釘”在螢幕底部 */
        #chat-interface-screen #chat-input-area {
            position: absolute !important;
            bottom: 0;
            left: 0;
            right: 0;
            width: auto !important;
            z-index: 100 !important;
            /* 核心：為輸入框本身添加適配“小黑條”的底部內邊距 */
            padding-bottom: calc(8px + env(safe-area-inset-bottom)); 
        }
        
        /* 4. 【核心】重新定義【聊天內容區】的佈局 */
        #chat-interface-screen #chat-messages {
            /* 讓它填滿整個螢幕 */
            height: 100% !important; 
            width: 100% !important;
            
            /* 允許其內容垂直捲動 */
            overflow-y: auto !important; 
            
            /* 確保 padding 的計算方式正確 */
            box-sizing: border-box !important; 
            
            /* 移除所有可能干擾佈局的 margin */
            margin-top: 0 !important; 
        
            /* 關鍵：使用內邊距為頂部的“頭部”和底部的“輸入框”留出空間 */
            /* 這樣內容就會在半透明的頂/底部之下滾動，效果美觀且精准 */
            padding-top: 150px !important;  /* 為頭部預留約110px空間 */
            padding-bottom: 150px !important; /* 為輸入框預留約120px空間 */
        }
        
        /* ▲▲▲ 替換結束 ▲▲▲ */
        
        /* ▲▲▲ 修復代碼黏貼結束 ▲▲▲ */
        /* ▼▼▼ 【全新】“動態已刪除”提示樣式 ▼▼▼ */
        .post-deleted-placeholder {
            align-self: center;
            padding: 4px 12px;
            margin: 5px 0;
            background-color: rgba(0, 0, 0, 0.1);
            color: var(--text-secondary);
            font-size: 12px;
            border-radius: 10px;
            text-align: center;
            max-width: 80%;
            cursor: pointer; /* 關鍵：讓它看起來可以點擊 */
        }
        
        #phone-screen.dark-mode .post-deleted-placeholder {
            background-color: rgba(255, 255, 255, 0.15);
        }
        /* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */
        /* ▼▼▼ 【全新】為塗黑（劇透）功能添加的樣式 ▼▼▼ */
        .spoiler {
            background-color: #333; /* 塗黑的背景色 */
            color: #333;           /* 塗黑的文字顏色，使其與背景融為一體 */
            padding: 0 4px;         /* 輕微的左右內邊距，使其更美觀 */
            border-radius: 4px;     /* 圓角 */
            cursor: pointer;        /* 滑鼠懸停時顯示為可點擊的手型 */
            transition: all 0.2s ease-in-out; /* 讓顯示/隱藏效果更平滑 */
        }
        
        /* 滑鼠懸停或點擊時，恢復背景和文字顏色以顯示內容 */
        .spoiler:hover, .spoiler:active {
            background-color: #e0e0e0; /* 顯示時給一個淡淡的背景色 */
            color: inherit;           /* 恢復為正常的文字顏色 */
        }
        /* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */
        /* ▼▼▼ 【全新】長期記憶管理按鈕美化樣式 ▼▼▼ */
        .memory-action-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 5px; /* 增加一點可點擊區域，方便使用者操作 */
            border-radius: 50%; /* 圓形背景 */
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
        }
        
        .memory-action-btn svg {
            width: 18px;  /* 讓圖示比頂部的稍小一點，更顯精緻 */
            height: 18px;
            stroke: var(--text-secondary); /* 預設使用次要文字的灰色 */
            transition: stroke 0.2s;
        }
        
        .memory-action-btn:hover {
            background-color: #e9ecef; /* 滑鼠懸停時給一個淡淡的背景色 */
        }
        
        /* 夜間模式下的懸停效果 */
        #phone-screen.dark-mode .memory-action-btn:hover {
            background-color: #38383a;
        }
        
        /* 編輯按鈕懸停時，圖示變為藍色 */
        .memory-action-btn.edit-memory-btn:hover svg {
            stroke: var(--accent-color);
        }
        
        /* 刪除按鈕懸停時，圖示變為危險的紅色 */
        .memory-action-btn.delete-memory-btn:hover svg {
            stroke: #ff3b30;
        }
        /* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */
        /* ▼▼▼ 【全新】表情批量刪除功能樣式 ▼▼▼ */
        
        /* 管理模式下，為表情項添加一個選中框 */
        #sticker-grid.management-mode .sticker-item::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: 3px solid transparent;
            border-radius: 10px;
            box-sizing: border-box;
            transition: border-color 0.2s;
        }
        
        /* 管理模式下，被選中的表情項，顯示藍色邊框 */
        #sticker-grid.management-mode .sticker-item.selected::after {
            border-color: var(--accent-color);
        }
        
        /* 管理模式下，總是顯示刪除按鈕 */
        #sticker-grid.management-mode .sticker-item .delete-btn {
            display: block;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            border: 1px solid white;
        }
        
        /* 底部批量刪除操作欄 */
        #sticker-action-bar {
            display: none; /* 默認隱藏 */
            padding: 10px 15px;
            padding-bottom: calc(10px + env(safe-area-inset-bottom));
            background-color: rgba(247, 247, 247, 0.9);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-top: 1px solid var(--border-color);
        }
        
        #sticker-action-bar button {
            width: 100%;
            padding: 12px;
            border-radius: 8px;
            border: none;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            background-color: #ff3b30;
            color: white;
        }
        /* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */

        /* ▼▼▼ 【全新】導演剪輯室樣式 ▼▼▼ */
        #ai-response-editor-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .ai-response-editor-block {
            background-color: #f9f9f9;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px;
        }
        
        .ai-response-editor-block textarea {
            width: 100%;
            min-height: 80px; /* 默認給一個更大的高度 */
            resize: vertical;
            border: 1px solid #ccc;
            border-radius: 6px;
            padding: 8px;
            font-size: 14px; /* 使用小一點的字體，方便查看JSON */
            font-family: monospace; /* 使用等寬字體，讓JSON對齊更美觀 */
            box-sizing: border-box;
        }
        
        .ai-response-editor-block .format-helpers {
            margin-top: 8px;
            margin-bottom: 0; /* 覆蓋默認的 margin-bottom */
        }
        
        .ai-response-editor-block .delete-block-btn {
            float: right;
            margin-top: -5px;
            background: none;
            border: none;
            color: #ff3b30;
            font-size: 20px;
            cursor: pointer;
        }
        
        #phone-screen.dark-mode .ai-response-editor-block {
            background-color: #2c2c2e;
            border-color: #38383a;
        }
        #phone-screen.dark-mode .ai-response-editor-block textarea {
            background-color: #1c1c1e;
            color: #f0f0f0;
            border-color: #4a4a4e;
        }
        /* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */
/* ▼▼▼ 【全新 | 線下模式內心獨白樣式 (已修復斜體)】 ▼▼▼ */
.offline-dialogue {
    /* 對話部分可以保持預設樣式，或者稍作強調 */
    font-weight: 500;
}
.offline-description {
    display: block; 
    color: inherit; /* 保持普通描寫文字顏色與對話一致 */
    font-style: normal; 
    margin-top: 4px; 
    white-space: pre-wrap; 
    line-height: 1.6;
}

/* ✨ 核心新增：專門為內心獨白（斜體）設置樣式 */
.offline-description em {
    color: var(--text-secondary); /* 將顏色設置為次要文字的淺灰色 */
    /* font-style: normal;  <-- 已刪除此行，恢復斜體 */
}

#phone-screen.dark-mode .offline-description {
    color: inherit; /* 夜間模式下也保持普通描寫文字顏色一致 */
}
/* ▲▲▲ 修改結束 ▲▲▲ */
        /* ▼▼▼ 【全新】引用跳轉高亮效果 ▼▼▼ */
        
        /* 1. 為消息氣泡的內容區添加一個平滑的背景色過渡效果 */
        .message-bubble .content {
            transition: background-color 0.5s ease-out;
        }
        
        /* 2. 定義高亮時的背景色 */
        /*    我們使用 !important 來確保它能覆蓋掉所有主題的預設顏色 */
        .message-bubble.highlighted .content {
            background-color: rgba(0, 123, 255, 0.2) !important;
        }
        /* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */
        /* ▼▼▼ 【佈局終極修復】請用這一整塊全新的CSS，替換掉您舊的所有五子棋相關樣式 ▼▼▼ */
        
        /* ▼▼▼ 【邊框終極修復V2】請用這一整塊全新的CSS，替換掉您舊的所有五子棋相關樣式 ▼▼▼ */
        
        /* 1. 棋盤的外部容器 (負責定位和動畫視窗) */
        #gomoku-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 350px;
            z-index: 50;
            pointer-events: none; /* 讓點擊可以穿透 */
            overflow: hidden;     /* 【核心】隱藏掉滑出螢幕外的內容 */
            display: none;        /* 預設不顯示，由JS控制 */
        }
        
        /* ▼▼▼ 【遮罩終極修復】請用這整塊全新的CSS，替換掉您舊的 #gomoku-content-wrapper 樣式 ▼▼▼ */
        
        /* 2. 棋盤的內部包裝器 (負責外觀和內容佈局) */
        #gomoku-content-wrapper {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* 【核心】移除所有背景和效果，使其完全透明 */
            background-color: transparent !important;
            backdrop-filter: none !important;
            box-shadow: none !important;
            /* --- 其他佈局樣式保持不變 --- */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 15px;
            padding: 15px 0;
            box-sizing: border-box;
            transition: transform 0.3s ease-out;
            transform: translateY(-100%);
            pointer-events: auto;
        }
        
        /* ▲▲▲ 替換結束 ▲▲▲ */
        
        #phone-screen.dark-mode #gomoku-content-wrapper {
            background-color: rgba(28, 28, 30, 0.9);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }
        
        /* 當棋盤可見時，將內部包裝器滑入視圖 */
        #gomoku-overlay.visible #gomoku-content-wrapper {
            transform: translateY(0);
        }
        
        /* 3. 聊天消息區 (保持不變) */
        #chat-messages {
            transition: padding-top 0.3s ease-out;
        }
        
        /* 4. 棋盤畫布和控制按鈕 (保持不變) */
        #gomoku-board {
            background-color: #e4b591;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
            cursor: pointer;
        }
        
        #gomoku-controls {
            width: 100%;
            text-align: center;
            flex-shrink: 0;
        }
        
        #close-gomoku-btn {
            padding: 6px 15px;
            border-radius: 15px;
            border: 1px solid var(--text-secondary);
            background-color: rgba(255,255,255,0.5);
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 13px;
        }
        #phone-screen.dark-mode #close-gomoku-btn {
            background-color: rgba(0,0,0,0.2);
            border-color: var(--text-secondary);
        }
        
        /* ▲▲▲ 替換結束 ▲▲▲ */
        /* ▼▼▼ 【棋盤交互終極修復】請將這整塊CSS黏貼到 <style> 的最末尾 ▼▼▼ */
        
        /* 
          第一步：【核心】讓棋盤的巨大透明容器“穿透”所有滑鼠/觸摸點擊。
          這樣您就可以點擊到它下方的聊天消息了。
        */
        #gomoku-overlay {
            pointer-events: none;
        }
        
        /* 
          第二步：現在，我們必須“恢復”棋盤和按鈕本身的可點擊性。
          我們將它們設置為 auto，這樣它們就又能回應您的操作了。
        */
        #gomoku-board,
        #gomoku-controls {
            pointer-events: auto;
        }
        
        /* --- 請用這整塊【最終佈局修復版】代碼，替換從 #product-grid 到 .product-footer 的所有相關樣式 --- */
        
        #product-grid {
            flex-grow: 1; 
            overflow-y: auto; 
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            padding: 10px;
            padding-bottom: 80px;
            /* 【核心修改1】: 移除 align-items: start，恢復Grid默認的拉伸對齊，確保卡片等高 */
        }
        
        .product-item {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.04);
            display: flex;         /* 【核心修改2】: 必須是Flex容器，才能控制內部元素 */
            flex-direction: column;
        
            cursor: pointer;
            position: relative;
        }
        
        .product-image {
            width: 100%;
            aspect-ratio: 1 / 1;
            object-fit: cover;
        }
        
        /* --- 請用這整塊【最終緊湊佈局版】代碼，替換舊的 .product-info, .product-name, 和 .product-footer 樣式 --- */
        
        .product-info {
            padding: 12px 10px;
            flex-grow: 1;      /* 保持：讓資訊區填滿，確保所有卡片等高 */
            display: flex;
            flex-direction: column;
        }
        
        .product-name {
            font-size: 13px;
            color: #333;
            line-height: 1.4;
            min-height: 36px;
            /* 移除所有flex-grow屬性，讓它只佔據自己需要的高度 */
        }
        
        .product-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 8px;      /* 【核心修改】：不再使用 auto，而是設置一個固定的、較小的頂部間距 */
        }
        
        /* --- 替換結束 --- */
        
        
        
        
        
        /* --- 替換結束 --- */
        
        .product-price {
            font-size: 16px;
            font-weight: 700;
            color: #ff5722;
        }
        .product-price::before { content: '¥'; font-size: 12px; }
        
        .add-to-cart-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 15px;
            background: linear-gradient(90deg, #ff9800, #ff5722);
            color: white;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
        }
        
        /* --- 管理模式樣式 (保持不變) --- */
        .product-management-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 15px;
            z-index: 7;
        }
        .product-management-overlay button {
            padding: 8px 20px;
            border: 1px solid white;
            background-color: rgba(255,255,255,0.2);
            color: white;
            border-radius: 15px;
            cursor: pointer;
        }
        .product-management-overlay .delete-product-btn {
            border-color: #ff8a80;
            color: #ff8a80;
        }
        #shopping-screen.management-mode .product-footer {
            display: none;
        }
        
        
        /* --- 購物車頁 (微調) --- */
        #cart-title {
            position: static;
            transform: none;
        }
        #cart-items-list { padding: 10px; display: flex; flex-direction: column; gap: 10px; }
        .cart-item {
            display: flex; align-items: flex-start; gap: 12px; background-color: white;
            padding: 12px; border-radius: 12px;
        }
        .cart-item-checkbox { margin-top: 28px; }
        .cart-item-image { width: 80px; height: 80px; object-fit: cover; border-radius: 8px; flex-shrink: 0; }
        .cart-item-info { flex-grow: 1; display: flex; flex-direction: column; }
        .cart-item-name { font-weight: 500; font-size: 14px; line-height: 1.4; }
        .cart-item-footer { display: flex; justify-content: space-between; align-items: center; margin-top: 10px;}
        .cart-item-price { color: #ff5722; font-weight: bold; font-size: 16px; }
        .quantity-control { display: flex; align-items: center; gap: 4px; }
        .quantity-btn {
            width: 26px; height: 26px; border: none; background-color: #f7f8fa;
            border-radius: 4px; font-weight: 500; cursor: pointer; color: #666;
        }
        .quantity-display { font-weight: 500; min-width: 30px; text-align: center; }
        
        #cart-footer {
            position: absolute; bottom: 0; left: 0; width: 100%; display: flex;
            justify-content: space-between; align-items: center; padding: 10px 15px;
            padding-bottom: calc(10px + env(safe-area-inset-bottom));
            background-color: white; border-top: 1px solid var(--border-color); box-sizing: border-box;
        }
        #cart-footer .select-all-label { display: flex; align-items: center; gap: 5px; }
        #cart-footer .cart-summary { text-align: right; }
        #cart-footer .cart-subtext { font-size: 11px; color: #999; }
        #checkout-btn {
            padding: 10px 25px; border: none; border-radius: 20px;
            background: linear-gradient(90deg, #ff9800, #ff5722);
            color: white; font-size: 15px; font-weight: 500; cursor: pointer;
        }
        
        /* --- 禮物卡片 & 小票 (樣式不變) --- */
        .gift-card {
            width: 220px; /* 【核心修改】將 max-width 改為固定的 width */
            box-sizing: border-box; 
            border-radius: 12px; 
            background-color: #fff; 
            border: 1px solid #eee; 
            padding: 12px;
            cursor: pointer; 
            box-shadow: 0 2px 8px rgba(0,0,0,0.07);
        }
        /* ▲▲▲ 替換結束 ▲▲▲ */
        .gift-header { display: flex; align-items: center; gap: 8px; padding-bottom: 8px; border-bottom: 1px solid #f0f0f0; }
        .gift-header-icon { width: 20px; height: 20px; color: #ff9800; }
        .gift-header-text { font-size: 15px; font-weight: 600; color: var(--text-primary); }
        .gift-items-preview { padding: 12px 0; display: flex; flex-direction: column; gap: 8px; }
        .gift-preview-item { display: flex; align-items: center; gap: 8px; }
        .gift-preview-img { width: 32px; height: 32px; object-fit: cover; border-radius: 4px; flex-shrink: 0; }
        .gift-preview-name { flex-grow: 1; font-size: 13px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .gift-preview-quantity { font-size: 12px; color: var(--text-secondary); }
        .gift-footer { font-size: 12px; color: var(--text-secondary); text-align: right; }
        #gift-receipt-body { font-family: 'Helvetica Neue', Arial, sans-serif; padding: 15px; background-color: #f7f8fa; }
        .receipt-header { text-align: center; padding-bottom: 15px; border-bottom: 1px solid #ddd; }
        .receipt-header h3 { margin: 0 0 5px 0; font-size: 20px; }
        .receipt-header p { margin: 0; font-size: 12px; color: #888; }
        .receipt-items-table { width: 100%; border-collapse: collapse; margin: 15px 0; }
        .receipt-items-table th, .receipt-items-table td { padding: 10px 5px; font-size: 13px; }
        .receipt-items-table thead th { border-bottom: 1px solid #333; text-align: left; }
        .receipt-items-table .item-name { width: 50%; }
        .receipt-items-table .item-qty { text-align: center; }
        .receipt-items-table .item-price, .receipt-items-table .item-subtotal { text-align: right; }
        .receipt-total { padding-top: 15px; border-top: 1px solid #333; text-align: right; font-size: 16px; font-weight: bold; }
        .receipt-footer { text-align: center; margin-top: 25px; font-size: 12px; color: #888; }
        /* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */
        /* ▼▼▼ (可選，但推薦) 為商品管理模式添加新樣式 ▼▼▼ */
        .product-item {
            position: relative; /* 為了定位遮罩層 */
        }
.product-management-overlay {
    position: absolute;
    bottom: 0; /* 定位到底部 */
    left: 0;
    width: 100%;
    background-color: rgba(0,0,0,0.6); /* 半透明黑色背景 */
    display: none; /* 默認依然隱藏 */
    justify-content: center; /* 按鈕水準居中 */
    align-items: center;
    gap: 15px; /* 按鈕之間的間距 */
    padding: 10px 0; /* 上下留出一點空間 */
    border-radius: 0 0 8px 8px; /* 匹配卡片的底部圓角 */
    z-index: 5; /* 確保在圖片之上，但在選擇框之下 */
    transition: opacity 0.2s;
}
        #shopping-screen.management-mode .product-management-overlay {
            display: flex; /* 在管理模式下顯示 */
        }
        .product-management-overlay button {
            padding: 8px 20px;
            border: 1px solid white;
            background-color: rgba(255,255,255,0.2);
            color: white;
            border-radius: 15px;
            cursor: pointer;
        }
        .product-management-overlay .delete-product-btn {
            border-color: #ff8a80;
            color: #ff8a80;
        }
        /* 管理模式下，隱藏“加入購物車”按鈕 */
        #shopping-screen.management-mode .add-to-cart-btn {
            display: none;
        }
        /* ▲▲▲ 新增CSS結束 ▲▲▲ */
        /* ▼▼▼ 【檢查並添加】卡片/特殊內容氣泡佈局規則 ▼▼▼ */
        .message-bubble.is-card-like {
            flex: initial; /* 覆蓋通用的 flex: 1，讓氣泡本身不再拉伸 */
            min-width: auto; /* 允許其自由收縮 */
        }
        .message-bubble.is-card-like .content {
            flex: initial; 
            padding: 0;
            background: transparent;
        }
        /* ▲▲▲ 添加結束 ▲▲▲ */
        /* ▼▼▼ 【全新】修復購物車圖示對齊問題 ▼▼▼ */
        #go-to-cart-btn {
            display: flex;
            align-items: center; /* 核心：垂直居中對齊 */
            gap: 4px; /* 在圖示和數位之間增加一點間距 */
        }
        /* ▲▲▲ 新增CSS結束 ▲▲▲ */
        /* ▼▼▼ 【全新】為禮物接收人清單添加樣式 ▼▼▼ */
        #gift-recipient-list .contact-picker-item {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            cursor: pointer;
            border-bottom: 1px solid var(--border-color);
        }
        #gift-recipient-list .contact-picker-item:last-child {
            border-bottom: none;
        }
        #gift-recipient-list .contact-picker-item .checkbox {
            width: 20px;
            height: 20px;
            border: 2px solid #ccc;
            border-radius: 50%;
            margin-right: 15px;
            transition: all 0.2s ease;
        }
        #gift-recipient-list .contact-picker-item.selected .checkbox {
            background-color: var(--accent-color);
            border-color: var(--accent-color);
        }
        #gift-recipient-list .contact-picker-item .avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            margin-right: 12px;
        }
        #gift-recipient-list .contact-picker-item .name {
            font-weight: 500;
        }
        /* ▲▲▲ 新增CSS結束 ▲▲▲ */
        /* ▼▼▼ 【全新】歌詞欄替換心率顯示器樣式 (最終版) ▼▼▼ */
        
        /* 1. 徹底隱藏舊的心率顯示器，不再需要它了 */
        #ai-heart-rate-display {
            display: none !important;
        }
        
        /* 2. 為歌詞欄應用新的樣式，使其外觀和定位與原心率顯示器完全一致 */
        /* ▼▼▼ 【全新】歌詞欄位置控制樣式 ▼▼▼ */
        #global-lyrics-bar {
            /* 核心定位：絕對定位 */
            position: absolute;
            z-index: 20;
        
            /* 外觀樣式 (保持不變) */
            display: flex;
            align-items: center;
            font-size: 13px;
            font-weight: 500;
            color: var(--text-secondary);
            background-color: rgba(0, 0, 0, 0.05);
            padding: 4px 12px;
            border-radius: 12px;
            
            /* 動畫效果 (保持不變) */
            opacity: 0;
            visibility: hidden;
            /* 【核心修改】為位置屬性添加平滑過渡 */
            transition: opacity 0.4s ease, visibility 0.4s ease, top 0.3s ease, bottom 0.3s ease, left 0.3s ease, right 0.3s ease, transform 0.3s ease;
        
            /* 附加樣式 (保持不變) */
            pointer-events: none;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 65%;
        }
        
        #phone-screen.dark-mode #global-lyrics-bar {
            color: #a0a0a0;
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        /* 3. 當JS添加.visible類時，顯示歌詞欄 */
        #global-lyrics-bar.visible {
            opacity: 1;
            visibility: visible;
        }
        
        /* 4. 適配夜間模式 */
        #phone-screen.dark-mode #global-lyrics-bar {
            color: #a0a0a0;
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        /* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */
        /* ▼▼▼ 【全新】世界書頁面美化樣式 (V2 - 頁簽切換版) ▼▼▼ */
        
        /* 1. 確保世界書頁面背景色統一 */
        #world-book-screen {
            background-color: #f0f2f5;
            display: flex; /* 改為flex佈局，讓頭部、頁簽、內容區垂直排列 */
            flex-direction: column;
        }
        
        #phone-screen.dark-mode #world-book-screen {
            background-color: #000000;
        }
        
        /* 2. 頁簽欄樣式 */
        #world-book-tabs {
            display: flex;
            overflow-x: auto; /* 如果分類太多，可以橫向滾動 */
            padding: 10px 15px 0 15px;
            flex-shrink: 0; /* 防止被壓縮 */
            border-bottom: 1px solid var(--border-color);
            background-color: var(--secondary-bg);
        
            /* 隱藏捲軸 */
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: none;  /* Firefox */
        }
        #world-book-tabs::-webkit-scrollbar {
            display: none; /* Chrome, Safari, and Opera */
        }
        
        
        /* 3. 單個頁簽按鈕樣式 */
        .world-book-tab {
            padding: 8px 16px;
            cursor: pointer;
            border: none;
            background-color: transparent;
            font-size: 15px;
            font-weight: 500;
            color: var(--text-secondary);
            border-bottom: 2px solid transparent;
            margin-bottom: -1px; /* 讓底邊框與容器邊框重合 */
            transition: all 0.2s ease-in-out;
            white-space: nowrap; /* 防止分類名換行 */
        }
        
        /* 4. 啟動的頁簽樣式 */
        .world-book-tab.active {
            color: var(--accent-color);
            border-bottom-color: var(--accent-color);
            font-weight: 600;
        }
        #phone-screen.dark-mode .world-book-tab.active {
            color: #ffffff;
        }
        
        
        /* 5. 內容區總容器，負責滾動 */
        #world-book-content-container {
            flex-grow: 1;
            overflow-y: auto;
        }
        
        /* 6. 單個分類的內容面板，使用Grid佈局美化 */
        .world-book-category-pane {
            display: none; /* 默認隱藏 */
            grid-template-columns: repeat(2, 1fr); /* 每行顯示2本書 */
            gap: 15px;
            padding: 15px;
        }
        
        /* 7. 啟動的內容面板 */
        .world-book-category-pane.active {
            display: grid;
        }
        

/* 8. 美化後的世界書卡片樣式 (最終修復版) */
.world-book-card {
    background-color: var(--secondary-bg);
    border-radius: 12px;
    padding: 15px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    cursor: pointer;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
    display: flex;
    flex-direction: column;
    gap: 8px;
    
    /* 核心修復 1: 允許卡片在網格佈局中正確地收縮，這是解決問題的關鍵 */
    min-width: 0;

    /* 核心修復 2: 強制對所有內容（包括中英文）進行換行，作為雙重保險 */
    word-break: break-all;
}
        
        .world-book-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.12);
        }
        #phone-screen.dark-mode .world-book-card {
            box-shadow: 0 2px 8px rgba(255,255,255,0.05);
        }
        
        .world-book-card .card-title {
            font-weight: 600;
            font-size: 15px;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis; /* 防止長標題溢出 */
        }
        
        .world-book-card .card-content-preview {
            font-size: 13px;
            color: var(--text-secondary);
            line-height: 1.5;
            /* 多行省略效果 */
            display: -webkit-box;
            -webkit-line-clamp: 3; /* 最多顯示3行 */
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        /* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */
        /* ▼▼▼ 【全新】渲染器頁面美化樣式 (V2 - 頁簽切換版) ▼▼▼ */
        
        /* 1. 確保渲染器頁面背景色統一 */
        #rendering-rules-screen {
            background-color: #f0f2f5;
            display: flex; /* 改為flex佈局，讓元素垂直排列 */
            flex-direction: column;
        }
        
        #phone-screen.dark-mode #rendering-rules-screen {
            background-color: #000000;
        }
        
        /* 2. 頁簽欄樣式 (仿世界書) */
        #rules-tabs {
            display: flex;
            overflow-x: auto;
            padding: 10px 15px 0 15px;
            flex-shrink: 0;
            border-bottom: 1px solid var(--border-color);
            background-color: var(--secondary-bg);
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        #rules-tabs::-webkit-scrollbar {
            display: none;
        }
        
        /* 3. 單個頁簽按鈕樣式 */
        .rules-tab {
            padding: 8px 16px;
            cursor: pointer;
            border: none;
            background-color: transparent;
            font-size: 15px;
            font-weight: 500;
            color: var(--text-secondary);
            border-bottom: 2px solid transparent;
            margin-bottom: -1px;
            transition: all 0.2s ease-in-out;
            white-space: nowrap;
        }
        
        /* 4. 啟動的頁簽樣式 */
        .rules-tab.active {
            color: var(--accent-color);
            border-bottom-color: var(--accent-color);
            font-weight: 600;
        }
        #phone-screen.dark-mode .rules-tab.active {
            color: #ffffff;
        }
        
        /* 5. 內容區總容器 */
        #rules-content-container {
            flex-grow: 1;
            overflow-y: auto;
        }
        
        /* 6. 單個分類的內容面板 (Grid佈局) */
        .rules-category-pane {
            display: none; /* 默認隱藏 */
            grid-template-columns: repeat(2, 1fr); /* 每行顯示2個 */
            gap: 15px;
            padding: 15px;
        }
        
        .rules-category-pane.active {
            display: grid;
        }
        
        /* 7. 美化後的規則卡片樣式 */
        .rule-card {
            background-color: var(--secondary-bg);
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            display: flex;
            flex-direction: column;
            gap: 8px; /* 標題和內容的間距 */
            border-left: 5px solid #6c757d; /* 默認給一個灰色邊框 */
        }
        .rule-card.enabled {
            border-left-color: #28a745; /* 啟用的規則用綠色邊框 */
        }
        
        .rule-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.12);
        }
        #phone-screen.dark-mode .rule-card {
            box-shadow: 0 2px 8px rgba(255,255,255,0.05);
        }
        
        .rule-card .card-title {
            font-weight: 600;
            font-size: 15px;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .rule-card .card-content-preview {
            font-size: 12px;
            font-family: monospace; /* 使用等寬字體，顯示正則更清晰 */
            color: var(--text-secondary);
            background-color: #f0f2f5;
            padding: 5px 8px;
            border-radius: 4px;
            word-break: break-all;
        }
        #phone-screen.dark-mode .rule-card .card-content-preview {
            background-color: #2c2c2e;
        }
        
        /* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */

        /* ▼▼▼ 【全新美化版】重新生成回復按鈕樣式 ▼▼▼ */
        .control-btn.regenerate-btn {
            /* 核心修改：將背景色改為與其他功能按鈕一致的半透明灰色 */
            background-color: rgba(255, 255, 255, 0.2);
            background-size: 55%; /* 圖示大小保持不變 */
            /* SVG圖示保持不變，依然是我們的刷新圖示 */
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 11A8.1 8.1 0 0 0 4.5 9M4 5v4h4"/><path d="M4 13a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4"/></svg>');
        }
        /* ▲▲▲ 新增CSS結束 ▲▲▲ */
        /* ▼▼▼ 【全新】推進劇情按鈕樣式 ▼▼▼ */
        .control-btn.propel-btn {
            background-color: rgba(255, 255, 255, 0.2);
            background-size: 55%;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="13 19 22 12 13 5 13 19"></polygon><polygon points="2 19 11 12 2 5 2 19"></polygon></svg>');
        }
        /* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 【全新】這是解決HTML代碼被氣泡樣式“壓縮”的核心CSS ▼▼▼ */

/* 當一個消息氣泡被標記為 is-raw-html 時 */
.message-bubble.is-raw-html .content {
    padding: 0 !important; /* 強制移除所有內邊距 */
    background: transparent !important; /* 強制背景透明 */
    border: none !important; /* 強制移除邊框 */
    box-shadow: none !important; /* 強制移除陰影 */
}
/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 【全新】防止長按時觸發藍色文本選中 ▼▼▼ */

#phone-screen {
    /* 核心屬性，適用于大多數現代流覽器 */
    user-select: none;

    /* 相容舊版 Safari, iOS Safari, Chrome */
    -webkit-user-select: none;

    /* 相容舊版 Firefox */
    -moz-user-select: none;

    /* 相容 Internet Explorer/Edge */
    -ms-user-select: none;

    /* 防止在 iOS 上長按連結、圖片時彈出功能表 */
    -webkit-touch-callout: none;
}

/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 步驟 2：用這整塊新代碼，替換掉所有舊的主螢幕和個人資料相關CSS ▼▼▼ */

/* --- 1. 隱藏所有舊的主螢幕元素 --- */
#home-screen #clock-container,
#home-screen #app-grid,
#home-screen #home-widgets-container {
    display: none !important;
}

/* --- 2. 【最終修復】重新定義主螢幕佈局 --- */

#home-screen {
    background: linear-gradient(135deg, #6DD5FA, #2980B9);
    /* ▼▼▼ 核心修復：添加下面這兩行 ▼▼▼ */
    background-size: cover;
    background-position: center;
    /* ▲▲▲ 修復結束 ▲▲▲ */
    padding: 20px;
    padding-top: calc(20px + env(safe-area-inset-top));
    padding-bottom: calc(20px + env(safe-area-inset-bottom));
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    justify-content: space-between; 
    align-items: center;
    height: 100%;
}

/* --- 替換這一整塊代碼 --- */
/* ▼▼▼ 請用這整塊新代碼替換舊的 #main-content-area 樣式 ▼▼▼ */

#main-content-area {
    width: 100%;
    display: flex;
    flex-direction: column;
    /* 核心修改1：將卡片和下方圖示的間距從60px縮小到30px */
    gap: 30px; 
    align-items: center;
    /* 核心修改2：將頂部的外邊距從40px縮小到20px，給螢幕頂部留出一點呼吸空間即可 */
    margin-top: 20px; 
}

/* ▲▲▲ 替換結束 ▲▲▲ */

/* ▼▼▼ 【最終解決方案】請用這一整塊代碼，替換所有舊的個人資料卡片相關CSS ▼▼▼ */

/* 1. 卡片外層容器：這是所有內部元素定位的“錨點” */
#profile-widget {
    position: relative; /* 關鍵：讓內部的頭像和偽元素可以相對於它進行絕對定位 */
    width: 100%;
    max-width: 380px;
    flex-shrink: 0;
}

/* 2. 背景頭圖：只給頂部設置圓角 */
#profile-banner-img {
    display: block; 
    width: 100%;
    height: 150px;
    object-fit: cover;
    border-radius: 24px 24px 0 0; /* 只給頂部設置圓角 */
    position: relative;
    z-index: 1; /* 讓頭圖在下方 */
}

/* 3. 頭像容器：精確定位，使其中心線與頭圖底部對齊 */
#profile-widget .profile-avatar-container {
    position: absolute;
    top: 80px; 
    left: 50%;
    transform: translateX(-50%);
    width: 80px;
    height: 80px;
    border-radius: 50%;
    background-color: white; 
    padding: 4px; 
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    z-index: 3; /* 頭像層級最高，壓住一切 */
}

#profile-avatar-img {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    object-fit: cover;
}

/* 4. 白色資訊卡片：使用負外邊距實現無縫拼接 */
#profile-widget .profile-info {
    background-color: rgba(255, 255, 255, 0.9);
    border-radius: 24px;
    
    /* --- ★★★★★ 這就是本次修復的核心！ ★★★★★ --- */
    
    /* 1. 使用負外邊距，將卡片向上移動24px（等於其圓角半徑） */
    margin-top: -24px; 
    
    /* 2. 為頭像的下半部分和上方的負邊距，共同留出精確的空間 */
    /* 40px (頭像半徑) + 10px (額外間距) + 24px (抵消負邊距) = 74px */
    padding-top: 44px; 
    
    /* --- ★★★★★ 修復結束 ★★★★★ --- */
    
    min-height: 120px;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    justify-content: center;
    padding-left: 15px;
    padding-right: 15px;
    padding-bottom: 15px;
    text-align: center;
    color: #1c1c1e;
    position: relative;
    z-index: 2; /* 讓資訊卡在頭圖之上，但在頭像之下 */
}

/* ▲▲▲ 替換結束 ▲▲▲ */

/* 5. 強制禁用任何可能殘留的舊偽元素樣式 */
#profile-widget::before {
    display: none !important;
}

/* (這個是頭像圖片本身的樣式，保持不變) */
#profile-avatar-img {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    object-fit: cover;
}

/* ▲▲▲ 替換結束 ▲▲▲ */

/* 5. 強制禁用任何可能殘留的舊偽元素樣式 */
#profile-widget::before {
    display: none !important;
}

/* ▲▲▲ 替換結束 ▲▲▲ */

/* (這個是頭像圖片本身的樣式，保持不變) */
#profile-avatar-img {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    object-fit: cover;
}

/* ▲▲▲ 替換結束 ▲▲▲ */



/* (以下為個人資料內部文字樣式，保持不變) */
#profile-username { font-size: 18px; font-weight: 600; margin: 0 0 2px 0; }
#profile-sub-username { font-size: 13px; color: #8a8a8a; margin: 0 0 10px 0; }
#profile-bio { font-size: 14px; margin: 0 0 12px 0; color: #333; }
#profile-location {
    font-size: 12px; color: #8a8a8a; margin: 0 auto; display: inline-flex;
    align-items: center; gap: 4px; background-color: rgba(0,0,0,0.05);
    padding: 3px 9px; border-radius: 10px;
}

/* --- (從這裡開始，後面的所有樣式都保持不變即可) --- */
#desktop-layout {
    display: grid;
    grid-template-columns: 1fr 1.1fr;
    gap: 20px;
    width: 100%;
    align-items: start;
}
#desktop-widget-column {
    display: flex;
    flex-direction: column;
    gap: 12px;
}
.widget-header {
    font-size: 14px;
    font-weight: 500;
    color: rgba(255, 255, 255, 0.8);
    margin: 0 0 5px 5px;
}
.desktop-widget {
    background-color: rgba(255, 255, 255, 0.2);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 18px;
    padding: 12px 15px;
    /* 核心修改：將顏色從 white 改為接近黑色的深灰色 */
    color: #1f1f1f; 
    font-weight: 500;
    font-size: 13px;
    display: flex;
    align-items: center;
}
/* ▼▼▼ 【全新】這是移除第一個小元件背景框的樣式 ▼▼▼ */

.desktop-widget.text-only {
    background-color: transparent; /* 將背景色設為透明 */
    border: none;                  /* 移除邊框 */
    padding: 0;                    /* 移除內邊距，避免多餘的空白 */
    box-shadow: none;              /* 確保沒有陰影 */
}

/* ▲▲▲ 新增CSS結束 ▲▲▲ */
.desktop-widget.icon-left { justify-content: flex-start; gap: 10px; }
/* This is the NEW code */
.desktop-widget.icon-right {
    justify-content: flex-end; /* Pushes both items to the right */
    gap: 10px;                 /* Adds a nice space between the text and the avatar */
}
.desktop-widget img { width: 28px; height: 28px; border-radius: 50%; object-fit: cover; }
.desktop-widget p, .desktop-widget span { margin: 0; }
#desktop-app-container {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 25px;
    align-content: start;
}
#desktop-dock {
    background-color: rgba(255, 255, 255, 0.15);
    border-radius: 20px;
    padding: 15px 25px;
    display: flex;
    justify-content: center;
    gap: 30px;
    width: fit-content;
    flex-shrink: 0;
    /* ▼▼▼ 核心修改 ▼▼▼ */
    /* 我們為Dock欄增加一個底部外邊距，
       這個邊距由20px的基礎間距和底部的安全距離組成，
       能將它從螢幕底部完美地抬起。 */
    margin-bottom: calc(20px + env(safe-area-inset-bottom));
}
.desktop-app-icon {
    display: flex; flex-direction: column; align-items: center; gap: 8px; cursor: pointer; text-align: center;
}
.icon-bg-desktop {
    width: 55px; height: 55px; border-radius: 14px; background-color: #f0f2f5; justify-content: center; box-shadow: 0 4px 10px rgba(0,0,0,0.1); transition: transform 0.2s ease; overflow: hidden;
}
.icon-bg-desktop img {
    width: 100%; height: 100%; object-fit: cover; border-radius: 0;
}
.desktop-app-icon .label {
    color: #333; font-size: 13px; font-weight: 500;
}
.desktop-app-icon:active .icon-bg-desktop {
    transform: scale(0.9);
}
.editable-text:hover, .editable-image:hover {
    outline: 2px dashed rgba(255, 255, 255, 0.8);
    cursor: pointer;
    opacity: 0.9;
}
/* ▲▲▲ 替換結束 ▲▲▲ */
/* ▼▼▼ 【全新】這是為小元件編輯功能添加的樣式 ▼▼▼ */

/* 為可編輯的元素添加可點擊的游標和過渡效果 */
.editable-text, .editable-image {
    cursor: pointer;
    transition: all 0.2s ease-in-out;
}

/* 滑鼠懸停時，顯示一個半透明的虛線外框，並輕微變暗，提供視覺回饋 */
.editable-text:hover, .editable-image:hover {
    outline: 2px dashed rgba(255, 255, 255, 0.8);
    opacity: 0.9;
    border-radius: 4px; /* 讓外框也有一點圓角 */
}

/* ▲▲▲ 新增CSS結束 ▲▲▲ */

/* ▼▼▼ 【方案A：僅背景漸變，文字保持實體】(可能導致底部文字可讀性下降) ▼▼▼ */

#profile-widget .profile-info {
    /* 1. 將卡片本身的背景設為透明 */
    background: transparent !important;
    /* 2. 建立定位上下文，讓偽元素可以相對於它定位 */
    position: relative;
    z-index: 1; /* 確保文字內容在背景之上 */
}

#profile-widget .profile-info::before {
    /* 3. 創建一個偽元素作為新的背景層 */
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    
    /* 4. 將原本的白色背景和圓角應用到這個背景層上 */
    background-color: rgba(255, 255, 255, 0.9);
    border-radius: 24px;
    
    /* 5. 【核心】只對這個背景層應用漸變消失效果 */
    mask-image: linear-gradient(to bottom, black 50%, transparent 100%);
    -webkit-mask-image: linear-gradient(to bottom, black 50%, transparent 100%);
    
    /* 6. 將背景層放到文字內容的後面 */
    z-index: -1;
}

/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 【全新】聊天設置頁面樣式 ▼▼▼ */
#chat-settings-screen {
    /* 確保頁面是 Flex 容器，讓內容區可以正確地拉伸 */
    display: flex;
    flex-direction: column;
    background-color: #f0f2f5; /* 與其他設置頁保持一致的背景色 */
}

#phone-screen.dark-mode #chat-settings-screen {
     background-color: #000000; /* 夜間模式背景 */
}

#chat-settings-screen .form-container {
    flex-grow: 1;      /* 核心：讓內容區佔據所有剩餘空間 */
    overflow-y: auto;  /* 核心：確保內容過長時可以滾動 */
    padding-top: 100px;  /* 為浮動的 Header 留出足夠的頂部空間 */
    margin-top: -80px;   /* 將內容區向上拉，使其可以滾動到 Header 下方 */
}
/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 【全新】BGM搜索結果彈窗樣式 ▼▼▼ */

.search-result-item {
    display: flex;
    flex-direction: column;
    padding: 12px 18px;
    border-bottom: 1px solid var(--border-color);
    cursor: pointer;
    transition: background-color 0.2s;
}

.search-result-item:hover {
    background-color: rgba(0, 0, 0, 0.1);
}

#phone-screen.dark-mode .search-result-item:hover {
    background-color: rgba(255, 255, 255, 0.1);
}

.search-result-item .title {
    font-weight: 500;
    font-size: 15px;
    color: var(--text-primary);
}

.search-result-item .artist {
    font-size: 12px;
    color: var(--text-secondary);
    margin-top: 4px;
}

.search-result-item .source {
    font-size: 10px;
    color: var(--accent-color);
    background-color: rgba(0, 123, 255, 0.1);
    padding: 2px 6px;
    border-radius: 4px;
    font-weight: bold;
    margin-left: 8px;
}
/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 【全新】音樂播放機專輯封面樣式 ▼▼▼ */
#music-player-cover {
    width: 180px;
    height: 180px;
    border-radius: 15px;
    object-fit: cover;
    box-shadow: 0 8px 25px rgba(0,0,0,0.2);
    margin-bottom: 25px; /* 在封面和標題之間增加間距 */
    transition: opacity 0.5s ease-in-out; /* 讓圖片切換時有淡入淡出效果 */
}
/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 【全新】仿網易雲唱片/歌詞切換樣式 ▼▼▼ */

/* 1. 切換的總容器，負責定位和大小 */
#music-visual-container {
    position: relative;
    width: 220px;
    height: 220px;
    margin-bottom: 25px;
    cursor: pointer;
}

/* 2. 唱片和歌詞視圖的通用樣式，讓它們重疊在一起 */
#vinyl-view, #inline-lyrics-view {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    /* 核心：為切換效果添加平滑的過渡動畫 */
    transition: opacity 0.5s ease, transform 0.5s ease;
}

/* 3. 黑膠唱片視圖的專屬樣式 */
#vinyl-view {
    background-color: #222;
    border-radius: 50%;
    padding: 18px;
    box-shadow: 0 8px 25px rgba(0,0,0,0.3), 
                inset 0 0 0 2px rgba(255, 255, 255, 0.05);
    background-image: repeating-radial-gradient(circle, #333, #333 1px, #222 1px, #222 2px);
    box-sizing: border-box;
}
#vinyl-view #music-player-cover {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    object-fit: cover;
    box-shadow: 0 0 10px rgba(0,0,0,0.5);
    margin: 0; /* 移除舊的外邊距 */
}

/* 4. 內聯歌詞視圖的專屬樣式 */
#inline-lyrics-view {
    /* 預設狀態：完全透明，輕微放大，且不可點擊 */
    opacity: 0;
    transform: scale(1.1);
    pointer-events: none;
    padding: 10px;
    box-sizing: border-box;
}

/* 5. 【核心】切換邏輯 */
/* 當容器擁有 .lyrics-active 類時... */
#music-visual-container.lyrics-active #vinyl-view {
    /* ...唱片視圖消失 */
    opacity: 0;
    transform: scale(0.9);
}
#music-visual-container.lyrics-active #inline-lyrics-view {
    /* ...歌詞視圖出現 */
    opacity: 1;
    transform: scale(1);
    pointer-events: auto;
}

/* 6. 歌詞容器的樣式 (與之前類似，但有微調) */
#inline-lyrics-view #music-lyrics-container {
    width: 100%;
    height: 100%;
}
/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 【全新】頂部歌曲資訊區域樣式 ▼▼▼ */

/* 1. 新的頂部資訊容器 */
#music-info-top {
    text-align: center; /* 讓所有文字居中 */
    flex-shrink: 0;
    margin-bottom: 20px; /* 在資訊和唱片之間增加一些間距 */
}

/* 2. 移除舊的、多餘的邊距，避免雙重間距 */
#music-player-song-title,
#music-player-artist,
#music-time-counter {
    margin-bottom: 5px; /* 統一設置一個較小的行間距 */
}

/* 3. 調整唱片容器的外邊距 */
#music-visual-container {
    margin-bottom: 15px; /* 適當減小唱片和進度條的距離 */
}

/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 【全新】黑膠唱片旋轉動畫 ▼▼▼ */

/* 1. 定義一個名為 "spin-vinyl" 的旋轉動畫 */
@keyframes spin-vinyl {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

/* 2. 創建一個 .spinning 類，應用這個動畫 */
/*    我們希望它無限、勻速地旋轉 */
#vinyl-view.spinning {
  animation: spin-vinyl 12s linear infinite;
}
/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 【全新】單行歌詞顯示樣式 ▼▼▼ */

#single-lyric-display {
    /* 1. 尺寸與定位 */
    height: 40px;          /* 給一個固定的高度，防止文字換行時佈局跳動 */
    line-height: 40px;     /* 垂直居中 */
    width: 100%;           /* 寬度撐滿 */
    margin-top: 15px;      /* 和上方的唱片拉開一些距離 */
    
    /* 2. 文字外觀 */
    text-align: center;    /* 文字居中 */
    font-size: 14px;       /* 字體大小 */
    color: #333;           /* 字體顏色 */
    font-weight: 500;      /* 字體稍微加粗一點 */

    /* 3. 效果與動畫 */
    transition: opacity 0.3s ease; /* 讓文字切換時有淡入淡出效果 */
    white-space: nowrap;           /* 強制不換行 */
    overflow: hidden;              /* 超出部分隱藏 */
    text-overflow: ellipsis;       /* 超出部分顯示省略號 */
}

/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 【全新】切換到全屏歌詞時，隱藏單行歌詞預覽 ▼▼▼ */

#music-visual-container.lyrics-active + #single-lyric-display {
    /* 核心：使用 display: none; 將其徹底隱藏，不占空間 */
    display: none;
}

/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* 1. 彈窗背景 */
#character-profile-modal {
    background-color: rgba(0, 0, 0, 0.3);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
}

/* 2. 卡片主體內容區 */
.character-profile-content {
    width: 320px;
    height: 75vh;
    max-height: 580px;
    background-color: #f0f2f5;
    border-radius: 20px;
    box-shadow: 0 8px 30px rgba(0,0,0,0.12);
    display: flex;
    flex-direction: column;
    position: relative;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
     overflow: visible; /* <--- CHANGE TO THIS */
    /* 【核心修改1】增加頂部的內邊距，讓頭部資訊更舒展 */
    padding-top: 40px; 
}

/* 3. 右上角“查看歷史”圖示按鈕 (保持不變) */
#profile-history-icon-btn {
    position: absolute;
    top: 20px;
    right: 20px;
    width: 36px;
    height: 36px;
    background: none;
    border: none;
    cursor: pointer;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background-color 0.2s;
    padding: 0;
    z-index: 10;
}
#profile-history-icon-btn:hover { background-color: rgba(0,0,0,0.05); }
#profile-history-icon-btn svg { width: 20px; height: 20px; stroke: #b0b0b0; stroke-width: 2; }

/* 4. 主資料頁與歷史記錄頁的容器 */
#profile-main-content, #profile-thoughts-history-view {
    display: flex;
    flex-direction: column;
    width: 100%;
    height: 100%;
    box-sizing: border-box;
}

/* 5. 主資料頁獨有的樣式 */
#profile-main-content {
    padding: 0 25px 25px 25px; /* 移除了頂部padding，因為它已在父元素中定義 */
    /* 【核心修改2】顯著增加卡片之間的垂直間距，解決“擠”的問題 */
    gap: 20px; 
    flex-grow: 1;
    overflow-y: auto;
}

/* 6. 頭部信息區 */
.profile-header {
    display: flex;
    align-items: center;
    gap: 15px;
    flex-shrink: 0;
    /* 【核心修改3】為頭部下方增加明確的邊距 */
    margin-bottom: 10px; 
}
#profile-avatar { width: 60px; height: 60px; border-radius: 12px; object-fit: cover; }
.profile-info { display: flex; flex-direction: column; }
#profile-name { font-size: 20px; font-weight: 600; color: #1f1f1f; }
#profile-id { font-size: 14px; color: #8a8a8a; }
        
/* ▼▼▼ 【全新V2版】心聲與散記卡片樣式 ▼▼▼ */

/* 1. 卡片通用容器樣式 */
.profile-section {
    background-color: #ffffff; /* 乾淨的白色背景 */
    border-radius: 16px;
    padding: 20px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.06); /* 柔和的卡片陰影 */
    display: flex;
    flex-direction: column;
    gap: 12px; /* 頭部和內容區的間距 */
    flex-shrink: 0;
}

/* 2. 卡片頭部容器 */
.profile-section-header {
    display: flex;
    align-items: center;
    gap: 10px; /* 圖示和文字的間距 */
    padding-bottom: 12px;
    border-bottom: 1px solid #f0f0f0; /* 一條精緻的分割線 */
}

/* 3. 卡片頭部圖示樣式 */
.profile-section-icon {
    font-size: 20px;
    opacity: 0.5;
}

/* 4. 卡片頭部標題文字 ("心聲", "散記") */
.profile-section label {
    font-size: 15px;
    font-weight: 600;
    color: #555; /* 比之前更深的顏色，更有質感 */
    margin: 0; /* 移除舊的邊距 */
}

/* 5. 卡片內容區文字 (保持不變) */
.profile-section p {
    font-size: 15px;
    color: #333;
    line-height: 1.7;
    margin: 0;
    white-space: pre-wrap;
}

/* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */
        
/* 10. 歷史記錄頁面特定樣式 (保持不變) */
#profile-thoughts-history-view { display: none; padding: 0 25px 25px 25px; }
#profile-thoughts-history-view .profile-header { justify-content: space-between; padding-bottom: 15px; }
#profile-thoughts-history-view .profile-header span { font-size: 18px; font-weight: 600; }
#history-back-btn { width: 36px; height: 36px; background: none; border: none; cursor: pointer; border-radius: 50%; display: flex; align-items: center; justify-content: center; transition: background-color 0.2s; padding: 0; }
#history-back-btn:hover { background-color: rgba(0,0,0,0.05); }
#history-back-btn svg { width: 22px; height: 22px; stroke: #a0a0a0; stroke-width: 2.5; }

/* 11. 歷史記錄清單 (保持不變) */
#thoughts-history-list {
    flex-grow: 1;
    overflow-y: auto;
    padding-right: 5px;
    margin-right: -10px;
    display: flex;
    flex-direction: column;
    gap: 15px;
}
.thought-card { background-color: #ffffff; border-radius: 16px; padding: 15px 20px; border: 1px solid #eee; }
.thought-header { font-size: 12px; color: #b0b0b0; margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid #f0f0f0; }
.thought-content .label { display: flex; align-items: center; gap: 6px; font-weight: 600; color: #a0a0a0; font-size: 13px; margin-bottom: 6px; }
.thought-content .label svg { width: 16px; height: 16px; }
.thought-content .text { font-size: 14px; color: #555; line-height: 1.7; white-space: pre-wrap; padding-left: 22px; }
.thought-content .jottings { margin-top: 15px; }

/* 12. 隱藏捲軸 (保持不變) */
#profile-main-content::-webkit-scrollbar,
#thoughts-history-list::-webkit-scrollbar { display: none; }
#profile-main-content, #thoughts-history-list { -ms-overflow-style: none; scrollbar-width: none; }
/* ▼▼▼ 【最終版】心聲頁面與歷史記錄美化樣式 ▼▼▼ */

/* 1. 將角色詳情頁（心聲頁面）的背景修改為純白色 */
.character-profile-content {
    background-color: #ffffff !important;
}

/* 2. 僅隱藏“散記”標籤 (在主頁和歷史記錄中都生效) */
#character-profile-modal .jottings .label {
    display: none;
}

/* 3. 【對齊修正】移除心聲和散記內容的左邊距，讓它們與標題對齊 */
#character-profile-modal .thought-content .text {
    padding-left: 0;
}

/* ▲▲▲ 樣式結束 ▲▲▲ */
/* ▼▼▼ 步驟 2：將這段全新的CSS代碼，黏貼到 <style> 標籤的最末尾 ▼▼▼ */

/* 為動態頁面的“三點”按鈕設置專屬樣式 */
#qzone-more-actions-btn {
    font-size: 24px;      /* 增大字體，讓“…”更清晰 */
    font-weight: bold;    /* 加粗 */
    padding: 0 10px;      /* 增加水準可點擊區域 */
    border-radius: 50%;   /* 添加一個圓形背景（懸停時可見） */
    line-height: 1;       /* 確保垂直居中 */
    position: relative;
    top: -2px;            /* 位置微調 */
    transition: background-color 0.2s;
}
#qzone-more-actions-btn:hover {
    background-color: rgba(0,0,0,0.05); /* 滑鼠懸停時顯示一個淡淡的灰色圓形背景 */
}

/* 夜間模式下的懸停效果 */
#phone-screen.dark-mode #qzone-more-actions-btn:hover {
    background-color: rgba(255,255,255,0.1);
}

/* ▲▲▲ 新增CSS黏貼結束 ▲▲▲ */
/* ▼▼▼ 步驟 2：將這段【全新的CSS代碼】，黏貼到 <style> 標籤的最末尾 ▼▼▼ */

/* 清空動態選擇清單的樣式 */
#clear-posts-list {
    overflow-y: auto; /* 內容過長時可以滾動 */
    flex-grow: 1;
}

/* 每一個可勾選的項目 */
.clear-posts-item {
    display: flex;
    align-items: center;
    padding: 12px 18px;
    cursor: pointer;
    border-bottom: 1px solid var(--border-color);
    transition: background-color 0.2s;
}
.clear-posts-item:hover {
    background-color: #f5f5f5;
}

/* 模擬的勾選框 */
.clear-posts-item .checkbox {
    width: 22px;
    height: 22px;
    border: 2px solid #ccc;
    border-radius: 50%;
    margin-right: 15px;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
}
/* 選中後的樣式 */
.clear-posts-item.selected .checkbox {
    background-color: var(--accent-color);
    border-color: var(--accent-color);
}
/* 為勾選框添加一個“✔”號 */
.clear-posts-item.selected .checkbox::after {
    content: '✔';
    font-size: 14px;
    font-weight: bold;
}

/* 項目名稱 */
.clear-posts-item .name {
    font-weight: 500;
}

/* 為危險選項（如“清空所有”）添加紅色警告樣式 */
.clear-posts-item.danger-option .name {
    color: #ff3b30;
    font-weight: 600;
}

/* ▲▲▲ 新增CSS黏貼結束 ▲▲▲ */
/* ▼▼▼ 步驟 2：將這段【全新的CSS代碼】，黏貼到 <style> 標籤的最末尾 ▼▼▼ */

/* 1. 讓心聲卡片成為刪除按鈕的定位錨點 */
.thought-card {
    position: relative; /* 關鍵！ */
}

/* 2. 刪除按鈕的樣式 */
.thought-delete-btn {
    position: absolute;
    top: 10px;
    right: 10px;
    width: 26px;
    height: 26px;
    border-radius: 50%;
    border: none;
    background-color: rgba(0,0,0,0.05);
    color: var(--text-secondary);
    font-size: 20px;
    line-height: 26px;
    text-align: center;
    cursor: pointer;
    opacity: 0; /* 默認隱藏 */
    transition: all 0.2s ease-in-out;
}

/* 3. 滑鼠懸停在卡片上時，顯示刪除按鈕 */
.thought-card:hover .thought-delete-btn {
    opacity: 1;
}

/* 4. 滑鼠懸停在刪除按鈕上時，變為紅色警告 */
.thought-delete-btn:hover {
    background-color: #ff3b30;
    color: white;
}
/* ▲▲▲ 新增CSS黏貼結束 ▲▲▲ */
/* ▼▼▼ 【全新】BGM搜索結果彈窗美化 (多選支持版) ▼▼▼ */



/* 2. 讓列表項支援Flex佈局，為核取方塊留出空間 */
.search-result-item {
    display: flex;       /* 改為Flex佈局 */
    align-items: center; /* 垂直居中 */
    padding: 12px 18px;
    border-bottom: 1px solid var(--border-color);
    cursor: pointer;
    transition: background-color 0.2s;
}
.search-result-item:hover {
    background-color: rgba(0, 0, 0, 0.05);
}
#phone-screen.dark-mode .search-result-item:hover {
    background-color: rgba(255, 255, 255, 0.1);
}

/* 3. 讓歌曲資訊部分佔據剩餘空間 */
.search-result-item .search-result-info {
    flex-grow: 1;
    pointer-events: none; /* 讓點擊穿透到父元素 */
}

/* 4. 核取方塊樣式 */
.search-result-item .music-search-checkbox {
    width: 20px;
    height: 20px;
    margin-right: 15px;
    flex-shrink: 0;
}

/* 5. 調整彈窗頭部，為“全選”留出空間 */
#music-search-results-modal .modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

/* 6. 調整彈窗頁腳，容納兩個按鈕 */
#music-search-results-modal .modal-footer {
    display: flex;
    justify-content: space-around;
}
#music-search-results-modal .modal-footer button {
    width: 45%; /* 讓每個按鈕佔據近一半寬度 */
}
/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 【全新】美化外觀設置頁面的次要按鈕 ▼▼▼ */
.bg-upload-container {
    /* 確保容器內的按鈕能正確對齊 */
    width: 100%;
    justify-content: center;
    gap: 15px; /* 增加按鈕之間的間距 */
}

.bg-upload-container .form-button-secondary {
    flex-grow: 1; /* 讓按鈕自動填充空間 */
    flex-basis: 0; /* 確保flex-grow生效 */
    max-width: 180px; /* 給一個最大寬度，避免在寬屏上拉伸過度 */
    margin-top: 0;
    padding: 12px; /* 適中的內邊距，讓按鈕更飽滿 */
    font-size: 15px;
    font-weight: 600; /* 與主按鈕一致的字重 */
    border-radius: 8px; /* 與主按鈕一致的圓角 */
    border: none; /* 移除邊框，更像iOS風格 */
    background-color: #e9e9eb; /* iOS風格的淺灰色 */
    color: #1c1c1e; /* 深色文字 */
    cursor: pointer;
    transition: background-color 0.2s, transform 0.1s;
}

.bg-upload-container .form-button-secondary:active {
    transform: scale(0.98); /* 添加點擊回饋 */
}

/* 為“移除”按鈕設置特殊的警告色 */
#remove-global-bg-btn {
    background-color: #ffebee;
    color: #c62828;
}
/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 【全新】心聲/散記卡片票根樣式 ▼▼▼ */

/* 1. 為卡片主體設置相對定位和溢出隱藏，這是實現效果的基礎 */
#character-profile-modal .character-profile-content {
    position: relative; /* 讓偽元素可以相對於它定位 */
    overflow: visible;  /* 【核心修改】允許偽元素“溢出”到外面一點，形成打孔效果 */
    padding-bottom: 35px; /* 增加底部內邊距，防止內容與底部打孔重疊 */
}

/* 2. 創建頂部的打孔效果 */
#character-profile-modal .character-profile-content::before {
    content: '';
    position: absolute;
    top: -10px; /* 向上移動，露出一半 */
    left: 0;
    right: 0;
    height: 20px; /* 打孔條的高度 */
    /* 核心：使用徑向漸變創建重複的半圓形“孔” */
    background-image: radial-gradient(circle at 50% 0, transparent 8px, #f0f2f5 8px);
    background-size: 25px 20px; /* 控制每個孔的大小和間距 */
    background-repeat: repeat-x;
}

/* 3. 創建底部的打孔效果 */
#character-profile-modal .character-profile-content::after {
    content: '';
    position: absolute;
    bottom: -10px; /* 向下移動，露出一半 */
    left: 0;
    right: 0;
    height: 20px; /* 打孔條的高度 */
    /* 核心：與頂部類似，但圓心位置相反 */
    background-image: radial-gradient(circle at 50% 100%, transparent 8px, #f0f2f5 8px);
    background-size: 25px 20px; /* 控制每個孔的大小和間距 */
    background-repeat: repeat-x;
}

/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 【全新】票根樣式美化 (直角 + 純白背景) ▼▼▼ */

/* 1. 覆蓋主容器樣式，改為直角和白色背景 */
#character-profile-modal .character-profile-content {
    border-radius: 0;         /* 核心修改1: 移除圓角，變為直角 */
    background-color: #ffffff; /* 核心修改2: 將背景色改為純白色 */
}

/* 2. 覆蓋頂部打孔條的顏色，與新的白色背景統一 */
#character-profile-modal .character-profile-content::before {
    /* 核心修改3: 將打孔條的顏色從灰色改為純白色 */
    background-image: radial-gradient(circle at 50% 0, transparent 8px, #ffffff 8px);
}

/* 3. 覆蓋底部打孔條的顏色，與新的白色背景統一 */
#character-profile-modal .character-profile-content::after {
    /* 核心修改4: 將打孔條的顏色也改為純白色 */
    background-image: radial-gradient(circle at 50% 100%, transparent 8px, #ffffff 8px);
}

/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 【全新】為心聲/散記卡片添加票根分割線 ▼▼▼ */

/* 1. 為頭部區域（時間戳記）添加相對定位和空間，作為分割線的“錨點” */
#character-profile-modal .thought-header {
    position: relative;
    width: 100%;
    /* 增加底部內邊距，為分割線創造空間 */
    padding-bottom: 15px; 
    /* 增加底部外邊距，將下方的“心聲”內容推開 */
    margin-bottom: 25px; 
    /* 這就是中間的灰色虛線 */
    border-bottom: 2px dashed #e0e0e0; 
}

/* ▼▼▼ 【最終修復】票根分割線打孔透明效果 ▼▼▼ */


/* 2. 重新創建左側的“打孔”，使其顏色與頁面背景一致 */
#character-profile-modal .thought-header::before {
    content: '';
    position: absolute;
    bottom: -11px;
    left: -35px;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    /* 核心修復：使用頁面的背景色 (#f0f2f5) 來“偽裝”透明效果 */
    background-color:  rgba(0, 0, 0, 0.3);
}

/* 3. 重新創建右側的“打孔” */
#character-profile-modal .thought-header::after {
    content: '';
    position: absolute;
    bottom: -11px;
    right: -35px;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    /* 核心修復：顏色與頁面背景保持一致 */
    background-color:  rgba(0, 0, 0, 0.3);
}

/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 【最終版】角色資料卡固定背景圖樣式 (直角) ▼▼▼ */

/* ▼▼▼ 【最終圖片顯示修復】請用這整塊代碼替換舊的 .thought-header 樣式 ▼▼▼ */
#character-profile-modal .thought-header {
    height: 140px;         /* 保持固定的、防壓縮的高度 */
    flex-shrink: 0;
    padding: 10px;         /* 在圖片四周留出“畫框”邊距 */
    padding-bottom: 25px;  /* 加大底部邊距，將圖片與虛線分開 */
    box-sizing: border-box;
    border-bottom: 2px dashed #e0e0e0; /* 恢復虛線分割線 */
    margin-bottom: 25px;
    position: relative;     /* 保持，為了讓打孔能正確定位 */

    /* --- 核心修復：在這裡重新添加背景圖片 --- */
    background-image: url('https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1758340625111_qdqqd_zqr2cl.jpeg'); /* <-- 請在這裡替換為您自己的圖片URL */
    background-size: cover;
    background-position: center top;
    border-radius: 0;      /* 確保圖片容器是直角的 */
}
/* ▲▲▲ 替換結束 ▲▲▲ */

/* 2. 移除之前為JS動態圖片準備的樣式（可選，但推薦） */
#profile-photo-slot {
    display: none; /* 隱藏掉JS可能創建的<img>標籤 */
}

/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 【最終修復】隔離資料卡樣式，防止洩露到歷史記錄 ▼▼▼ */

/* ▼▼▼ 【最終修復】隔離資料卡樣式，防止洩露到歷史記錄 ▼▼▼ */

/* 1. 【核心】使用更精確的選擇器，確保照片區域只出現在主資料頁上 */
#character-profile-modal #profile-main-content .thought-header {
   // height: 120px;
    //padding-bottom: 15px; /* 步驟1：保留足夠的空間，將虛線向下推 */
    box-sizing: border-box;
    background-image: url('https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1758340625111_qdqqd_zqr2cl.jpeg');
    background-size: cover;
    background-position: center top;
    border-bottom: 2px dashed #e0e0e0;
    margin-bottom: 15px;
    
    /* ▼▼▼ 步驟2：這就是解決問題的關鍵！▼▼▼ */
    /* 強制背景圖只在內容區繪製，不要進入我們用padding撐開的空白區域 */
    background-clip: content-box; 
    -webkit-background-clip: content-box; /* 相容舊版流覽器 */
    /* ▲▲▲ 關鍵代碼結束 ▲▲▲ */
}

/* 2. 【核心】確保打孔效果也只出現在主資料頁上 */
#character-profile-modal #profile-main-content .thought-header::before,
#character-profile-modal #profile-main-content .thought-header::after {
    content: '';
    position: absolute;
    bottom: -11px;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background-color: rgba(0, 0, 0, 0.3);
}
#character-profile-modal #profile-main-content .thought-header::before {
    left: -35px;
}
#character-profile-modal #profile-main-content .thought-header::after {
    right: -35px;
}

/* 3. 【重要】將歷史記錄頁裡的小卡片頭部樣式，強制恢復為原始的簡潔樣式 */
#character-profile-modal #thoughts-history-list .thought-card .thought-header {
    height: auto;
    padding: 0;
    padding-bottom: 8px; /* 恢復底部的小間距 */
    margin-bottom: 12px;
    background-image: none; /* 移除背景圖 */
    border: none; /* 移除所有邊框 */
    border-bottom: 1px solid #f0f0f0; /* 只保留底部的細分割線 */
}

/* 4. 【重要】在歷史記錄的小卡片上，強制隱藏掉打孔的偽元素 */
#character-profile-modal #thoughts-history-list .thought-card .thought-header::before,
#character-profile-modal #thoughts-history-list .thought-card .thought-header::after {
    display: none !important; /* 強制不顯示 */
}

/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 【全新】心聲/散記美化與字體修復 ▼▼▼ */

/* 
  第一步：強制顯示“心聲”和“散記”的標籤。
  我們使用 !important 來確保這條規則的優先順序最高，
  可以覆蓋掉任何之前可能存在的 display: none; 隱藏規則。
*/
#character-profile-modal #profile-main-content .label {
    display: flex !important;
}

/* 
  第二步：為“心聲”和“散記”的正文內容更換字體。
  這裡以常見的宋體(SimSun)為例，您可以替換成任何您喜歡的字體名稱。
*/
#character-profile-modal #profile-main-content .text {
    font-family: "SimSun", "Songti SC", serif; /* 示例：更換為宋體 */
    font-size: 16px; /* (可選) 稍微放大字體，讓宋體更清晰 */
}

/* ▲▲▲ 新增CSS黏貼結束 ▲▲▲ */
/* ▼▼▼ 【最終修復】強制將心聲/散記內容變為純黑色 ▼▼▼ */

/* 1. 將“心聲”和“散記”的標題文字和圖示變為黑色 */
#character-profile-modal .thought-content .label {
    color: #000000 !important;
}

/* 2. 將“心聲”和“散記”的正文段落文字變為黑色 */
#character-profile-modal .thought-content .text {
    color: #000000 !important;
}

/* ▲▲▲ 新增CSS黏貼結束 ▲▲▲ */
/* ▼▼▼ 【全新】修復心聲/資料卡頁面左右滑動問題 ▼▼▼ */
#character-profile-modal #profile-main-content {
    overflow-x: hidden;
}
/* ▲▲▲ 新增CSS結束 ▲▲▲ */
        /* ▼▼▼ 【全新】表情包分類功能樣式 ▼▼▼ */

        /* 1. 分類頁簽容器樣式 */
        #sticker-category-tabs {
            display: flex;
            overflow-x: auto;
            padding: 0 15px; /* 左右留白 */
            flex-shrink: 0;
            border-bottom: 1px solid var(--border-color);
            background-color: var(--secondary-bg);
            /* 隱藏捲軸 */
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        #sticker-category-tabs::-webkit-scrollbar {
            display: none;
        }

        /* 2. 單個頁簽按鈕樣式 */
        .sticker-category-tab {
            padding: 10px 16px; /* 增加上下內邊距，讓頁簽更高一些 */
            cursor: pointer;
            border: none;
            background-color: transparent;
            font-size: 14px;
            font-weight: 500;
            color: var(--text-secondary);
            border-bottom: 2px solid transparent;
            margin-bottom: -1px; /* 讓底邊框與容器邊框重合 */
            transition: all 0.2s ease-in-out;
            white-space: nowrap; /* 防止分類名換行 */
        }

        /* 3. 啟動的頁簽樣式 */
        .sticker-category-tab.active {
            color: var(--accent-color);
            border-bottom-color: var(--accent-color);
            font-weight: 600;
        }

        #phone-screen.dark-mode .sticker-category-tab.active {
            color: #ffffff;
        }
        /* ▲▲▲ 新增CSS結束 ▲▲▲ */
        /* ▼▼▼ 【全新】表情批量刪除與全選功能樣式 ▼▼▼ */
        
        /* 管理模式下，為表情項添加一個選中框 */
        #sticker-grid.management-mode .sticker-item::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: 3px solid transparent;
            border-radius: 10px;
            box-sizing: border-box;
            transition: border-color 0.2s;
            pointer-events: none; /* 確保不影響點擊 */
        }
        
        /* 管理模式下，被選中的表情項，顯示藍色邊框 */
        #sticker-grid.management-mode .sticker-item.selected::after {
            border-color: var(--accent-color);
        }
        
        /* 管理模式下，總是顯示刪除按鈕 */
        #sticker-grid.management-mode .sticker-item .delete-btn {
            display: block;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            border: 1px solid white;
        }
        
        /* 【全新】底部批量刪除操作欄 */
        #sticker-action-bar {
            display: none; /* 默認隱藏 */
            flex-shrink: 0;
            padding: 10px 15px;
            padding-bottom: calc(10px + env(safe-area-inset-bottom));
            background-color: rgba(247, 247, 247, 0.9);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-top: 1px solid var(--border-color);
            justify-content: space-between; /* 讓“全選”和“刪除”兩端對齊 */
            align-items: center;
        }
        
        #sticker-action-bar .select-all-label {
            font-size: 16px;
            color: var(--text-primary);
            cursor: pointer;
        }

        #sticker-action-bar button {
            padding: 10px 25px;
            border-radius: 20px;
            border: none;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            background-color: #ff3b30;
            color: white;
        }
        /* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 【全新 V2.0】Cphone功能的所有CSS樣式 ▼▼▼ */

/* --- 1. 角色選擇介面 (保持不變) --- */
#character-selection-screen { background-color: #f0f2f5; }
#phone-screen.dark-mode #character-selection-screen { background-color: #000; }
/* --- 請用這一整塊【全新】的CSS，替換舊的 #character-grid 和 .character-select-item 相關的所有樣式 --- */

/* 1. 將網格容器變為列表容器 */
#character-grid {
    /* 移除了 display: grid 和相關屬性 */
    padding: 0; /* 移除內邊距，由列表項自己控制 */
    overflow-y: auto; /* 確保內容超出時可以滾動 */
    flex-grow: 1;
}

/* 2. 修改每個列表項的佈局，從垂直變為水準 */
.character-select-item {
    display: flex;
    flex-direction: row;     /* 核心修改：從 column 變為 row */
    align-items: center;     /* 保持垂直居中 */
    cursor: pointer;
    padding: 12px 20px;      /* 增加內邊距，形成列表項外觀 */
    border-bottom: 1px solid var(--border-color); /* 添加分割線 */
    gap: 15px;               /* 在頭像和名字之間增加間距 */
    transition: background-color 0.2s; /* 添加懸停效果 */
    /* 移除了 text-align: center */
}
.character-select-item:hover {
    background-color: #f5f5f5; /* 滑鼠懸停時高亮 */
}


/* 3. 調整頭像大小和樣式 */
.character-select-item .avatar {
    width: 45px;             /* 核心修改：縮小頭像尺寸 */
    height: 45px;
    border-radius: 50%;      /* 改為圓形，更適合列表視圖 */
    object-fit: cover;
    margin-bottom: 0;        /* 移除底部外邊距 */
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    transition: transform 0.2s ease;
    flex-shrink: 0;          /* 防止頭像被壓縮 */
}

/* 4. 調整名字樣式 */
.character-select-item .name {
    font-weight: 500;
    font-size: 16px;         /* 稍微增大字體，提高可讀性 */
    color: var(--text-primary);
}
/* --- 替換結束 --- */

/* --- 2. Cphone主容器與螢幕切換 (保持不變) --- */
#character-phone-screen { background-size: cover; background-position: center; }
.char-screen { width: 100%; height: 100%; position: absolute; top: 0; left: 0; display: flex; flex-direction: column; overflow: hidden; opacity: 0; visibility: hidden; transition: opacity 0.3s, visibility 0.3s; }
.char-screen.active { opacity: 1; visibility: visible; z-index: 2; }

/* --- 3. Cphone主螢幕 (保持不變) --- */
#char-home-screen { justify-content: flex-start; align-items: center; box-sizing: border-box; padding: 0 20px; }
#char-clock-container { text-align: center; color: white; text-shadow: 0 3px 8px rgba(0,0,0,0.4); margin-top: calc(60px + env(safe-area-inset-top)); flex-shrink: 0; margin-bottom: 100px; }
#char-main-time { font-size: 88px; font-weight: 600; letter-spacing: -2px; font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", sans-serif; }
#char-main-date { font-size: 22px; font-weight: normal; }
#char-app-grid { display: flex; flex-direction: column; align-items: center; gap: 20px; width: 100%; }

/* --- 4. Cphone內的App通用背景色 (已擴展) --- */
#char-qq-screen, #char-memo-screen, #char-diary-screen, #char-usage-screen, 
#char-album-screen, #char-browser-screen, #char-taobao-screen {
     background-color: var(--secondary-bg);
}

/* --- 5. 備忘錄、日記、使用記錄清單樣式 (保持不變) --- */
.memo-item, .diary-item, .usage-item { padding: 15px 20px; border-bottom: 1px solid var(--border-color); cursor: pointer; }
.memo-item .content, .diary-item .content { font-size: 16px; color: var(--text-primary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.diary-item .date, .usage-item .timestamp { font-size: 12px; color: var(--text-secondary); margin-bottom: 5px; }
.usage-item .action { font-size: 15px; color: var(--text-primary); }

/* --- 6. 【全新】角色相冊樣式 --- */
#char-album-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr); /* 每行3張圖 */
    gap: 5px;
    padding: 5px;
}
.char-photo-item {
    aspect-ratio: 1 / 1; /* 保持正方形 */
    background-size: cover;
    background-position: center;
    background-color: #e9ecef;
}

/* --- 7. 【全新】角色流覽器歷史樣式 --- */
.char-browser-item {
    padding: 12px 20px;
    border-bottom: 1px solid var(--border-color);
}
.char-browser-item .title {
    font-weight: 500;
    font-size: 15px;
    color: var(--text-primary);
    margin-bottom: 4px;
}
.char-browser-item .url {
    font-size: 12px;
    color: var(--accent-color);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* --- 8. 【全新】角色淘寶頁面樣式 (複用主購物頁樣式) --- */
#char-product-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 10px;
    padding: 10px;
}
.char-product-item {
    background-color: #fff;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.04);
    display: flex;
    flex-direction: column;
}
.char-product-item .product-image {
    width: 100%;
    aspect-ratio: 1 / 1;
    object-fit: cover;
    border-radius: 8px 8px 0 0;
}
.char-product-item .product-info {
    padding: 12px 10px;
    flex-grow: 1;
}
.char-product-item .product-name {
    font-size: 13px;
    color: #333;
    line-height: 1.4;
    min-height: 36px;
}
.char-product-item .product-price {
    font-size: 16px;
    font-weight: 700;
    color: #ff5722;
    margin-top: 8px;
}
.char-product-item .product-price::before { content: '¥'; font-size: 12px; }

/* ▲▲▲ 全新CSS黏貼結束 ▲▲▲ */
/* ▼▼▼ 【全新V2.0】CphoneQQ類比功能樣式 ▼▼▼ */
#char-qq-screen .list-container {
    padding: 0; /* 移除容器的內邊距 */
}
/* ▲▲▲ 新增CSS黏貼結束 ▲▲▲ */
/* ▼▼▼ 【全新】CphoneQQ類比聊天記錄彈窗樣式 ▼▼▼ */

/* 1. 讓彈窗內容區擁有和主聊天介面一樣的佈局 */
#transcript-modal-body {
    display: flex;
    flex-direction: column;
    gap: 20px; /* 消息氣泡之間的間距 */
    padding: 15px; /* 內邊距 */
    background-color: #f0f2f5;
}

/* 2. 夜間模式適配 */
#phone-screen.dark-mode #transcript-modal-body {
    background-color: #000000;
}

/* ▲▲▲ 新增CSS黏貼結束 ▲▲▲ */
/* ▼▼▼ 【全新V2.0 | 最終佈局修復】請用這整塊代碼，替換掉您上一次黏貼的 #char-chat-list 相關的CSS ▼▼▼ */

/* 1. 為兩個列表的列表項（主QQ列表和角色QQ列表）設置統一的 Flexbox 佈局 */
#chat-list .chat-list-item,
#char-chat-list .chat-list-item {
    display: flex;
    align-items: center;
    gap: 15px; /* 【核心修復1】使用 gap 屬性在頭像和文字之間創建間距，這比 margin 更現代、更可靠 */
}

/* 2. 確保頭像容器（無論在哪一個列表中）都絕對不會被壓縮 */
#chat-list .chat-list-item .avatar-group,
#char-chat-list .chat-list-item .avatar-group {
    flex-shrink: 0;
    /* 移除了舊的 margin-right，因為現在由父元素的 gap 屬性統一控制間距 */
}

/* 3. 確保文字資訊區域（無論在哪一個列表中）都能夠正確地伸縮 */
#chat-list .chat-list-item .info,
#char-chat-list .chat-list-item .info {
    flex-grow: 1;
    min-width: 0; /* 關鍵！允許容器收縮，從而防止內部的長文字撐破佈局導致重疊 */
}
/* ▲▲▲ 替換結束 ▲▲▲ */
/* ▼▼▼ 【全新】CphoneQQ類比對話頁面美化樣式 ▼▼▼ */

/* 1. 讓彈窗內容區擁有和主聊天介面一樣的佈局 */
#char-qq-conversation-screen .list-container {
    display: flex;
    flex-direction: column;
    gap: 20px; /* <-- 核心：添加20px的間距 */
    padding: 15px; /* <-- 新增：在四周增加內邊距，避免氣泡貼邊 */
    background-color: #f0f2f5;
}

/* 2. 夜間模式適配 */
#phone-screen.dark-mode #char-qq-conversation-screen .list-container {
    background-color: #000000;
}
/* ▼▼▼ 【全新】CphoneApp通用背景色 (已修復) ▼▼▼ */
#char-qq-screen, 
#char-memo-screen, 
#char-diary-screen, 
#char-usage-screen, 
#char-album-screen, 
#char-browser-screen, 
#char-taobao-screen,
/* --- 【核心修復】將新的文章頁面也加入這個規則，確保它有正確的背景色 --- */
#char-browser-article-screen {
     background-color: var(--secondary-bg);
}
/* ▲▲▲ 修復結束 ▲▲▲ */
/* ▼▼▼ 【全新】CphoneApp通用背景色 (已修復錢包頁面) ▼▼▼ */
#char-qq-screen, 
#char-memo-screen, 
#char-diary-screen, 
#char-usage-screen, 
#char-album-screen, 
#char-browser-screen, 
#char-taobao-screen,
#char-browser-article-screen,
/* --- 【核心修復】將新的錢包頁面也加入這個規則，確保它有正確的背景色 --- */
#char-wallet-screen {
     background-color: var(--secondary-bg);
}
/* ▲▲▲ 修復結束 ▲▲▲ */
/* ▼▼▼ 【全新】Cphone備忘錄詳情頁樣式 ▼▼▼ */

#char-memo-detail-content {
    width: 100%;
    height: 100%;
    border: none;
    background-color: transparent;
    font-size: 16px;
    line-height: 1.7; /* 增加行高，更易讀 */
    padding: 15px 20px; /* 增加左右內邊距 */
    box-sizing: border-box;
    resize: none; /* 禁止用戶拖動調整大小 */
    outline: none; /* 移除選中時的藍色邊框 */
    font-family: inherit; /* 繼承頁面字體 */
    color: var(--text-primary); /* 確保文字顏色能適配夜間模式 */
}

/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 【全新】Cphone備忘錄詳情頁美化 (仿iOS Notes App) ▼▼▼ */

/* 1. 讓詳情頁擁有自己的、能適配夜間模式的背景色 */
#char-memo-detail-screen {
    background-color: var(--secondary-bg);
}

/* 2. 美化頭部，添加分割線，並調整內邊距 */
#char-memo-detail-screen .header {
    background-color: var(--secondary-bg); /* 與頁面背景色統一 */
    border-bottom: 1px solid var(--border-color); /* 添加精緻的分割線 */
    
    padding-bottom: 10px;
}

/* 3. 【核心】強制標題居中顯示 */
#char-memo-detail-title {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    font-weight: 600; /* 標題加粗 */
}

/* 4. 移除內容容器的預設內邊距，讓文本區能撐滿 */
#char-memo-detail-screen .form-container {
    padding: 0;
}

/* 5. 美化文本區域，使其看起來像一個真正的筆記頁面 */
#char-memo-detail-content {
    background-color: var(--secondary-bg); /* 背景色與頭部統一，形成整體感 */
    padding: 15px 20px; /* 增加頂部和左右的內邊距，讓文字有呼吸空間 */
    font-size: 17px; /* 仿iOS備忘錄的字體大小 */
    line-height: 1.7; /* 更寬鬆的行高，提升閱讀體驗 */
    color: var(--text-primary);
}

/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 【全新】Cphone日記詳情頁“信紙”樣式 ▼▼▼ */

/* 1. 詳情頁主螢幕，使用柔和的米白色背景 */
#char-diary-detail-screen {
    background-color: #FDFBF5; /* 柔和的信紙底色 */
}

/* 夜間模式下的適配 */
#phone-screen.dark-mode #char-diary-detail-screen {
    background-color: #2c2c2e; /* 深色背景 */
}

/* 2. 移除內容區的預設內邊距，讓我們的“信紙”能撐滿 */
#char-diary-detail-content-wrapper {
    padding: 0;
    overflow-y: auto; /* 確保長日記可以滾動 */
}

/* 3. “信紙”本身的核心樣式 */
#char-diary-detail-content {
    padding: 25px 20px; /* 在信紙四周留出舒適的邊距 */
    font-family: Georgia, 'Times New Roman', Times, serif; /* 使用更典雅的襯線字體 */
    font-size: 16px;
    line-height: 1.8; /* 更大的行高，提升閱讀感 */
    color: #383838; /* 使用深灰色文字，比純黑更柔和 */
}

/* 夜間模式下的文字顏色 */
#phone-screen.dark-mode #char-diary-detail-content {
    color: #e0e0e0;
}

/* 4. 為日記的第一行（通常是標題）設置特殊樣式 */
#char-diary-detail-content > p:first-of-type {
    font-size: 20px;
    font-weight: 600;
    margin-bottom: 20px;
    text-align: center;
}

/* 5. 確保Markdown轉換後的標籤樣式正確 */
#char-diary-detail-content strong {
    font-weight: 600; /* 加粗 */
}
#char-diary-detail-content .spoiler {
    /* 這裡的樣式與主聊天介面保持一致 */
    background-color: #333;
    color: #333;
    padding: 0 4px;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s ease-in-out;
}
#char-diary-detail-content .spoiler:hover {
    background-color: #e0e0e0;
    color: inherit;
}

/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 【全新】日記詳情頁自訂Markdown樣式 ▼▼▼ */

/* 0. 引入外部手寫字體 (Google Fonts) */
@import url('https://fonts.googleapis.com/css2?family=Zhi+Mang+Xing&display=swap');

/* 1. 黃色背景高亮 */
#char-diary-detail-content .diary-highlight {
    background-color: #FFFACD; /* 檸檬綢色，一種柔和的黃色 */
    padding: 1px 4px;
    border-radius: 3px;
    margin: 0 2px;
}

/* 2. 粉色虛線底線 */
#char-diary-detail-content .diary-underline {
    border-bottom: 2px dotted #FFB6C1; /* 淺粉色 */
    text-decoration: none; /* 移除默認的實線底線 */
    padding-bottom: 1px;
}

/* 3. 粉紅色加粗文字 */
#char-diary-detail-content .diary-emphasis {
    color: #DB7093; /* 灰紫色 */
    font-weight: bold;
}

/* 4. 手寫體黑色文字 */
#char-diary-detail-content .diary-handwritten {
    font-family: 'Zhi Mang Xing', cursive; /* 應用手寫字體 */
    font-size: 1.1em; /* 手寫體稍微大一點更好看 */
    color: #1a1a1a; /* 比純黑更柔和的深灰色 */
}

/* 5. 稍微傾斜的手寫體文字 */
#char-diary-detail-content .diary-messy {
    font-family: 'Zhi Mang Xing', cursive;
    font-size: 1.1em;
    color: #1a1a1a;
    transform: rotate(-2deg); /* 輕微旋轉 */
    display: inline-block; /* 旋轉需要 display 屬性配合 */
    margin: 0 2px;
}

/* 6. 被塗黑的內容 */
#char-diary-detail-content .diary-censored {
    background-color: #222;
    color: #222; /* 讓文字顏色和背景色一樣，實現塗黑效果 */
    user-select: none; /* 防止使用者通過選中來查看內容 */
    padding: 0 3px;
    border-radius: 2px;
}

/* ▲▲▲ 新增CSS結束 ▲▲▲ */
.diary-censored:hover, .diary-censored:active {
  background-color: #E0E0E0; /* 滑鼠懸停時變成淺灰色背景 */
  color: inherit; /* 恢復為正常的文字顏色 */
  cursor: pointer; /* 滑鼠變為可點擊的手型 */
}
/* ▼▼▼ 【全新】角色高德地圖功能樣式 ▼▼▼ */

/* 1. 主螢幕背景色 */
#char-amap-screen {
    background-color: #f0f2f5;
}
#phone-screen.dark-mode #char-amap-screen {
    background-color: #000000;
}

/* 2. 足跡列表容器 */
#char-amap-list {
    padding: 15px;
    display: flex;
    flex-direction: column;
    gap: 18px; /* 增加足跡之間的間距 */
}

/* 3. 單個足跡卡片 */
.char-amap-item {
    background-color: var(--secondary-bg);
    border-radius: 12px;
    padding: 15px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.06);
    display: flex;
    flex-direction: column; /* 讓內容垂直排列 */
}

/* 4. 卡片頭部 (圖示 + 地點資訊) */
.amap-item-header {
    display: flex;
    align-items: flex-start; /* 圖示和文字頂部對齊 */
    gap: 12px;
    border-bottom: 1px solid var(--border-color);
    padding-bottom: 12px;
    margin-bottom: 12px;
}

/* 5. 地點圖示 */
.amap-item-icon {
    font-size: 24px;
    color: var(--accent-color);
    margin-top: 2px;
}

/* 6. 地點資訊 (標題 + 位址) */
.amap-item-info {
    flex-grow: 1;
}
.amap-item-title {
    font-weight: 600;
    font-size: 16px;
    margin-bottom: 4px;
}
.amap-item-address {
    font-size: 13px;
    color: var(--text-secondary);
}

/* 7. 卡片主體 (評論 + 圖片) */
.amap-item-body {
    display: flex;
    flex-direction: column;
    gap: 10px;
}
.amap-item-comment {
    font-size: 14px;
    line-height: 1.6;
    white-space: pre-wrap; /* 支持換行 */
}

/* 8. 足跡附帶的圖片 */
.amap-item-photo {
    width: 100%;
    height: 150px;
    border-radius: 8px;
    background-size: cover;
    background-position: center;
    cursor: pointer;
}

/* 9. 卡片底部 (時間戳記) */
.amap-item-footer {
    font-size: 12px;
    color: var(--text-secondary);
    margin-top: 10px;
    text-align: right;
}
/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 【全新】角色App使用記錄功能樣式 ▼▼▼ */

/* 1. 列表容器 */
#char-usage-list {
    padding: 10px 0; /* 上下留白，左右由列表項控制 */
}

/* 2. 單個App記錄項 */
.char-usage-item {
    display: flex;
    align-items: center;
    gap: 15px;
    padding: 10px 20px;
    transition: background-color 0.2s;
}
.char-usage-item:hover {
    background-color: rgba(0,0,0,0.03);
}

/* 3. App圖示 */
.usage-item-icon {
    width: 40px;
    height: 40px;
    border-radius: 8px; /* iOS風格的圓角矩形 */
    object-fit: cover;
    flex-shrink: 0;
    background-color: #e9ecef;
}

/* 4. 中間資訊區 (App名 + 分類) */
.usage-item-info {
    flex-grow: 1; /* 佔據所有剩餘空間 */
}
.usage-item-name {
    font-weight: 500;
    font-size: 16px;
}
.usage-item-category {
    font-size: 12px;
    color: var(--text-secondary);
}

/* 5. 右側時長顯示 */
.usage-item-time {
    font-size: 15px;
    color: var(--text-secondary);
    font-weight: 500;
    flex-shrink: 0;
}
/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 【全新】角色網易雲音樂功能樣式 ▼▼▼ */

/* 1. 主螢幕背景色 */
#char-music-screen {
    background-color: #f0f2f5;
}
#phone-screen.dark-mode #char-music-screen {
    background-color: #000000;
}

/* 2. 歌曲列表容器 */
#char-music-list {
    padding: 0;
}

/* 3. 單個歌曲列表項 (仿網易雲風格) */
.char-music-item {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 10px 20px;
    cursor: pointer;
    border-bottom: 1px solid var(--border-color);
}
.char-music-item:hover {
    background-color: rgba(0,0,0,0.03);
}

/* 4. 歌曲封面 */
.music-item-cover {
    width: 50px;
    height: 50px;
    border-radius: 8px;
    object-fit: cover;
    flex-shrink: 0;
}

/* 5. 歌曲信息 (歌名 + 歌手) */
.music-item-info {
    flex-grow: 1;
    overflow: hidden; /* 防止長文本溢出 */
}
.music-item-name {
    font-weight: 500;
    font-size: 16px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}
.music-item-artist {
    font-size: 12px;
    color: var(--text-secondary);
}
/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 這是你要【添加】到 <style> 標籤末尾的【全新播放機CSS代碼】 ▼▼▼ */

/* 1. 播放機主視窗樣式 */
#char-music-player-modal .modal-content {
    width: 400px !important; /* 固定寬度 */
    height: auto !important; /* 高度自我調整 */
    max-height: 90vh;
    background-color: #f7f8fa !important; /* 淺灰色背景 */
    border-radius: 12px !important;
    box-shadow: 0 10px 40px rgba(0,0,0,0.1) !important;
    color: #333 !important;
    display: flex;
    flex-direction: column;
}

/* 2. 頭部標題列 */
#char-music-player-modal .char-player-header {
    flex-shrink: 0;
    padding: 12px 15px;
    border-bottom: 1px solid #e5e5e5;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-weight: 600;
}
#char-music-player-modal .char-player-close-btn {
    background: none;
    border: none;
    font-size: 20px;
    color: #aaa;
    cursor: pointer;
}
#char-music-player-modal .char-player-close-btn:hover {
    color: #333;
}


/* 3. 主內容區（封面、進度條、按鈕） */
#char-music-player-modal .char-player-body {
    padding: 30px 35px 20px 35px;
    text-align: center;
}
#char-music-player-modal #char-music-cover {
    width: 220px;
    height: 220px;
    border-radius: 10px;
    box-shadow: 0 6px 20px rgba(0,0,0,0.15);
    margin-bottom: 20px;
    object-fit: cover;
}

/* 4. 進度條樣式 */
#char-music-player-modal .char-player-progress-bar-container {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 15px;
}
#char-music-player-modal .char-player-progress-bar {
    flex-grow: 1;
    height: 4px;
    background-color: #e0e0e0;
    border-radius: 2px;
    cursor: pointer;
}
#char-music-player-modal #char-music-progress-fill {
    width: 0%;
    height: 100%;
    background-color: #555;
    border-radius: 2px;
}

/* 5. 控制按鈕樣式 */
#char-music-player-modal .char-player-controls {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 20px;
}
#char-music-player-modal .char-player-controls .control-btn {
    background: none;
    border: none;
    color: #555;
    cursor: pointer;
    transition: color 0.2s;
    padding: 5px;
    display: flex;
    align-items: center;
    justify-content: center;
}
#char-music-player-modal .char-player-controls .control-btn:hover {
    color: #000;
}
#char-music-player-modal .char-player-controls .control-btn.play {
    width: 50px;
    height: 50px;
    background-color: #f0f1f3;
    border-radius: 50%;
    color: #333;
}
#char-music-player-modal .char-player-controls .control-btn.mode {
    font-size: 14px;
    font-weight: 500;
    width: 50px;
}

/* 6. 歌詞區域樣式 */
#char-music-player-modal #char-music-lyrics {
    flex-grow: 1;
    overflow-y: auto;
    padding: 0 35px 25px 35px;
    font-size: 14px;
    line-height: 2;
    color: #888;
    text-align: center;
}
#char-music-player-modal #char-music-lyrics p.active {
    color: #000;
    font-weight: 600;
}

/* 隱藏捲軸 */
#char-music-player-modal #char-music-lyrics::-webkit-scrollbar {
    display: none;
}
#char-music-player-modal #char-music-lyrics {
    -ms-overflow-style: none;
    scrollbar-width: none;
}

/* ▲▲▲ 新增CSS黏貼結束 ▲▲▲ */
/* ▼▼▼ 這是你要【添加】到 <style> 標籤末尾的【全新播放機CSS V3.0】 ▼▼▼ */

/* 1. 定義唱片旋轉動畫 */
@keyframes spin-vinyl {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

/* 2. 播放機主視窗樣式 */
#char-music-player-modal .modal-content {
    width: 340px !important; /* 寬度適中 */
    height: auto !important;
    background-color: #f0f1f3 !important; /* 輕柔的灰色背景 */
    border-radius: 12px !important;
    box-shadow: 0 10px 40px rgba(0,0,0,0.1) !important;
    color: #333 !important;
    display: flex;
    flex-direction: column;
    padding: 20px; /* 統一內邊距 */
    position: relative;
}

/* 3. 移除舊的頭部，因為關閉按鈕已獨立 */
#char-music-player-modal .modal-header {
    display: none !important;
}

/* 4. 右上角關閉按鈕 */
#char-music-player-modal .char-player-close-btn {
    position: absolute;
    top: 15px;
    right: 15px;
    background: none;
    border: none;
    font-size: 24px;
    font-weight: 300;
    color: #aaa;
    cursor: pointer;
    line-height: 1;
    z-index: 10;
}

/* 5. 主內容區 */
#char-music-player-modal .char-player-body {
    display: flex;
    flex-direction: column;
    align-items: center;
    flex-grow: 1;
}

/* 6. 歌曲信息 */
#char-music-player-modal .char-player-song-info {
    text-align: center;
    margin-bottom: 25px;
}
#char-music-player-modal #char-music-player-title {
    font-size: 20px;
    font-weight: 600;
    margin: 0 0 5px 0;
}
#char-music-player-modal #char-music-artist {
    font-size: 14px;
    color: #888;
    margin: 0;
}

/* 7. 黑膠唱片效果 */
#char-music-player-modal #char-vinyl-container {
    width: 210px;
    height: 210px;
    border-radius: 50%;
    background-color: #222;
    padding: 15px;
    box-shadow: 0 8px 25px rgba(0,0,0,0.2), 
                inset 0 0 0 2px rgba(255, 255, 255, 0.05);
    background-image: repeating-radial-gradient(circle, #333, #333 1px, #222 1px, #222 2px);
    box-sizing: border-box;
    margin-bottom: 25px;
}
#char-music-player-modal #char-vinyl-container.spinning {
    animation: spin-vinyl 12s linear infinite;
}
#char-music-player-modal #char-music-cover {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    object-fit: cover;
}

/* 8. 歌詞預留位置 (音符) */
#char-music-player-modal #char-lyric-placeholder {
    color: #aaa;
    font-size: 18px;
    letter-spacing: 5px;
    margin-bottom: 25px;
}

/* 9. 底部控制欄 */
#char-music-player-modal .char-player-footer {
    width: 100%;
    margin-top: auto; /* 將其推到底部 */
}

/* 10. 進度條和控制按鈕 (與上一版類似，但class已更新) */
#char-music-player-modal .char-player-progress-bar-container {
    display: flex; align-items: center; gap: 10px; margin-bottom: 10px;
}
#char-music-player-modal .char-player-progress-bar {
    flex-grow: 1; height: 4px; background-color: #e0e0e0; border-radius: 2px; cursor: pointer;
}
#char-music-player-modal #char-music-progress-fill {
    width: 0%; height: 100%; background-color: #555; border-radius: 2px;
}
#char-music-player-modal .char-player-controls {
    display: flex; align-items: center; justify-content: center; gap: 20px;
}
#char-music-player-modal .char-player-controls .control-btn {
    background: none; border: none; color: #555; cursor: pointer; transition: color 0.2s; padding: 5px;
    display: flex; align-items: center; justify-content: center;
}
#char-music-player-modal .char-player-controls .control-btn:hover { color: #000; }
#char-music-player-modal .char-player-controls .control-btn.play {
    width: 50px; height: 50px; background-color: #e0e1e3; border-radius: 50%; color: #333;
}
#char-music-player-modal .char-player-controls .control-btn.mode {
    font-size: 14px; font-weight: 500; width: 50px;
}
#char-music-player-modal #char-music-lyrics {
    display: none; /* 在這個版本中，我們徹底隱藏歌詞區域 */
}

/* ▲▲▲ 新增CSS黏貼結束 ▲▲▲ */
/* ▼▼▼ 這是你要【添加】到 <style> 標籤末尾的【全新播放機CSS V3.0】 ▼▼▼ */

/* 1. 定義唱片旋轉動畫 */
@keyframes spin-vinyl {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

/* 2. 播放機主視窗樣式 */
#char-music-player-modal .modal-content {
    width: 340px !important; /* 寬度適中 */
    height: auto !important;
    background-color: #f0f1f3 !important; /* 輕柔的灰色背景 */
    border-radius: 12px !important;
    box-shadow: 0 10px 40px rgba(0,0,0,0.1) !important;
    color: #333 !important;
    display: flex;
    flex-direction: column;
    padding: 20px; /* 統一內邊距 */
    position: relative;
}

/* 3. 移除舊的頭部，因為關閉按鈕已獨立 */
#char-music-player-modal .modal-header {
    display: none !important;
}

/* 4. 右上角關閉按鈕 */
#char-music-player-modal .char-player-close-btn {
    position: absolute;
    top: 15px;
    right: 15px;
    background: none;
    border: none;
    font-size: 24px;
    font-weight: 300;
    color: #aaa;
    cursor: pointer;
    line-height: 1;
    z-index: 10;
}

/* 5. 主內容區 */
#char-music-player-modal .char-player-body {
    display: flex;
    flex-direction: column;
    align-items: center;
    flex-grow: 1;
}

/* 6. 歌曲信息 */
#char-music-player-modal .char-player-song-info {
    text-align: center;
    margin-bottom: 25px;
}
#char-music-player-modal #char-music-player-title {
    font-size: 20px;
    font-weight: 600;
    margin: 0 0 5px 0;
}
#char-music-player-modal #char-music-artist {
    font-size: 14px;
    color: #888;
    margin: 0;
}

/* 7. 黑膠唱片效果 */
#char-music-player-modal #char-vinyl-container {
    width: 210px;
    height: 210px;
    border-radius: 50%;
    background-color: #222;
    padding: 15px;
    box-shadow: 0 8px 25px rgba(0,0,0,0.2), 
                inset 0 0 0 2px rgba(255, 255, 255, 0.05);
    background-image: repeating-radial-gradient(circle, #333, #333 1px, #222 1px, #222 2px);
    box-sizing: border-box;
    margin-bottom: 25px;
}
#char-music-player-modal #char-vinyl-container.spinning {
    animation: spin-vinyl 12s linear infinite;
}
#char-music-player-modal #char-music-cover {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    object-fit: cover;
}

/* 8. 【核心新增】歌詞區域樣式 */
#char-music-player-modal #char-music-lyrics {
    width: 100%;
    height: 50px; /* 設定一個固定高度，用於顯示約兩行歌詞 */
    overflow: hidden; /* 隱藏超出部分的歌詞 */
    position: relative;
    margin-bottom: 25px;
    font-size: 14px;
    line-height: 25px; /* 設置行高 */
    color: #888;
    text-align: center;
    transition: all 0.3s ease;
}

#char-music-player-modal #char-music-lyrics p {
    margin: 0;
    transition: all 0.3s ease;
}

#char-music-player-modal #char-music-lyrics p.active {
    color: #000;
    font-weight: 600;
    font-size: 16px; /* 當前行歌詞放大一點 */
}


/* 9. 底部控制欄 */
#char-music-player-modal .char-player-footer {
    width: 100%;
    margin-top: auto; /* 將其推到底部 */
}

/* 10. 進度條和控制按鈕 */
#char-music-player-modal .char-player-progress-bar-container {
    display: flex; align-items: center; gap: 10px; margin-bottom: 10px;
}
#char-music-player-modal .char-player-progress-bar {
    flex-grow: 1; height: 4px; background-color: #e0e0e0; border-radius: 2px; cursor: pointer;
}
#char-music-player-modal #char-music-progress-fill {
    width: 0%; height: 100%; background-color: #555; border-radius: 2px;
}
#char-music-player-modal .char-player-controls {
    display: flex; align-items: center; justify-content: center; gap: 20px;
}
#char-music-player-modal .char-player-controls .control-btn {
    background: none; border: none; color: #555; cursor: pointer; transition: color 0.2s; padding: 5px;
    display: flex; align-items: center; justify-content: center;
}
#char-music-player-modal .char-player-controls .control-btn:hover { color: #000; }
#char-music-player-modal .char-player-controls .control-btn.play {
    width: 50px; height: 50px; background-color: #e0e1e3; border-radius: 50%; color: #333;
}
#char-music-player-modal .char-player-controls .control-btn.mode {
    font-size: 14px; font-weight: 500; width: 50px;
}

/* ▲▲▲ 新增CSS黏貼結束 ▲▲▲ */
#chat-list .chat-list-item {
    /* 核心1：強制使用 gap 屬性來控制間距，並覆蓋舊有衝突 */
    gap: 15px !important;
    /* 確保沒有其他對齊方式干擾 */
    justify-content: flex-start !important;
}

#chat-list .chat-list-item .avatar-group {
    /* 核心2：強制移除之前用於間距的 margin，現在完全由 gap 控制 */
    margin-right: 0 !important;
}
/* ▼▼▼ 【全新V2.0 | 仿豆瓣UI】豆瓣小組功能樣式 ▼▼▼ */

/* 1. 豆瓣主題色與頁面背景 */
#douban-screen {
    background-color: #F6F6F1; /* 豆瓣經典的米色背景 */
}
#phone-screen.dark-mode #douban-screen {
    background-color: #1a1a1a;
}
#douban-posts-list {
    padding: 0; /* 清單本身不需要內邊距 */
    display: flex;
    flex-direction: column;
}

/* 2. 帖子卡片美化 (V2.0) */
.douban-post-item {
    background-color: var(--secondary-bg);
    padding: 12px 15px;
    border: none;
    box-shadow: none;
    border-bottom: 1px solid var(--border-color); /* 用分割線代替邊框 */
    cursor: pointer;
    transition: background-color 0.2s;
}
.douban-post-item:hover {
    background-color: #f9f9f9;
}
#phone-screen.dark-mode .douban-post-item:hover {
    background-color: #2c2c2e;
}

/* 3. 帖子頭部 (頭像、昵稱、小組名) */
.douban-post-header {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 12px;
}
.douban-post-avatar {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    object-fit: cover;
}
.douban-author-info {
    flex-grow: 1;
}
.douban-author-name {
    font-weight: 500;
    color: var(--text-primary);
    font-size: 14px;
}
.douban-group-name {
    font-size: 12px;
    color: #007722; /* 豆瓣標誌性的綠色 */
    font-weight: 500;
}

/* 4. 帖子標題和內容預覽 */
.douban-post-title {
    font-size: 16px;
    font-weight: 600;
    margin-bottom: 8px;
    color: var(--text-primary);
}
.douban-post-content {
    font-size: 14px;
    color: #555;
    line-height: 1.7;
    white-space: pre-wrap;
    word-break: break-word;
    display: -webkit-box;
    -webkit-line-clamp: 4;
    -webkit-box-orient: vertical;
    overflow: hidden;
}
#phone-screen.dark-mode .douban-post-content {
    color: #dcdcdc;
}

/* 5. 帖子底部 (統計資料) */
.douban-post-footer {
    margin-top: 15px;
    padding-top: 10px;
    border-top: 1px solid #f0f0f0;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 13px;
    color: var(--text-secondary);
}
.douban-post-actions {
    display: flex;
    gap: 20px;
}
.douban-post-actions span {
    display: flex;
    align-items: center;
    gap: 6px; /* 增加圖示和數位之間的間距 */
    color: var(--text-secondary); /* 確保顏色統一 */
}
/* 【核心新增】為SVG圖示設置統一樣式 */
.douban-post-actions svg {
    width: 18px;
    height: 18px;
    fill: currentColor; /* 讓圖示顏色跟隨父元素的文字顏色 */
    position: relative;
    top: -1px; /* 位置微調，使其與數字更對齊 */
}
/* ▼▼▼ 【全新】羽毛筆圖示按鈕樣式 ▼▼▼ */
.douban-feather-btn {
    /* 1. 基礎樣式 (複用主聊天介面的圓形按鈕) */
    font-size: 24px;
    padding: 0;
    width: 38px;
    height: 38px;
    line-height: 38px;
    text-align: center;
    border-radius: 50%;
    border: none;
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    flex-shrink: 0; /* 防止被壓縮 */
    margin-right: 8px; /* 和發送按鈕拉開距離 */

    /* 2. 外觀 (仿iOS風格的淺灰色) */
    background-color: #f0f2f5;
    color: #555;
    transition: background-color 0.2s;
}
.douban-feather-btn:hover {
    background-color: #e2e6ea;
}
.douban-feather-btn svg {
    width: 20px;
    height: 20px;
}
/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* 6. 【V2.2 | 最終佈局修復版】帖子詳情頁 */

#douban-post-detail-screen {
    background-color: #F6F6F1; /* 外部米色背景 */
}
#phone-screen.dark-mode #douban-post-detail-screen {
    background-color: #1a1a1a;
}

/* 【核心修復1】重置外部容器的內邊距，讓白色背景能撐滿全屏 */
#douban-detail-content-wrapper {
    background-color: var(--secondary-bg);
    padding: 0; /* 移除導致兩側空白的內邊距 */
    padding-bottom: 80px; /* 只保留底部的空間給輸入框 */
}

/* 【核心修復2】將邊距應用到內部的正文區域 */
#douban-post-detail-body {
    padding: 20px 18px 25px 18px; /* 在內容四周留出呼吸空間 */
    border-bottom: 1px solid #f0f0f0;
}
#phone-screen.dark-mode #douban-post-detail-body {
    border-bottom-color: #38383a;
}

/* 美化帖子標題 */
.douban-post-title {
    font-size: 18px;
    font-weight: 600;
    margin-bottom: 15px;
    line-height: 1.5;
}

/* 優化正文閱讀體驗 */
.douban-detail-content {
    white-space: pre-wrap;
    line-height: 1.8;
    font-size: 15px;
    color: #333;
}
#phone-screen.dark-mode .douban-detail-content {
    color: #dcdcdc;
}

/* 【核心修復3】將邊距也應用到評論區，並移除與正文的間距 */
.douban-comments-section {
    margin-top: 0;
    padding: 15px 18px;
}

/* 為“回應”增加標題樣式 */
.douban-comments-section h4 {
    font-size: 14px;
    font-weight: 500;
    color: var(--text-secondary);
    margin: 0 0 15px 0;
    padding-bottom: 10px;
    border-bottom: 1px solid #f0f0f0;
}
#phone-screen.dark-mode .douban-comments-section h4 {
    border-bottom-color: #38383a;
}

/* 美化單條評論 */
.douban-comment-item {
    display: flex;
    gap: 12px;
    padding: 15px 0;
    border-bottom: 1px solid #f0f0f0;
}
.douban-comment-item:last-child {
    border-bottom: none;
}
#phone-screen.dark-mode .douban-comment-item {
    border-bottom-color: #38383a;
}

.douban-comment-avatar {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    flex-shrink: 0;
}
.douban-comment-body {
    flex-grow: 1;
}
.douban-comment-author {
    font-weight: 500;
    font-size: 14px;
    color: var(--text-primary);
}
.douban-comment-text {
    font-size: 14px;
    color: #555;
    margin-top: 6px;
    line-height: 1.7;
    word-break: break-word;
}
#phone-screen.dark-mode .douban-comment-text {
    color: #b0b0b0;
}

/* 7. 【V2.2 | 最終佈局修復版】詳情頁底部評論輸入欄 */
#douban-comment-footer {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    
    /* 【核心修復1】增加上下左右的內邊距，解決貼邊問題 */
    padding: 10px 18px; 
    
    /* 【核心修復2】保留對iPhone底部安全區域的適配 */
    padding-bottom: calc(10px + env(safe-area-inset-bottom));
    
    /* 【核心修復3】確保 padding 不會撐破佈局 */
    box-sizing: border-box; 
    
    /* (其他樣式保持不變) */
    background-color: rgba(247, 247, 247, 0.9);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-top: 1px solid var(--border-color); /* 在頂部也加一條分割線，更精緻 */
}
#douban-send-comment-btn {
    background-color: #007722; /* 豆瓣綠 */
}
/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 【最終修復 | V3.0】豆瓣頭部按鈕顯示終極解決方案 ▼▼▼ */

/* 1. 確保右側的按鈕容器本身不會被意外壓縮 */
#douban-screen .header .header-actions {
    flex-shrink: 0;
    display: flex;       /* 確保它是一個flex容器 */
    align-items: center; /* 垂直居中內部的圖示 */
}

/* 2. 【核心修復】為所有頭部操作按鈕內的SVG圖示設置一個固定的、統一的尺寸 */
.header .action-btn svg {
    width: 24px;   /* 確保尺寸統一 */
    height: 24px;
    display: block; /* 移除SVG可能帶有的額外底部空間 */
}

/* 3. 為所有操作按鈕設置一個最小寬度，保證它們不會被擠壓得過小 */
.header .action-btn {
    min-width: 30px; /* 給予每個按鈕足夠的點擊區域 */
    display: flex;
    align-items: center;
    justify-content: center;
}
/* ▲▲▲ 修復結束 ▲▲▲ */
/* ▼▼▼ 【全新】這是用於對齊頭部左側按鈕的樣式 ▼▼▼ */
.header .header-left-actions {
    display: flex;
    align-items: center;
    gap: 15px; /* (可選) 在返回、導入、匯出按鈕之間增加一些間距 */
}
/* ▲▲▲ 新增CSS結束 ▲▲▲ */
        /* ▼▼▼ 【全新】這是為“角色相冊生圖關閉”功能添加的樣式 ▼▼▼ */

        /* 1. 讓相冊格子成為 Flex 容器，這樣我們才能方便地居中內部的文字 */
        .char-photo-item {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 8px; /* 在文字周圍留出一點內邊距，避免貼邊 */
            box-sizing: border-box;
        }
        
        /* 2. 照片描述文字本身的樣式 */
        .char-photo-description {
            font-size: 13px;
            color: var(--text-secondary); /* 使用次要文字顏色，看起來更柔和 */
            text-align: center;
            line-height: 1.5;
        
            /* 核心：這是一個實現“多行省略號”的技巧，防止過長的描述撐破佈局 */
            display: -webkit-box;
            -webkit-box-orient: vertical;
            -webkit-line-clamp: 5; /* 最多顯示5行 */
            overflow: hidden;
            word-break: break-all; /* 確保長單詞或URL也能被截斷 */
        }
        
        /* ▲▲▲ 新增CSS結束 ▲▲▲ */
        /* ▼▼▼ 【全新】這是為淘寶/流覽器生圖關閉功能添加的樣式 ▼▼▼ */

        /* 1. 為淘寶商品卡片上的文字描述創建一個容器 */
        .char-product-description-overlay {
            width: 100%;
            aspect-ratio: 1 / 1; /* 與圖片保持相同的正方形比例，確保網格佈局不亂 */
            background-color: #f7f8fa; /* 柔和的背景色 */
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 15px; /* 內邊距 */
            box-sizing: border-box;
            border-bottom: 1px solid #eee; /* 在描述和商品資訊之間加一條分割線 */
            border-radius: 8px 8px 0 0; /* 匹配圖片的頂部圓角 */
        }

        /* 2. 描述文字本身的樣式 (複用相冊的樣式，並讓流覽器也使用) */
        .char-product-description-overlay .char-photo-description,
        .char-browser-image-description { 
            font-size: 14px; /* 字體可以稍微大一點 */
            color: var(--text-secondary);
            text-align: center;
            line-height: 1.6;
            display: -webkit-box;
            -webkit-box-orient: vertical;
            -webkit-line-clamp: 6; /* 最多顯示6行 */
            overflow: hidden;
            word-break: break-all;
        }

        /* 3. 為流覽器中的圖片描述創建一個容器 */
        .char-browser-image-description {
            padding: 40px 20px; /* 上下留出更多空間 */
        }

        /* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 【全新】這是為角色淘寶訂單狀態添加的樣式 ▼▼▼ */
.char-product-status {
    font-size: 12px;
    color: #8a8a8a; /* 使用柔和的灰色 */
    background-color: #f0f2f5; /* 給一個淡淡的背景 */
    padding: 3px 8px;
    border-radius: 10px;
}
/* ▲▲▲ 新增CSS結束 ▲▲▲ *
/* 1. 搜索螢幕的背景色 */
#search-history-screen {
    background-color: #f0f2f5;
}
#phone-screen.dark-mode #search-history-screen {
    background-color: #000000;
}

/* 2. 搜索結果列表，確保可以滾動 */
#search-results-list {
    flex-grow: 1;
    overflow-y: auto;
}

/* 3. 日期分隔符號的樣式 */
.date-separator {
    text-align: center;
    color: var(--text-secondary);
    font-size: 12px;
    padding: 10px 0;
    font-weight: 500;
}

/* 4. 夜間模式下的輸入框適配 */
#phone-screen.dark-mode #search-bar input {
    background-color: #1c1c1e;
    color: #ffffff;
    border-color: #38383a;
}
/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 【全新】主螢幕分頁功能樣式 ▼▼▼ */

        /* 1. 讓主螢幕成為Flex容器，但方向改為水準，為翻頁做準備 */
        #home-screen {
            flex-direction: column;
            padding: 0; /* 移除舊的內邊距，由內部頁面自己控制 */
        }

        /* 2. 頁面容器，負責橫向排列所有頁面 */
        #home-screen-pages-container {
            flex-grow: 1; /* 佔據除了Dock欄外的所有空間 */
            width: 100%;
            overflow: hidden; /* 隱藏橫向捲軸 */
            position: relative;
        }

        #home-screen-pages {
            display: flex;
            width: 200%; /* 假設有兩頁，寬度設為200% */
            height: 100%;
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1); /* 平滑的翻頁動畫 */
        }

        /* 3. 單個頁面的樣式 */
        .home-screen-page {
            width: 50%; /* 每頁佔據一半寬度 */
            height: 100%;
            padding: 20px;
            padding-top: calc(20px + env(safe-area-inset-top));
            padding-bottom: 0; /* 底部由分頁指示器控制 */
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* 4. 分頁指示器 (小圓點) */
        #home-screen-pagination {
            display: flex;
            justify-content: center;
            gap: 8px;
            padding: 10px 0;
             /* 適配iPhone底部安全區 */
            padding-bottom: calc(10px + env(safe-area-inset-bottom) / 2);
            flex-shrink: 0;
        }

        .pagination-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.4);
            transition: all 0.3s ease;
        }

        .pagination-dot.active {
            background-color: white;
            transform: scale(1.1);
        }
        
        /* 5. 第二頁的App網格容器 */

        /* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 【全新】聊天工具列按鈕排序功能樣式 ▼▼▼ */
.draggable-button-item {
    padding: 8px 12px;
    background-color: var(--secondary-bg);
    border: 1px solid var(--border-color);
    border-radius: 20px;
    cursor: grab;
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 14px;
    font-weight: 500;
    transition: background-color 0.2s, box-shadow 0.2s;
    user-select: none;
}
.draggable-button-item:active {
    cursor: grabbing;
}
.draggable-button-item svg {
    width: 18px;
    height: 18px;
    stroke-width: 2;
}
/* 當一個元素正在被拖動時應用的樣式 */
.draggable-button-item.dragging {
    opacity: 0.5;
    background-color: #e0e0e0;
}
/* 當拖動的元素懸停在另一個元素上方時，為那個元素應用的樣式 */
.draggable-button-item.drag-over {
    background-color: #d0eaff;
    box-shadow: 0 0 0 2px var(--accent-color);
}
/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 【全新 | 移動端相容】為拖動過程添加的樣式 ▼▼▼ */

/* 當一個元素正在被拖動時應用的樣式 */
.draggable-button-item.dragging {
    opacity: 0.5;
    background-color: #e0e0e0;
    /* 核心：讓被拖動的元素“浮”起來，不會影響其他元素的佈局 */
    position: relative; 
    z-index: 10;
}

/* 防止在手機上拖動時，意外選中頁面上的文字 */
#button-order-editor {
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
}
/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 【全新】這是為彈窗內可滾動長文本添加的樣式 ▼▼▼ */
.scrollable-content-preview {
    /* 核心1：設置一個最大高度。內容超出這個高度就會觸發滾動。
       35vh 表示視窗高度的35%，這是一個靈活的高度，能適應不同螢幕。*/
    max-height: 35vh;
    
    /* 核心2：當內容垂直方向溢出時，自動顯示捲軸。 */
    overflow-y: auto;
    
    /* (可選) 美化樣式，讓它看起來更像一個代碼/引用塊 */
    background-color: #f0f2f5;
    padding: 10px 15px;
    border-radius: 8px;
    text-align: left;
    white-space: pre-wrap; /* 保持文本中的換行 */
    border: 1px solid var(--border-color);
}
/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 【全新】高級資料清理嚮導樣式 ▼▼▼ */
.wizard-step {
    display: none; /* 預設隱藏所有步驟 */
    flex-direction: column;
    width: 100%;
    height: 100%;
}

.wizard-step.active {
    display: flex; /* 只顯示啟動的步驟 */
}

/* 複用現有的清單項樣式，為其添加一點內邊距 */
#data-clear-char-list .clear-posts-item,
#data-clear-type-list .clear-posts-item {
    padding: 12px 18px;
}
/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 【全新】為清理嚮導添加“全選”樣式 ▼▼▼ */
#data-clear-wizard-modal .modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
}
#data-clear-wizard-modal .modal-header label {
    font-size: 14px;
    font-weight: normal;
    display: flex;
    align-items: center;
    gap: 5px;
    cursor: pointer;
}
/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 【全新】教程頁面樣式 ▼▼▼ */
#tutorial-screen {
    background-color: #f0f2f5;
}
#phone-screen.dark-mode #tutorial-screen {
    background-color: #000000;
}
/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 【全新】預設編輯器內容折疊功能樣式 ▼▼▼ */
.entry-content-container {
    display: none; /* 預設隱藏內容區域 */
    margin-top: 8px; /* 和上方的標籤拉開一點距離 */
}
.toggle-content-btn {
    background: none;
    border: 1px solid #ccc;
    color: var(--text-secondary);
    font-size: 12px;
    padding: 2px 8px;
    border-radius: 5px;
    cursor: pointer;
}
/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 【全新】這是更新通知彈窗的樣式 ▼▼▼ */
#update-notice-modal {
    position: fixed; /* 固定定位，覆蓋在所有內容之上 */
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.4);
    display: none; /* 默認隱藏 */
    align-items: center;
    justify-content: center;
    z-index: 2000; /* 確保在最上層 */
    opacity: 0;
    transition: opacity 0.3s ease;
}
#update-notice-modal.visible {
    display: flex;
    opacity: 1;
}
.update-notice-content {
    background-color: #fff;
    width: 300px;
    border-radius: 14px;
    box-shadow: 0 5px 25px rgba(0,0,0,0.15);
    display: flex;
    flex-direction: column;
    transform: scale(0.95);
    transition: transform 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28);
}
#update-notice-modal.visible .update-notice-content {
    transform: scale(1);
}
.update-notice-body {
    padding: 20px;
    font-size: 15px;
    line-height: 1.6;
    color: #333;
    
    /* --- ▼▼▼ 核心修改就在這裡 ▼▼▼ --- */

    /* 1. 設置一個最大高度。我們使用 vh (視窗高度) 單位，
       讓彈窗最大不超過螢幕高度的60%，以適應不同尺寸的手機。 */
    max-height: 60vh; 
    
    /* 2. 當內容超出這個最大高度時，自動顯示垂直捲動條。 */
    overflow-y: auto; 

    /* --- ▲▲▲ 修改結束 ▲▲▲ --- */
}
.update-notice-footer {
    border-top: 1px solid #dbdbdb;
    display: flex;
}
.update-notice-footer button {
    flex: 1;
    background: none;
    border: none;
    padding: 14px;
    font-size: 17px;
    cursor: pointer;
    color: var(--accent-color);
}
.update-notice-footer button:first-child {
    border-right: 1px solid #dbdbdb;
    font-weight: 600;
}
/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 【全新 | 保持橫向佈局】這是修復長按功能表截斷問題的最終版樣式 ▼▼▼ */

/* 1. 核心修改：讓按鈕容器支援換行 */
#message-actions-modal .custom-modal-footer {
    flex-wrap: wrap; /* 允許項目換行 */
    padding: 10px;   /* 在容器周圍增加一些內邊距，讓佈局更舒展 */
    gap: 10px;       /* 在按鈕之間增加間距 */
    justify-content: flex-start; /* 讓按鈕從左側開始排列 */
}

/* 2. 為每一個操作按鈕（除了取消按鈕）設置尺寸和樣式 */
#message-actions-modal .custom-modal-footer button:not(#cancel-message-action-btn) {
    /* 核心修改：不再平分寬度，而是允許它們根據內容生長，並設置一個基礎寬度 */
    flex-grow: 1;
    flex-basis: 75px; /* 每個按鈕的基礎寬度，確保至少能容納4個字 */
    
    /* (可選但推薦) 統一按鈕外觀，使其更像一個網格 */
    border: none;
    background-color: #f0f2f5;
    border-radius: 8px;
    padding: 12px 5px; /* 調整內邊距，讓文字居中 */
    font-size: 16px;
    font-weight: 500;
}

/* 3. 讓“取消”按鈕單獨佔據一整行，並恢復其獨立樣式 */
#message-actions-modal #cancel-message-action-btn {
    width: 100%; /* 強制寬度為100% */
    flex-basis: 100%; /* 在flex佈局中也確保它占滿一行 */
    margin-top: 8px;
    border-radius: 8px;
    background-color: #f0f2f5;
    font-weight: 600;
}
/* ▲▲▲ 新增CSS黏貼結束 ▲▲▲ */
/* 修復iOS輸入框自動放大問題 (強製版) */
input, textarea, select {
    font-size: 16px !important;
}
/* ▼▼▼ 【全新】這是為日記收藏功能添加的樣式 ▼▼▼ */

/* 收藏按鈕啟動時的樣式（填充黃色） */
#favorite-diary-btn.active svg {
    fill: #ffc107; /* 您可以換成任何您喜歡的顏色 */
    color: #ffc107;
}

/* 收藏卡片中日記標題的樣式 */
.favorite-item-card .diary-title {
    font-weight: 600;
    display: block;
    margin-bottom: 8px;
    font-size: 15px;
}

/* 收藏卡片中日記內容預覽的樣式 */
.favorite-item-card .diary-content-preview {
    font-size: 13px;
    opacity: 0.8;
    line-height: 1.6;
    
    /* 多行省略號效果 */
    display: -webkit-box;
    -webkit-line-clamp: 3; /* 最多顯示3行 */
    -webkit-box-orient: vertical;
    overflow: hidden;
}
/* ▼▼▼ 把這段CSS代碼【完全刪除】▼▼▼ */
.favorite-item-card .diary-content-preview {
    font-size: 13px;
    opacity: 0.8;
    line-height: 1.6;
    
    /* 多行省略號效果 */
    display: -webkit-box;
    -webkit-line-clamp: 3; /* 最多顯示3行 */
    -webkit-box-orient: vertical;
    overflow: hidden;
}
/* ▲▲▲ 刪除到這裡結束 ▲▲▲ */
#npc-list-view {
    background-color: #f0f2f5;
}
#phone-screen.dark-mode #npc-list-view {
    background-color: #000;
}

/* ▼▼▼ 【全新】這是為“圍觀群聊”操作按鈕添加的樣式 ▼▼▼ */

/* 1. 讓“圍觀中”文字和按鈕容器垂直排列 */
#chat-lock-content {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 15px; /* 在文字和按鈕之間增加間距 */
}

/* 2. 按鈕的容器，使用Flex佈局讓它們水準排列 */
.spectator-actions-container {
    display: flex;
    gap: 12px; /* 按鈕之間的間距 */
    align-items: center;
}

/* 3. 為次要按鈕（重Roll/剪輯）創建一個新樣式 */
#chat-lock-content .lock-action-btn.secondary {
    background-color: transparent; /* 透明背景 */
    color: var(--accent-color);   /* 使用主題色文字 */
    border: 1px solid var(--accent-color); /* 同樣顏色的邊框 */
    padding: 8px 18px; /* 調整內邊距，讓它比主按鈕小一點 */
    font-size: 14px;
}
/* ▲▲▲ 新增CSS黏貼結束 ▲▲▲ */
/* ▼▼▼ 【全新】這是為“圍觀群聊”SVG圖示按鈕添加的樣式 ▼▼▼ */

.spectator-actions-container .lock-action-btn.secondary svg {
    width: 20px;  /* 設置圖示寬度 */
    height: 20px; /* 設置圖示高度 */
    stroke: currentColor; /* 關鍵：讓圖示顏色自動繼承按鈕的文字顏色 */
}

/* ▲▲▲ 新增CSS黏貼結束 ▲▲▲ */
/* ▼▼▼ 【全新】音樂播放機背景樣式 ▼▼▼ */

/* 1. 讓播放機視窗成為相對定位的容器，以便偽元素定位 */
.music-player-window {
    position: relative;
    /* (可選) 增加一個輕微的背景蒙版，讓文字在亮色背景下更清晰 */
    background-color: rgba(255, 255, 255, 0.75);
}

/* 2. 這就是我們的背景層核心樣式 */
.music-player-window::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    
    /* 3. 使用CSS變數來動態設置背景圖片 */
    background-image: var(--music-bg-image);
    background-size: cover;
    background-position: center;
    
    /* 4. 添加視覺效果：高斯模糊和降低亮度，營造氛圍感 */
    filter: blur(15px) brightness(0.8);
    
    /* 5. 確保背景在最底層，不遮擋內容 */
    z-index: -1;
    
    /* 6. 讓背景層的圓角和播放機窗口保持一致 */
    border-radius: inherit; 
    
    /* 7. 為背景切換增加平滑的過渡動畫 */
    transition: background-image 0.5s ease-in-out;
}

/* ▲▲▲ 新增CSS結束 ▲▲▲ */

/* ▼▼▼ 【全新V2.0 | 最終修復版】背景清晰度切換功能樣式 ▼▼▼ */

/* 1. 當播放機窗口擁有 .bg-clear 這個 class 時，讓背景變得清晰 (此規則不變) */
.music-player-window.bg-clear::before {
    filter: none;
}

/* 2. 【核心修改】為“清”字按鈕設置新的、與其它控制按鈕一致的樣式 */
#toggle-blur-btn {
    /* 移除所有定位屬性 */
    /* position: absolute; bottom: 95px; right: 20px; z-index: 55; */

    /* 複用其他按鈕的樣式 */
    background: none;
    border: none;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    color: #333;
    width: 44px;
    height: 44px;
    display: flex;
    justify-content: center;
    align-items: center;
    transition: all 0.2s ease;
    border-radius: 50%;
    
    /* 給一個和其他按鈕相似的淡淡背景 */
    background-color: rgba(0, 0, 0, 0.05);
}

/* 3. 按鈕啟動時的樣式（表示當前是清晰模式） */
#toggle-blur-btn.active {
    background-color: var(--accent-color); /* 例如，啟動時變為主題色 */
    color: white;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}
/* ▲▲▲ 新增CSS結束 ▲▲▲ */

/* ▼▼▼ 【全新】播放機全屏功能樣式 ▼▼▼ */

/* 1. 當播放機窗口擁有 .fullscreen 這個 class 時，讓它撐滿整個螢幕 */
.music-player-window.fullscreen {
    width: 100%;
    height: 100%;
    max-height: 100%; /* 覆蓋可能存在的 max-height 限制 */
    border-radius: 0; /* 全屏時移除圓角 */
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1); /* 讓放大縮小的動畫更流暢 */
}

/* 2. 當播放機全屏時，移除外部容器的內邊距，讓播放機能真正貼合螢幕邊緣 */
#music-player-overlay.fullscreen-active {
    padding-top: 0;
    align-items: stretch; /* 讓播放機在垂直方向上也能撐滿 */
}

/* 3. 【核心】為新的全屏切換按鈕定義樣式 */
#toggle-fullscreen-btn {
    background: none;
    border: none;
    font-size: 22px; /* 設置一個合適的圖示大小 */
    cursor: pointer;
    color: #555;
    padding: 5px;
    line-height: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: color 0.2s;
}
#toggle-fullscreen-btn:hover {
    color: #000;
}

/* 4. 【核心】通過 CSS 控制放大/縮小圖示的顯示和隱藏 */
/* 預設情況下，只顯示“放大”圖示 */
#toggle-fullscreen-btn .icon-minimize {
    display: none;
}
/* 當播放機處於全屏狀態時，隱藏“放大”圖示，顯示“縮小”圖示 */
.music-player-window.fullscreen #toggle-fullscreen-btn .icon-maximize {
    display: none;
}
.music-player-window.fullscreen #toggle-fullscreen-btn .icon-minimize {
    display: block;
}
/* ▲▲▲ 新增CSS結束 ▲▲▲ */

/* ▼▼▼ 【全新】播放機全屏頭像顯示功能樣式 ▼▼▼ */

/* 1. 頭像顯示容器的樣式 */
#music-player-avatar-display {
    display: none; /* 默認隱藏 */
    width: 100%;
    padding: 15px 20px;
    box-sizing: border-box;
    justify-content: space-between; /* 讓兩個頭像分佈在兩端 */
    align-items: center;
    border-bottom: 1px solid rgba(0, 0, 0, 0.1); /* 添加一條分割線 */
    margin-bottom: 10px;
}

/* 2. 只有當播放機全屏，並且該容器有 .visible 類時，才顯示它 */
.music-player-window.fullscreen #music-player-avatar-display.visible {
    display: flex;
}

/* 3. 頭像本身的樣式 */
.participant-display-avatar {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    object-fit: cover;
    box-shadow: 0 2px 6px rgba(0,0,0,0.2);
}

/* 4. 新的“顯示頭像”按鈕的樣式 */
#show-avatars-btn {
    background: none;
    border: none;
    cursor: pointer;
    padding: 5px;
    display: none; /* 預設在非全屏模式下隱藏 */
    align-items: center;
    justify-content: center;
    opacity: 0.6;
    transition: opacity 0.2s;
}

/* 5. 只有在全屏模式下才顯示這個按鈕 */
.music-player-window.fullscreen #show-avatars-btn {
    display: flex;
}

#show-avatars-btn:hover {
    opacity: 1;
}

/* 6. 當頭像正在顯示時，讓按鈕也高亮 */
#show-avatars-btn.active {
    opacity: 1;
}
/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 【全新】這是為豆瓣設置彈窗添加的樣式 ▼▼▼ */
.douban-settings-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
}
.douban-settings-item label {
    margin-bottom: 0;
    flex-grow: 1; /* 讓標籤佔據更多空間 */
}
.douban-settings-controls {
    display: flex;
    align-items: center;
    gap: 8px; /* 在輸入框和文字之間增加間距 */
    flex-shrink: 0; /* 防止被壓縮 */
}
.douban-settings-controls input {
    width: 60px;
    text-align: center;
}
/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 【全新】這是為時區搜索框添加的樣式 ▼▼▼ */
#time-zone-search-input {
    width: 100%;
    padding: 10px 12px;
    margin-bottom: 8px; /* 和下方的下拉清單拉開一點距離 */
    border: 1px solid var(--border-color);
    border-radius: 6px;
    box-sizing: border-box;
    font-size: 16px; /* 避免在iOS上輸入時自動放大頁面 */
}
/* 夜間模式適配 */
#phone-screen.dark-mode #time-zone-search-input {
    background-color: #1c1c1e;
    color: #ffffff;
    border-color: #38383a;
}
/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 【全新】狼人殺遊戲功能樣式 ▼▼▼ */

/* 遊戲主螢幕佈局 */
#werewolf-game-screen {
    background-color: #2c2c2e; /* 深邃的背景，營造氛圍 */
    color: white;
}
#werewolf-player-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
    gap: 15px;
    padding: 15px;
    flex-shrink: 0;
    border-bottom: 1px solid #444;
}
.werewolf-player-avatar {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px;
    position: relative;
}
.werewolf-player-avatar img {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    border: 2px solid #888;
    transition: all 0.3s;
}
.werewolf-player-avatar .player-name {
    font-size: 12px;
    font-weight: 500;
    text-shadow: 0 1px 2px black;
}
/* 死亡玩家的樣式 */
.werewolf-player-avatar.dead img {
    filter: grayscale(100%);
    border-color: #ff3b30;
}
.werewolf-player-avatar.dead .player-name {
    color: #ff3b30;
    text-decoration: line-through;
}

/* 遊戲日誌/對話區域 */
#werewolf-log {
    padding: 15px;
    background: none;
    display: flex;
    flex-direction: column;
    gap: 12px;
}
.werewolf-log-entry {
    background-color: rgba(255, 255, 255, 0.08);
    padding: 8px 12px;
    border-radius: 8px;
    font-size: 14px;
    line-height: 1.6;
}
.werewolf-log-entry.system {
    text-align: center;
    color: #ffc107;
    font-style: italic;
    background-color: rgba(255, 193, 7, 0.1);
}
.werewolf-log-entry .speaker {
    font-weight: bold;
}

/* 底部操作欄 */
#werewolf-action-bar {
    padding: 10px 15px;
    padding-bottom: calc(10px + env(safe-area-inset-bottom));
    background-color: rgba(0,0,0,0.3);
    flex-shrink: 0;
    text-align: center;
}
#werewolf-next-step-btn {
    width: 100%;
}

/* 角色揭示卡片樣式 */
#werewolf-role-card {
    background: linear-gradient(135deg, #4a4a4a, #2a2a2a);
    border: 1px solid #666;
    border-radius: 12px;
    padding: 20px;
    color: white;
}
#werewolf-role-name {
    font-size: 22px;
    font-weight: bold;
    color: #ffc107;
    margin-bottom: 10px;
}
#werewolf-role-description {
    font-size: 14px;
    line-height: 1.6;
}

/* 選擇清單的通用樣式 (用於查人、投票等) */
.werewolf-selection-item {
    display: flex;
    align-items: center;
    padding: 12px 18px;
    cursor: pointer;
    border-bottom: 1px solid var(--border-color);
}
.werewolf-selection-item.selected {
    background-color: var(--accent-color);
    color: white;
}
.werewolf-selection-item img {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    margin-right: 15px;
}
.werewolf-selection-item .name {
    font-weight: 500;
}
/* ▲▲▲ 狼人殺樣式結束 ▲▲▲ */
/* ▼▼▼ 【V3.0 | 狼人殺UI美化】請將這整塊代碼，黏貼到 <style> 標籤的末尾 ▼▼▼ */

        /* 1. 美化底部常駐輸入欄的背景 */
        #werewolf-game-screen #werewolf-action-bar {
            background-color: rgba(0, 0, 0, 0.3); /* 半透明黑色背景，營造懸浮感 */
            border-top: 1px solid rgba(255, 255, 255, 0.1); /* 頂部加一條微光分割線 */
            padding: 10px 15px; /* 增加內邊距 */
            padding-bottom: calc(10px + env(safe-area-inset-bottom)); /* 適配iPhone底部安全區 */
        }

        /* 2. 【核心修復】讓文本輸入框能夠動態伸縮 */
        #werewolf-game-screen #werewolf-user-input {
            flex-grow: 1; /* 這是最關鍵的一步，讓輸入框佔據所有剩餘空間 */
            border: none;
            padding: 10px 15px;
            border-radius: 20px; /* 圓角 */
            background-color: rgba(255, 255, 255, 0.1); /* 深色半透明背景 */
            color: #f0f0f0; /* 淺色文字 */
            font-size: 16px; /* 適配iOS，防止輸入時放大 */
            resize: none; /* 禁止拖動 */
            height: 40px; /* 與主聊天框保持一致的高度 */
            box-sizing: border-box;
        }

        /* 3. 美化輸入框的預留位置文字 */
        #werewolf-game-screen #werewolf-user-input::placeholder {
            color: #8d8d92; /* 暗灰色 */
        }

        /* 4. 美化操作按鈕，使其與主聊天介面的發送按鈕風格一致 */
        #werewolf-game-screen #input-actions-wrapper button {
            height: 40px;
            padding: 0 15px;
            border-radius: 20px;
            border: none;
            color: white;
            font-weight: 600;
            cursor: pointer;
            flex-shrink: 0; /* 防止按鈕被擠壓變形 */
        }

        /* 5. 美化“等待回應”和“繼續討論”按鈕 (次要按鈕) */
        #werewolf-game-screen #werewolf-wait-reply-btn {
            background-color: #555; /* 深灰色背景 */
        }

        /* 6. 美化“結束發言”和“進入投票”按鈕 (主要按鈕) */
        #werewolf-game-screen #werewolf-finish-speech-btn {
            background-color: #c62828; /* 暗紅色，更有狼人殺氛圍 */
        }

        /* ▲▲▲ 新增CSS黏貼結束 ▲▲▲ */
/* ▼▼▼ 【全新】表情包搜索欄樣式 ▼▼▼ */

#sticker-search-container {
    padding: 10px 15px; /* 在搜索框周圍留出一些內邊距 */
    flex-shrink: 0; /* 防止被壓縮 */
    border-bottom: 1px solid var(--border-color); /* 在下方添加分割線 */
    background-color: var(--secondary-bg); /* 確保背景色能適配夜間模式 */
}

#sticker-search-input {
    width: 100%;
    padding: 10px 15px;
    font-size: 16px; /* 避免在iOS上輸入時自動放大頁面 */
    border: 1px solid var(--border-color);
    border-radius: 18px; /* 圓角矩形 */
    background-color: #f0f2f5; /* 默認的淺灰色背景 */
    box-sizing: border-box;
    outline: none; /* 移除選中時的外框 */
    -webkit-appearance: none; /* 移除iOS上的預設樣式 */
}

#sticker-search-input:focus {
    border-color: var(--accent-color); /* 選中時邊框變為主題色 */
    background-color: var(--secondary-bg); /* 選中時背景變為白色 */
}

/* 夜間模式適配 */
#phone-screen.dark-mode #sticker-search-input {
    background-color: #2c2c2e;
    color: #f0f0f0;
    border-color: #38383a;
}
#phone-screen.dark-mode #sticker-search-input:focus {
    background-color: #38383a;
}
/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 【全新】引用跳轉高亮效果 ▼▼▼ */

/* 1. 為消息氣泡的內容區添加一個平滑的背景色過渡效果 */
.message-bubble .content {
    transition: background-color 0.5s ease-out;
}

/* 2. 定義高亮時的背景色 */
/*    我們使用 !important 來確保它能覆蓋掉所有主題的預設顏色 */
.message-bubble.highlighted .content {
    background-color: rgba(0, 123, 255, 0.2) !important;
}
/* ▲▲▲ 新樣式黏貼結束 ▲▲▲
/* ▼▼▼ 【全新】無限滾動載入動畫 ▼▼▼ */

.loader-container {
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 10px 0;
    width: 100%;
    height: 44px; /* 給予一個固定高度來防止載入時頁面跳動 */
    box-sizing: border-box;
}

.spinner {
    width: 24px;
    height: 24px;
    border: 3px solid rgba(0, 0, 0, 0.1); /* 旋轉軌道的淺灰色 */
    border-top-color: var(--accent-color); /* 旋轉部分的顏色，會跟隨主題色變化 */
    border-radius: 50%;
    animation: spin 1s linear infinite; /* 複用您已有的 spin 動畫 */
}

/* 夜間模式下的適配 */
#phone-screen.dark-mode .spinner {
    border: 3px solid rgba(255, 255, 255, 0.2);
    border-top-color: #fff; /* 夜間模式下旋轉部分為白色 */
}
/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 【V2.1 | 交互修復版】請用這一整塊代碼，完整替換從 #reading-overlay 到 .reading-footer button:disabled 的所有相關樣式 ▼▼▼ */

/* 1. 外部容器：提升 z-index，確保它在頂欄之上 */
#reading-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 150; /* 高於頂欄的 100 */
    display: flex;
    justify-content: center;
    align-items: center;
    pointer-events: none; /* 允許點擊穿透背景 */
    display: none; /* 默認隱藏 */
}

/* 2. 主視窗樣式 */
#reading-window {
    width: 90%;
    max-width: 340px;
    height: 60vh;
    max-height: 480px;
    background-color: rgba(255, 255, 255, 0.7);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border-radius: 18px;
    box-shadow: 0 8px 32px rgba(31, 38, 135, 0.2);
    border: 1px solid rgba(255, 255, 255, 0.18);
    display: flex;
    flex-direction: column;
    pointer-events: auto; /* 視窗本身可以交互 */
    position: absolute; /* 改為 absolute 以支持拖動 */
    /* 初始居中定位由JS控制，這裡不再設置 */
    transition: transform 0.3s ease, opacity 0.3s ease, visibility 0s 0.3s; /* 添加平滑的過渡動畫 */
}
#phone-screen.dark-mode #reading-window {
    background-color: rgba(40, 40, 42, 0.7);
}

/* ▼▼▼ 請用這整塊代碼，完整替換舊的 .reading-header 和 #reading-title 樣式 ▼▼▼ */

/* 3. 頭部樣式，作為“拖動把手” */

.reading-header {
    cursor: move;
    user-select: none;
    -webkit-user-select: none;
    flex-shrink: 0;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 15px;
    border-bottom: 1px solid var(--border-color);
    gap: 10px;
    /* 新增：強制不換行，作為雙重保險 */
    flex-wrap: nowrap;
}

#reading-title {
    font-weight: 600;
    /* 核心：讓標題佔據所有可用空間，但允許收縮 */
    flex: 1;
    min-width: 0;
    /* 以下三行負責實現省略號效果 */
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.reading-controls {
    /* 關鍵：告訴按鈕容器絕對不要被壓縮 */
    flex-shrink: 0;
}

/* ▲▲▲ 替換結束 ▲▲▲ */
.reading-controls button {
    background: none; border: none; color: var(--text-secondary); padding: 4px 8px;
    border-radius: 4px; cursor: pointer; font-size: 14px; transition: background-color 0.2s;
}
.reading-controls button:hover {
    background-color: rgba(0,0,0,0.1);
}
#minimize-reading-btn {
    font-weight: bold; font-size: 16px; line-height: 1;
}

/* 4. 【核心修復】最小化後的狀態：使其透明、縮小並不可交互 */
#reading-window.minimized {
    transform: scale(0.8); /* 縮小效果 */
    opacity: 0;           /* 透明效果 */
    pointer-events: none; /* 禁止交互 */
    visibility: hidden;   /* 徹底隱藏 */
}

/* 5. 【核心修復】最小化後用於“恢復”的小球，改為螢幕居中 */
#reading-restore-btn {
    position: absolute;
    /* --- 核心修改1：從居中改為靠右 --- */
    top: 50%;
    right: 15px; /* 距離右側邊緣15圖元 */
    /* 【關鍵】只在Y軸上垂直居中，不再需要X軸的平移 */
    transform: translateY(-50%); 
    /* --- 修改結束 --- */
    width: 50px; 
    height: 50px;
    background-color: rgba(255, 255, 255, 0.8);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 28px; 
    cursor: move; 
    box-shadow: 0 4px 10px rgba(0,0,0,0.15);
    pointer-events: auto; 
    z-index: 160; 
    transition: transform 0.2s; 
}
#reading-restore-btn:active {
    /* 【核心修改2】修復點擊時的位移問題 */
    transform: translateY(-50%) scale(0.95);
}
#phone-screen.dark-mode #reading-restore-btn {
    background-color: rgba(50, 50, 52, 0.8);
}

/* 6. 內容和頁腳樣式 (保持不變) */
#reading-content {
    flex-grow: 1; 
    overflow-y: auto; 
    padding: 15px;
    font-size: 15px; 
    line-height: 1.8;
    /* ▼▼▼ 核心新增 ▼▼▼ */
    white-space: pre-wrap; /* 保持分行符號，同時允許長單詞自動換行 */
    word-break: break-word;  /* 強制長單詞或URL斷開，防止撐破佈局 */
    /* ▲▲▲ 新增結束 ▲▲▲ */
}
.reading-footer {
    flex-shrink: 0; display: flex; justify-content: space-between; align-items: center;
    padding: 12px 15px; border-top: 1px solid var(--border-color);
}
#page-indicator {
    font-size: 14px; 
    color: var(--text-secondary);
    cursor: pointer; /* 添加手型游標，提示用戶可以點擊 */
    transition: color 0.2s;
}
#page-indicator:hover {
    color: var(--accent-color); /* 滑鼠懸停時變色 */
}
.reading-footer button {
    padding: 6px 15px; border-radius: 15px; border: none;
    background-color: var(--accent-color); color: white; cursor: pointer;
}
.reading-footer button:disabled {
    background-color: #ccc;
}
#phone-screen.dark-mode .reading-footer button:disabled {
    background-color: #555;
}

/* ▲▲▲ V2.1 CSS 替換結束 ▲▲▲ */
/* ▼▼▼ 【全新】這是為書庫搜索功能添加的樣式 ▼▼▼ */
#reading-library-search-container {
    padding: 10px 15px;
    border-bottom: 1px solid var(--border-color);
    flex-shrink: 0; /* 防止被壓縮 */
}
#reading-library-search-input {
    width: 100%;
    padding: 10px 12px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    box-sizing: border-box;
    font-size: 16px; /* 避免在iOS上輸入時自動放大頁面 */
    -webkit-appearance: none; /* 移除iOS上的預設樣式 */
}
#phone-screen.dark-mode #reading-library-search-input {
    background-color: #2c2c2e;
    color: #f0f0f0;
    border-color: #38383a;
}
/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 【全新】語音訊息元件樣式 ▼▼▼ */

.voice-message-body {
    display: flex;
    align-items: center;
    cursor: pointer;
    min-width: 80px;
    max-width: 220px;
    padding: 8px 12px;
}
.message-bubble.user .voice-message-body {
    color: #1a3d00;
    flex-direction: row-reverse;
}
.message-bubble.ai .voice-message-body {
    color: var(--text-primary);
}

.voice-play-btn {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    border: none;
    background-color: rgba(0, 0, 0, 0.1);
    color: currentColor;
    font-size: 16px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    flex-shrink: 0;
    transition: background-color 0.2s;
}
.voice-play-btn:hover {
    background-color: rgba(0, 0, 0, 0.2);
}

.voice-spinner {
    width: 20px;
    height: 20px;
    border: 2px solid rgba(0, 0, 0, 0.2);
    border-top-color: var(--accent-color);
    border-radius: 50%;
    animation: spin 1s linear infinite;
    display: none; /* 默認隱藏 */
    margin: 4px;
}

.voice-duration {
    font-size: 14px;
    font-weight: 500;
    margin: 0 10px;
    flex-shrink: 0;
}
.message-bubble.user .voice-duration {
    color: #3e6224;
}

/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 【全新】仿淘寶風格的商品分類頁簽樣式 ▼▼▼ */

#product-category-tabs {
    display: flex;
    overflow-x: auto; /* 允許橫向滾動 */
    padding: 10px 15px 0 15px;
    flex-shrink: 0;
    border-bottom: 1px solid var(--border-color);
    background-color: var(--secondary-bg);

    /* 隱藏捲軸，讓介面更乾淨 */
    -ms-overflow-style: none;  /* IE and Edge */
    scrollbar-width: none;  /* Firefox */
}
#product-category-tabs::-webkit-scrollbar {
    display: none; /* Chrome, Safari, and Opera */
}

/* 單個頁簽按鈕的樣式 */
.product-category-tab {
    padding: 8px 16px;
    cursor: pointer;
    border: none;
    background-color: transparent;
    font-size: 15px;
    font-weight: 500;
    color: var(--text-secondary);
    border-bottom: 2px solid transparent; /* 默認下方邊框是透明的 */
    margin-bottom: -1px; /* 讓底邊框與容器邊框重合 */
    transition: all 0.2s ease-in-out;
    white-space: nowrap; /* 防止分類名換行 */
    flex-shrink: 0; /* 防止按鈕被壓縮 */
}

/* 啟動的頁簽樣式 */
.product-category-tab.active {
    color: #FF5722; /* 淘寶標誌性的橙紅色 */
    border-bottom-color: #FF5722; /* 下方顯示橙紅色線條 */
    font-weight: 600; /* 字體加粗 */
}

#phone-screen.dark-mode .product-category-tab.active {
    color: #FF8A65; /* 夜間模式下使用柔和一點的橙色 */
    border-bottom-color: #FF8A65;
}

/* ▲▲▲ 新增CSS黏貼結束 ▲▲▲ */
/* ▼▼▼ 【全新】這是修復購物中心分類欄橫向滾動的代碼 ▼▼▼ */

#product-category-tabs {
    /* --- 核心代碼開始 --- */
    overflow-x: auto;      /* 1. 允許在水準方向上滾動 */
    white-space: nowrap;   /* 2. 強制所有分類項不換行，保持在同一行 */
    /* --- 核心代碼結束 --- */

    /* (可選但推薦) 以下代碼用於美化，可以在移動設備上隱藏醜陋的捲軸，但保留滾動功能 */
    -webkit-overflow-scrolling: touch; /* 在iOS上提供更流暢的滾動體驗 */
    scrollbar-width: none;             /* 隱藏 Firefox 的捲軸 */
    -ms-overflow-style: none;          /* 隱藏 IE/Edge 的捲軸 */
}

/* 隱藏 WebKit 流覽器 (Chrome, Safari) 的捲軸 */
#product-category-tabs::-webkit-scrollbar {
    display: none; 
}

/* (可選但推薦) 確保每個分類按鈕本身不會被意外壓縮變形 */
.product-category-tab {
    flex-shrink: 0;
}

/* ▲▲▲ 新增CSS黏貼結束 ▲▲▲ */
        /* ▼▼▼ 【全新】這是為商品管理批量刪除功能添加的【全部CSS樣式】，請黏貼到 <style> 的末尾 ▼▼▼ */

        /* 1. 管理模式下，為商品卡片添加手型游標 */
        #shopping-screen.management-mode .product-item {
            cursor: pointer;
        }
        
        /* 2. 在管理模式下，隱藏舊的“編輯/刪除”浮層 */
        #shopping-screen.management-mode .product-management-overlay {
            display: none;
        }

        /* 3. 選擇框的樣式 (仿我的最愛) */
        #shopping-screen.management-mode .product-item::before {
            content: '';
            position: absolute;
            top: 10px;
            right: 10px;
            width: 22px;
            height: 22px;
            border: 2px solid #ccc;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.7);
            transition: all 0.2s ease;
            z-index: 6; /* 確保在圖片之上 */
        }

        /* 4. 選中後的樣式 */
        #shopping-screen.management-mode .product-item.selected::before {
            background-color: var(--accent-color);
            border-color: var(--accent-color);
            content: '✔';
            color: white;
            font-size: 14px;
            text-align: center;
            line-height: 22px;
        }

        /* 5. 在管理模式下，輕微調暗未選中的卡片，突出可選狀態 */
        #shopping-screen.management-mode .product-item:not(.selected) {
            opacity: 0.8;
        }

        /* 6. 底部操作欄 (仿我的最愛) */
        #shopping-action-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            width: auto;
            padding: 10px 15px;
            padding-bottom: calc(10px + env(safe-area-inset-bottom));
            background-color: rgba(247, 247, 247, 0.9);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-top: 1px solid var(--border-color);
            box-sizing: border-box;
            z-index: 5;
            display: none; /* 默認隱藏 */
            justify-content: space-between;
            align-items: center;
        }

        #shopping-action-bar .select-all-label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 16px;
            color: var(--text-primary);
            cursor: pointer;
        }

        #shopping-action-bar .action-bar-btn {
            padding: 10px 25px;
            border-radius: 20px;
            border: none;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            background-color: #ff3b30;
            color: white;
        }
        /* ▲▲▲ 新增CSS黏貼結束 ▲▲▲ */
/* ▼▼▼ 【全新】這是為主螢幕第二屏添加的拍立得小元件樣式 ▼▼▼ */

/* 1. 小組件總容器 */
.polaroid-widget-container {
    width: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    margin-bottom: 30px; /* 和下方的App圖示拉開距離 */
    flex-shrink: 0;
    
    /* --- ▼▼▼ 核心修改就在這裡 ▼▼▼ --- */
    margin-top: 20px; /* 添加和第一屏同樣的頂部外邊距 */
    /* --- ▲▲▲ 修改結束 ▲▲▲ --- */
}

/* 2. 三張照片的容器 */
.polaroid-photos {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 5px; /* 照片之間的輕微間距 */
}

/* 3. 單張拍立得照片的樣式 */
.polaroid-photo {
    background-color: white;
    padding: 8px 8px 15px 8px; /* 頂部和左右8px，底部15px，模擬拍立得的白邊 */
    border-radius: 4px;
    box-shadow: 0 5px 12px rgba(0, 0, 0, 0.2); /* 更柔和的陰影 */
    transition: transform 0.25s cubic-bezier(0.4, 0, 0.2, 1), box-shadow 0.25s;
    width: 80px; /* 設置一個固定寬度 */
    flex-shrink: 0;
}
.polaroid-photo:hover {
    transform: scale(1.1) rotate(0deg) !important; /* 滑鼠懸停時放大並擺正 */
    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.25);
    z-index: 10; /* 確保懸停的照片在最上層 */
}

/* 4. 拍立得內部的圖片 */
.polaroid-photo img {
    width: 100%;
    display: block;
    aspect-ratio: 1 / 1; /* 保持圖片為正方形 */
    object-fit: cover;
}

/* 5. 小組件標題 */
.polaroid-widget-title {
    margin-top: 15px;
    font-size: 13px;
    font-weight: 500;
    color: white; /* 與主螢幕其他文字顏色統一 */
    text-shadow: 0 1px 3px rgba(0,0,0,0.4); /* 與主螢幕其他文字陰影統一 */
}

/* ▲▲▲ 新增CSS黏貼結束 ▲▲▲ */
/* ▼▼▼ 請將這段新樣式黏貼到 <style> 的末尾 ▼▼▼ */

#page-2-app-container {
    display: grid;
    /* --- The core change is on this line --- */
    grid-template-columns: 155px 1fr; /* Set a fixed width for the left widget */
    gap: 15px;
    width: 100%;
    padding-top: 20px;
    align-items: start;
}
/* 2. 右側 2x2 小組件的網格容器 */
.app-subgrid {
    display: grid;
    grid-template-columns: 1fr 1fr; /* 內部是2列均分 */
    gap: 15px; /* 小元件之間的間距 */
}

/* 3. 左側大元件的樣式 */
.large-widget {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px; /* 圖片和文字的間距 */
}
.large-widget-img {
    width: 100%;
    aspect-ratio: 1 / 1; /* 保持正方形 */
    border-radius: 22px; /* iOS風格圓角 */
    object-fit: cover;
    box-shadow: 0 5px 15px rgba(0,0,0,0.1);
}
.large-widget-label {
    color: white;
    font-size: 13px;
    font-weight: 500;
    text-shadow: 0 1px 3px rgba(0,0,0,0.4);
}

/* 4. 右側小元件的通用樣式 */
.small-widget {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
}
/* 新增一個包裝器，用於控制小圖示的大小和居中 */
.small-widget-icon-wrapper {
    width: 55px;
    height: 55px;
    display: flex;
    align-items: center;
    justify-content: center;
}
.small-widget-img {
    /* 核心修改：移除 max-width 和 max-height */
    width: 100%;     /* 讓圖片寬度填滿 55px 的父容器 */
    height: 100%;    /* 讓圖片高度填滿 55px 的父容器 */
    object-fit: cover; /* 確保圖片不變形地填滿 */
    border-radius: 14px; /* 推薦：為圖示本身也加上圓角，與Dock欄圖示風格統一 */
}
.small-widget-label {
    color: white;
    font-size: 13px;
    font-weight: 500;
    text-shadow: 0 1px 3px rgba(0,0,0,0.4);
}
/* ▲▲▲ 新增CSS黏貼結束 ▲▲▲ */
/* ▼▼▼ 【全新】這是讓主螢幕第二屏小元件字體變黑的樣式 ▼▼▼ */

#page-2-app-container .small-widget-label {
    color: #000 !important;       /* 核心：強制將文字顏色設為黑色 */
    text-shadow: none !important; /* 推薦：移除文字陰影，讓黑色字體更清晰 */
}

/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 【全新】修復Cphone內部App清單項在夜間模式下的顏色 ▼▼▼ */

#phone-screen.dark-mode #char-diary-list .list-item .item-title,
#phone-screen.dark-mode #char-diary-list .list-item .item-content,
#phone-screen.dark-mode #char-memo-list .list-item .item-title,
#phone-screen.dark-mode #char-memo-list .list-item .item-content,
#phone-screen.dark-mode #char-browser-history .char-browser-item .title,
#phone-screen.dark-mode #char-usage-list .usage-item-name,
#phone-screen.dark-mode #char-music-list .music-item-name {
    color: #f0f0f0; /* 將主要文字強制設為亮灰色 */
}

#phone-screen.dark-mode #char-diary-list .list-item .item-content,
#phone-screen.dark-mode #char-browser-history .char-browser-item .url,
#phone-screen.dark-mode #char-usage-list .usage-item-category,
#phone-screen.dark-mode #char-music-list .music-item-artist {
    color: #a0a0a0; /* 將次要文字（如日期、網址）設為柔和的灰色 */
}

/* ▲▲▲ 新增CSS黏貼結束 ▲▲▲ */
/* ▼▼▼ 【全新】修復日記詳情頁自訂Markdown樣式在夜間模式下的可見性 ▼▼▼ */

/* 1. 黃色高亮 */
#phone-screen.dark-mode #char-diary-detail-content .diary-highlight {
    background-color: rgba(255, 223, 100, 0.2); /* 暗黃色背景 */
    color: #FFD700; /* 亮黃色文字 */
}

/* 2. 粉色虛線底線 */
#phone-screen.dark-mode #char-diary-detail-content .diary-underline {
    border-bottom-color: #FF85B3; /* 更亮的粉色 */
}

/* 3. 粉紅色加粗文字 */
#phone-screen.dark-mode #char-diary-detail-content .diary-emphasis {
    color: #FF85B3; /* 更亮的粉色 */
}

/* 4. 手寫體 (包括淩亂手寫體) */
#phone-screen.dark-mode #char-diary-detail-content .diary-handwritten,
#phone-screen.dark-mode #char-diary-detail-content .diary-messy {
    color: #dcdcdc; /* 淺灰色，確保可見 */
}

/* ▼▼▼ 【全新 | 最終修復版】修復聊天介面“塗黑”功能在夜間模式下的可見性 ▼▼▼ */

/* 1. 夜間模式下，“塗黑”區域的預設樣式 */
#phone-screen.dark-mode .spoiler {
    background-color: #444; /* 將背景改為中度灰色，以便在純黑背景下能被看到 */
    color: #444;           /* 文字也改為同樣的灰色，保持隱藏效果 */
}

/* 2. 夜間模式下，滑鼠懸停或點擊時，顯示內容 */
#phone-screen.dark-mode .spoiler:hover, 
#phone-screen.dark-mode .spoiler:active {
    background-color: #555; /* 背景變為更亮的灰色，與周圍有區分 */
    color: #fff;           /* 文字變為白色，清晰可見 */
}

/* ▲▲▲ 新增CSS黏貼結束 ▲▲▲ */
/* ▼▼▼ 【全新】頭像框批量刪除功能樣式 ▼▼▼ */

/* 1. 管理模式下，為頭像框網格添加一個class，用於樣式控制 */
#avatar-frame-modal .frame-grid.management-mode .frame-item {
    cursor: pointer;
}

/* 2. 管理模式下，為自訂頭像框添加一個選中框的偽元素 */
/*    注意：我們只為帶有 .delete-btn 的自訂頭像框添加可選效果 */
#avatar-frame-modal .frame-grid.management-mode .frame-item:has(.delete-btn)::after {
    content: '';
    position: absolute;
    top: -2px;
    left: -2px;
    width: calc(100% + 4px);
    height: calc(100% + 4px);
    border: 3px solid transparent;
    border-radius: 12px;
    box-sizing: border-box;
    transition: border-color 0.2s;
    pointer-events: none; /* 確保不影響點擊 */
}

/* 3. 管理模式下，被選中的自訂頭像框，顯示藍色邊框 */
#avatar-frame-modal .frame-grid.management-mode .frame-item.selected::after {
    border-color: var(--accent-color);
}

/* 4. 底部批量刪除操作欄 (複用已有樣式) */
#frame-action-bar {
    display: none; /* 默認隱藏 */
    flex-shrink: 0;
    padding: 10px 15px;
    padding-bottom: calc(10px + env(safe-area-inset-bottom));
    background-color: rgba(247, 247, 247, 0.9);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-top: 1px solid var(--border-color);
    justify-content: space-between;
    align-items: center;
}

#frame-action-bar .select-all-label {
    font-size: 16px;
    color: var(--text-primary);
    cursor: pointer;
}

#frame-action-bar .action-bar-btn {
    padding: 10px 25px;
    border-radius: 20px;
    border: none;
    font-size: 15px;
    font-weight: 600;
    cursor: pointer;
    background-color: #ff3b30;
    color: white;
}
/* ▲▲▲ 新增CSS黏貼結束 ▲▲▲ */
    </style>
</head>
<body>
    <div id="phone-screen">
        <div id="status-bar">
            <span id="status-bar-time">12:00</span>
            <div id="status-bar-battery" class="battery-container">
                <span class="battery-text">--%</span>
                <div class="battery-icon">
                    <div class="battery-level"></div>
                </div>
            </div>
        </div>
        <div id="notification-bar"><img id="notification-avatar" src="">
            <div id="notification-content">
                <div class="name"></div>
                <div class="message"></div>
            </div>
        </div>
<!-- ▼▼▼ 步驟 1：用這整塊新代碼，完整替換掉您現有的 <div id="home-screen" ...> ... </div> ▼▼▼ -->

<div id="home-screen" class="screen active">

    <!-- 1. 頁面滑動容器 -->
    <div id="home-screen-pages-container">
        <div id="home-screen-pages">
            <!-- 頁面 1: 保持您原有的佈局 -->
            <div class="home-screen-page">
                <div id="main-content-area">
                    <div id="profile-widget">
                        <img id="profile-banner-img" src="https://i.imgur.com/1n3a43H.jpeg" class="editable-image">
                        <div class="profile-avatar-container">
                            <img id="profile-avatar-img" src="https://i.postimg.cc/y8xWzCqj/anime-boy.jpg" class="editable-image">
                        </div>
                        <div class="profile-info">
                            <p id="profile-username" class="editable-text">@ insonneve 🪦</p>
                            <p id="profile-sub-username" class="editable-text">@ insonneve</p>
                            <p id="profile-bio" class="editable-text">你好像過得很好 迫不及待的抹去我存在的痕跡</p>
                            <p id="profile-location" class="editable-text">
                                <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5-2.5-1.12 2.5-2.5 2.5z"></path></svg>
                                <span>北海道</span>
                            </p>
                        </div>
                    </div>
                    <div id="desktop-layout">
                        <div id="desktop-widget-column">
                            <div class="desktop-widget text-only">
                                <p id="widget-text-1" class="editable-text">Be fearless in pursuit of happiness</p>
                            </div>
                            <div class="desktop-widget icon-left">
                                <img id="widget-avatar-1" src="https://i.imgur.com/1n3a43H.jpeg" class="editable-image">
                                <span id="widget-text-2" class="editable-text">Dare to be different</span>
                            </div>
                            <div class="desktop-widget icon-right">
                                <span id="widget-text-3" class="editable-text">* Keep your spirit free</span>
                                <img id="widget-avatar-2" src="https://i.imgur.com/5A0tE9a.jpeg" class="editable-image">
                            </div>
                        </div>
                        <div id="desktop-app-container">
                            <div class="desktop-app-icon" onclick="showScreen('chat-list-screen')">
                                <div class="icon-bg-desktop"><img id="icon-img-qq" src="https://i.postimg.cc/MTC3Tkw8/IMG-6436.jpg" alt="QQ"></div>
                                <span class="label">QQ</span>
                            </div>
                            <div class="desktop-app-icon" onclick="showScreen('world-book-screen')">
                                <div class="icon-bg-desktop"><img id="icon-img-world-book" src="https://i.postimg.cc/HWf1JKzn/IMG-6435.jpg" alt="世界書"></div>
                                <span class="label">世界書</span>
                            </div>
                            <div class="desktop-app-icon" onclick="showScreen('wallpaper-screen')">
                                <div class="icon-bg-desktop"><img id="icon-img-wallpaper" src="https://i.postimg.cc/T1j03pQr/IMG-6440.jpg" alt="外觀設置"></div>
                                <span class="label">外觀設置</span>
                            </div>
                            <div class="desktop-app-icon" onclick="openRenderingRulesScreen()">
                                <div class="icon-bg-desktop"><img id="icon-img-renderer" src="https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1756312261242_qdqqd_g0eriz.jpeg" alt="渲染器"></div>
                                <span class="label">渲染器</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <!-- 頁面 2: 放置新App圖示的地方 -->
<div class="home-screen-page">
 <div class="polaroid-widget-container">
    <div class="polaroid-photos">
        <!-- 照片1 -->
        <div class="polaroid-photo" style="transform: rotate(-6deg);" onclick="handleWidgetImageChange('polaroid-img-1')">
            <img id="polaroid-img-1" src="https://i.imgur.com/Bv63o3h.jpg" alt="Photo 1">
        </div>
        <!-- 照片2 -->
        <div class="polaroid-photo" style="transform: rotate(2deg);" onclick="handleWidgetImageChange('polaroid-img-2')">
            <img id="polaroid-img-2" src="https://i.imgur.com/GzPzBfF.jpg" alt="Photo 2">
        </div>
        <!-- 照片3 -->
        <div class="polaroid-photo" style="transform: rotate(5deg);" onclick="handleWidgetImageChange('polaroid-img-3')">
            <img id="polaroid-img-3" src="https://i.imgur.com/Wp72cEM.jpg" alt="Photo 3">
        </div>
    </div>
</div>
<div id="page-2-app-container">
    <!-- 1. 左側大元件 (保持可點擊更換圖片) -->
    <div class="large-widget" onclick="handleWidgetImageChange('large-widget-img')">
        <img class="large-widget-img" id="large-widget-img" src="https://i.imgur.com/Bv63o3h.jpg" alt="Colorful Widget">
    </div>
    <!-- 2. 右側 2x2 小組件網格 (恢復App點擊事件) -->
                <div class="app-subgrid">
                    <div class="small-widget" onclick="openPresetScreen()">
                        <div class="small-widget-icon-wrapper">
                            <img class="small-widget-img" id="icon-img-preset" src="https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1758510900942_qdqqd_djw0z2.jpeg" alt="預設">
                        </div>
                        <span class="small-widget-label">預設</span>
                    </div>
                    <div class="small-widget" onclick="showScreen('tutorial-screen')">
                        <div class="small-widget-icon-wrapper">
                            <img class="small-widget-img" id="icon-img-tutorial" src="https://i.postimg.cc/d10GjC4g/IMG-7302.jpg" alt="教程">
                        </div>
                        <span class="small-widget-label">教程</span>
                    </div>
                    <div class="small-widget" onclick="openWerewolfLobby('global')">
                        <div class="small-widget-icon-wrapper">
                            <img class="small-widget-img" id="icon-img-werewolf" src="https://i.postimg.cc/k401K5g7/IMG-7304.jpg" alt="狼人殺">
                        </div>
                        <span class="small-widget-label">狼人殺</span>
                    </div>
                    <div class="small-widget" onclick="showScreen('x-social-screen')">
                        <div class="small-widget-icon-wrapper">
                            <img class="small-widget-img" id="icon-img-x" src="https://s3plus.meituan.net/opapisdk/op_ticket_1_885190757_1760887395449_qdqqd_nf1k0e.png " alt="X">
                        </div>
                        <span class="small-widget-label">X</span>
                    </div>
                </div>
</div>
        </div>
    </div>
</div>

    <!-- 2. 分頁指示器 -->
    <div id="home-screen-pagination">
        <div class="pagination-dot active"></div>
        <div class="pagination-dot"></div>
    </div>

    <!-- 3. 底部 Dock (已為您補全所有文字) -->
    <div id="desktop-dock">
        <div class="desktop-app-icon" onclick="showScreen('api-settings-screen')">
            <div class="icon-bg-desktop"><img id="icon-img-api-settings" src="https://i.postimg.cc/MK8rJ8t7/IMG-6438.jpg" alt="API設置"></div>
            <span class="label">API設置</span>
        </div>
        <div class="desktop-app-icon" onclick="showScreen('font-settings-screen')">
            <div class="icon-bg-desktop"><img id="icon-img-font" src="https://i.postimg.cc/pXxk1JXk/IMG-6442.jpg" alt="字體"></div>
            <span class="label">字體</span>
        </div>
        <div class="desktop-app-icon" onclick="openCharacterSelector()">
            <div class="icon-bg-desktop"><img id="icon-img-char-phone" src="https://i.postimg.cc/pXj9h20L/IMG-7275.jpg" alt="Cphone"></div>
            <span class="label">Cphone</span>
        </div>
        <div class="desktop-app-icon" onclick="showScreen('douban-screen')">
            <div class="icon-bg-desktop"><img id="icon-img-douban" src="https://i.postimg.cc/Pq2xJN1g/IMG-7301.jpg" alt="豆瓣"></div>
            <span class="label">豆瓣</span>
        </div>
    </div>
</div>

<!-- ▲▲▲ 替換結束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】Cphone功能的所有HTML螢幕 ▼▼▼ -->

<!-- 1. 角色選擇螢幕 -->
<div id="character-selection-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
        <span>選擇一部手機</span>
        <span style="width: 30px;"></span>
    </div>
    <div id="character-grid" class="list-container">
        <!-- 角色清單將由JS動態生成在這裡 -->
    </div>
</div>

<!-- ▼▼▼ 【V3.0 全新版本】請用這整塊代碼，完整替換舊的 #character-phone-screen ▼▼▼ -->
<div id="character-phone-screen" class="screen">
    
    <!-- 1. Cphone - 主螢幕 (這是它應該在的位置，作為獨立的頁面) -->
    <div id="char-home-screen" class="char-screen active">
        <div id="char-clock-container">
            <div id="char-main-time">12:00</div>
            <div id="char-main-date">1月1日 星期一</div>
        </div>
        <div id="char-app-grid">
            <div class="app-row">
                <div class="app-icon" onclick="openCharApp('qq')"><div class="icon-bg"><img id="cphone-icon-img-qq" src=""></div><span class="label">QQ</span></div>
                <div class="app-icon" onclick="openCharApp('album')"><div class="icon-bg"><img id="cphone-icon-img-album" src=""></div><span class="label">相冊</span></div>
                <div class="app-icon" onclick="openCharApp('browser')"><div class="icon-bg"><img id="cphone-icon-img-browser" src=""></div><span class="label">流覽器</span></div>
                <div class="app-icon" onclick="openCharApp('taobao')"><div class="icon-bg"><img id="cphone-icon-img-taobao" src=""></div><span class="label">淘寶</span></div>
            </div>
            <div class="app-row">
                <div class="app-icon" onclick="openCharApp('memo')"><div class="icon-bg"><img id="cphone-icon-img-memo" src=""></div><span class="label">備忘錄</span></div>
                <div class="app-icon" onclick="openCharApp('diary')"><div class="icon-bg"><img id="cphone-icon-img-diary" src=""></div><span class="label">日記</span></div>
                <div class="app-icon" onclick="openCharApp('amap')"><div class="icon-bg"><img id="cphone-icon-img-amap" src=""></div><span class="label">高德地圖</span></div>
                <div class="app-icon" onclick="openCharApp('usage')"><div class="icon-bg"><img id="cphone-icon-img-usage" src=""></div><span class="label">App記錄</span></div>
            </div>
            <div class="app-row">
                <div class="app-icon" onclick="openCharApp('music')"><div class="icon-bg"><img id="cphone-icon-img-music" src=""></div><span class="label">網易雲</span></div>
                <div class="app-icon" onclick="switchToMyPhone()"><div class="icon-bg"><img id="cphone-icon-img-ephone" src=""></div><span class="label">Ephone</span></div>
            </div>
        </div>
    </div>
<div id="char-amap-screen" class="char-screen">
    <div class="header">
        <span class="back-btn" onclick="switchToCharHomeScreen()">‹</span>
        <span>足跡</span>
        <div class="header-actions">
            <span class="action-btn" id="regenerate-char-amap-btn" title="重新生成足跡">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M20 11A8.1 8.1 0 0 0 4.5 9M4 5v4h4"></path>
                    <path d="M4 13a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4"></path>
                </svg>
            </span>
        </div>
    </div>
    <div id="char-amap-list" class="list-container">
        <!-- 足跡清單將由JS動態生成在這裡 -->
    </div>
</div>
    <!-- 2. Cphone - QQ App 列表頁 -->
    <div id="char-qq-screen" class="char-screen">
        <div class="header">
            <span class="back-btn" onclick="switchToCharHomeScreen()">‹</span>
            <span>QQ</span>
            <div class="header-actions">
                <span class="action-btn" id="regenerate-char-qq-btn" title="重新生成">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M20 11A8.1 8.1 0 0 0 4.5 9M4 5v4h4"></path>
                        <path d="M4 13a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4"></path>
                    </svg>
                </span>
            </div>
        </div>
        <div id="char-chat-list" class="list-container"></div>
    </div>
    
    <!-- 3. Cphone - 類比對話頁面 -->
    <div id="char-qq-conversation-screen" class="char-screen">
        <div class="header">
            <span class="back-btn" id="back-to-char-qq-list-btn">‹</span>
            <span id="char-conversation-partner-name"></span>
            <span style="width: 30px;"></span>
        </div>
        <div id="char-conversation-messages" class="list-container">
        </div>
        <div id="char-conversation-input-area" style="padding: 8px; border-top: 1px solid var(--border-color); display: flex; gap: 8px; background-color: #f7f7f7;">
            <input type="text" id="char-simulated-input" placeholder="這是類比對話，無法發送消息" disabled style="flex-grow: 1; padding: 10px; border-radius: 6px; border: 1px solid #ddd; background: #eee;">
            <button id="char-simulated-send-btn" style="padding: 0 20px; border: none; background-color: var(--accent-color); color: white; border-radius: 6px; font-weight: 500;">發送</button>
        </div>
    </div>
    
    <!-- 4. Cphone - 相冊 App 頁面 (這是它應該在的位置，與主螢幕平級) -->
    <div id="char-album-screen" class="char-screen">
        <div class="header">
            <span class="back-btn" onclick="switchToCharHomeScreen()">‹</span>
            <span>TA的相冊</span>
            <div class="header-actions">
                <span class="action-btn" id="regenerate-char-album-btn" title="重新生成相冊內容">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M20 11A8.1 8.1 0 0 0 4.5 9M4 5v4h4"></path>
                        <path d="M4 13a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4"></path>
                    </svg>
                </span>
            </div>
        </div>
        <div class="list-container">
            <div id="char-album-grid"></div>
        </div>
    </div>

<!-- ▼▼▼ 【全新V2.0 | 支援文章/圖片】請用這整塊代碼，替換舊的 #char-browser-screen ▼▼▼ -->
<div id="char-browser-screen" class="char-screen">
    <div class="header">
        <span class="back-btn" onclick="switchToCharHomeScreen()">‹</span>
        <span>TA的流覽器歷史</span>
        <!-- 【核心新增】重新生成按鈕 -->
        <div class="header-actions">
            <span class="action-btn" id="regenerate-char-browser-btn" title="重新生成流覽記錄">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M20 11A8.1 8.1 0 0 0 4.5 9M4 5v4h4"></path>
                    <path d="M4 13a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4"></path>
                </svg>
            </span>
        </div>
    </div>
    <div id="char-browser-history" class="list-container">
        <!-- 流覽記錄將由JS動態生成在這裡 -->
    </div>
</div>

<!-- 【【【核心新增：全新的文章查看頁面】】】 -->
<div id="char-browser-article-screen" class="char-screen">
    <div class="header">
        <span class="back-btn" onclick="switchToCharScreen('char-browser-screen')">‹</span>
        <span id="char-article-title" style="max-width: 70%; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">文章</span>
        <span style="width: 30px;"></span>
    </div>
    <div id="char-article-content" class="list-container" style="padding: 20px; font-size: 16px; line-height: 1.8; color: #333; overflow-y: auto;">
        <!-- 文章或圖片內容將由JS動態生成在這裡 -->
    </div>
</div>
<!-- ▼▼▼ 【全新V2.0 | 支持錢包】請用這整塊代碼，完整替換舊的 #char-taobao-screen ▼▼▼ -->
<div id="char-taobao-screen" class="char-screen">
    <div class="header">
        <span class="back-btn" onclick="switchToCharHomeScreen()">‹</span>
        <span>TA的淘寶訂單</span>
        <div class="header-actions">
            
            <!-- 【核心新增2】重新生成按鈕 -->
            <span class="action-btn" id="regenerate-char-taobao-btn" title="重新生成購買記錄">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M20 11A8.1 8.1 0 0 0 4.5 9M4 5v4h4"></path>
                    <path d="M4 13a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4"></path>
                </svg>
            </span>
        </div>
    </div>
    <!-- 購買記錄清單 (複用舊的grid，但內容會是動態的) -->
    <div id="char-product-grid" class="list-container"></div>
</div>


<div id="char-memo-screen" class="char-screen">
    <div class="header">
        <span class="back-btn" onclick="switchToCharHomeScreen()">‹</span>
        <span>備忘錄</span>
        <div class="header-actions">
            <!-- 【核心新增】重新生成按鈕 -->
            <span class="action-btn" id="regenerate-char-memo-btn" title="重新生成備忘錄">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M20 11A8.1 8.1 0 0 0 4.5 9M4 5v4h4"></path>
                    <path d="M4 13a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4"></path>
                </svg>
            </span>
            <span class="action-btn" id="add-char-memo-btn">+</span>
        </div>
    </div>
    <!-- 【核心修改】確保列表有內邊距，更美觀 -->
    <div id="char-memo-list" class="list-container" style="padding: 10px;"></div>
</div>
<!-- ▲▲▲ 替換結束 ▲▲▲ -->
<!-- ▼▼▼ 在 #char-memo-screen 的 div 之後，黏貼這個全新的備忘錄詳情螢幕 ▼▼▼ -->
<div id="char-memo-detail-screen" class="char-screen">
    <div class="header">
        <!-- 這個返回按鈕會帶我們回到備忘錄列表 -->
        <span class="back-btn" id="char-memo-detail-back-btn">‹</span>
        <!-- 這裡會動態顯示備忘錄的標題 -->
        <span id="char-memo-detail-title"></span>
        <!-- 右上角的預留位置，保持標題居中 -->
        <span style="width: 80px;"></span>
    </div>
    <!-- 這個容器將用來顯示備忘錄的完整內容 -->
    <div class="form-container" style="padding: 0;">
        <textarea id="char-memo-detail-content" readonly></textarea>
    </div>
</div>
<!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->
<!-- ▼▼▼ 用這整塊新代碼替換舊的 #char-diary-screen ▼▼▼ -->
<div id="char-diary-screen" class="char-screen">
    <div class="header">
        <span class="back-btn" onclick="switchToCharHomeScreen()">‹</span>
        <span>日記</span>
        <div class="header-actions">
            <!-- 【核心新增】重新生成按鈕 -->
            <span class="action-btn" id="regenerate-char-diary-btn" title="重新生成日記本">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M20 11A8.1 8.1 0 0 0 4.5 9M4 5v4h4"></path>
                    <path d="M4 13a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4"></path>
                </svg>
            </span>
            <!-- 【核心修改】這個“+”號現在會觸發AI寫一篇新日記 -->
            <span class="action-btn" id="add-char-diary-btn">+</span>
        </div>
    </div>
    <div id="char-diary-list" class="list-container"></div>
</div>

<!-- 【【【核心新增：全新的日記詳情螢幕】】】 -->
<div id="char-diary-detail-screen" class="char-screen">
<div class="header">
    <span class="back-btn" id="char-diary-detail-back-btn">‹ </span>
    <span id="char-diary-detail-title"></span>
    <!-- 【核心新增】在這裡添加收藏按鈕 -->
    <div class="header-actions">
        <span class="action-btn" id="favorite-diary-btn" title="收藏">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>
            </svg>
        </span>
    </div>
</div>
    <div id="char-diary-detail-content-wrapper" class="list-container">
        <div id="char-diary-detail-content">
            <!-- 日記內容將由JS動態生成在這裡 -->
        </div>
    </div>
</div>
<!-- ▲▲▲ 替換結束 ▲▲▲ -->
<!-- ▼▼▼ 【請用這個V2.0版本】完整替換舊的 id="char-usage-screen" 的 div ▼▼▼ -->
<div id="char-usage-screen" class="char-screen">
    <div class="header">
        <span class="back-btn" onclick="switchToCharHomeScreen()">‹</span>
        <span>App使用記錄</span>
        <div class="header-actions">
            <!-- 【核心新增】重新生成按鈕 -->
            <span class="action-btn" id="regenerate-char-usage-btn" title="重新生成記錄">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M20 11A8.1 8.1 0 0 0 4.5 9M4 5v4h4"></path>
                    <path d="M4 13a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4"></path>
                </svg>
            </span>
        </div>
    </div>
    <div id="char-usage-list" class="list-container">
        <!-- App使用記錄將由JS動態生成在這裡 -->
    </div>
</div>
<!-- ▲▲▲ 替換結束 ▲▲▲ -->

    <!-- 類比聊天記錄的彈窗 (保持不變) -->
    <div id="char-qq-transcript-modal" class="modal">
        <div class="modal-content" style="height: 80%;">
            <div class="modal-header">
                <span id="transcript-modal-char-name"></span>
            </div>
            <div class="modal-body" id="transcript-modal-body" style="background-color: #f0f2f5; padding: 15px; display: flex; flex-direction: column; gap: 15px;">
            </div>
            <div class="modal-footer">
                <button class="save" id="close-transcript-modal-btn" style="width:100%;">關閉</button>
            </div>
        </div>
    </div>
<!-- ▼▼▼ 步驟 1-2：將這整塊全新的“網易雲音樂”螢幕和播放機，完整黏貼到 id="character-phone-screen" 的 div 內部末尾 ▼▼▼ -->

<!-- 1. 網易雲音樂App主螢幕 -->
<div id="char-music-screen" class="char-screen">
    <div class="header">
        <span class="back-btn" onclick="switchToCharHomeScreen()">‹</span>
        <span>TA的歌單</span>
        <div class="header-actions">
            <span class="action-btn" id="regenerate-char-music-btn" title="重新生成歌單">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M20 11A8.1 8.1 0 0 0 4.5 9M4 5v4h4"></path>
                    <path d="M4 13a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4"></path>
                </svg>
            </span>
        </div>
    </div>
    <div id="char-music-list" class="list-container">
        <!-- 歌曲清單將由JS動態生成在這裡 -->
    </div>
</div>

<!-- ▼▼▼ 請用這整塊【全新 V3.0 | 仿黑膠唱片機UI】的代碼，替換舊的 char-music-player-modal ▼▼▼ -->
<div id="char-music-player-modal" class="modal">
    <div class="modal-content">
        <!-- 主內容區 -->
        <div class="char-player-body">
            <!-- 歌曲信息 -->
            <div class="char-player-song-info">
                <p id="char-music-player-title">歌曲名稱</p>
                <p id="char-music-artist">歌手</p>
            </div>

            <!-- 專輯封面 (黑膠唱片效果) -->
            <div id="char-vinyl-container">
                <img id="char-music-cover" src="">
            </div>
            
            <!-- 【核心修改】將音符預留位置替換為真正的歌詞容器 -->
            <div id="char-music-lyrics">
                <!-- 歌詞將由JS動態生成在這裡 -->
            </div>

            <!-- 底部控制欄 -->
            <div class="char-player-footer">
                <div class="char-player-progress-bar-container">
                    <span id="char-music-current-time" class="time-display">0:00</span>
                    <div id="char-music-progress-bar" class="char-player-progress-bar">
                        <div id="char-music-progress-fill"></div>
                    </div>
                    <span id="char-music-total-time" class="time-display">0:00</span>
                </div>

                <div class="char-player-controls">
                    <button id="char-music-prev-btn" class="control-btn">
                        <svg viewBox="0 0 24 24" width="24" height="24" fill="currentColor"><path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"></path></svg>
                    </button>
                    <button id="char-music-play-pause-btn" class="control-btn play">
                        <svg viewBox="0 0 24 24" width="32" height="32" fill="currentColor"><path d="M8 5v14l11-7z"></path></svg>
                    </button>
                    <button id="char-music-next-btn" class="control-btn">
                         <svg viewBox="0 0 24 24" width="24" height="24" fill="currentColor"><path d="M16 6h2v12h-2zm-3.5 6l-8.5 6V6z"></path></svg>
                    </button>
                     <button id="char-music-mode-btn" class="control-btn mode">順序</button>
                </div>
            </div>
        </div>
        <!-- 關閉按鈕被移到右上角 -->
        <button id="close-char-music-player-btn" class="char-player-close-btn">×</button>
    </div>
</div>
<!-- ▲▲▲ 替換結束 ▲▲▲ -->
</div>
<!-- ▲▲▲ 替換結束 ▲▲▲ -->

        <!-- ▼▼▼ 【請用這個新版本】完整替換舊的 world-book-screen ▼▼▼ -->
        <div id="world-book-screen" class="screen">
            <div class="header">
    <!-- 將所有需要靠左的按鈕，用一個新的 div 包裹起來 -->
    <div class="header-left-actions">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
        <span class="action-btn" id="import-world-book-btn" title="導入世界書">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                <polyline points="17 8 12 3 7 8"></polyline>
                <line x1="12" y1="3" x2="12" y2="15"></line>
            </svg>
        </span>
        <span class="action-btn" id="export-world-book-btn" title="匯出世界書">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                <polyline points="7 10 12 15 17 10"></polyline>
                <line x1="12" y1="15" x2="12" y2="3"></line>
            </svg>
        </span>
    </div>
                <span>世界書</span>
                <div class="header-actions">
                    <!-- 【核心修改1】將文字按鈕替換為SVG圖示 -->
                    <span class="action-btn" id="manage-world-book-categories-btn" title="管理分類">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                            <polyline points="14 2 14 8 20 8"></polyline>
                            <line x1="16" y1="13" x2="8" y2="13"></line>
                            <line x1="16" y1="17" x2="8" y2="17"></line>
                            <polyline points="10 9 9 9 8 9"></polyline>
                        </svg>
                    </span>
                    <span class="action-btn" id="add-world-book-btn">+</span>
                </div>
            </div>
            <!-- 【核心修改2】全新的頁簽和內容區結構 -->
            <div id="world-book-tabs"></div>
            <div id="world-book-content-container"></div>
        </div>
        <!-- ▼▼▼ 【請將這個缺失的代碼塊】黏貼到 id="world-book-screen" 的 div 之後 ▼▼▼ -->
        <div id="world-book-editor-screen" class="screen">
            <div class="header">
                <span class="back-btn" onclick="showScreen('world-book-screen')">‹</span>
                <span id="world-book-editor-title">編輯世界書</span>
                <span class="save-btn" id="save-world-book-btn">保存</span>
            </div>
            <div class="form-container">
                <div class="form-group">
                    <label for="world-book-name-input">書名</label>
                    <input type="text" id="world-book-name-input" placeholder="請輸入世界書的名稱...">
                </div>
                <div class="form-group">
                    <label for="world-book-category-select">分類</label>
                    <select id="world-book-category-select"></select>
                </div>
                <!-- 編輯器區域 -->
                <div class="form-group" style="flex-grow: 1; display: flex; flex-direction: column;">
                    <label>內容條目</label>
                    <!-- 這個容器將用來動態裝載所有可編輯的條目塊 -->
                    <div id="world-book-entries-container" style="display: flex; flex-direction: column; gap: 15px; overflow-y: auto; padding: 5px; flex-grow: 1;">
                        <!-- JS 會在這裡動態生成內容 -->
                    </div>
                </div>
                <!-- 添加新條目的按鈕 -->
                <button id="add-world-book-entry-btn" class="form-button form-button-secondary"> [+] 添加新條目 </button>
            </div>
        </div>
        <!-- ▲▲▲ 黏貼結束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】這是“預設”App的所有HTML螢幕，請黏貼到 world-book-editor-screen 之後 ▼▼▼ -->
<div id="preset-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
        <span>預設</span>
        <div class="header-actions">
 <span class="action-btn" id="import-preset-btn" title="導入預設文件">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="17 8 12 3 7 8"></polyline>
                        <line x1="12" y1="3" x2="12" y2="15"></line>
                    </svg>
                </span>
            <span class="action-btn" id="manage-preset-categories-btn" title="管理分類">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                    <polyline points="14 2 14 8 20 8"></polyline>
                    <line x1="16" y1="13" x2="8" y2="13"></line>
                    <line x1="16" y1="17" x2="8" y2="17"></line>
                </svg>
            </span>
            <span class="action-btn" id="add-preset-btn">+</span>
        </div>
    </div>
    <div id="preset-tabs"></div>
    <div id="preset-content-container"></div>
</div>
<!-- ▼▼▼ 【全新】這是教程頁面，請黏貼到其他 .screen 的div旁邊 ▼▼▼ -->
<div id="tutorial-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
        <span>教程</span>
        <span style="width: 30px;"></span> <!-- 預留位置，保持標題居中 -->
    </div>
    <div class="list-container" style="padding: 0; overflow: hidden;">
        <!-- 這裡會嵌入你的教程HTML檔 -->
        <iframe id="tutorial-iframe" src="tutorial.html" style="width: 100%; height: 100%; border: none;"></iframe>
    </div>
</div>
<!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->
<div id="preset-editor-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('preset-screen')">‹</span>
        <span id="preset-editor-title">編輯預設</span>
        <span class="save-btn" id="save-preset-btn">保存</span>
    </div>
    <div class="form-container">
        <div class="form-group">
            <label for="preset-name-input">預設名稱</label>
            <input type="text" id="preset-name-input" placeholder="請輸入預設的名稱...">
        </div>
        <div class="form-group">
            <label for="preset-category-select">分類</label>
            <select id="preset-category-select"></select>
        </div>
        <div class="form-group" style="flex-grow: 1; display: flex; flex-direction: column;">
            <label>內容條目</label>
            <div id="preset-entries-container" style="display: flex; flex-direction: column; gap: 15px; overflow-y: auto; padding: 5px; flex-grow: 1;">
            </div>
        </div>
        <button type="button" id="add-preset-entry-btn" class="form-button form-button-secondary"> [+] 添加新條目 </button>
    </div>
</div>
<!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->
        <!-- ▼▼▼ 用下面這段代碼，完整替換掉你原來的 id="api-settings-screen" 的 div ▼▼▼ -->
        <div id="api-settings-screen" class="screen">
            <div class="header">
                <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
                <span>API 設置</span>
                <span style="width: 30px;"></span>
            </div>
            <div class="form-container">
                <!-- 【【【全新：API預設管理】】】 -->
                <h3 style="margin-top:0; border-bottom: 1px solid #eee; padding-bottom: 10px;">API 預設管理</h3>
                <div class="form-group">
                    <label for="api-preset-select">選擇或切換預設</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <select id="api-preset-select" style="flex-grow: 1;"></select>
                        <button id="save-api-preset-btn" class="form-button-secondary" style="margin-top: 0; padding: 12px;">保存</button>
                        <button id="delete-api-preset-btn" class="form-button-secondary" style="margin-top: 0; padding: 12px; background-color: #ffebee; color: #d32f2f; border-color: #ffcdd2;">刪除</button>
                    </div>
                </div>
                <hr style="margin: 30px 0; opacity: 0.3;">
                <!-- 主API設置 -->
                <h3 style="margin-top:0; border-bottom: 1px solid #eee; padding-bottom: 10px;">主API設置 (用於聊天)</h3>
                <p style="font-size: 14px; color: #666; background-color: #f0f0f0; padding: 10px; border-radius: 8px;"> 提示: 若要使用“發送圖片”功能, 請務必選擇支援Vision(視覺)的模型, 如<code style="background-color: #e0e0e0; padding: 2px 4px; border-radius: 4px;">gpt-4o</code>或<code
                        style="background-color: #e0e0e0; padding: 2px 4px; border-radius: 4px;">gpt-4-vision-preview</code>。 </p>
                <div class="form-group">
                    <label for="proxy-url">反代位址 (不需要添加/v1噢~)</label>
                    <input type="text" id="proxy-url" placeholder="例如: https://api.openai.com">
                </div>
                <div class="form-group">
                    <label for="api-key">金鑰 (API Key)</label>
                    <input type="password" id="api-key" placeholder="sk-...">
                </div>
                <div class="form-group">
                    <label for="model-select">模型</label>
                    <select id="model-select"></select>
                </div>
                <button class="form-button" id="fetch-models-btn">拉取主模型</button>
                <!-- 副API設置 -->
                <hr style="margin: 30px 0; opacity: 0.3;">
                <h3 style="border-bottom: 1px solid #eee; padding-bottom: 10px;">副API設置 (用於總結長期記憶)</h3>
                <p style="font-size: 14px; color: #666; background-color: #f0f0f0; padding: 10px; border-radius: 8px;"> 您可以在此配置一個獨立的、可能成本更低的API，專門用於後臺的長期記憶總結任務，以節省主API的費用。如果留空，將默認使用主API進行總結。 </p>
                <div class="form-group">
                    <label for="secondary-proxy-url">副反代地址</label>
                    <input type="text" id="secondary-proxy-url" placeholder="例如: https://api.groq.com/openai">
                </div>
                <div class="form-group">
                    <label for="secondary-api-key">副金鑰</label>
                    <input type="password" id="secondary-api-key" placeholder="gsk_...">
                </div>
                <div class="form-group">
                    <label for="secondary-model-select">副模型</label>
                    <select id="secondary-model-select"></select>
                </div>
                <button class="form-button form-button-secondary" id="fetch-secondary-models-btn">拉取副模型</button>
<div class="form-group">
    <label for="api-temperature-slider">API 溫度 (Temperature) <span id="api-temperature-value">0.8</span></label>
    <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
        控制AI回復的隨機性和創造性。值越高，回復越隨機；值越低，回復越確定。建議範圍 0.7-1.0。
    </p>
    <input type="range" id="api-temperature-slider" min="0" max="2" step="0.1" value="0.8" style="width: 100%; margin-top: 8px;">
</div>
                <!-- 後臺活動設置 -->
                <hr style="margin: 30px 0; opacity: 0.3;">
                <h3 style="border-bottom: 1px solid #eee; padding-bottom: 10px;">後臺活動設置</h3>
                <div class="form-group" style="display: flex; justify-content: space-between; align-items: center;">
                    <label for="background-activity-switch" style="margin-bottom: 0;"> 啟用後臺角色活動 <p style="font-size: 12px; font-weight: normal; color: #ff6b6b; margin-top: 5px;"> 警告：此功能會顯著增加API調用和費用！ </p>
                    </label>
                    <input type="checkbox" id="background-activity-switch" style="width: auto; height: 20px;">
                </div>
                <div class="form-group" style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px;">
                    <label for="background-interval-input" style="margin-bottom: 0;"> 後臺活動檢測間隔 (秒) <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;"> 建議值 60-300。值越大，費用越低，但角色反應越慢。 </p>
                    </label>
                    <input type="number" id="background-interval-input" min="30" value="60" style="width: 80px; text-align: center;">
                </div>
                <div class="form-group" style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px;">
                    <label for="block-cooldown-input" style="margin-bottom: 0;"> AI被拉黑後冷靜期 (小時) <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;"> 被拉黑超過這個時間後，AI才有幾率重新申請好友。 </p>
                    </label>
                    <input type="number" id="block-cooldown-input" min="0.1" step="0.1" value="1" style="width: 80px; text-align: center;">
                </div>
<!-- ▼▼▼ 在這裡黏貼下面的新代碼 ▼▼▼ -->
<hr style="margin: 30px 0; opacity: 0.3;">
<h3 style="border-bottom: 1px solid #eee; padding-bottom: 10px;">語音訊息設置 (Minimax TTS)</h3>
<p style="font-size: 14px; color: #666; background-color: #f0f0f0; padding: 10px; border-radius: 8px;">
    在 AI 回復的文字前加上 <code style="background-color: #e0e0e0; padding: 2px 4px; border-radius: 4px;">[V]</code> 首碼，即可讓該條消息自動渲染為可播放的語音。
</p>
<div class="form-group">
    <label for="minimax-group-id">Minimax Group ID</label>
    <input type="text" id="minimax-group-id" placeholder="在此輸入你的 Group ID">
</div>
<div class="form-group">
    <label for="minimax-api-key">Minimax API Key</label>
    <input type="password" id="minimax-api-key" placeholder="在此輸入你的 API Key">
</div>
<!-- ▲▲▲ 黏貼結束 ▲▲▲ -->
<!-- ▼▼▼ 在這裡黏貼下面的新代碼 ▼▼▼ -->
<div class="form-group">
    <label for="minimax-model-select">語音模型 (Model)</label>
    <select id="minimax-model-select">
        <option value="speech-01">speech-01 (標準)</option>
        <option value="speech-02">speech-02 (高清)</option>
    </select>
</div>
<!-- ▲▲▲ 黏貼結束 ▲▲▲ -->
<hr style="margin: 30px 0; opacity: 0.3;">
                <h3 style="border-bottom: 1px solid #eee; padding-bottom: 10px;">性能與顯示設定</h3>
                <div class="form-group" style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px;">
                    <label for="chat-list-render-window-input" style="margin-bottom: 0;">
                        聊天列表每次載入條數
                        <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
                            控制主頁聊天列表下拉時每次載入會話的數量。默認30。
                        </p>
                    </label>
                    <input type="number" id="chat-list-render-window-input" min="10" value="30" style="width: 80px; text-align: center;">
                </div>
                <div class="form-group" style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px;">
                    <label for="chat-render-window-input" style="margin-bottom: 0;">
                        聊天介面初始載入條數
                        <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
                            打開聊天時預設顯示的最近消息數量。值越大，初次載入越慢。
                        </p>
                    </label>
                    <input type="number" id="chat-render-window-input" min="10" value="50" style="width: 80px; text-align: center;">
                </div>
                <hr style="margin: 30px 0; opacity: 0.3;">
                <h3 style="border-bottom: 1px solid #eee; padding-bottom: 10px;">生圖功能設置</h3>
                <div class="form-group" style="display: flex; justify-content: space-between; align-items: center;">
                    <label for="enable-ai-drawing-switch" style="margin-bottom: 0;">
                        啟用AI生圖功能
                        <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
                            關閉後，所有需要AI生成的圖片（動態、頭像等）都將顯示為占點陣圖，以節省流量和API費用。
                        </p>
                    </label>
                    <label class="toggle-switch">
                        <input type="checkbox" id="enable-ai-drawing-switch">
                        <span class="slider"></span>
                    </label>
                </div>
<!-- ▼▼▼ 在這裡黏貼下面的新按鈕代碼 ▼▼▼ -->
<hr style="margin: 30px 0; opacity: 0.3;">
<h3 style="border-bottom: 1px solid #eee; padding-bottom: 10px;">存儲空間優化</h3>
<button class="form-button form-button-secondary" id="compress-images-btn" style="background-color: #e8f5e9; color: #2e7d32; border-color: #c8e6c9;">
    一鍵壓縮本地圖片
</button>
<p style="font-size: 12px; color: #8a8a8a; margin-top: 8px; line-height: 1.5;">
    此功能會將您所有本地上傳的圖片（如頭像、表情包、聊天圖片、頭像框、元件圖等）壓縮為JPEG格式，以大幅減小資料體積。
    <br><strong style="color: #ff3b30;">警告：這是一個失真壓縮且不可逆的操作，會輕微降低圖片品質。建議操作前先備份資料。</strong>
</p>
<!-- ▲▲▲ 黏貼結束 ▲▲▲ -->
                <!-- 保存與導入匯出 -->
                <hr style="margin: 30px 0; opacity: 0.3;">
                <button class="form-button" id="save-api-settings-btn" style="margin-top: 20px;">保存所有設置</button>
                <button class="form-button" id="export-data-btn">匯出數據</button>
                <button class="form-button" id="import-btn">導入備份檔案</button>
<!-- ▼▼▼ 在這裡黏貼下面的新按鈕代碼 ▼▼▼ -->
<button class="form-button form-button-secondary" id="cleanup-data-btn" style="background-color: #ffebee; color: #c62828; border-color: #ef9a9a; margin-top: 10px;">清理冗餘數據</button>
<button class="form-button form-button-secondary" id="delete-world-books-btn" style="background-color: #ffebee; color: #c62828; border-color: #ef9a9a; margin-top: 10px;">刪除世界書</button>
<!-- ▲▲▲ 黏貼結束 ▲▲▲ -->
<button class="form-button form-button-secondary" id="clear-specific-data-btn" style="background-color: #ffcdd2; color: #b71c1c; border-color: #ef9a9a; margin-top: 10px;">高級資料清理</button>
<button class="form-button form-button-secondary" id="check-and-fix-data-btn" style="background-color: #e3f2fd; color: #0d47a1; border-color: #bbdefb; margin-top: 10px;">資料檢查與修復</button>
                <input id="import-data-input" type="file" accept="application/json" hidden>

            </div>
        </div>
        <!-- ▲▲▲ 替換結束 ▲▲▲ -->
<!-- 【【【全新 V2.0 | 支持全選】：高級資料清理嚮導模態框】】】 -->
<div id="data-clear-wizard-modal" class="modal">
    <div class="modal-content" style="height: 80%;">
        <!-- 步驟 1: 選擇角色 -->
        <div id="data-clear-step-1" class="wizard-step">
            <div class="modal-header">
                <span>第一步：選擇要清理的角色</span>
                <!-- 核心新增：全選核取方塊 -->
                <label>
                    <input type="checkbox" id="select-all-chars-for-clear"> 全選
                </label>
            </div>
            <div class="modal-body" id="data-clear-char-list" style="padding: 0;">
                <!-- 角色清單將由JS動態生成 -->
            </div>
            <div class="modal-footer">
                <button class="cancel" id="cancel-clear-wizard-btn-step1">取消</button>
                <button class="save" id="go-to-clear-step2-btn">下一步</button>
            </div>
        </div>
        <!-- 步驟 2: 選擇資料類型 -->
        <div id="data-clear-step-2" class="wizard-step" style="display: none;">
            <div class="modal-header">
                <span>第二步：選擇要清理的資料類型</span>
                <!-- 核心新增：全選核取方塊 -->
                <label>
                    <input type="checkbox" id="select-all-types-for-clear"> 全選
                </label>
            </div>
            <div class="modal-body" id="data-clear-type-list" style="padding: 0;">
                <!-- 資料類型清單將由JS動態生成 -->
            </div>
            <div class="modal-footer">
                <button class="form-button-secondary" id="back-to-clear-step1-btn" style="width: 30%; margin:0;">上一步</button>
                <button class="cancel" id="cancel-clear-wizard-btn-step2" style="width: 30%; margin:0;">取消</button>
                <button class="save btn-danger" id="confirm-final-clear-btn" style="width: 30%; margin:0;">確認清理</button>
            </div>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->
        <!-- ▼▼▼ 用下面這段代碼，完整替換掉你原來的 chat-list-screen ▼▼▼ -->
        <div id="chat-list-screen" class="screen">
            <!-- 主頭部 (只在消息清單顯示) -->
            <div class="header" id="main-chat-list-header">
                <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
                <span id="chat-list-title">消息</span>
                <div class="header-actions">
                    <span class="action-btn" id="add-group-chat-btn" title="創建群聊"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M17.5 17.5C19.1569 17.5 20.5 16.1569 20.5 14.5C20.5 12.8431 19.1569 11.5 17.5 11.5C15.8431 11.5 14.5 12.8431 14.5 14.5C14.5 16.1569 15.8431 17.5 17.5 17.5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                            <path d="M21 21L19 19" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                            <path d="M8.5 11.5C10.1569 11.5 11.5 10.1569 11.5 8.5C11.5 6.84315 10.1569 5.5 8.5 5.5C6.84315 5.5 5.5 6.84315 5.5 8.5C5.5 10.1569 6.84315 11.5 8.5 11.5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                            <path d="M12.5 14.5H4.5C3.39543 14.5 2.5 15.3954 2.5 16.5V18.5H12.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                        </svg></span>
                    <span class="action-btn" id="add-chat-btn">+</span>
                </div>
            </div>
            <!-- 消息清單視圖 -->
            <div id="messages-view" class="chat-list-view active">
                <div id="chat-list">
                    <!-- JS會在這裡生成聊天列表 -->
                </div>
            </div>
            <!-- 動態介面視圖 -->
            <div id="qzone-screen" class="chat-list-view">
                <div class="qzone-header">
                    <span class="back-btn" id="qzone-back-btn">‹</span> <!-- 這個按鈕現在只負責從動態返回 -->
                    <span>好友動態</span>
    <div class="header-actions">
        <span class="action-btn" id="qzone-more-actions-btn" title="更多操作">…</span>
    </div>
                </div>
                <div class="qzone-content">
                    <div class="qzone-profile-header">
                        <div id="qzone-banner-container" class="qzone-banner-container">
                            <img id="qzone-banner-img" src="https://files.catbox.moe/r5heyt.gif" alt="背景">
                            <input type="file" id="qzone-banner-input" accept="image/*" hidden>
                        </div>
                        <div class="qzone-user-info">
                            <div id="qzone-avatar-container" class="qzone-avatar-container">
                                <img id="qzone-avatar-img" src="https://files.catbox.moe/q6z5fc.jpeg" alt="頭像">
                                <input type="file" id="qzone-avatar-input" accept="image/*" hidden>
                            </div>
                            <span id="qzone-nickname">{{user}}</span>
                        </div>
                    </div>
                    <div class="qzone-actions-bar">
                        <div class="action-item" id="create-shuoshuo-btn"><span>說說</span></div>
                        <div class="action-item" id="create-post-btn"><span>動態</span></div>
                        <div class="action-item" id="open-album-btn"><span>相冊</span></div>
                    </div>
                    <div id="qzone-posts-list"></div>
                </div>
            </div>
            <!-- 收藏介面視圖 -->
            <div id="favorites-view" class="chat-list-view">
                <div class="header">
                    <span class="back-btn" id="favorites-back-btn">‹</span>
                    <span>我的收藏</span>
                    <!-- 新增的編輯按鈕 -->
                    <span class="action-btn" id="favorites-edit-btn">編輯</span>
                </div>
                <!-- 【新增】搜索欄容器 -->
                <div class="search-bar-container">
                    <input type="search" id="favorites-search-input" placeholder="搜索收藏的標題、內容或作者...">
                    <button id="favorites-search-clear-btn" class="search-clear-btn" style="display: none;">×</button>
                </div>
                <div id="favorites-list" class="list-container">
                    <!-- 收藏內容將由JS動態生成在這裡 -->
                </div>
                <!-- 新增：收藏頁底部操作欄 -->
                <div id="favorites-action-bar" style="display: none;">
                    <button id="favorites-delete-selected-btn" class="action-bar-btn">刪除 (0)</button>
                </div>
            </div>
            <!-- ▼▼▼ 【全新】回憶錄介面視圖 ▼▼▼ -->
            <div id="memories-view" class="chat-list-view">
                <div class="header">
                    <span class="back-btn" id="memories-back-btn">‹</span>
                    <span>我們的回憶</span>
                    <span class="action-btn" id="add-countdown-btn">+</span>
                </div>
                <div id="memories-list" class="list-container" style="padding: 15px; display: flex; flex-direction: column; gap: 15px;">
                    <!-- 回憶卡片將由JS動態生成在這裡 -->
                </div>
            </div>
            <!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->
            <div id="npc-list-view" class="chat-list-view">
                <div class="header">
                    <span class="back-btn" id="npc-list-back-btn">‹</span>
                    <span>NPC 列表</span>
                    <div class="header-actions">
                        <span class="action-btn" id="add-npc-btn">+</span>
                    </div>
                </div>
                <div id="npc-list" class="list-container" style="padding: 0;">
                    <!-- NPC清單將由JS動態生成在這裡 -->
                </div>
            </div>
            <!-- 底部巡覽列 -->
            <div id="chat-list-bottom-nav">
                <div class="nav-item active" data-view="messages-view">
                    <span>消息</span>
                </div>
                <div class="nav-item" data-view="qzone-screen">
                    <span>動態</span>
                </div>
                <!-- ▼▼▼ 在“動態”和“收藏”之間，加入這個新頁簽 ▼▼▼ -->
                <div class="nav-item" data-view="memories-view">
                    <span>回憶</span>
                </div>
                <!-- ▲▲▲ 添加結束 ▲▲▲ -->
                <div class="nav-item" data-view="favorites-view">
                    <span>收藏</span>
                </div>
                <div class="nav-item" data-view="npc-list-view">
                    <span>NPC</span>
                </div>
            </div>
        </div>
        <!-- ▲▲▲ 替換區域結束 ▲▲▲ -->
        <!-- ▼▼▼ 請將這段新的 HTML 黏貼到 id="chat-list-screen" 的 div 之後 ▼▼▼ -->
        <div id="album-screen" class="screen">
            <!-- 1. 頁面頭部，包含返回按鈕和標題 -->
            <div class="header">
                <span class="back-btn" id="album-back-btn">‹</span>
                <span>我的相冊</span>
                <span class="action-btn" id="create-album-btn-page">+</span>
            </div>
            <!-- 2. 頁面內容容器 -->
            <div class="list-container">
                <div id="album-grid-page">
                    <!-- 相簿清單將由 JS 動態生成在這裡 -->
                </div>
            </div>
        </div>
        <!-- ▲▲▲ 新的 HTML 黏貼結束 ▲▲▲ -->
        <!-- ▼▼▼ 請將這段新的 HTML 黏貼到 id="album-screen" 的 div 之後 ▼▼▼ -->
        <div id="album-photos-screen" class="screen">
            <!-- 1. 頁面頭部 -->
            <div class="header">
                <span class="back-btn" id="album-photos-back-btn">‹</span>
                <span id="album-photos-title">相冊名稱</span>
                <span class="action-btn" id="album-upload-photo-btn">上傳</span>
            </div>
            <!-- 2. 頁面內容容器 -->
            <div class="list-container">
                <div id="photos-grid-page">
                    <!-- 照片清單將由 JS 動態生成在這裡 -->
                </div>
                <!-- ▼▼▼ 請將這段新的 HTML 黏貼到所有模態框的末尾 ▼▼▼ -->
                <div id="photo-viewer-modal" class="modal">
                    <!-- 1. 關閉按鈕 -->
                    <button id="photo-viewer-close-btn">×</button>
                    <!-- 2. 上一張照片按鈕 -->
                    <button id="photo-viewer-prev-btn" class="nav-arrow">‹</button>
                    <!-- 3. 圖片容器 -->
                    <div class="photo-viewer-content">
                        <img id="photo-viewer-image" src="" alt="全屏照片預覽">
                    </div>
                    <!-- 4. 下一張照片按鈕 -->
                    <button id="photo-viewer-next-btn" class="nav-arrow">›</button>
                </div>
                <!-- ▲▲▲ 新的 HTML 黏貼結束 ▲▲▲ -->
            </div>
        </div>
        <!-- ▲▲▲ 新的 HTML 黏貼結束 ▲▲▲ -->
<div id="npc-editor-modal" class="modal">
    <div class="modal-content" style="height: 80%;">
        <div class="modal-header">
            <span id="npc-editor-title">添加 NPC</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label>NPC 頭像</label>
                <div class="avatar-upload">
                    <img id="npc-avatar-preview" src="https://i.postimg.cc/VkQfgzGJ/1.jpg">
                    <button onclick="document.getElementById('npc-avatar-input').click()">上傳頭像</button>
                    <input type="file" id="npc-avatar-input" accept="image/*" hidden>
                </div>
            </div>
            <div class="form-group">
                <label for="npc-name-input">NPC 昵稱</label>
                <input type="text" id="npc-name-input" placeholder="輸入NPC的常用名">
            </div>
            <div class="form-group">
                <label for="npc-persona-input">NPC 人設</label>
                <textarea id="npc-persona-input" rows="4" placeholder="詳細描述這個NPC的性格、背景、說話方式等..."></textarea>
            </div>
<!-- ▼▼▼ 在NPC人設輸入框之後，黏貼這段新代碼 ▼▼▼ -->
                <hr style="opacity: 0.2;">
                <div class="form-group" style="display: flex; justify-content: space-between; align-items: center;">
                    <label for="npc-background-activity-switch" style="margin-bottom: 0;">
                        啟用獨立後臺活動
                        <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
                            允許該NPC在後臺獨立發表動態評論。需同時開啟API設置中的總開關。
                        </p>
                    </label>
                    <label class="toggle-switch">
                        <input type="checkbox" id="npc-background-activity-switch">
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="form-group">
                    <label for="npc-action-cooldown-input">
                        獨立行動冷卻 (分鐘)
                        <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
                            該NPC在後臺主動行動的最小間隔。
                        </p>
                    </label>
                    <input type="number" id="npc-action-cooldown-input" min="1" value="15" style="width: 80px; text-align: center;">
                </div>
<!-- ▲▲▲ 新增代碼黏貼結束 ▲▲▲ -->
            <div class="form-group">
                <label>關聯的角色 (NPC會去評論這些角色的動態)</label>
                <div id="npc-association-list" style="max-height: 150px; overflow-y: auto; background: #f9f9f9; padding: 10px; border-radius: 8px;">
                    <!-- 關聯角色多選框將由JS動態生成 -->
                </div>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-npc-editor-btn">取消</button>
            <button class="save" id="save-npc-btn">保存</button>
        </div>
    </div>
</div>
<!-- ▼▼▼ 步驟 1：將這個【全新的模態框】黏貼到 body 內其他模態框的旁邊 ▼▼▼ -->
<div id="clear-posts-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span>選擇清空範圍</span>
        </div>
        <div class="modal-body" id="clear-posts-list" style="padding: 0;">
            <!-- 清空選項將由JS動態生成在這裡 -->
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-clear-posts-btn">取消</button>
            <!-- 添加了 btn-danger 類，讓按鈕顯示為紅色以示警告 -->
            <button class="save btn-danger" id="confirm-clear-posts-btn">確認清空</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->
        <!-- ▼▼▼ 黏貼到 #album-photos-screen 的 div 之後 ▼▼▼ -->
        <input type="file" id="album-photo-input" accept="image/*" multiple hidden>
        <div id="chat-interface-screen" class="screen">
            <!-- ▼▼▼ 【全新】請將這個五子棋容器黏貼到聊天介面(chat-interface-screen)的【最頂部】 ▼▼▼ -->
            <div id="gomoku-overlay">
                <div id="gomoku-content-wrapper">
                    <canvas id="gomoku-board"></canvas>
                    <div id="gomoku-controls">
                        <button id="close-gomoku-btn">收起棋盤</button>
                    </div>
                </div>
            </div>
            <!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->
<div id="reading-overlay">
    <!-- 這是全新的、用於恢復視窗的小按鈕 -->
    <div id="reading-restore-btn" style="display: none;">📖</div>

    <!-- 這是可拖動的主視窗 -->
    <div id="reading-window">
        <div class="reading-header">
            <span id="reading-title">未選擇書籍</span>
<div class="reading-controls">
    <button id="minimize-reading-btn" title="最小化" style="font-size: 20px; line-height: 1;">
        <svg width="1em" height="1em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round">
            <line x1="5" y1="12" x2="19" y2="12"></line>
        </svg>
    </button>
    <button id="open-reading-library-btn" title="打開書庫" style="font-size: 22px; line-height: 1;">
    <svg width="1em" height="1em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
        <line x1="3" y1="12" x2="21" y2="12"></line>
        <line x1="3" y1="6" x2="21" y2="6"></line>
        <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
</button>
    <button id="close-reading-btn" title="關閉">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
    </button>
</div>
        </div>
        <div id="reading-content">
            <p>點擊“導入”按鈕，<br>從本地.txt檔或網路URL載入書籍內容。</p>
        </div>
        <div class="reading-footer">
            <button id="prev-page-btn">上一頁</button>
            <span id="page-indicator">0 / 0</span>
            <button id="next-page-btn">下一頁</button>
        </div>
    </div>
</div>
<!-- 這是一個隱藏的檔輸入框，用於本地上傳 -->
<input type="file" id="book-upload-input" accept=".txt, text/plain" hidden>
<!-- ▲▲▲ 替換結束 ▲▲▲ -->
            <div class="header">
                <div class="default-controls">
                    <span class="back-btn" id="back-to-list-btn">‹</span>
                    <div id="global-lyrics-bar"></div>

                    <div id="chat-header-title-wrapper">
                        <span id="chat-header-title">聊天對象</span>
                        <div id="chat-header-status">
                            <span class="status-dot"></span>
                            <span class="status-text">線上</span>
                        </div>
                    </div>
                    <div class="header-actions">
                        <!-- ▼▼▼ 請用這整塊代碼，替換你現有的 id="open-memory-screen-btn" 的 span 標籤 ▼▼▼ -->
                        <span class="action-btn" id="open-memory-screen-btn" title="長期記憶">
                            <!-- 【核心修改】使用SVG圖示替換原來的圖片 -->
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M16 3H5C3.89543 3 3 3.89543 3 5V19C3 20.1046 3.89543 21 5 21H16" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                                <path d="M12 6L9 9L12 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                                <path d="M21 5V19C21 20.1046 20.1046 21 19 21H16" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                            </svg>
                        </span>
                        <!-- ▲▲▲ 替換結束 ▲▲▲ -->
                        <span class="action-btn" id="listen-together-btn" title="一起聽"><img src="https://i.postimg.cc/dV8sdNcx/210-20250618115221.png" alt="一起聽"></span>
                        <span class="action-btn" id="chat-settings-btn" title="聊天設置"><img src="https://i.postimg.cc/bvPq64cv/CCA834-BA-5-A90-408-D-94-FA-7-EE156-B6-A765.png" alt="設置"></span>
                    </div>
                </div>
                <!-- ▼▼▼ 請用這整塊代碼替換你原來的 .selection-controls div ▼▼▼ -->
                <div class="selection-controls">
                    <span id="selection-cancel-btn">取消</span>
                    <span id="selection-count"></span>
                    <div class="header-actions">
                        <span id="selection-screenshot-btn" class="action-btn">長截圖</span>
                        <span id="selection-favorite-btn" class="action-btn">收藏</span>
                        <span id="selection-share-btn" class="action-btn">分享</span>
                        <!-- 【核心修改1】舊按鈕重命名，功能不變 -->
                        <span id="selection-soft-delete-btn" class="action-btn">刪除(通知AI)</span>
                        <!-- 【核心修改2】新增一個紅色的、更強力的刪除按鈕 -->
                        <span id="selection-erase-btn" class="action-btn" style="color: #ff3b30;">徹底刪除</span>
                    </div>
                </div>
                <!-- ▲▲▲ 替換結束 ▲▲▲ -->
            </div>
            <div id="chat-messages">
                <div id="typing-indicator">對方正在輸入...</div>
            </div>
            <div id="chat-input-area">
                <div id="chat-at-mention-popup" class="at-mention-popup"></div>
                <div id="reply-preview-bar">
                    <div class="reply-preview-content">
                        <div class="sender">回復 xxx:</div>
                        <div class="text">被引用的消息內容...</div>
                    </div>
                    <span id="cancel-reply-btn">×</span>
                </div>
                <div id="chat-input-actions-top">
                    <button id="open-sticker-panel-btn" class="chat-action-icon-btn action-button" title="表情面板">+</button>
                    <button id="send-photo-btn" class="chat-action-icon-btn action-button" title="發送照片"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path>
                            <circle cx="12" cy="13" r="4"></circle>
                        </svg></button>
                    <button id="upload-image-btn" class="chat-action-icon-btn action-button" title="上傳圖片">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M21 3.5H3C2.44772 3.5 2 3.94772 2 4.5V19.5C2 20.0523 2.44772 20.5 3 20.5H21C21.5523 20.5 22 20.0523 22 19.5V4.5C22 3.94772 21.5523 3.5 21 3.5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
                            <path d="M16.5 13.5C17.6046 13.5 18.5 12.6046 18.5 11.5C18.5 10.3954 17.6046 9.5 16.5 9.5C15.3954 9.5 14.5 10.3954 14.5 11.5C14.5 12.6046 15.3954 13.5 16.5 13.5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
                            <path d="M22 14.5L18 10.5L10.3333 18.5M12.5 16L9 12.5L2 19.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
                        </svg>
                    </button>
                    <button id="transfer-btn" class="chat-action-icon-btn action-button" title="轉帳">￥</button>
                    <button id="voice-message-btn" class="chat-action-icon-btn action-button" title="發送語音"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
                            <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                            <path d="M12 19v4"></path>
                            <path d="M8 23h8"></path>
                        </svg></button>
                    <button id="send-waimai-request-btn" class="chat-action-icon-btn action-button" title="發起外賣請求"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z"></path>
                            <line x1="3" y1="6" x2="21" y2="6"></line>
                            <path d="M16 10a4 4 0 0 1-8 0"></path>
                        </svg></button>
                    <button id="video-call-btn" class="chat-action-icon-btn action-button" title="視頻通話"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polygon points="23 7 16 12 23 17 23 7"></polygon>
                            <rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect>
                        </svg></button>
                    <button id="group-video-call-btn" class="chat-action-icon-btn action-button" title="群視頻通話"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                            <circle cx="9" cy="7" r="4"></circle>
                            <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                            <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
                        </svg></button>
                    <button id="send-poll-btn" class="chat-action-icon-btn action-button" title="發起投票"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M8 6h10"></path>
                            <path d="M6 6h.01"></path>
                            <path d="M8 12h10"></path>
                            <path d="M6 12h.01"></path>
                            <path d="M8 18h10"></path>
                            <path d="M6 18h.01"></path>
                        </svg></button>
                    <button id="share-link-btn" class="chat-action-icon-btn action-button" title="分享連結"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"></path>
                            <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"></path>
                        </svg></button>
                    <button id="share-location-btn" class="chat-action-icon-btn action-button" title="共用位置"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
                            <circle cx="12" cy="10" r="3"></circle>
                        </svg></button>
                    <!-- ▼▼▼ 請將這個新按鈕，黏貼到 id="chat-input-actions-top" 容器的末尾 ▼▼▼ -->
                    <button id="gomoku-btn" class="chat-action-icon-btn action-button" title="五子棋">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="10"></circle>
                            <circle cx="12" cy="12" r="4"></circle>
                            <circle cx="12" cy="12" r="7"></circle>
                        </svg>
                    </button>
                    <!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->
                    <!-- ▼▼▼ 在“表情面板”按鈕後，黏貼這個新按鈕 ▼▼▼ -->
                    <button id="open-shopping-btn" class="chat-action-icon-btn action-button" title="購物">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="9" cy="21" r="1"></circle>
                            <circle cx="20" cy="21" r="1"></circle>
                            <path d="M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6"></path>
                        </svg>
                    </button>
                    <!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->
                    <!-- ▼▼▼ 【全新】單聊專用的“拍一-拍”按鈕 (Q彈圖示版) ▼▼▼ -->
                    <button id="pat-btn" class="chat-action-icon-btn action-button" title="拍一-拍" style="display: none;">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M16 5.02c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round" />
                            <path d="M14.5 11.02c0 .83-.67 1.5-1.5 1.5v0c-.83 0-1.5-.67-1.5-1.5v-5c0-.83.67-1.5 1.5-1.5v0c.83 0 1.5.67 1.5 1.5" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round" />
                            <path d="M5.5 14.52l-1.92-1.92c-.34-.34-.34-.89 0-1.23l3.58-3.58c.34-.34.89-.34 1.23 0l1.92 1.92c.34.34.34.89 0 1.23l-3.58 3.58c-.34.34-.89.34-1.23 0Z" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round" />
                        </svg>
                    </button>
                    <!-- ▲▲▲ 替換結束 ▲▲▲ -->
                    <!-- ▼▼▼ 請將這個新按鈕，黏貼到 id="chat-input-actions-top" 容器的末尾 ▼▼▼ -->
                    <button id="edit-last-response-btn" class="chat-action-icon-btn action-button" title="導演模式：編輯AI上一輪的完整回應">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M12 20h9"></path>
                            <path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path>
                        </svg>
                    </button>
                    <!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->
                        <!-- ▼▼▼ 在這裡黏貼新按鈕 ▼▼▼ -->
                        <button id="regenerate-btn" class="chat-action-icon-btn action-button" title="重新生成回復" style="display: flex;">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M20 11A8.1 8.1 0 0 0 4.5 9M4 5v4h4"></path>
                                <path d="M4 13a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4"></path>
                            </svg>
                        </button>
                        <!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->
<!-- ▼▼▼ 在這裡黏貼新按鈕 ▼▼▼ -->
                        <button id="propel-btn" class="chat-action-icon-btn action-button" title="推進劇情" style="display: flex;">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polygon points="13 19 22 12 13 5 13 19"></polygon>
                                <polygon points="2 19 11 12 2 5 2 19"></polygon>
                            </svg>
                        </button>
                        <!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->
                    <button id="show-announcement-board-btn" class="chat-action-icon-btn action-button" title="群公告板" style="display: none;">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M21.782 6.132a1 1 0 0 0-1.053-.08l-4.729 2.489a1 1 0 0 0-.5.88v4.158a1 1 0 0 0 .5.88l4.729 2.489a1 1 0 0 0 1.053-.08a1 1 0 0 0 .499-.921V7.052a1 1 0 0 0-.499-.92zm-6 3.207L11 7.05v9.9l4.782-2.281V9.339zM10 6H4a1 1 0 0 0-1 1v10a1 1 0 0 0 1 1h6V6z" />
                        </svg>
                    </button>
<button id="werewolf-game-btn" class="chat-action-icon-btn action-button" title="狼人殺" style="display: none;">
    <svg width="24" height="24" viewBox="0 0 512 512" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
        <path d="M332.6 128.5c-61.1 0-110.5 49.4-110.5 110.5 0 23.4 7.3 45.1 19.9 63.3-19.3 6.3-40.1 9.7-61.9 9.7-88.2 0-160-71.8-160-160s71.8-160 160-160c5.3 0 10.5.3 15.6.8C202.9 44.1 160 0 160 0s-53.3 44.1-45.9 92.5c-48.4 24.3-82.1 73.4-82.1 129.6 0 80.9 65.5 146.4 146.4 146.4 20.2 0 39.4-4.1 56.8-11.5 24.1 33.6 63.3 56.8 107.4 56.8 7.2 0 14.2-0.6 21-1.7 15.2 24.2 41.2 41.1 71.6 41.1 44.7 0 80.9-36.2 80.9-80.9 0-25.2-11.5-47.7-29.6-62.6 11.6-16.1 18.4-35.6 18.4-56.5C443.1 177.9 393.7 128.5 332.6 128.5zM180.1 85.8c-52.1 0-94.4 42.3-94.4 94.4s42.3 94.4 94.4 94.4 94.4-42.3 94.4-94.4S232.2 85.8 180.1 85.8zM332.6 170.9c-37.8 0-68.4 30.6-68.4 68.4s30.6 68.4 68.4 68.4 68.4-30.6 68.4-68.4S370.4 170.9 332.6 170.9z"></path>
    </svg>
</button>
<button id="read-together-btn" class="chat-action-icon-btn action-button" title="一起讀書">
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path>
        <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path>
    </svg>
</button>
                </div>
                <div id="chat-input-main-row">
                    <textarea id="chat-input" rows="1" placeholder="輸入消息..."></textarea>
                    <div id="input-actions-wrapper">
                        <button id="wait-reply-btn" title="等待回復"><img src="https://i.postimg.cc/q72zq80N/ECE92-BBC-BE57-48-E9-BB2-C-345-B6019-C4-B2.png" alt="等待回復"></button>
                        <button id="send-btn" class="action-button">發送</button>
                    </div>
                </div>
            </div>
            <div id="chat-lock-overlay">
                <div id="chat-lock-content"></div>
            </div>
        <!-- ▼▼▼ 【請用這個 V2.0 版本】完整替換舊的 id="sticker-panel" 的 div ▼▼▼ -->
        <div id="sticker-panel">
            <div id="sticker-panel-header">
                <span class="panel-btn" id="close-sticker-panel-btn">取消</span>
                <span class="title">我的表情</span>
                <div style="display: flex; gap: 10px;">
                    <span class="panel-btn" id="manage-sticker-categories-btn">分類</span>
                    <span class="panel-btn" id="manage-stickers-btn">管理</span>
                    <span class="panel-btn" id="add-sticker-batch-btn">批量</span>
                    <span class="panel-btn" id="add-sticker-url-btn">URL</span>
                    <span class="panel-btn" id="upload-sticker-btn">上傳</span>
                </div>
            </div>
            <div id="sticker-category-tabs"></div>
<div id="sticker-search-container">
    <input type="search" id="sticker-search-input" placeholder="搜索表情名稱...">
</div>
            <div id="sticker-grid"></div>

            <!-- 【核心修改】將舊的單個刪除按鈕，升級為一個包含“全選”和“刪除”的操作欄 -->
            <div id="sticker-action-bar">
                <label class="select-all-label" style="display: flex; align-items: center; gap: 5px;">
                    <input type="checkbox" id="select-all-stickers-checkbox"> 全選
                </label>
                <button id="delete-selected-stickers-btn">刪除 (0)</button>
            </div>
        </div>
        <!-- ▲▲▲ 替換結束 ▲▲▲ -->
            <input type="file" id="sticker-upload-input" accept="image/*" style="display: none;">
            <input type="file" id="image-upload-input" accept="image/*" style="display: none;">
<div id="music-player-overlay">
    <!-- ▼▼▼ 【請用這整塊代碼】替換舊的 .music-player-window ▼▼▼ -->
    <div class="music-player-window">
        <!-- ▼▼▼ 【請用這整塊代碼】替換舊的 .music-player-top-actions ▼▼▼ -->
<div class="music-player-top-actions">
    <div class="top-left-cluster">
        <button id="music-return-btn">‹</button>
        <button id="music-exit-btn">×</button>
    </div>
    
    <!-- 【核心修改】創建一個新的容器來包裹右側的兩個按鈕 -->
    <div style="display: flex; align-items: center; gap: 15px;">
        <!-- 【全新】這就是我們的全屏切換按鈕 -->
        <button id="toggle-fullscreen-btn" title="切換全屏">
            <!-- 放大圖示 -->
            <svg class="icon-maximize" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg>
            <!-- 縮小圖示 (預設隱藏) -->
            <svg class="icon-minimize" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"/></svg>
        </button>

        <!-- 播放清單按鈕保持不變 -->
        <span id="music-playlist-btn">☰</span>
    </div>
</div>
<!-- ▲▲▲ 替換結束 ▲▲▲ -->

        <!-- ▼▼▼ 【全新】這是頭像顯示容器，預設隱藏 ▼▼▼ -->
<div id="music-player-avatar-display">
    <!-- 頭像將由JS動態生成在這裡 -->
</div>
<!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->

<!-- 核心修改：將歌曲資訊移動到唱片上方，並用一個容器包裹 -->
<div id="music-info-top">
    <!-- 【核心修改】將時間和按鈕包裹在一個flex容器中，使其並排顯示 -->
    <div style="display: flex; justify-content: center; align-items: center; gap: 10px;">
        <div id="music-time-counter">已經一起聽了0.0小時</div>
        <!-- 【全新】這是我們的新按鈕 -->
        <button id="show-avatars-btn" title="顯示/隱藏頭像">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg>
        </button>
    </div>
    <div id="music-player-song-title">請添加歌曲</div>
    <div id="music-player-artist">...</div>
</div>

        <!-- 唱片/歌詞切換容器保持不變 -->
        <div id="music-visual-container">
            <div id="vinyl-view">
                <img id="music-player-cover" src="https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1757748720126_qdqqd_1jt5sv.jpeg" alt="Album Art">
            </div>
            <div id="inline-lyrics-view">
                <div id="music-lyrics-container">
                    <div id="music-lyrics-list">
                        <!-- JS 會在這裡填充歌詞 -->
                    </div>
                </div>
            </div>
        </div>
    <div id="single-lyric-display">♪ ♪ ♪</div>
        <!-- 底部控制區域保持不變 -->
        <div class="music-player-controls-wrapper">
            <div class="music-progress-bar-container">
                <div id="music-current-time" class="time-display">0:00</div>
                <div class="progress-bar">
                    <div id="music-progress-fill" class="progress-bar-fill"></div>
                </div>
                <div id="music-total-time" class="time-display">0:00</div>
            </div>
            <div class="music-controls">
                <button id="music-prev-btn">◀</button>
                <button id="music-play-pause-btn" class="play-pause-btn">▶</button>
                <button id="music-next-btn">▶</button>
                <button id="music-mode-btn">順序</button>
                <button id="toggle-blur-btn" title="切換背景清晰度">清</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 替換結束 ▲▲▲ -->
</div>
            <div id="music-playlist-panel">
                <div class="playlist-header">
                    <span class="panel-btn" id="close-playlist-btn">返回</span>
                    <span>播放清單</span>
                    <div>
                     <span class="panel-btn" id="cleanup-songs-btn">清理</span>
                        <span class="panel-btn" id="add-song-local-btn">本地</span>
                        <span class="panel-btn" id="add-song-url-btn">URL</span>
        <span class="panel-btn" id="add-song-search-btn">搜索</span>
                    </div>
                </div>
                <div class="playlist-body" id="playlist-body"></div>
            </div>
            <input type="file" id="local-song-upload-input" accept="audio/*" multiple style="display: none;">
            <input type="file" id="lrc-upload-input" accept=".lrc" style="display: none;">
        </div>
        <!-- ▼▼▼ 請用這整塊【已修復】的代碼，完整替換你現有的 id="wallpaper-screen" 的那整個 <div> ▼▼▼ -->
<div id="wallpaper-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
        <span>外觀設置</span>
        <span style="width: 30px;"></span>
    </div>
    <div class="form-container">
        <label style="font-weight: 500; color: var(--text-secondary);">EPhone 主螢幕壁紙</label>
        <div id="wallpaper-preview">點擊下方上傳</div>
        <div class="bg-upload-container">
            <button class="form-button-secondary" onclick="document.getElementById('wallpaper-upload-input').click();">本地上傳</button>
            <button id="upload-ephone-bg-url-btn" class="form-button-secondary">網路URL</button>
            <button id="remove-ephone-bg-btn" class="form-button-secondary">移除壁紙</button>
        </div>
        <input type="file" id="wallpaper-upload-input" accept="image/*" hidden>
        
        <hr style="width: 80%; opacity: 0.3; margin: 30px 0;">
        <label style="font-weight: 500; color: var(--text-secondary);">CPhone 手機壁紙</label>
        <div id="cphone-wallpaper-preview">點擊下方上傳</div>
        <div class="bg-upload-container">
            <button class="form-button-secondary" onclick="document.getElementById('cphone-wallpaper-upload-input').click();">本地上傳</button>
            <button id="upload-cphone-bg-url-btn" class="form-button-secondary">網路URL</button>
            <button id="remove-cphone-bg-btn" class="form-button-secondary">移除壁紙</button>
        </div>
        <input type="file" id="cphone-wallpaper-upload-input" accept="image/*" hidden>

        <hr style="width: 80%; opacity: 0.3; margin: 30px 0;">
        <label style="font-weight: 500; color: var(--text-secondary);">全域聊天背景 (所有聊天默認)</label>
        <div id="global-bg-preview" class="wallpaper-preview" style="height: 160px; width: 90px;">點擊下方上傳</div>
        <div class="bg-upload-container">
            <button class="form-button-secondary" onclick="document.getElementById('global-bg-input').click()">本地上傳</button>
            <button id="upload-global-bg-url-btn" class="form-button-secondary">網路URL</button>
            <button id="remove-global-bg-btn" class="form-button-secondary">移除全域背景</button>
        </div>
        <input type="file" id="global-bg-input" accept="image/*" style="display: none;">
        
        <hr style="width: 80%; opacity: 0.3; margin: 30px 0;">
        <div class="form-group" style="display: flex; justify-content: space-between; align-items: center;">
            <label for="theme-toggle-switch" style="margin-bottom: 0;">夜間模式</label>
            <label class="toggle-switch">
                <input type="checkbox" id="theme-toggle-switch">
                <span class="slider"></span>
            </label>
        </div>
        <div class="form-group" style="display: flex; justify-content: space-between; align-items: center;">
            <label for="status-bar-toggle-switch" style="margin-bottom: 0;">顯示頂部狀態列</label>
            <label class="toggle-switch">
                <input type="checkbox" id="status-bar-toggle-switch">
                <span class="slider"></span>
            </label>
        </div>
        
        <hr style="width: 80%; opacity: 0.3; margin: 30px 0;">
        <div style="width:100%; text-align: left; margin-bottom: 15px;">
            <label style="font-weight: 500; color: var(--text-secondary);">消息提示音</label>
        </div>
        <div class="form-group" style="width:100%;">
            <label for="notification-sound-url-input">提示音檔 URL (.mp3, .wav, .ogg)</label>
            <div style="display: flex; gap: 10px; align-items: center; margin-top: 8px;">
                <input type="text" id="notification-sound-url-input" placeholder="留空則使用默認提示音" style="flex-grow: 1;">
                <button id="test-sound-btn" class="form-button-secondary" style="margin-top: 0; padding: 12px;">▶</button>
                <button id="reset-sound-btn" class="form-button-secondary" style="margin-top: 0; padding: 12px;">重置</button>
            </div>
        </div>

        <hr style="width: 80%; opacity: 0.3; margin: 30px 0;">
        <div style="width:100%; text-align: left; margin-bottom: 15px;">
            <label style="font-weight: 500; color: var(--text-secondary);">EPhone App 圖示設置</label>
        </div>
        <div id="icon-settings-grid"></div>

        <hr style="width: 80%; opacity: 0.3; margin: 30px 0;">
        <div class="form-group" style="width:100%;">
            <div style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
                <label>聊天工具列按鈕排序</label>
                <button id="reset-button-order-btn" title="恢復預設順序" class="form-button-secondary" style="margin: 0; padding: 4px 12px; font-size: 13px;">重置順序</button>
            </div>
            <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
                按住下方的按鈕並拖動即可排序，設置會自動保存。
            </p>
            <div id="button-order-editor" style="display: flex; flex-wrap: wrap; gap: 10px; padding: 10px; background-color: #f0f2f5; border-radius: 8px; border: 1px solid var(--border-color);">
            </div>
        </div>

        <hr style="width: 80%; opacity: 0.3; margin: 30px 0;">
        <div style="width:100%; text-align: left; margin-bottom: 15px;">
            <label style="font-weight: 500; color: var(--text-secondary);">CPhone App 圖示設置</label>
        </div>
        <div id="cphone-icon-settings-grid"></div>
<hr style="width: 80%; opacity: 0.3; margin: 30px 0;">
<h3 style="margin-top:0; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; width:100%; text-align: left;">外觀預設管理</h3>
<p style="font-size: 12px; color: #8a8a8a; margin-top: -5px; line-height: 1.5; width:100%; text-align: left;">
    一鍵保存或載入壁紙、圖示、按鈕排序、主題等所有非CSS的視覺風格。
</p>
<div class="form-group" style="width:100%;">
    <label for="appearance-preset-select">選擇或切換預設</label>
    <div style="display: flex; gap: 10px; align-items: center;">
        <select id="appearance-preset-select" style="flex-grow: 1;"></select>
        <button id="save-appearance-preset-btn" class="form-button-secondary" style="margin-top: 0; padding: 12px;">保存</button>
        <button id="delete-appearance-preset-btn" class="form-button-secondary" style="margin-top: 0; padding: 12px; background-color: #ffebee; color: #d32f2f; border-color: #ffcdd2;">刪除</button>
    </div>
</div>
        <hr style="width: 80%; opacity: 0.3; margin: 30px 0;">
        <h3 style="margin-top:0; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; width:100%; text-align: left;">CSS 預設管理</h3>
        <div class="form-group" style="width:100%;">
            <label for="css-preset-select">選擇或切換預設</label>
            <div style="display: flex; gap: 10px; align-items: center;">
                <select id="css-preset-select" style="flex-grow: 1;"></select>
                <button id="save-css-preset-btn" class="form-button-secondary" style="margin-top: 0; padding: 12px;">保存</button>
                <button id="delete-css-preset-btn" class="form-button-secondary" style="margin-top: 0; padding: 12px; background-color: #ffebee; color: #d32f2f; border-color: #ffcdd2;">刪除</button>
            </div>
        </div>
        <div class="form-group" style="width:100%;">
            <label for="global-css-input"> 全域美化樣式 (CSS) <button id="reset-global-css-btn" type="button" style="background: none; border: 1px solid #ccc; color: #555; font-size: 12px; padding: 2px 8px; border-radius: 5px; cursor: pointer; margin-left: 10px;">重置</button>
            </label>
            <textarea id="global-css-input" rows="6" style="width: 100%; margin-top: 8px; font-family: monospace; font-size: 16px; resize: vertical;" placeholder="/* 在此輸入自訂CSS */"></textarea>
        </div>

        <button class="form-button form-button-secondary" id="import-appearance-btn" style="margin-top: 10px;">導入外觀 (JSON)</button>
        <input type="file" id="import-appearance-input" accept="application/json" hidden>
                        
        <button class="form-button" id="save-wallpaper-btn" style="margin-top: 30px;">保存所有外觀設置</button>
    </div>
</div>

        <!-- ▲▲▲ 替換結束 ▲▲▲ -->
        <!-- ▼▼▼ 【全新】分享連結功能 HTML ▼▼▼ -->
        <div id="browser-screen" class="screen">
            <div class="header">
                <span class="back-btn" id="browser-back-btn">‹</span>
                <span id="browser-title"></span>
                <span style="width: 30px;"></span>
            </div>
            <div id="browser-content" class="list-container">
                <!-- 文章內容將由JS動態生成在這裡 -->
            </div>
        </div>
        <!-- ▲▲▲ 新HTML黏貼結束 ▲▲▲ -->
        <div id="font-settings-screen" class="screen">
            <div class="header">
                <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
                <span>字體設置</span>
                <span style="width: 30px;"></span>
            </div>
            <div class="form-container">
                <!-- ▼▼▼ 在這裡黏貼下面的新代碼 ▼▼▼ -->
                <!-- 【【【全新：字體預設管理】】】 -->
                <h3 style="margin-top:0; border-bottom: 1px solid #eee; padding-bottom: 10px;">字體預設管理</h3>
                <div class="form-group">
                    <label for="font-preset-select">選擇或切換預設</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <select id="font-preset-select" style="flex-grow: 1;"></select>
                        <button id="save-font-preset-btn" class="form-button-secondary" style="margin-top: 0; padding: 12px;">保存</button>
                        <button id="delete-font-preset-btn" class="form-button-secondary" style="margin-top: 0; padding: 12px; background-color: #ffebee; color: #d32f2f; border-color: #ffcdd2;">刪除</button>
                    </div>
                </div>
                <hr style="margin: 30px 0; opacity: 0.3;">
                <!-- ▲▲▲ 黏貼結束 ▲▲▲ -->
                <div class="form-group">
                    <label for="font-url-input">字體檔URL (.ttf, .otf, .woff等)</label>
                    <input type="text" id="font-url-input" placeholder="https://..../font.ttf">
                </div>
                <div class="form-group">
                    <label>即時預覽</label>
                    <div id="font-preview">
                        <p style="font-size: 20px; margin: 0 0 10px 0;">你好世界 Hello World</p>
                        <p style="margin: 0;">這是字體預覽效果，12345。</p>
                    </div>
                </div>
                <button class="form-button" id="save-font-btn">保存並應用</button>
                <button class="form-button form-button-secondary" id="reset-font-btn">恢復預設字體</button>
            </div>
        </div>
        <!-- ▼▼▼ 【全新】選擇連絡人以創建群聊的螢幕 ▼▼▼ -->
        <div id="contact-picker-screen" class="screen">
            <div class="header">
                <span class="back-btn" id="cancel-contact-picker-btn">取消</span>
                <span>選擇連絡人</span>
                <span class="save-btn" id="confirm-contact-picker-btn">完成(0)</span>
            </div>
            <div class="list-container" id="contact-picker-list">
                <!-- 連絡人清單將由JS動態生成 -->
            </div>
        </div>
        <!-- ▲▲▲ 新HTML黏貼結束 ▲▲▲ -->
        <!-- ▼▼▼ 【全新】群成員管理螢幕 ▼▼▼ -->
        <div id="member-management-screen" class="screen">
            <div class="header">
                <span class="back-btn" id="back-from-member-management">‹</span>
                <span>群成員管理</span>
                <span style="width: 30px;"></span>
            </div>
            <div class="list-container" id="member-management-list">
                <!-- 現有成員清單會在這裡動態生成 -->
            </div>
            <div id="member-management-actions">
                <button id="add-existing-contact-btn">從好友列表添加</button>
                <button id="create-new-member-btn">創建群內新成員</button>
            </div>
        </div>
        <!-- ▲▲▲ 新HTML黏貼結束 ▲▲▲ -->
    <!-- ▼▼▼ 【全新】請將這個彈窗HTML黏貼到其他所有 modal 的旁邊 ▼▼▼ -->
    <div id="sticker-category-manager-modal" class="modal">
        <div class="modal-content" style="height: 60%;">
            <div class="modal-header">
                <span>管理表情分類</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>新建分類</label>
                    <div style="display: flex; gap: 10px;">
                        <input type="text" id="new-sticker-category-name-input" placeholder="輸入分類名..." style="flex-grow: 1;">
                        <button id="add-new-sticker-category-btn" class="form-button" style="width: auto; margin-top: 0; padding: 0 15px;">添加</button>
                    </div>
                </div>
                <hr style="opacity: 0.2;">
                <div id="existing-sticker-categories-list" style="display: flex; flex-direction: column; gap: 10px;">
                    <!-- 分類清單將由JS動態生成 -->
                </div>
            </div>
            <div class="modal-footer">
                <button class="save" id="close-sticker-category-manager-btn" style="width: 100%;">完成</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->
        <!-- ▼▼▼ 【全新】來電請求模態框 ▼▼▼ -->
        <div id="incoming-call-modal" class="modal">
            <div class="incoming-call-content">
                <img id="caller-avatar" class="caller-avatar" src="">
                <div id="caller-name" class="caller-name"></div>
                <div class="caller-text">邀請你視頻通話</div>
                <div class="incoming-call-actions">
                    <div class="action-button-wrapper">
                        <button id="decline-call-btn" class="call-action-btn decline"></button>
                        <span>拒絕</span>
                    </div>
                    <div class="action-button-wrapper">
                        <button id="accept-call-btn" class="call-action-btn accept"></button>
                        <span>接聽</span>
                    </div>
                </div>
            </div>
        </div>
        <!-- ▲▲▲ 新增結束 ▲▲▲ -->
        <!-- ▼▼▼ 請用這段【全新群聊相容結構】的代碼，完整替換你舊的 #video-call-screen ▼▼▼ -->
        <div id="video-call-screen" class="screen">
            <!-- 1. 頂部欄 (保持不變) -->
            <div class="video-call-top-bar">
                <span id="call-timer">00:00</span>
            </div>
            <!-- 2. 【升級】參與者頭像網格區域 -->
            <div class="video-call-avatar-area">
                <div id="participant-avatars-grid">
                    <!-- JS會在這裡動態生成頭像 -->
                </div>
            </div>
            <!-- 3. 對話方塊區域 (保持不變) -->
            <div id="video-call-main" class="video-call-main">
                <!-- 對話內容會動態生成在這裡 -->
            </div>
            <!-- 4. 【升級】底部控制欄，現在包含一個“加入”按鈕 -->
            <div class="video-call-controls">
                <button id="user-speak-btn" class="control-btn speak-btn"></button>

                <button id="hang-up-btn" class="control-btn hangup-btn"></button>
                <!-- ▼▼▼ 在這裡黏貼新按鈕 ▼▼▼ -->
                <button id="regenerate-call-btn" class="control-btn regenerate-btn"></button>
                <!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->
                <!-- 這個按鈕預設隱藏，只在使用者“旁觀”時顯示 -->
                <button id="join-call-btn" class="control-btn join-btn" style="display: none;"></button>
            </div>
        </div>
        <!-- ▲▲▲ 替換結束 ▲▲▲ -->
        <!-- ▼▼▼ 【全新添加】正在呼叫介面 ▼▼▼ -->
        <div id="outgoing-call-screen" class="screen">
            <div class="outgoing-call-content">
                <img id="outgoing-call-avatar" class="caller-avatar" src="">
                <div id="outgoing-call-name" class="caller-name"></div>
                <div class="caller-text">正在呼叫...</div>
                <div class="outgoing-call-actions">
                    <button id="cancel-call-btn" class="call-action-btn decline"></button>
                    <span>取消</span>
                </div>
            </div>
        </div>
        <!-- ▲▲▲ 添加結束 ▲▲▲ -->
        <!-- ▼▼▼ 【全新】通話記錄頁面 ▼▼▼ -->
        <div id="call-history-screen" class="screen">
            <div class="header">
                <span class="back-btn" id="call-history-back-btn">‹</span>
                <span id="call-history-title">通話記錄</span>
                <span style="width: 30px;"></span> <!-- 預留位置，保持標題居中 -->
            </div>
            <div id="call-history-list" class="list-container" style="padding: 15px; display: flex; flex-direction: column; gap: 15px;">
                <!-- 通話記錄卡片將由JS動態生成在這裡 -->
            </div>
        </div>
        <!-- ▲▲▲ 新HTML黏貼結束 ▲▲▲ -->
<!-- =================================================================== -->
<!-- ▼▼▼ 【最終修復版】請用這整塊代碼替換所有舊的豆瓣HTML ▼▼▼ -->
<!-- =================================================================== -->

<!-- 1. 豆瓣小組帖子清單螢幕 -->
<div id="douban-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
        <span>豆瓣小組</span>
        <div class="header-actions">
        <!-- 【核心新增】這就是我們的新設置按鈕 -->
        <span class="action-btn" id="douban-settings-btn" title="豆瓣設置">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.44,0.17-0.48,0.41L9.12,4.84c-0.59,0.24-1.12,0.56-1.62,0.94L5.11,4.82c-0.22-0.08-0.47,0-0.59,0.22l-1.92,3.32 c-0.12,0.22-0.07,0.47,0.12,0.61l2.03,1.58C4.84,11.36,4.82,11.68,4.82,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.48,2.03 c0.04,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.48-0.41l0.48-2.03c0.59-0.24,1.12-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"></path>
            </svg>
        </span>
            <span class="action-btn" id="douban-cast-select-btn" title="選擇參與角色">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                    <circle cx="9" cy="7" r="4"></circle>
                    <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                    <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
                </svg>
            </span>
            <span class="action-btn" id="regenerate-douban-btn" title="重新生成內容">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M20 11A8.1 8.1 0 0 0 4.5 9M4 5v4h4"></path>
                    <path d="M4 13a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4"></path>
                </svg>
            </span>
        </div>
    </div>
    <div id="douban-posts-list" class="list-container">
        <!-- AI生成的帖子將在這裡顯示 -->
    </div>
</div>

<!-- 2. 豆瓣帖子詳情頁螢幕 -->
<div id="douban-post-detail-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="douban-detail-back-btn">‹</span>
        <span id="douban-post-detail-title">帖子詳情</span>
        <span style="width: 30px;"></span>
    </div>
    <div id="douban-detail-content-wrapper" class="list-container">
        <div id="douban-post-detail-body">
            <div class="douban-post-header">
                <img id="douban-detail-avatar" class="douban-post-avatar">
                <div class="douban-author-info">
                    <div id="douban-detail-author" class="douban-author-name"></div>
                    <div id="douban-detail-group" class="douban-group-name"></div>
                </div>
            </div>
            <h2 id="douban-detail-post-title" class="douban-post-title"></h2>
            <div id="douban-detail-content" class="douban-detail-content"></div>
        </div>
        <div class="douban-comments-section">
            <h4>回應</h4>
            <div id="douban-detail-comments-list"></div>
        </div>
    </div>
    <div id="douban-comment-footer" class="post-footer">
        <div class="comment-section">
            <img id="douban-my-comment-avatar" src="" class="comment-avatar">
            <input type="text" id="douban-comment-input" class="comment-input" placeholder="寫回應...">
        </div>
        <button id="douban-wait-reply-btn" class="douban-feather-btn" title="讓AI繼續討論">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M20.24 12.24a6 6 0 0 0-8.49-8.49L5 10.5V19h8.5z"></path>
                <line x1="16" y1="8" x2="2" y2="22"></line>
                <line x1="17.5" y1="15" x2="9" y2="15"></line>
            </svg>
        </button>
        <button id="douban-send-comment-btn" class="comment-send-btn">發送</button>
    </div>
</div>
        <div id="werewolf-game-screen" class="screen">
            <div class="header">
                <span id="werewolf-game-title">狼人殺</span>
                <div class="header-actions">
<span class="action-btn" id="werewolf-retry-btn" title="重試上一步AI操作" style="display: none;">
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M20 11A8.1 8.1 0 0 0 4.5 9M4 5v4h4"></path>
        <path d="M4 13a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4"></path>
    </svg>
</span>
                    <span class="action-btn" id="exit-werewolf-game-btn">退出</span>
                </div>
            </div>
            <!-- 玩家頭像區 (保持不變) -->
            <div id="werewolf-player-grid"></div>
            <!-- 遊戲日誌/對話區 (保持不變) -->
            <div id="werewolf-log" class="list-container"></div>
            
            <!-- 【核心修改】全新的、常駐的底部操作欄 -->
            <div id="werewolf-action-bar">
                <div id="chat-input-main-row" style="width: 100%;">
                    <textarea id="werewolf-user-input" rows="1" placeholder="輪到你發言了..."></textarea>
                    <div id="input-actions-wrapper" style="gap: 5px;">
                        <!-- 發言階段的按鈕 -->
                        <button id="werewolf-wait-reply-btn" class="action-button" style="display: none; background-color: #007bff; height: 40px; padding: 0 10px; font-size: 13px;">等待回應</button>
                        <button id="werewolf-finish-speech-btn" class="action-button" style="display: none; background-color: var(--accent-color); height: 40px; padding: 0 10px; font-size: 13px;">結束發言</button>
                        <!-- 非發言階段的按鈕 -->
                        <button id="werewolf-next-step-btn" class="form-button" style="margin-top:0; display: none;">下一步</button>
                    </div>
                </div>
            </div>
        </div>
        <!-- ▲▲▲ 替換結束 ▲▲▲ -->
    <!-- ▼▼▼ 【全新】長期記憶管理全屏頁面 ▼▼▼ -->
    <div id="long-term-memory-screen" class="screen">
        <div class="header">
            <span class="back-btn" id="memory-screen-back-btn">‹</span>
            <span>長期記憶</span>
            <div class="header-actions">
                <span class="action-btn" id="refine-memory-btn-header">精煉</span>
                <span class="action-btn" id="summarize-recent-btn-header">總結</span>
                <span class="action-btn" id="add-manual-memory-btn-header">+</span>
            </div>
        </div>
        <div class="list-container" id="memory-list-container" style="padding: 15px; display: flex; flex-direction: column; gap: 15px; background-color: #f0f2f5;">
            <!-- 長期記憶清單將由JS動態生成在這裡 -->
        </div>
    </div>
    <!-- ▲▲▲ 新HTML黏貼結束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】聊天設置頁面結構 ▼▼▼ -->
<div id="chat-settings-screen" class="screen">
    <!-- 1. 頁面的頭部，包含返回和保存按鈕 -->
    <div class="header">
        <span class="back-btn" onclick="showScreen('chat-interface-screen')">‹</span>
        <span>聊天設置</span>
        <span class="save-btn" id="save-chat-settings-btn">保存</span>
    </div>

    <!-- 2. 頁面的內容容器，現在可以滾動了 -->
    <div class="form-container">
        <!-- 
          這裡的內容就是你原來 modal-body 裡的所有 form-group。
          我們已經將它們原封不動地移動到這裡了。
        -->
        <div class="form-group" id="chat-name-group"><label for="chat-name-input">備註名 / 群名</label><input type="text" id="chat-name-input"></div>
        <div class="form-group" id="my-nickname-group">
            <label for="my-nickname-input">我的昵稱</label>
            <input type="text" id="my-nickname-input">
        </div>
        <div class="form-group" id="assign-group-section" style="display: none;">
            <label for="assign-group-select">好友分組</label>
            <div style="display: flex; align-items: center; gap: 10px;">
                <select id="assign-group-select" style="flex-grow: 1;"></select>
                <button id="manage-groups-btn" class="form-button-secondary" style="margin-top: 0; padding: 12px;">管理分組</button>
            </div>
        </div>
        <div class="form-group" id="my-group-nickname-group"><label for="my-group-nickname-input">我的群昵稱</label><input type="text" id="my-group-nickname-input"></div>
        <button class="form-button form-button-secondary" id="search-history-btn" style="margin-top: 10px;">搜索聊天記錄</button>
<!-- ▼▼▼ 在這裡黏貼下面的新代碼 ▼▼▼ -->
<div class="form-group" id="single-char-background-activity-group">
    <div style="display: flex; justify-content: space-between; align-items: center;">
        <label for="char-background-activity-switch" style="margin-bottom: 0;">
            啟用獨立後臺活動
            <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
                允許該角色在後臺獨立發消息或動態。需同時開啟API設置中的總開關。
            </p>
        </label>
        <label class="toggle-switch">
            <input type="checkbox" id="char-background-activity-switch">
            <span class="slider"></span>
        </label>
    </div>
</div>
<!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->
        <div class="form-group" id="ai-cooldown-group">
            <label for="ai-action-cooldown-input"> 獨立行動冷卻 (分鐘) <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;"> AI在後臺主動發消息或動態的最小間隔。 </p>
            </label>
            <input type="number" id="ai-action-cooldown-input" min="1" value="10" style="width: 80px; text-align: center;">
        </div>
<!-- ▼▼▼ 在這裡黏貼下面的新代碼 ▼▼▼ -->
        <!-- ▼▼▼ 【全新】時間感知開關 ▼▼▼ -->
        <div class="form-group" id="time-perception-group">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <label for="time-perception-toggle" style="margin-bottom: 0;">
                    啟用時間感知
                    <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
                        關閉後，AI將不會接收到當前時間資訊，對話中不再體現時間變化。
                    </p>
                </label>
                <label class="toggle-switch">
                    <input type="checkbox" id="time-perception-toggle">
                    <span class="slider"></span>
                </label>
            </div>
        </div>
        <!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->
<div class="form-group" id="time-zone-group" style="display: none;">
    <label for="time-zone-select">選擇時區</label>
    <!-- 【核心新增】這就是我們的搜索框 -->
    <input type="search" id="time-zone-search-input" placeholder="搜索時區，例如 Shanghai, New York...">
    <select id="time-zone-select" style="width: 100%;"></select>
</div>
<div class="form-group" id="group-background-activity-group">
    <div style="display: flex; justify-content: space-between; align-items: center;">
        <label for="group-background-activity-switch" style="margin-bottom: 0;">
            啟用群內後臺活動
            <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
                允許AI成員在該群聊中獨立行動。需同時開啟API設置中的總開關。
            </p>
        </label>
        <label class="toggle-switch">
            <input type="checkbox" id="group-background-activity-switch">
            <span class="slider"></span>
        </label>
    </div>
</div>
<!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->
        <div class="form-group" id="group-cooldown-group">
            <label for="group-action-cooldown-input"> 群聊行動冷卻 (分鐘) <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;"> AI在後臺主動在群內行動的最小間隔。 </p>
            </label>
            <input type="number" id="group-action-cooldown-input" min="1" value="10" style="width: 80px; text-align: center;">
        </div>
        <div class="form-group" id="group-avatar-group">
            <label>群頭像</label>
            <div class="avatar-upload">
                <img id="group-avatar-preview">
                <button onclick="document.getElementById('group-avatar-input').click()">上傳群頭像</button>
                <button id="manage-group-avatar-library-btn">管理頭像庫</button>
                <input type="file" id="group-avatar-input" accept="image/*">
            </div>
        </div>
        <div class="form-group" id="world-book-link-group">
            <label>關聯世界書 (可多選)</label>
            <div class="custom-multiselect">
                <div class="select-box">
                    <span class="selected-options-text">-- 點擊選擇 --</span>
                    <span class="arrow-down">▼</span>
                </div>
                <div id="world-book-checkboxes-container" class="checkboxes-container">
                </div>
            </div>
        </div>
        <div class="form-group" id="lyrics-position-group" style="display: none;">
            <hr style="opacity: 0.3; margin: 20px 0;">
            <label>歌詞欄位置</label>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 8px;">
                <div>
                    <label for="lyrics-vertical-pos" style="font-size: 0.9em; color: var(--text-secondary);">垂直位置</label>
                    <select id="lyrics-vertical-pos" style="width: 100%; padding: 8px; border: 1px solid var(--border-color); border-radius: 6px; font-size: 14px;">
                        <option value="top">頂部</option>
                        <option value="bottom">底部</option>
                    </select>
                </div>
                <div>
                    <label for="lyrics-horizontal-pos" style="font-size: 0.9em; color: var(--text-secondary);">水準對齊</label>
                    <select id="lyrics-horizontal-pos" style="width: 100%; padding: 8px; border: 1px solid var(--border-color); border-radius: 6px; font-size: 14px;">
                        <option value="left">居左</option>
                        <option value="center">居中</option>
                        <option value="right">居右</option>
                    </select>
                </div>
            </div>
            <div style="margin-top: 10px;">
                <label for="lyrics-offset-input" style="font-size: 0.9em; color: var(--text-secondary);">垂直偏移 (px)</label>
                <input type="number" id="lyrics-offset-input" value="10" style="width: 100%; padding: 8px; border: 1px solid var(--border-color); border-radius: 6px; font-size: 14px; box-sizing: border-box;">
            </div>
        </div>
        <div class="form-group" id="offline-mode-group">
            <hr style="opacity: 0.3; margin: 20px 0;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <label for="offline-mode-toggle" style="margin-bottom: 0;"> 啟用線下模式 <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;"> 開啟後, AI的回復將變為包含「對話」和<i style="color: #666;">動作/環境描寫</i>的劇情模式。 </p>
                </label>
                <label class="toggle-switch">
                    <input type="checkbox" id="offline-mode-toggle">
                    <span class="slider"></span>
                </label>
            </div>
            <div id="offline-mode-options" style="display: none; margin-top: 15px;">
                <label for="offline-min-length-input">回復字數範圍</label>
                <div style="display: flex; align-items: center; gap: 10px; margin-top: 5px;">
                    <input type="number" id="offline-min-length-input" value="100" style="width: 80px; text-align: center;">
                    <span>到</span>
                    <input type="number" id="offline-max-length-input" value="300" style="width: 80px; text-align: center;">
                    <span>字</span>
                </div>
    <div class="form-group" style="margin-top: 15px; margin-bottom: 0;">
        <label for="offline-preset-select">文風預設 (將影響AI的描寫風格)</label>
        <select id="offline-preset-select" style="width: 100%; margin-top: 5px;"></select>
    </div>
            </div>
        </div>
        <div class="form-group" id="linked-memory-group">
            <label for="link-memory-toggle">掛載其他聊天記憶</label>
            <input type="checkbox" id="link-memory-toggle" style="width: auto; height: 20px; vertical-align: middle; margin-left: 10px;">
            <div id="linked-memory-selection" style="display: none; margin-top: 10px;">
                <label>選擇要掛載記憶的聊天 (可多選):</label>
                <div class="custom-multiselect">
                    <div class="select-box">
                        <span class="selected-options-text">-- 點擊選擇 --</span>
                        <span class="arrow-down">▼</span>
                    </div>
                    <div id="linked-chats-checkboxes-container" class="checkboxes-container" style="max-height: 120px;">
                    </div>
                </div>
                <p style="font-size: 12px; color: #8a8a8a; margin-top: 8px; line-height: 1.5;"> • 掛載的記憶會以“參考記憶”的形式提供給AI，不會直接顯示在聊天介面。<br> • 建議每個聊天掛載3-10輪記憶，避免影響回應速度。 </p>
            </div>
        </div>
        <div class="form-group" id="ai-original-name-group">
            <label for="ai-original-name-input">對方本名 (AI識別用)</label>
            <input type="text" id="ai-original-name-input">
        </div>
        <div class="form-group" id="ai-persona-group"><label for="ai-persona">對方人設 (AI Persona)</label><textarea id="ai-persona" rows="3"></textarea></div>
        <div class="form-group" id="ai-avatar-group"><label>對方頭像</label>
            <div class="avatar-upload"><img id="ai-avatar-preview"><button onclick="document.getElementById('ai-avatar-input').click()">上傳對方頭像</button><button id="manage-ai-avatar-library-btn">管理頭像庫</button><button class="change-frame-btn" data-type="ai">更換頭像框</button>
                <input type="file" id="ai-avatar-input" accept="image/*">
            </div>
        </div>
        <div class="form-group" id="my-persona-group"><label for="my-persona">我的人設 (My Persona)</label><textarea id="my-persona" rows="3"></textarea></div>
        <div class="form-group" id="switch-greeting-group" style="display: none;">
            <label>切換開場 (會清空當前對話)</label>
            <button id="switch-greeting-btn" class="form-button form-button-secondary" style="margin-top: 5px;">選擇其他開場故事...</button>
        </div>
        <div class="form-group" id="my-avatar-group">
            <label>我的頭像</label>
            <div class="avatar-upload">
                <img id="my-avatar-preview">
                <button onclick="document.getElementById('my-avatar-input').click()">上傳我的頭像</button>
                <button id="manage-my-avatar-library-btn">管理頭像庫</button>
                <button class="change-frame-btn" data-type="my">更換頭像框</button>
                <button id="open-persona-library-btn">預設</button>
                <input type="file" id="my-avatar-input" accept="image/*">
            </div>
        </div>
        <div class="form-group" id="group-members-group"><label>群成員人設</label>
            <div id="group-members-settings"></div>
            <button id="manage-members-btn" class="form-button form-button-secondary" style="margin-top: 15px;">管理群成員</button>
        </div>
<div class="form-group" id="tts-enable-group">
    <div style="display: flex; justify-content: space-between; align-items: center;">
        <label for="enable-tts-switch" style="margin-bottom: 0;">
            啟用語音合成 (TTS)
            <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
                關閉後，即使AI回復包含 [V] 首碼，也不會生成語音訊息。
            </p>
        </label>
        <label class="toggle-switch">
            <input type="checkbox" id="enable-tts-switch">
            <span class="slider"></span>
        </label>
    </div>
</div>
<div class="form-group" id="ai-voice-id-group">
    <label for="ai-voice-id-input">語音 ID (Minimax voice_id)</label>
    <input type="text" id="ai-voice-id-input" placeholder="例如: female-shaonv-jingpin">
</div>
        <div class="form-group">
            <label for="max-memory">短期記憶（上下文）條數</label>
            <input type="number" id="max-memory" value="10">
        </div>
        <div class="form-group">
            <label for="linked-memory-count">掛載記憶條數</label>
            <input type="number" id="linked-memory-count" value="10">
            <p style="font-size: 12px; color: #8a8a8a; margin-top: 8px; line-height: 1.5;"> • 每次調用時，從每個“掛載的聊天”中提取最後幾條記錄作為參考記憶。 <br> • 建議值 5-20。值越大記憶越全，但API費用越高、回應越慢。 </p>
        </div>
        <hr style="opacity: 0.3; margin: 20px 0;">
        <div class="form-group" style="display: flex; justify-content: space-between; align-items: center;">
            <label for="auto-memory-toggle" style="margin-bottom: 0;"> 啟用自動總結長期記憶 <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;"> 開啟後，AI會在對話達到一定長度時，自動將內容提煉為長期記憶。 </p>
            </label>
            <label class="toggle-switch">
                <input type="checkbox" id="auto-memory-toggle">
                <span class="slider"></span>
            </label>
        </div>
        <div class="form-group">
            <label for="auto-memory-interval">自動總結間隔（消息條數）</label>
            <input type="number" id="auto-memory-interval" min="10" value="20" style="width: 80px; text-align: center;">
            <p style="font-size: 12px; color: #8a8a8a; margin-top: 8px;"> 建議值 15-30。值越小，總結越頻繁，但API費用也越高。 </p>
        </div>
        <hr style="opacity: 0.3; margin: 20px 0;">
        <div class="form-group">
            <label>聊天氣泡主題 <button id="reset-theme-btn" type="button">重置</button></label>
            <div class="theme-selector">
                <label><input type="radio" name="theme-select" value="default" id="theme-default"> 默認</label>
                <label><input type="radio" name="theme-select" value="pink_blue"> 粉藍</label>
                <label><input type="radio" name="theme-select" value="blue_white"> 藍白</label>
                <label><input type="radio" name="theme-select" value="purple_yellow"> 紫黃</label>
                <label><input type="radio" name="theme-select" value="black_white"> 黑白</label>
                <label><input type="radio" name="theme-select" value="yellow_white"> 黃白</label>
                <label><input type="radio" name="theme-select" value="red_black"> 紅黑</label>
                <label><input type="radio" name="theme-select" value="blue_yellow"> 藍黃</label>
                <label><input type="radio" name="theme-select" value="pink_yellow"> 粉黃</label>
                <label><input type="radio" name="theme-select" value="pink_purple"> 粉紫</label>
                <label><input type="radio" name="theme-select" value="gray_white"> 灰白</label>
                <label><input type="radio" name="theme-select" value="blue_green"> 藍綠</label>
                <label><input type="radio" name="theme-select" value="pink_white"> 粉白</label>
                <label><input type="radio" name="theme-select" value="pink_black"> 粉黑</label>
                <label><input type="radio" name="theme-select" value="pink_green"> 粉綠</label>
                <label><input type="radio" name="theme-select" value="green_black"> 綠黑</label>
            </div>
        </div>
        <div class="form-group">
            <label for="font-size-slider">聊天字體大小 <span id="font-size-value">13px</span></label>
            <input type="range" id="font-size-slider" min="12" max="20" step="1" value="13" style="width: 100%; margin-top: 8px;">
        </div>
        <!-- ▼▼▼ 在這裡黏貼下面的新代碼 ▼▼▼ -->
        <!-- 【【【全新：氣泡主題預設管理】】】 -->
        <hr style="opacity: 0.3; margin: 20px 0;">
        <div class="form-group">
            <label for="theme-preset-select">主題預設管理</label>
            <div style="display: flex; gap: 10px; align-items: center;">
                <select id="theme-preset-select" style="flex-grow: 1;"></select>
                <button id="save-theme-preset-btn" class="form-button-secondary" style="margin-top: 0; padding: 12px;">保存</button>
                <button id="delete-theme-preset-btn" class="form-button-secondary" style="margin-top: 0; padding: 12px; background-color: #ffebee; color: #d32f2f; border-color: #ffcdd2;">刪除</button>
            </div>
        </div>
        <!-- ▲▲▲ 黏貼結束 ▲▲▲ -->
        <div class="form-group">
            <label for="custom-css-input"> 自訂氣泡樣式 (CSS) <button id="reset-custom-css-btn" type="button" style="background: none; border: 1px solid #ccc; color: #555; font-size: 12px; padding: 2px 8px; border-radius: 5px; cursor: pointer; margin-left: 10px;">重置</button>
            </label>
            <textarea id="custom-css-input" rows="5" style="width: 100%; margin-top: 8px; font-family: monospace; font-size: 16px; resize: vertical;" placeholder="/* 示例：為“我”的氣泡添加漸變背景和陰影 */ .message-bubble.user .content { background: linear-gradient(135deg, #a1c4fd, #c2e9fb); box-shadow: 0 4px 10px rgba(0,0,0,0.1); border-radius: 15px 4px 15px 15px; }"></textarea>
        </div>
        <div class="form-group">
            <label>即時預覽</label>
            <div id="settings-preview-area"></div>
        </div>
        <div class="form-group">
            <label>聊天背景</label>
            <div class="bg-upload-container">
                <button type="button" class="form-button-secondary" style="width: auto; padding: 8px 12px; margin-top: 0;" onclick="document.getElementById('bg-input').click()">上傳背景圖</button>
                <button type="button" id="remove-bg-btn">移除背景</button>
            </div>
            <img id="bg-preview" class="bg-preview-img">
            <input type="file" id="bg-input" accept="image/*" style="display: none;">
        </div>
        <hr style="margin: 25px 0; border: none; border-top: 1px solid #eee;">
        <button class="form-button form-button-secondary" id="block-chat-btn" style="background-color: #ff3b30; color: white; border-color: #ff3b30;">拉黑對方</button>
<!-- ▼▼▼ 在這裡黏貼下面的新代碼 ▼▼▼ -->
<hr style="margin: 25px 0; border: none; border-top: 1px solid #eee;">
<button class="form-button form-button-secondary" id="export-single-chat-btn" style="background-color: #e8f5e9; color: #2e7d32; border-color: #c8e6c9;">匯出該聊天</button>
<button class="form-button form-button-secondary" id="import-single-chat-btn" style="background-color: #fff3e0; color: #ef6c00; border-color: #ffe0b2;">導入該聊天</button>
<input type="file" id="import-single-chat-input" accept="application/json" hidden>
<!-- ▲▲▲ 黏貼結束 ▲▲▲ -->
        <button class="form-button form-button-secondary" id="clear-chat-btn">清空聊天記錄</button>
    </div>
</div>
<!-- ▲▲▲ 替換結束 ▲▲▲ -->
    <!-- ▼▼▼ 【全新】請用這整塊代碼，完整替換舊的 rendering-rules-screen ▼▼▼ -->
    <div id="rendering-rules-screen" class="screen">
        <div class="header">
            <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
            <span>渲染規則</span>
            <span class="action-btn" id="add-new-rule-btn">+</span>
        </div>
        <!-- 【核心修改1】全新的頁簽和內容區結構 -->
        <div id="rules-tabs">
            <!-- JS 會在這裡動態生成頁簽 -->
        </div>
        <div id="rules-content-container">
            <!-- JS 會在這裡動態生成內容面板 -->
        </div>
    </div>
    <!-- ▲▲▲ 替換結束 ▲▲▲ -->
    <!-- 2. 規則編輯器模態框 -->
    <div id="rule-editor-modal" class="modal">
        <div class="modal-content" style="height: 85%;">
            <div class="modal-header">
                <span id="rule-editor-title">創建新規則</span>
            </div>
            <div class="modal-body" style="display: flex; flex-direction: column; gap: 15px;">
                <div class="form-group" style="flex-shrink: 0;">
                    <label for="rule-name-input">規則名稱</label>
                    <input type="text" id="rule-name-input" placeholder="例如：美團外賣卡片">
                </div>
                <div class="form-group" style="flex-shrink: 0;">
                    <label for="rule-chat-id-select">綁定範圍</label>
                    <select id="rule-chat-id-select">
                        <option value="global">公用 (所有角色)</option>
                        <!-- 角色清單將由JS動態填充 -->
                    </select>
                </div>
                <div class="form-group" style="flex-grow: 1; display: flex; flex-direction: column;">
                    <label for="rule-regex-input">規則運算式 (使用g作為標誌)</label>
                    <textarea id="rule-regex-input" rows="3" style="font-family: monospace; resize: vertical;" placeholder="例如：MTR\[(.*?)\]\[(.*?)\|(.*?)\]"></textarea>
                </div>
                <div class="form-group" style="flex-grow: 2; display: flex; flex-direction: column;">
                    <label for="rule-template-input">HTML 範本 (用 $1, $2 引用)</label>
                    <textarea id="rule-template-input" rows="6" style="font-family: monospace; resize: vertical;" placeholder="例如：<div class=`waimai-card`>...<span>$2</span>...</div>"></textarea>
                </div>
                <div class="form-group" style="display: flex; justify-content: space-between; align-items: center; flex-shrink: 0;">
                    <label for="rule-enabled-switch" style="margin-bottom: 0;">啟用規則</label>
                    <label class="toggle-switch">
                        <input type="checkbox" id="rule-enabled-switch" checked>
                        <span class="slider"></span>
                    </label>
                </div>
            </div>
            <div class="modal-footer">
                <button class="cancel" id="cancel-rule-editor-btn">取消</button>
                <button class="save" id="save-rule-btn">保存規則</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新HTML黏貼結束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】這是聊天記錄搜索功能的HTML代碼 ▼▼▼ -->
<div id="search-history-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="search-history-back-btn">‹</span>
        <span>搜索聊天記錄</span>
        <span style="width: 30px;"></span>
    </div>
    <!-- 搜索條件輸入區 -->
    <div id="search-bar" style="padding: 10px 15px; border-bottom: 1px solid var(--border-color); background-color: var(--secondary-bg); flex-shrink: 0;">
        <div style="display: flex; gap: 10px; margin-bottom: 10px;">
            <input type="search" id="keyword-search-input" placeholder="輸入關鍵字..." style="flex-grow: 1; padding: 8px 12px; border: 1px solid var(--border-color); border-radius: 6px; font-size: 16px;">
            <input type="date" id="date-search-input" style="padding: 8px 12px; border: 1px solid var(--border-color); border-radius: 6px; font-size: 16px;">
        </div>
        <div style="display: flex; gap: 10px;">
            <button id="execute-search-btn" class="form-button" style="margin-top: 0; flex-grow: 1;">搜索</button>
            <button id="clear-search-btn" class="form-button form-button-secondary" style="margin-top: 0; flex-grow: 1;">重置</button>
        </div>
    </div>
    <!-- 搜索結果顯示區 -->
 
    <div id="chat-search-results-list" class="list-container" style="padding: 15px; display: flex; flex-direction: column; gap: 15px;">
        <!-- 聊天記錄的搜索結果將在這裡顯示 -->
    </div>
</div>
<!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->
<!-- =================================================================== -->
<!-- ▲▲▲ 替換結束 ▲▲▲ -->
<!-- =================================================================== -->
        <!-- ▼▼▼ 【全新】購物功能相關頁面與彈窗 (V4.0 - 仿淘寶終極版) ▼▼▼ -->
<div id="shopping-screen" class="screen">
<div class="header">
    <div class="header-left-actions">
        <span class="back-btn" id="shopping-back-btn">‹</span>
        <span class="action-btn" id="generate-shopping-items-btn" title="AI生成商品">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M20 11A8.1 8.1 0 0 0 4.5 9M4 5v4h4"></path>
                <path d="M4 13a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4"></path>
            </svg>
        </span>
        <span class="action-btn" id="shopping-settings-btn" title="生成設置">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.44,0.17-0.48,0.41L9.12,4.84c-0.59,0.24-1.12,0.56-1.62,0.94L5.11,4.82c-0.22-0.08-0.47,0-0.59,0.22l-1.92,3.32 c-0.12,0.22-0.07,0.47,0.12,0.61l2.03,1.58C4.84,11.36,4.82,11.68,4.82,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.48,2.03 c0.04,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.48-0.41l0.48-2.03c0.59-0.24,1.12-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07,0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"></path>
            </svg>
        </span>
    </div>
    <span>購物中心</span>
    <div class="header-actions">
        <span class="action-btn" id="manage-products-btn" title="管理商品">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"></path>
            </svg>
        </span>
        <span class="action-btn" id="add-new-product-btn" title="添加新商品">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="12" y1="8" x2="12" y2="16"></line>
                <line x1="8" y1="12" x2="16" y2="12"></line>
            </svg>
        </span>
        <span class="action-btn" id="go-to-cart-btn" title="查看購物車">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="9" cy="21" r="1"></circle>
                <circle cx="20" cy="21" r="1"></circle>
                <path d="M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6"></path>
            </svg>
            <span id="cart-count">0</span>
        </span>
    </div>
</div>
            <!-- ▲▲▲ 替換結束 ▲▲▲ -->
           <div id="product-category-tabs"></div>
            <div id="product-grid" class="list-container">
                <!-- 商品將在這裡動態生成 -->
            </div>
        <div id="shopping-action-bar">
            <label class="select-all-label">
                <input type="checkbox" id="select-all-products-checkbox"> 全選
            </label>
            <button id="delete-selected-products-btn" class="action-bar-btn">刪除 (0)</button>
        </div>
        </div>
        <!-- 【核心新增】商品詳情頁 -->
        <div id="product-detail-screen" class="screen">
            <div class="header">
                <span class="back-btn" id="product-detail-back-btn">‹</span>
                <span>商品詳情</span>
                <span style="width: 30px;"></span>
            </div>
            <div id="product-detail-content" class="list-container">
                <!-- 詳情內容將在這裡動態生成 -->
            </div>
            <div id="product-detail-footer">
                <button class="footer-btn add-to-cart-detail-btn">加入購物車</button>
                <button class="footer-btn buy-now-btn">立即購買</button>
            </div>
        </div>
        <div id="cart-screen" class="screen">
            <!-- ▼▼▼ 請用這段新代碼替換購物車頁面的Header ▼▼▼ -->
            <div class="header">
                <span class="back-btn" id="cart-back-btn">‹</span>
                <span id="cart-title">購物車(0)</span>
                <span class="action-btn" id="clear-cart-btn">清空</span> <!-- 將“管理”替換為“清空”功能 -->
            </div>
            <!-- ▲▲▲ 替換結束 ▲▲▲ -->
            <div id="cart-items-list" class="list-container">
                <!-- 購物車商品將在這裡動態生成 -->
            </div>
            <div id="cart-footer">
                <label class="select-all-label"><input type="checkbox" id="select-all-cart-items"> 全選</label>
                <div class="cart-summary">
                    <div id="cart-total">合計: ¥0.00</div>
                    <span class="cart-subtext">不含運費</span>
                </div>
                <button id="checkout-btn">結算(0)</button>
            </div>
        </div>
<div id="product-editor-modal" class="modal">
    <div class="modal-content" style="height: 85%;">
        <div class="modal-header">
            <span id="product-editor-title">添加商品</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label>商品圖片</label>
                <div class="avatar-upload">
                    <img id="product-image-preview" src="https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1756206115802_qdqqd_0c99bh.jpeg">
                    <button onclick="document.getElementById('product-image-input').click()">上傳圖片</button>
                    <input type="file" id="product-image-input" accept="image/*" hidden>
                </div>
            </div>
            <div class="form-group">
                <label for="product-name-input">商品名稱</label>
                <input type="text" id="product-name-input">
            </div>
            <div class="form-group">
                <label for="product-category-select">商品分類</label>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <select id="product-category-select" style="flex-grow: 1;"></select>
                    <button id="manage-product-categories-btn" class="form-button-secondary" style="margin-top: 0; padding: 12px;">管理</button>
                </div>
            </div>
            <div class="form-group">
                <label for="product-price-input">默認價格 (元)</label>
                <input type="number" id="product-price-input" min="0" step="0.01">
            </div>
            <div class="form-group">
                <label for="product-description-input">商品描述</label>
                <textarea id="product-description-input" rows="3" placeholder="詳細介紹一下這個商品..."></textarea>
            </div>
            
            <hr style="opacity: 0.2; margin: 20px 0;">
            <div class="form-group">
                <label>商品款式</label>
                <p style="font-size: 12px; color: #888; margin-top: -5px; margin-bottom: 10px;">如果沒有添加任何款式，將使用上面的默認價格。</p>
                <div id="product-variations-container" style="display: flex; flex-direction: column; gap: 15px;">
                    </div>
                <button id="add-product-variation-btn" class="form-button form-button-secondary" style="margin-top: 15px;">+ 添加新的一款</button>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-product-editor-btn">取消</button>
            <button class="save" id="save-product-btn">保存</button>
        </div>
    </div>
</div>
        <div id="gift-receipt-modal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <span>購物小票</span>
                </div>
                <div class="modal-body" id="gift-receipt-body">
                    <!-- 小票內容將在這裡動態生成 -->
                </div>
                <div class="modal-footer">
                    <button class="save" id="close-receipt-btn" style="width:100%;">關閉</button>
                </div>
            </div>
        </div>
        <!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->
    </div>

    </div>

    <input type="file" id="import-card-input" accept=".json,.png" style="display: none;">
   <input type="file" id="import-world-book-input" accept=".json" style="display: none;">


    <div id="persona-library-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header"><span>我的人設庫</span><button id="add-persona-preset-btn" class="action-button">添加</button></div>
            <div class="modal-body">
                <div id="persona-library-grid"></div>
            </div>
            <div class="modal-footer"><button class="cancel" id="close-persona-library-btn">關閉</button></div>
        </div>
    </div>
    <div id="persona-editor-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header"><span id="persona-editor-title">添加人設預設</span></div>
            <div class="modal-body">
                <div class="form-group"><label>預設頭像</label>
                    <div class="avatar-upload"><img id="preset-avatar-preview"><button onclick="document.getElementById('preset-avatar-input').click()">上傳頭像</button><input type="file" id="preset-avatar-input" accept="image/*"></div>
                </div>
                <div class="form-group"><label for="preset-persona-input">預設人設</label><textarea id="preset-persona-input" rows="4" placeholder="在此輸入這個人設的詳細設定..."></textarea></div>
            </div>
            <div class="modal-footer"><button class="cancel" id="cancel-persona-editor-btn">取消</button><button class="save" id="save-persona-preset-btn">保存</button></div>
        </div>
    </div>
    <div id="member-settings-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header"><span>編輯群成員</span></div>
            <div class="modal-body">
                <div class="form-group"><label for="member-name-input">名字</label><input type="text" id="member-name-input"></div>
                <div class="form-group"><label for="member-persona-input">人設</label><textarea id="member-persona-input" rows="4"></textarea></div>
                <div class="form-group"><label>頭像</label>
                    <div class="avatar-upload"><img id="member-avatar-preview"><button onclick="document.getElementById('member-avatar-input').click()">上傳頭像</button><button class="change-frame-btn" data-type="member">更換頭像框</button><input type="file" id="member-avatar-input" accept="image/*"></div>
                </div>
            </div>
            <div class="modal-footer"><button class="cancel" id="cancel-member-settings-btn">取消</button><button class="save" id="save-member-settings-btn">保存</button></div>
        </div>
    </div>
    <div id="custom-modal-overlay">
        <div id="custom-modal">
            <div class="custom-modal-header" id="custom-modal-title"></div>
            <div class="custom-modal-body" id="custom-modal-body"></div>
            <div class="custom-modal-footer">
                <button id="custom-modal-cancel">取消</button>
                <button id="custom-modal-confirm" class="confirm-btn">確定</button>
            </div>
        </div>
    </div>
    <div id="preset-actions-modal" class="modal">
        <div id="custom-modal" style="width: 250px;">
            <div class="custom-modal-footer">
                <button id="preset-action-edit">編輯預設</button>
                <button id="preset-action-delete" class="btn-danger">刪除預設</button>
                <button id="preset-action-cancel" style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">取消</button>
            </div>
        </div>
    </div>
    <div id="transfer-modal">
        <div class="transfer-content">
            <div class="transfer-header">給Ta一個驚喜！</div>
            <div class="transfer-input-group">
                <label for="transfer-amount">轉帳金額</label>
                <input type="number" id="transfer-amount" placeholder="0.00" min="0" max="999999" step="0.01">
            </div>
            <div class="transfer-input-group">
                <label for="transfer-note">備註 (可選)</label>
                <input type="text" id="transfer-note" placeholder="留下你的小心思~" maxlength="20">
            </div>
            <div class="transfer-actions">
                <button id="transfer-cancel-btn">取消</button>
                <button id="transfer-confirm-btn">確認轉帳</button>
            </div>
        </div>
    </div>
    <div id="battery-alert-modal">
        <div class="battery-alert-content">
            <img id="battery-alert-image" src="">
            <p id="battery-alert-text"></p>
        </div>
    </div>
<!-- ▼▼▼ 【全新】外賣請求模態框 (V2.0 - 支持為TA點單) ▼▼▼ -->
<div id="waimai-request-modal" class="modal">
    <div class="modal-content" style="width: 290px;">
        <div class="modal-header">
            <span>發起外賣訂單</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="waimai-product-info">商品資訊</label>
                <input type="text" id="waimai-product-info" placeholder="例如：一杯楊枝甘露">
            </div>
            <div class="form-group">
                <label for="waimai-amount">訂單金額 (元)</label>
                <input type="number" id="waimai-amount" placeholder="例如：21" min="0" step="0.01">
            </div>
        </div>
        <div class="modal-footer">
            <!-- 【核心修改1】原來的“取消”按鈕，現在變成了“為TA點外賣” -->
            <button class="save" id="waimai-order-for-ai-btn">為TA點單</button>
            <!-- 【核心修改2】原來的“發起請求”按鈕，現在是另一個選項 -->
            <button class="save" id="waimai-confirm-btn">發起請求</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML黏貼結束 ▲▲▲ -->
    <!-- ▼▼▼ 【全新】新建約定/倒計時模態框 ▼▼▼ -->
    <div id="create-countdown-modal" class="modal">
        <div class="modal-content" style="height: auto;">
            <div class="modal-header">
                <span>新建約定</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="countdown-title-input">約定標題</label>
                    <input type="text" id="countdown-title-input" placeholder="例如：我的生日">
                </div>
                <div class="form-group">
                    <label for="countdown-date-input">約定日期與時間</label>
                    <input type="datetime-local" id="countdown-date-input">
                </div>
            </div>
            <div class="modal-footer">
                <button class="cancel" id="cancel-create-countdown-btn">取消</button>
                <button class="save" id="confirm-create-countdown-btn">保存約定</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新HTML黏貼結束 ▲▲▲ -->
    <!-- ▼▼▼ 【全新】發紅包模態框 ▼▼▼ -->
    <div id="red-packet-modal" class="modal">
        <div class="modal-content" style="width: 300px; height: auto;">
            <div class="modal-header">
                <span>發紅包</span>
            </div>
            <div class="modal-body" style="padding: 0;">
                <!-- 1. 頁簽切換 -->
                <div class="frame-tabs">
                    <div id="rp-tab-group" class="frame-tab active">拼手氣紅包</div>
                    <div id="rp-tab-direct" class="frame-tab">專屬紅包</div>
                </div>
                <!-- 2. 拼手氣紅包內容區 -->
                <div id="rp-content-group" class="frame-content" style="padding: 20px 15px;">
                    <div class="form-group">
                        <label>總金額 (元)</label>
                        <input type="number" id="rp-group-amount" placeholder="0.00">
                    </div>
                    <div class="form-group">
                        <label>紅包個數</label>
                        <input type="number" id="rp-group-count" placeholder="填寫紅包個數">
                    </div>
                    <div class="form-group">
                        <label>祝福語</label>
                        <input type="text" id="rp-group-greeting" placeholder="恭喜發財，大吉大利！">
                    </div>
                    <p id="rp-group-total" style="text-align: center; font-size: 24px; font-weight: bold; margin: 10px 0;">¥ 0.00</p>
                    <button id="send-group-packet-btn" class="form-button">塞錢進紅包</button>
                </div>
                <!-- 3. 專屬紅包內容區 -->
                <div id="rp-content-direct" class="frame-content" style="display: none; padding: 20px 15px;">
                    <div class="form-group">
                        <label>發送給</label>
                        <select id="rp-direct-receiver"></select>
                    </div>
                    <div class="form-group">
                        <label>金額 (元)</label>
                        <input type="number" id="rp-direct-amount" placeholder="0.00">
                    </div>
                    <div class="form-group">
                        <label>祝福語</label>
                        <input type="text" id="rp-direct-greeting" placeholder="恭喜發財，大吉大利！">
                    </div>
                    <p id="rp-direct-total" style="text-align: center; font-size: 24px; font-weight: bold; margin: 10px 0;">¥ 0.00</p>
                    <button id="send-direct-packet-btn" class="form-button">塞錢進紅包</button>
                </div>
            </div>
            <div class="modal-footer" style="justify-content: center;">
                <button class="cancel" id="cancel-red-packet-btn" style="width: 100%;">取消</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新HTML黏貼結束 ▲▲▲ -->
    <!-- ▼▼▼ 【全新】紅包詳情模態框 ▼▼▼ -->
    <div id="red-packet-details-modal" class="modal">
        <div class="modal-content" style="width: 280px; height: auto; background-color: #f7f7f7;">
            <div class="modal-header" style="background-color: #F96259; color: white; border-bottom: none; padding-bottom: 5px;">
                <div style="text-align: center; width: 100%;">
                    <div id="rp-details-sender" style="font-size: 16px;"></div>
                    <div style="font-size: 13px; opacity: 0.8;">的紅包</div>
                </div>
            </div>
            <div class="modal-body" style="padding: 15px;">
                <p id="rp-details-greeting" style="text-align: center; font-size: 20px; color: #333; margin: 0 0 20px 0;"></p>
                <div id="rp-details-my-amount" style="text-align: center; display: none; margin-bottom: 20px;">
                    <span style="font-size: 40px; font-weight: bold; color: #E44D44;">0.00</span>
                    <span style="font-size: 18px; color: #E44D44;">元</span>
                </div>
                <div id="rp-details-summary" style="font-size: 13px; color: #8a8a8a; border-top: 1px solid #e0e0e0; padding-top: 10px;"></div>
                <div id="rp-details-list" style="max-height: 150px; overflow-y: auto; margin-top: 10px;">
                    <!-- 領取詳情將由JS動態生成在這裡 -->
                </div>
            </div>
            <div class="modal-footer">
                <button class="save" id="close-rp-details-btn" style="width: 100%;">關閉</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新HTML黏貼結束 ▲▲▲ -->
    <!-- ▼▼▼ 【全新】創建投票模態框 ▼▼▼ -->
    <div id="create-poll-modal" class="modal">
        <div class="modal-content" style="width: 300px; height: auto;">
            <div class="modal-header">
                <span>發起投票</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="poll-question-input">投票問題</label>
                    <textarea id="poll-question-input" rows="2" placeholder="例如：今晚我們看什麼電影？"></textarea>
                </div>
                <div class="form-group">
                    <label>投票選項 (至少2項)</label>
                    <div id="poll-options-container" style="display: flex; flex-direction: column; gap: 8px;">
                        <!-- 投票選項將由JS動態生成在這裡 -->
                    </div>
                    <button id="add-poll-option-btn" class="form-button form-button-secondary" style="margin-top: 12px;">+ 添加選項</button>
                </div>
            </div>
            <div class="modal-footer">
                <button class="cancel" id="cancel-create-poll-btn">取消</button>
                <button class="save" id="confirm-create-poll-btn">發起投票</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新HTML黏貼結束 ▲▲▲ -->
    <!-- ▼▼▼ 【全新】AI頭像庫管理模態框 ▼▼▼ -->
    <div id="ai-avatar-library-modal" class="modal">
        <div class="modal-content" style="height: 70%;">
            <div class="modal-header">
                <span id="ai-avatar-library-title">對方的頭像庫</span>
                <div class="header-actions">
                    <!-- 【核心修改】將一個按鈕拆分為兩個 -->
                    <button id="add-ai-avatar-batch-btn" class="action-button">批量</button>
                    <button id="add-ai-avatar-url-btn" class="action-button">URL</button>
                    <button id="add-ai-avatar-upload-btn" class="action-button">上傳</button>
                </div>
            </div>
            <div class="modal-body" style="padding: 15px;">
                <div id="ai-avatar-library-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 15px;">
                    <!-- 頭像庫內容將由JS動態生成 -->
                </div>
            </div>
            <div class="modal-footer">
                <button class="save" id="close-ai-avatar-library-btn" style="width: 100%;">關閉</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新HTML黏貼結束 ▲▲▲ -->
    <!-- ▼▼▼ 【全新】“我的”頭像庫管理模態框 ▼▼▼ -->
    <div id="my-avatar-library-modal" class="modal">
        <div class="modal-content" style="height: 70%;">
            <div class="modal-header">
                <span id="my-avatar-library-title">我的頭像庫</span>
                <div class="header-actions">
                    <button id="add-my-avatar-batch-btn" class="action-button">批量</button>
                    <button id="add-my-avatar-url-btn" class="action-button">URL</button>
                    <button id="add-my-avatar-upload-btn" class="action-button">上傳</button>
                </div>
            </div>
            <div class="modal-body" style="padding: 15px;">
                <div id="my-avatar-library-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 15px;">
                    <!-- “我的”頭像庫內容將由JS動態生成 -->
                </div>
            </div>
            <div class="modal-footer">
                <button class="save" id="close-my-avatar-library-btn" style="width: 100%;">關閉</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新HTML黏貼結束 ▲▲▲ -->
    <div id="group-avatar-library-modal" class="modal">
        <div class="modal-content" style="height: 70%;">
            <!-- ▼▼▼ 請用這整塊代碼，完整替換你現有的 #group-avatar-library-modal .modal-header ▼▼▼ -->
            <div class="modal-header">
                <span id="group-avatar-library-title">群頭像庫</span>
                <div class="header-actions">
                    <!-- 【核心修改】將一個按鈕拆分為兩個 -->
                    <button id="add-group-avatar-batch-btn" class="action-button">批量</button>
                    <button id="add-group-avatar-url-btn" class="action-button">URL</button>
                    <button id="add-group-avatar-upload-btn" class="action-button">上傳</button>
                </div>
            </div>
            <!-- ▲▲▲ 替換結束 ▲▲▲ -->
            <div class="modal-body" style="padding: 15px;">
                <div id="group-avatar-library-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 15px;">
                </div>
            </div>
            <div class="modal-footer">
                <button class="save" id="close-group-avatar-library-btn" style="width: 100%;">關閉</button>
            </div>
        </div>
    </div>
    <div id="chat-list-actions-modal" class="modal">
        <div id="custom-modal" style="width: 250px;">
            <div class="custom-modal-footer">
                <button id="chat-list-action-pin"></button> <button id="chat-list-action-delete" class="btn-danger">刪除聊天</button>
                <button id="chat-list-action-cancel" style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">取消</button>
            </div>
        </div>
    </div>
    <!-- ▼▼▼ 【全新】使用者分享連結模態框 ▼▼▼ -->
    <div id="share-link-modal" class="modal">
        <div class="modal-content" style="width: 300px; height: auto;">
            <div class="modal-header">
                <span>分享連結</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="link-title-input">標題</label>
                    <input type="text" id="link-title-input" placeholder="輸入文章或連結的標題">
                </div>
                <div class="form-group">
                    <label for="link-description-input">摘要 (可選)</label>
                    <textarea id="link-description-input" rows="2" placeholder="簡單描述一下連結內容"></textarea>
                </div>
                <div class="form-group">
                    <label for="link-source-input">來源名稱 (可選)</label>
                    <input type="text" id="link-source-input" placeholder="例如：知乎日報、B站">
                </div>
                <div class="form-group">
                    <label for="link-content-input">完整內容 (可選，用於流覽器內顯示)</label>
                    <textarea id="link-content-input" rows="4" placeholder="黏貼或輸入完整的文章內容"></textarea>
                </div>
            </div>
            <div class="modal-footer">
                <button class="cancel" id="cancel-share-link-btn">取消</button>
                <button class="save" id="confirm-share-link-btn">分享</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新HTML黏貼結束 ▲▲▲ -->
    <!-- ▼▼▼ 【全新】精緻版轉帳操作彈窗 ▼▼▼ -->
    <div id="transfer-actions-modal" class="modal">
        <div class="transfer-actions-content">
            <div class="transfer-actions-header">請選擇操作</div>
            <div class="transfer-actions-body">
                <p>你收到了來自 <strong id="transfer-sender-name"></strong> 的一筆轉帳。</p>
            </div>
            <div class="transfer-actions-footer">
                <button id="transfer-action-decline" class="action-btn decline">殘忍拒絕</button>
                <button id="transfer-action-accept" class="action-btn accept">開心收下</button>
            </div>
            <button id="transfer-action-cancel" class="cancel-btn">×</button>
        </div>
    </div>
    <!-- ▲▲▲ 新HTML黏貼結束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】通話記錄詳情模態框 ▼▼▼ -->
    <div id="call-transcript-modal" class="modal">
        <div class="modal-content" style="height: 70%;">
            <div class="modal-header">
                <span id="transcript-modal-title">通話詳情</span>
            </div>
            <div class="modal-body" id="call-transcript-modal-body" style="background-color: #f0f2f5;">
                <!-- 通話文字記錄將由JS動態生成在這裡 -->
            </div>
            <div class="modal-footer">
                <button class="cancel" id="delete-transcript-btn" style="background-color: #ff3b30; color: white; border-color: #ff3b30;">刪除記錄</button>
                <!-- 【【【核心新增】】】 -->
                <button class="save" id="manual-summarize-btn" style="background-color: #ffc107; border-color: #ffc107;">手動總結</button>
                <button class="save" id="close-call-transcript-btn" style="width: 100%;">關閉</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新HTML黏貼結束 ▲▲▲ -->
    <!-- ▼▼▼ 【全新】分享目標選擇器模態框 ▼▼▼ -->
    <div id="share-target-modal" class="modal">
        <div class="modal-content" style="height: 70%;">
            <div class="modal-header">
                <span>分享到...</span>
            </div>
            <div class="modal-body" id="share-target-list" style="padding: 0;">
                <!-- 聊天清單將由JS動態生成在這裡 -->
            </div>
            <div class="modal-footer">
                <button class="cancel" id="cancel-share-target-btn">取消</button>
                <button class="save" id="confirm-share-target-btn">確認分享</button>
            </div>
        </div>
    </div>
    <!-- ▼▼▼ 【全新】分享記錄檢視器模態框 ▼▼▼ -->
    <div id="shared-history-viewer-modal" class="modal">
        <div class="modal-content" style="height: 80%;">
            <div class="modal-header">
                <span id="shared-history-viewer-title">聊天記錄</span>
            </div>
            <div class="modal-body" id="shared-history-viewer-content" style="background-color: #f0f2f5;">
                <!-- 分享的聊天記錄氣泡將由JS動態生成在這裡 -->
            </div>
            <div class="modal-footer">
                <button class="save" id="close-shared-history-viewer-btn" style="width:100%;">關閉</button>
            </div>
        </div>
    </div>
    <!-- ▼▼▼ 【全新】世界書分類管理模態框 ▼▼▼ -->
    <div id="world-book-category-manager-modal" class="modal">
        <div class="modal-content" style="height: 60%;">
            <div class="modal-header">
                <span>管理世界書分類</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>新建分類</label>
                    <div style="display: flex; gap: 10px;">
                        <input type="text" id="new-category-name-input" placeholder="輸入分類名..." style="flex-grow: 1;">
                        <button id="add-new-category-btn" class="form-button" style="width: auto; margin-top: 0; padding: 0 15px;">添加</button>
                    </div>
                </div>
                <hr style="opacity: 0.2;">
                <div id="existing-categories-list" style="display: flex; flex-direction: column; gap: 10px;">
                    <!-- 分類清單將由JS動態生成 -->
                </div>
            </div>
            <div class="modal-footer">
                <button class="save" id="close-category-manager-btn" style="width: 100%;">完成</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新HTML黏貼結束 ▲▲▲ -->
    <div id="announcement-board-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <span>群公告板</span>
            </div>
            <div id="announcement-board-content">
            </div>
            <div class="modal-footer">
                <button class="save" id="close-announcement-board-btn" style="width: 100%;">關閉</button>
            </div>
        </div>
    </div>
    <div id="announcement-actions-modal" class="modal">
        <div id="custom-modal" style="width: 250px;">
            <div class="custom-modal-footer">
                <button id="announcement-action-pin">置頂公告</button>
                <button id="announcement-action-delete" class="btn-danger">刪除公告</button>
                <button id="announcement-action-cancel" style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">取消</button>
            </div>
        </div>
    </div>
    <!-- ▼▼▼ 請將這個新的模態框HTML黏貼到所有其他模態框之後 ▼▼▼ -->
    <div id="group-management-modal" class="modal">
        <div class="modal-content" style="height: 60%;">
            <div class="modal-header">
                <span>管理好友分組</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>新建分組</label>
                    <div style="display: flex; gap: 10px;">
                        <input type="text" id="new-group-name-input" placeholder="輸入分組名..." style="flex-grow: 1;">
                        <button id="add-new-group-btn" class="form-button" style="width: auto; margin-top: 0; padding: 0 15px;">添加</button>
                    </div>
                </div>
                <hr style="opacity: 0.2;">
                <div id="existing-groups-list" style="display: flex; flex-direction: column; gap: 10px;">
                    <!-- 分組清單將由JS動態生成 -->
                </div>
            </div>
            <div class="modal-footer">
                <button class="save" id="close-group-manager-btn" style="width: 100%;">完成</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新代碼黏貼結束 ▲▲▲ -->
    <!-- ▼▼▼ 請將這段新HTML黏貼到所有模態框的末尾 ▼▼▼ -->
    <div id="message-actions-modal" class="modal">
        <div id="custom-modal" style="width: 250px;">
            <div class="custom-modal-footer">
                <!-- 新的操作按鈕 -->
                <button id="edit-message-btn">編輯消息</button>
                <button id="copy-message-btn">複製文本</button>
            <button id="copy-timestamp-btn">複製時間戳記</button>
                <button id="recall-message-btn">撤回</button>
                <button id="publish-to-announcement-btn" style="display: none;">發佈到公告板</button>
                <button id="quote-message-btn">引用</button>
                <button id="select-message-btn">進入多選</button>
                <!-- 取消按鈕 -->
                <button id="cancel-message-action-btn" style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">取消</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新HTML黏貼結束 ▲▲▲ -->
    <!-- ▼▼▼ 請將這段新HTML黏貼到所有模態框的末尾 ▼▼▼ -->
    <div id="post-actions-modal" class="modal">
        <div id="custom-modal" style="width: 250px;">
            <div class="custom-modal-footer">
                <button id="edit-post-btn">編輯動態</button>
                <button id="copy-post-btn">複製內容</button>
                <button id="cancel-post-action-btn">取消</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新HTML黏貼結束 ▲▲▲ -->
    <!-- ▼▼▼ 【全新】視覺化消息編輯器模態框 ▼▼▼ -->
    <div id="message-editor-modal" class="modal">
        <div class="modal-content" style="height: 75%;">
            <div class="modal-header">
                <span>編輯與拆分消息</span>
            </div>
            <div class="modal-body" id="message-editor-body">
                <!-- 編輯器容器，JS會在這裡動態生成文字方塊 -->
                <div id="message-editor-container"></div>
                <!-- 添加新消息的按鈕 -->
                <button id="add-message-editor-block-btn" class="form-button form-button-secondary" style="margin-top: 15px;"> [+] 添加下一條消息 </button>
            </div>
            <div class="modal-footer">
                <button class="cancel" id="cancel-advanced-editor-btn">取消</button>
                <button class="save" id="save-advanced-editor-btn">保存更改</button>
            </div>
        </div>
    </div>
    <!-- ▼▼▼ 【全新】“導演剪輯室”模態框 ▼▼▼ -->
    <div id="ai-response-editor-modal" class="modal">
        <div class="modal-content" style="height: 80%;">
            <div class="modal-header">
                <span>導演剪輯室 (AI上一輪回應)</span>
            </div>
            <div class="modal-body" id="ai-response-editor-body">
                <!-- 導演剪輯器容器，JS會在這裡動態生成文字方塊 -->
                <div id="ai-response-editor-container" style="display: flex; flex-direction: column; gap: 15px;"></div>
                <!-- 添加新消息的按鈕 -->
                <button id="add-ai-response-block-btn" class="form-button form-button-secondary" style="margin-top: 15px;"> [+] 添加一個新動作 </button>
            </div>
            <div class="modal-footer">
                <button class="cancel" id="cancel-ai-response-editor-btn">取消</button>
                <button class="save" id="save-ai-response-editor-btn">應用修改</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新HTML黏貼結束 ▲▲▲ -->
    <div id="repost-modal" class="modal">
        <div id="custom-modal" style="width: 280px;">
            <div class="custom-modal-header">轉發動態</div>
            <div class="custom-modal-body">
                <textarea id="repost-comment-input" placeholder="請輸入轉發評論 (可選)" style="width: 100%; min-height: 60px; resize: vertical; border: 1px solid #ccc; border-radius: 6px; padding: 8px; font-size: 16px; box-sizing: border-box;"></textarea>
            </div>
            <div class="custom-modal-footer">
                <button id="repost-cancel-btn">取消</button>
                <button id="repost-confirm-btn" class="confirm-btn">確定</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新HTML黏貼結束 ▲▲▲ -->
    <!-- ▼▼▼ 【全新】視頻通話消息操作功能表 ▼▼▼ -->
    <div id="call-message-actions-modal" class="modal">
        <div id="custom-modal" style="width: 250px;">
            <div class="custom-modal-footer">
                <button id="edit-call-message-btn">編輯</button>
                <button id="delete-call-message-btn" class="btn-danger">刪除</button>
                <button id="cancel-call-message-action-btn" style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">取消</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新HTML黏貼結束 ▲▲▲ -->



    <audio id="audio-player" style="display:none;"></audio>
    <!-- ▼▼▼ 用下面這段【完整】的模態框代碼，替換掉你現有的 id="create-post-modal" 的整個 div ▼▼▼ -->
    <div id="create-post-modal" class="modal">
        <div class="modal-content" style="height: auto; max-height: 90%;">
            <div class="modal-header">
                <span>發佈動態</span>
            </div>
            <div class="modal-body">
                <!-- 公開文字輸入區 -->
                <div class="form-group">
                    <textarea id="post-public-text" rows="3" placeholder="分享新鮮事...（非必填的公開文字）"></textarea>
                </div>
                <!-- === 模式切換開關 (新增) === -->
                <div class="post-mode-switcher">
                    <button id="switch-to-image-mode" class="mode-btn active">上傳圖片</button>
                    <button id="switch-to-text-image-mode" class="mode-btn">使用文字圖</button>
                </div>
                <!-- ▼▼▼ 【修正後】的可見範圍設置 ▼▼▼ -->
                <div class="form-group">
                    <label>可見範圍</label>
                    <div id="post-visibility-options" style="display: flex; gap: 15px; margin-bottom: 10px;">
                        <label><input type="radio" name="visibility" value="public" checked> 公開</label>
                        <label><input type="radio" name="visibility" value="include"> 指定分組可見</label>
                    </div>
                    <div id="post-visibility-groups" style="display: none; max-height: 120px; overflow-y: auto; background: #f9f9f9; padding: 10px; border-radius: 8px;">
                        <!-- 分組多選框將由JS動態生成 -->
                    </div>
                </div>
                <!-- ▲▲▲ 修正結束 ▲▲▲ -->
                <!-- === 圖片模式區域 === -->
                <div id="image-mode-content" class="post-mode-content active">
                    <div class="form-group">
                        <div id="post-image-preview-container" class="post-image-preview-container">
                            <img id="post-image-preview" src="" alt="圖片預覽">
                            <button id="post-remove-image-btn">×</button>
                        </div>
                        <div class="post-image-upload-options">
                            <button id="post-upload-local-btn" class="form-button-secondary">本地上傳</button>
                            <button id="post-use-url-btn" class="form-button-secondary">網路URL</button>
                            <input type="file" id="post-local-image-input" accept="image/*" hidden>
                        </div>
                    </div>
                    <div id="post-image-desc-group" class="form-group" style="display: none;">
                        <label>圖片描述 (必填，給AI看)</label>
                        <input type="text" id="post-image-description" placeholder="簡單描述圖片內容，説明AI理解">
                    </div>
                </div>
                <!-- === 文字圖模式區域 (新增) === -->
                <div id="text-image-mode-content" class="post-mode-content">
                    <div class="form-group">
                        <label>文字圖 (給AI理解用的描述，點擊圖片後可見)</label>
                        <textarea id="post-hidden-text" rows="4" placeholder="在這裡寫下圖片描述..."></textarea>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="cancel" id="cancel-create-post-btn">取消</button>
                <button class="save" id="confirm-create-post-btn">發佈</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 替換結束 ▲▲▲ -->



    <input type="file" id="ai-avatar-upload-input" accept="image/*" hidden>
    <input type="file" id="group-avatar-upload-input" accept="image/*" hidden>
    <script>
// ▼▼▼ 在這裡黏貼下面的新代碼 ▼▼▼
if (!Array.prototype.findLastIndex) {
  Object.defineProperty(Array.prototype, 'findLastIndex', {
    value: function(predicate) {
      if (this == null) {
        throw new TypeError('Cannot read property \'findLastIndex\' of null or undefined');
      }
      if (typeof predicate !== 'function') {
        throw new TypeError('predicate must be a function');
      }
      let o = Object(this);
      let len = o.length >>> 0;
      let thisArg = arguments[1];
      let k = len - 1;
      while (k >= 0) {
        let kValue = o[k];
        if (predicate.call(thisArg, kValue, k, o)) {
          return k;
        }
        k--;
      }
      return -1;
    },
    configurable: true,
    writable: true
  });
}


        // ... 其他全域變數
        let activeMessageTimestamp = null;
        let activeTransferTimestamp = null; // <-- 確保這行在這裡，並且只有一行
        // ▼▼▼ 在下方黏貼新變數 ▼▼▼
        let lastRawAiResponse = ''; // 用於存儲AI上一輪的原始回應字串
        let lastResponseTimestamps = []; // 用於存儲上一輪回應生成的消息的時間戳記
        // ▲▲▲ 新增結束 ▲▲▲
        let currentQzoneReplyContext = null;
        let editingNpcId = null; // <-- 新增這一行
        // ...
                const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models'
            // gemini如果是多個金鑰, 那麼隨機獲取一個
            function getRandomValue(str) {
                // 檢查字串是否包含逗號
                if (str.includes(',')) {
                    // 用逗號分隔字串並移除多餘空格
                    const arr = str.split(',').map(item => item.trim());
                    // 生成隨機索引 (0 到 arr.length-1)
                    const randomIndex = Math.floor(Math.random() * arr.length);
                    // 返回隨機元素
                    return arr[randomIndex];
                }
                // 沒有逗號則直接返回原字串
                return str;
            }
            function isImage(content) {
                if(content.image_url && content.image_url.url){
                    let currentImageData = content.image_url.url
                    // 提取Base64資料（去掉首碼）
                    const base64Data = currentImageData.split(',')[1];
                    // 根據圖片類型獲取MIME類型
                    const mimeType = currentImageData.match(/^data:(.*);base64/)[1];
                    return [
                        {text: '使用者向你發送了一張圖片'},
                        {
                            inline_data: {
                                mime_type: mimeType,
                                data: base64Data
                            }
                        }
                    ]
                }
                return []
            }
        
        
        // ▼▼▼ 【最終診斷增強版】請用這個全新的函數，完整替換您現有的 getGeminiResponseText ▼▼▼
        /**
         * 【V3.0 | 診斷增強版】從Gemini或相容OpenAI的API回應中安全地提取文本內容
         * @param {object} data - 從 response.json() 解析後的資料物件
         * @returns {string} - 提取到的文本內容
         * @throws {Error} - 如果響應格式不正確或被遮罩，則拋出一個帶有詳細原因的錯誤
         */
        function getGeminiResponseText(data) {
            // 1. 檢查是否是相容OpenAI的回應格式
            if (data.choices && Array.isArray(data.choices) && data.choices.length > 0 && data.choices[0].message && data.choices[0].message.content) {
                return data.choices[0].message.content;
            }
        
            // 2. 檢查是否是成功的、標準的原生Gemini回應格式
            if (data.candidates && Array.isArray(data.candidates) && data.candidates.length > 0 && data.candidates[0].content && data.candidates[0].content.parts) {
                return data.candidates[0].content.parts[0].text;
            }
        
            // --- 【【【核心升級：全面的錯誤診斷】】】 ---
            console.error("Gemini API返回了非預期的格式:", data);
            let errorReason = "AI返回了空內容或未知格式。";
        
            // 3a. 診斷是否是因為內容安全性原則被遮罩 (Gemini官方API最常見的問題)
            // 這種情況data.candidates是存在的，但裡面沒有content
            if (data.candidates && Array.isArray(data.candidates) && data.candidates.length > 0 && data.candidates[0].finishReason === 'SAFETY') {
                const safetyRatings = data.candidates[0].safetyRatings;
                const blockedCategories = safetyRatings
                    .filter(r => r.probability !== 'NEGLIGIBLE' && r.probability !== 'LOW')
                    .map(r => `${r.category} (概率: ${r.probability})`)
                    .join(', ');
                errorReason = `內容因安全性原則被遮罩。觸發類別: ${blockedCategories || '未知'}`;
            }
            // 3b. 診斷另一種內容安全遮罩格式 (promptFeedback)
            else if (data.promptFeedback?.blockReason) {
                const reason = data.promptFeedback.blockReason;
                const details = data.promptFeedback.safetyRatings?.map(r => `${r.category}: ${r.probability}`).join(', ');
                errorReason = `內容因安全性原則被遮罩 (原因: ${reason})。詳情: ${details || '無'}`;
            } 
            // 3c. 診斷是否是其他類型的API錯誤
            else if (data.error) {
                errorReason = `API錯誤: ${data.error.message}`;
            }
            
            // 4. 拋出一個帶有詳細資訊的錯誤
            throw new Error(errorReason);
        }
        // ▲▲▲ 替換結束 ▲▲▲
        

            document.addEventListener('DOMContentLoaded', () => {
// ▼▼▼ 【最終識圖修復方案】請用這個全新的、相容性更強的函數，完整替換舊的 toGeminiRequestData ▼▼▼
function toGeminiRequestData(model, apiKey, systemInstruction, messagesForDecision) {
    const apiTemperature = state.globalSettings.apiTemperature || 0.8; // <-- 新增：獲取溫度
    const roleType = {
        user: 'user',
        assistant: 'model',
        system: 'user'
    };

    // --- 1. 將 systemInstruction 類比成第一次使用者對話，極大提高相容性 ---
    const contents = [
        {
            role: 'user',
            parts: [{ text: systemInstruction }]
        },
        {
            role: 'model',
            parts: [{ text: '好的，我明白了。我會嚴格遵守以上所有規則和設定。' }]
        },
        // --- 2. 【核心修復】智慧地處理每一條消息，構建正確的 parts 陣列 ---
        ...messagesForDecision.map((item) => {
            const parts = [];
            // a. 如果 content 是一個陣列，說明可能是複雜消息（文本+圖片）
            if (Array.isArray(item.content)) {
                item.content.forEach(part => {
                    if (part.type === 'text') {
                        parts.push({ text: part.text });
                    } else if (part.type === 'image_url' && part.image_url && part.image_url.url) {
                        // b. 正確地從 Base64 URL 中提取圖片資料和類型
                        const currentImageData = part.image_url.url;
                        const base64Data = currentImageData.split(',')[1];
                        const mimeTypeMatch = currentImageData.match(/^data:(.*);base64/);
                        if (mimeTypeMatch && base64Data) {
                            parts.push({
                                inline_data: {
                                    mime_type: mimeTypeMatch[1],
                                    data: base64Data
                                }
                            });
                        }
                    }
                });
            } else {
                // c. 如果 content 是普通字串，直接作為文本處理
                parts.push({ text: String(item.content) });
            }
            return { role: roleType[item.role], parts: parts };
        })
    ];

    // --- 3. 返回最終構建好的、完全符合 Gemini API 規範的請求資料 ---
    return {
        url: `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${getRandomValue(apiKey)}`,
        data: {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                contents: contents,
                generationConfig: {
                    temperature: apiTemperature, // <-- 【核心修改】使用我們獲取的溫度值
                },
            })
        }
    };
}
// ▲▲▲ 替換結束 ▲▲▲
        
                // ===================================================================
                // 1. 所有變數和常量定義
                // ===================================================================
                const db = new Dexie('GeminiChatDB');
        const avatarFrames = [ { id: 'none', url: '', name: '無' }, { id: 'frame_cat_ear', url: 'https://i.postimg.cc/fLDnz5Pn/IMG-5574.gif', name: '1' }, { id: 'frame_ribbon', url: 'https://i.postimg.cc/HxH3cNHz/IMG-6871.gif', name: '2' }, { id: 'frame_flower', url: 'https://i.postimg.cc/jCVK0fGL/IMG-6890.gif', name: '3' }, { id: 'frame_tech', url: 'https://i.postimg.cc/85Zsyjwn/IMG-6895.gif', name: '4' }, { id: 'frame_5', url: 'https://i.postimg.cc/cJtpZCB3/IMG-6894.gif', name: '5' }, { id: 'frame_6', url: 'https://i.postimg.cc/63sDQKMm/IMG-6893.gif', name: '6' }, { id: 'frame_7', url: 'https://i.postimg.cc/cHQPgzj4/IMG-6888.gif', name: '7' }, { id: 'frame_8', url: 'https://i.postimg.cc/dVLXm3Xf/IMG-6885.gif', name: '8' }, { id: 'frame_9', url: 'https://i.postimg.cc/kGsZwbq0/IMG-6886.gif', name: '9' }, { id: 'frame_10', url: 'https://i.postimg.cc/63NmX03s/IMG-4366.gif', name: '10' }, { id: 'frame_11', url: 'https://i.postimg.cc/zvz2LGK0/IMG-4367.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/prsGKMBx/IMG-4370.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/gk0BmrY0/IMG-4371.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/fRt2SFSn/IMG-4368.gif', name: '14' }, { id: 'frame_cat_ear', url: 'https://i.postimg.cc/kGgwJhPH/IMG-4374.gif', name: '1' }, { id: 'frame_ribbon', url: 'https://i.postimg.cc/PrcKH436/IMG-4376.gif', name: '2' }, { id: 'frame_flower', url: 'https://i.postimg.cc/fRV86FMq/IMG-4381.gif', name: '3' }, { id: 'frame_tech', url: 'https://i.postimg.cc/HsyqMVyk/IMG-4385.gif', name: '4' }, { id: 'frame_5', url: 'https://i.postimg.cc/qBbKK7dS/IMG-4386.gif', name: '5' }, { id: 'frame_6', url: 'https://i.postimg.cc/05wnd389/IMG-4388.gif', name: '6' }, { id: 'frame_7', url: 'https://i.postimg.cc/RZNLhbbr/IMG-4389.gif', name: '7' }, { id: 'frame_8', url: 'https://i.postimg.cc/fLTc42dg/IMG-4391.gif', name: '8' }, { id: 'frame_9', url: 'https://i.postimg.cc/FzbGNdRT/IMG-4392.gif', name: '9' }, { id: 'frame_10', url: 'https://i.postimg.cc/XY63sTS3/IMG-4393.gif', name: '10' }, { id: 'frame_11', url: 'https://i.postimg.cc/Cx9vCVWH/IMG-4395.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/kMfPQBwQ/IMG-4396.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/CLrZQMMD/IMG-4398.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/L4zwDhTC/IMG-4399.gif', name: '14' }, { id: 'frame_cat_ear', url: 'https://i.postimg.cc/yN3s8szM/IMG-4400.gif', name: '1' }, { id: 'frame_ribbon', url: 'https://i.postimg.cc/59Cn1tkB/IMG-4401.gif', name: '2' }, { id: 'frame_flower', url: 'https://i.postimg.cc/g0s1V0PX/IMG-4402.gif', name: '3' }, { id: 'frame_tech', url: 'https://i.postimg.cc/Jn1DFPgY/IMG-4403.gif', name: '4' }, { id: 'frame_5', url: 'https://i.postimg.cc/q7cQnDy1/IMG-4404.gif', name: '5' }, { id: 'frame_6', url: 'https://i.postimg.cc/RFK3q2t0/IMG-4407.gif', name: '6' }, { id: 'frame_7', url: 'https://i.postimg.cc/gcV0VR2t/IMG-4408.gif', name: '7' }, { id: 'frame_8', url: 'https://i.postimg.cc/W1CjLb4J/IMG-4409.gif', name: '8' }, { id: 'frame_9', url: 'https://i.postimg.cc/Ss7pM6fW/IMG-4410.gif', name: '9' }, { id: 'frame_10', url: 'https://i.postimg.cc/nrFfYX3N/IMG-4412.gif', name: '10' }, { id: 'frame_11', url: 'https://i.postimg.cc/cHWp0KG6/IMG-4413.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/4yNjHrdg/IMG-4414.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/hPX5F8Qp/IMG-4415.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/vHCSG1WM/IMG-4416.gif', name: '14' }, { id: 'frame_cat_ear', url: 'https://i.postimg.cc/x1Hp80Rm/IMG-4417.gif', name: '1' }, { id: 'frame_ribbon', url: 'https://i.postimg.cc/FHRcCGfH/IMG-4418.gif', name: '2' }, { id: 'frame_flower', url: 'https://i.postimg.cc/13hhJ77p/IMG-4419.gif', name: '3' }, { id: 'frame_tech', url: 'https://i.postimg.cc/J4WCQd2j/IMG-4420.gif', name: '4' }, { id: 'frame_5', url: 'https://i.postimg.cc/Dydkpd9H/IMG-4421.gif', name: '5' }, { id: 'frame_6', url: 'https://i.postimg.cc/mrkvDxPW/IMG-4422.gif', name: '6' }, { id: 'frame_7', url: 'https://i.postimg.cc/76Tj3g1B/IMG-4425.gif', name: '7' }, { id: 'frame_8', url: 'https://i.postimg.cc/3N5Vndn3/IMG-4426.gif', name: '8' }, { id: 'frame_9', url: 'https://i.postimg.cc/05DLr0yj/IMG-4427.gif', name: '9' }, { id: 'frame_10', url: 'https://i.postimg.cc/GhR6DT4Q/IMG-4428.gif', name: '10' }, { id: 'frame_11', url: 'https://i.postimg.cc/fRTF24jS/IMG-4430.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/R0WYmcYM/IMG-4431.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/nrJSqNhz/IMG-4432.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/tC9mJ0cv/IMG-4438.gif', name: '14' }, { id: 'frame_cat_ear', url: 'https://i.postimg.cc/XNkQTHvf/IMG-5561.gif', name: '1' }, { id: 'frame_ribbon', url: 'https://i.postimg.cc/Mpv5fzm5/IMG-4439.gif', name: '2' }, { id: 'frame_flower', url: 'https://i.postimg.cc/T1tjhsyB/IMG-4720.gif', name: '3' }, { id: 'frame_tech', url: 'https://i.postimg.cc/c4JMPd2W/IMG-4724.gif', name: '4' }, { id: 'frame_5', url: 'https://i.postimg.cc/g2XykNGB/IMG-4727.gif', name: '5' }, { id: 'frame_6', url: 'https://i.postimg.cc/y8MmJcd6/IMG-4728.gif', name: '6' }, { id: 'frame_7', url: 'https://i.postimg.cc/Lsjzj5Yt/IMG-4729.gif', name: '7' }, { id: 'frame_8', url: 'https://i.postimg.cc/bNdk33SN/IMG-4893.gif', name: '8' }, { id: 'frame_9', url: 'https://i.postimg.cc/4x9tTy1D/IMG-5563.gif', name: '9' }, { id: 'frame_10', url: 'https://i.postimg.cc/DZshzKv6/IMG-5576.gif', name: '10' }, { id: 'frame_11', url: 'https://i.postimg.cc/Fsvr71JL/IMG-5573.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/Fz3HwLk9/IMG-5569.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/wjH180kn/IMG-5566.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/MG6qtLYK/IMG-5565.gif', name: '14' }, { id: 'frame_cat_ear', url: 'https://i.postimg.cc/CKgDNYVb/IMG-5577.gif', name: '1' }, { id: 'frame_ribbon', url: 'https://i.postimg.cc/hj4dkrvj/IMG-5578.gif', name: '2' }, { id: 'frame_flower', url: 'https://i.postimg.cc/hj4dkrvj/IMG-5578.gif', name: '3' }, { id: 'frame_tech', url: 'https://i.postimg.cc/C5XnfpNB/IMG-5579.gif', name: '4' }, { id: 'frame_5', url: 'https://i.postimg.cc/4y7mGFgJ/IMG-5716.gif', name: '5' }, { id: 'frame_6', url: 'https://i.postimg.cc/FzM1Hgr0/IMG-5717.gif', name: '6' }, { id: 'frame_7', url: 'https://i.postimg.cc/rF4KYbjj/IMG-5720.gif', name: '7' }, { id: 'frame_8', url: 'https://i.postimg.cc/6pLTBvDG/IMG-5721.gif', name: '8' }, { id: 'frame_9', url: 'https://i.postimg.cc/VNK6Ccsf/IMG-5722.gif', name: '9' }, { id: 'frame_10', url: 'https://i.postimg.cc/wx72fhr2/IMG-5968.gif', name: '10' }, { id: 'frame_11', url: 'https://i.postimg.cc/QdrqdvdY/IMG-5969.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/0yd0MZ6k/IMG-5971.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/1zmcp66p/IMG-5973.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/wBw5Fvcn/IMG-5974.gif', name: '14' }, { id: 'frame_cat_ear', url: 'https://i.postimg.cc/R0pfKYvB/IMG-5976.gif', name: '1' }, { id: 'frame_ribbon', url: 'https://i.postimg.cc/9fQZ425b/IMG-5975.gif', name: '2' }, { id: 'frame_flower', url: 'https://i.postimg.cc/v8V9xXjJ/IMG-6137.gif', name: '3' }, { id: 'frame_tech', url: 'https://i.postimg.cc/WbmkXzsS/IMG-6138.gif', name: '4' }, { id: 'frame_5', url: 'https://i.postimg.cc/Dw2bDhZh/IMG-6140.gif', name: '5' }, { id: 'frame_6', url: 'https://i.postimg.cc/ZqQBCyLY/IMG-6144.gif', name: '6' }, { id: 'frame_7', url: 'https://i.postimg.cc/qRCtnMms/IMG-6145.gif', name: '7' }, { id: 'frame_8', url: 'https://i.postimg.cc/1Rwn3XVP/IMG-6146.gif', name: '8' }, { id: 'frame_9', url: 'https://i.postimg.cc/Kv51tW5H/IMG-6147.gif', name: '9' }, { id: 'frame_10', url: 'https://i.postimg.cc/nhcC21Rc/IMG-6148.gif', name: '10' }, { id: 'frame_11', url: 'https://i.postimg.cc/fTWzQRx8/IMG-6149.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/LXyyqDbY/IMG-6294.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/7Zgm1wRy/IMG-6295.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/5tbpnDcQ/IMG-6296.gif', name: '14' }, { id: 'frame_cat_ear', url: 'https://i.postimg.cc/YSRRV8kn/IMG-6297.gif', name: '1' }, { id: 'frame_ribbon', url: 'https://i.postimg.cc/k45sd8gn/IMG-6375.gif', name: '2' }, { id: 'frame_flower', url: 'https://i.postimg.cc/50k390X8/IMG-6376.gif', name: '3' }, { id: 'frame_tech', url: 'https://i.postimg.cc/90RBDh9K/IMG-6377.gif', name: '4' }, { id: 'frame_5', url: 'https://i.postimg.cc/cCpBYbMH/IMG-6552.gif', name: '5' }, { id: 'frame_6', url: 'https://i.postimg.cc/Pf9g2fSL/IMG-6554.gif', name: '6' }, { id: 'frame_7', url: 'https://i.postimg.cc/gkhf597g/IMG-6555.gif', name: '7' }, { id: 'frame_8', url: 'https://i.postimg.cc/g2PfbSFm/IMG-6556.gif', name: '8' }, { id: 'frame_9', url: 'https://i.postimg.cc/pLY3WfR8/IMG-6557.gif', name: '9' }, { id: 'frame_10', url: 'https://i.postimg.cc/65Cmcr7S/IMG-6559.gif', name: '10' }, { id: 'frame_11', url: 'https://i.postimg.cc/Y94XWYKd/IMG-6560.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/ydwLXx7s/IMG-6562.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/G3y73Fj2/IMG-6563.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/TYvkKKkc/IMG-6565.gif', name: '14' }, { id: 'frame_cat_ear', url: 'https://i.postimg.cc/GmcqjZn8/IMG-6566.gif', name: '1' }, { id: 'frame_ribbon', url: 'https://i.postimg.cc/k5Gs0K47/IMG-6567.gif', name: '2' }, { id: 'frame_flower', url: 'https://i.postimg.cc/XJy8JWdh/IMG-6568.gif', name: '3' }, { id: 'frame_tech', url: 'https://i.postimg.cc/fycfcvHf/IMG-6569.gif', name: '4' }, { id: 'frame_5', url: 'https://i.postimg.cc/J7ZxC11H/IMG-6570.gif', name: '5' }, { id: 'frame_6', url: 'https://i.postimg.cc/hPnrSHjy/IMG-4434.gif', name: '6' }, { id: 'frame_7', url: 'https://i.postimg.cc/YqxxjbLp/IMG-6572.gif', name: '7' }, { id: 'frame_8', url: 'https://i.postimg.cc/wjfcQMkZ/IMG-6573.gif', name: '8' }, { id: 'frame_9', url: 'https://i.postimg.cc/Vv8jkCYr/IMG-6574.gif', name: '9' }, { id: 'frame_10', url: 'https://i.postimg.cc/MZ77rdDy/IMG-6850.gif', name: '10' }, { id: 'frame_11', url: 'https://i.postimg.cc/T3NvqJCZ/IMG-6851.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/28TsrxRV/IMG-6852.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/VkV2bLNw/IMG-6853.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/gJ95NSRB/IMG-6854.gif', name: '14' }, { id: 'frame_cat_ear', url: 'https://i.postimg.cc/d1qsQsbQ/IMG-6855.gif', name: '1' }, { id: 'frame_ribbon', url: 'https://i.postimg.cc/gJNYx9pV/IMG-6856.gif', name: '2' }, { id: 'frame_flower', url: 'https://i.postimg.cc/fyPDvxJk/IMG-6860.gif', name: '3' }, { id: 'frame_tech', url: 'https://i.postimg.cc/QMDsSNxg/IMG-6861.gif', name: '4' }, { id: 'frame_5', url: 'https://i.postimg.cc/vBqsQW7X/IMG-6858.gif', name: '5' }, { id: 'frame_6', url: 'https://i.postimg.cc/Y0vwjhb7/IMG-6857.gif', name: '6' }, { id: 'frame_7', url: 'https://i.postimg.cc/90sH9Cn7/IMG-6868.gif', name: '7' }, { id: 'frame_8', url: 'https://i.postimg.cc/Y2PHZzCC/IMG-6866.gif', name: '8' }, { id: 'frame_9', url: 'https://i.postimg.cc/7Z8yYP7v/IMG-6889.gif', name: '9' }, { id: 'frame_10', url: 'https://i.postimg.cc/nryNzTXK/IMG-6915.gif', name: '10' }, { id: 'frame_11', url: 'https://i.postimg.cc/Qx5dqyJ3/IMG-6917.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/Wbr0JSDD/IMG-5316.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/tgR6wjBP/IMG-5570.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/d0WCKxff/IMG-6932.gif', name: '14' }, { id: 'frame_11', url: 'https://i.postimg.cc/Ss3znzk7/IMG-6934.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/nrm9BcL8/IMG-6941.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/ZYvd1jxf/IMG-6937.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/sDFhySn3/IMG-6936.gif', name: '14' }, { id: 'frame_13', url: 'https://i.postimg.cc/43PhvxRq/IMG-6922.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/3Rb46fRZ/IMG-6923.gif', name: '14' }, { id: 'frame_13', url: 'https://i.postimg.cc/PJppkbvn/IMG-6918.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/XqRZNZ9G/IMG-6916.gif', name: '14' }, { id: 'frame_14', url: 'https://i.postimg.cc/RVt6sRzc/IMG-6939.gif', name: '14' }, { id: 'frame_13', url: 'https://i.postimg.cc/mgGc0HbK/IMG-6926.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/P5zLh5JJ/IMG-6942.gif', name: '14' }, { id: 'frame_14', url: 'https://i.postimg.cc/xCqqKGRN/IMG-6929.gif', name: '14' },
              { id: 'frame_12', url: 'https://i.postimg.cc/7LSRp4hx/e7fa949b9pc84cff0dabe57defceb54c.gif', name: '12' },
            { id: 'frame_13', url: 'https://i.postimg.cc/DZgMwc1H/817178fdbpf2ff7740dc98e26ab78759.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/3NffgJSZ/e09c07034ld7e62266c0a5de6a36ae62.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/vHDNGfT2/35ac7f372v588bf48d4f659077196b85.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/KvVsjjgG/3c3aa5219s18b90187ef1f54b3db7ba8.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/k5P1NHcL/55f3e31d8qbc8a02d152b07b99d31567.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/FFCTCzpy/641bad3b3udc599fdb63ca75fde427e5.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/8k7YSLjK/1689aa46aqc4b9ffc0f970e668f56537.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/J0CZSwyW/IMG-6938.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/Df1qLzDf/IMG-6927.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/CLNkrQSW/IMG-6925.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/y8p9s3Jj/IMG-6919.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/Lsr1Zd3Z/IMG-6928.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/Ssgbv41n/IMG-6876.gif', name: '14' },
        { id: 'frame_14', url: 'https://i.postimg.cc/SNByPrf9/IMG-7005.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/Z5nrCyS5/IMG-7006.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/mDfMXXFP/IMG-7007.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/DZrGtrqB/IMG-7008.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/ZnJNZWHZ/IMG-7009.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/RhGH0vpt/IMG-7010.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/tRzPkzRg/IMG-7012.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/wTTNGs3Q/IMG-7013.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/3JSG5Jv5/IMG-7014.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/rwDr8X1d/IMG-7015.gif', name: '14' },
        { id: 'frame_14', url: 'https://i.postimg.cc/DzDy2vS7/IMG-7017.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/QMVdG9x6/IMG-7016.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/mZ9hgH3J/IMG-7019.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/t4ksHGdg/IMG-7020.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/hP9JpdfT/IMG-7023.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/wTKyXVT9/IMG-7024.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/ZqjKXPSv/IMG-7025.gif', name: '14' },
        
          { id: 'frame_14', url: 'https://i.postimg.cc/gj3Tmqz5/mmexport1751030241029.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/4yCXW52F/mmexport1751030908335.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/VkXngG72/mmexport1751031208329.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/LscBkxZb/mmexport1751017556565.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/1XqzGKwJ/mmexport1751018282681.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/8kHCQwbQ/mmexport1751020645824.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/HWynLK7f/mmexport1751021724230.gif', name: '14' },
        { id: 'frame_14', url: 'https://i.postimg.cc/JnwFp3Kx/mmexport1751031208329.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/HLZNWkQw/mmexport1751031767634.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/vH2X6N1y/mmexport1751032231179.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/NFS4ZyvM/mmexport1751032686953.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/3RpmWc8c/mmexport1751033102811.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/L5RLr3tg/mmexport1751035976943.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/4NCPsp5d/mmexport1751034427637.gif', name: '14' },
        { id: 'frame_14', url: 'https://i.postimg.cc/CMv02LHm/mmexport1751034842120.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/rFnSzWGx/mmexport1751035618517.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/7YRbzN51/mmexport1751036276038.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/cJpbtPWq/mmexport1751036607799.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/HxLV5v92/mmexport1751036977582.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/D01rYy86/mmexport1751037965259.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/J4fwkTLW/mmexport1751038167142.gif', name: '14' },
          
          
        { id: 'frame_14', url: 'https://i.postimg.cc/xjpN4swz/IMG-7240.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/ZnzbGdxX/IMG-7239.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/DyYDmKtw/IMG-7238.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/W40f9qtd/IMG-7098.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/8PsK20jQ/IMG-7236.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/cHsTXDVz/IMG-7235.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/sXwm8Yzg/IMG-7234.gif', name: '14' },
        { id: 'frame_14', url: 'https://i.postimg.cc/xTk5xN49/IMG-7233.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/k5yv6QBv/IMG-7232.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/yx2m4nbs/IMG-7231.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/vZt0fFKn/IMB-r-HMBXY.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/pddJj9zN/IMG-7094.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/rmB17Qbc/IMB-f-VDf-Fc.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/VkKjzYTK/IMB-f4kk-CT.gif', name: '14' },
        { id: 'frame_14', url: 'https://i.postimg.cc/B6KD52vz/IMG-7096.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/9XPwWmwy/IMB-Kf7um-P.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/mrFhKBGz/IMB-e-QWBpa.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/bw4wxW2z/IMB-16r-COL.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/3x0Kx1fz/IMB-K1u-Jp-P.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/CLz0cJ0d/IMG-7116.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/fyyGgW61/IMG-7115.gif', name: '14' },
        { id: 'frame_14', url: 'https://i.postimg.cc/gkk7s0vD/IMG-6984.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/0NpZPgYj/IMG-6985.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/tTWKKmTN/IMG-7073.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/jS8tc9wW/IMG-7083.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/rmRVKJpD/IMG-7087.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/zvWGPjms/IMG-7090.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/YSkqDg8V/IMG-7092.gif', name: '14' },
        { id: 'frame_14', url: 'https://i.postimg.cc/FzqHTBng/IMG-7093.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/tTpZ6wLs/IMG-7095.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/8P5vt8sW/IMG-7097.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/wMxmCZVC/IMG-7099.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/2jxd0FGp/IMG-7100.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/B6T59xGK/IMG-7101.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/kXfcgFRN/IMG-7106.gif', name: '14' },
        { id: 'frame_14', url: 'https://i.postimg.cc/htZppbS4/IMG-7107.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/hPgyjtyn/IMG-7108.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/HLKvs0Kv/IMG-7109.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/wjwbnYkp/IMG-7111.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/bJDMQVkj/IMG-7112.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/SNWBTP5S/IMG-7113.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/jCVMQsKH/IMG-7114.gif', name: '14' },
          
          ];
                // --- 已修正 ---
               // 【核心修復】在 state 物件中初始化 cache 屬性
let state = { chats: {}, activeChatId: null, globalSettings: {}, apiConfig: {}, userStickers: [], worldBooks: [], personaPresets: [], qzoneSettings: {}, activeAlbumId: null, cache: { songs: new Map(), lyrics: new Map() }, ttsCache: new Map() };
                // --- 修正結束 ---
// ▼▼▼ 在 let state = ... 之後，黏貼這個新變數 ▼▼▼
let werewolfGameState = {
    isActive: false,
    gameMode: null, // '6p', '9p', '12p'
    chatId: null, // 如果是從群聊發起的，記錄群聊ID
    players: [], // { id, name, avatar, role, isAlive, character_persona }
    currentDay: 1,
    currentPhase: 'setup', // setup, night, discussion, voting, gameover
    nightActions: {}, // 存儲當晚的行動結果
    gameLog: [], // 存儲遊戲事件日誌
    discussionLog: [], // 存儲討論對話
    voteResults: {},
    electionInfo: {
        candidates: [],
        votes: {}
    },
    sheriffId: null,
    lastFailedAction: null,
};
// ▲▲▲ 新增變數結束 ▲▲▲        
        let thoughtsHistoryRenderCount = 0;
        const THOUGHTS_RENDER_WINDOW = 15; // 每次載入15條歷史記錄
        // ▼▼▼ 在JS頂部，變數定義區，添加這個新變數 ▼▼▼
        // ▼▼▼ 【全新】為動態分頁載入添加的變數 ▼▼▼
        let qzonePostsRenderCount = 0;
        const QZONE_RENDER_WINDOW = 10; // 每次載入10條動態
        // ▲▲▲ 新增代碼結束 ▲▲▲
        let qzonePostsCache = []; // 用於緩存已載入的動態帖子資料
        // ▲▲▲ 添加結束 ▲▲▲
        let musicState = { 
            isActive: false, 
            activeChatId: null, 
            isPlaying: false, 
            playlist: [], 
            currentIndex: -1, 
            playMode: 'order', 
            totalElapsedTime: 0, 
            timerId: null,
            // 【新增】歌詞相關狀態
            parsedLyrics: [],      // 當前歌曲解析後的歌詞陣列
            currentLyricIndex: -1  // 當前高亮的歌詞行索引
        };
        let qzoneStickerPanelState = {
            isOpen: false,
            activePostId: null,
            panelEl: null,
            gridEl: null
        };
                const audioPlayer = document.getElementById('audio-player');
                let newWallpaperBase64 = null;
                let isSelectionMode = false;
let cphoneRenderedCount = 0;
let cphoneActiveConversationType = null; // 用於記錄Cphone中當前打開的對話類型
let isLoadingMoreCphoneMessages = false;
        let activeStickerCategoryId = 'all'; // 用於跟蹤當前選中的表情分類
                let selectedMessages = new Set();
                let editingMemberId = null;
let isAddingNpcToGroup = false; // 用於跟蹤是否正在為群聊創建新NPC
                let editingWorldBookId = null;
               let editingRuleId = null; // 用於存儲正在編輯的規則ID
let isLoadingMoreChats = false; // 防止在載入時重複觸發
let isLoadingMoreMessages = false; // 【全新】為聊天記錄添加獨立的載入狀態
let isLoadingMoreThoughts = false; // 【全新】為心聲歷史添加獨立的載入狀態
let isLoadingMorePosts = false;    // 【全新】為動態清單添加獨立的載入狀態
let sortedChatListItems = [];   // 用於存儲完整的、已排序的聊天列表項
                let editingPersonaPresetId = null;
                let currentReplyContext = null;
        let waimaiTimers = {}; // 用於存儲外賣倒計時
        
        let activeMessageTimestamp = null;
let activeCharacterId = null; // 用於跟蹤當前正在查看的CphoneID
let editingMemoId = null;
let editingDiaryId = null;
let activeDiaryForViewing = null; // 用於暫存當前正在查看的日記物件
        // ▼▼▼ 在下方黏貼新變數 ▼▼▼
        let shoppingCart = []; // 資料結構將變為 [{ productId: 123, quantity: 1 }, ...]
        let editingProductId = null; // 用於存儲正在編輯的商品ID
        let activeProductId = null; // 用於存儲當前查看的商品ID
let selectedProducts = new Set();
        // ▲▲▲ 新增結束 ▲▲▲
        // ▼▼▼ 【全新】為動態評論區回復功能添加的狀態變數 ▼▼▼
        let currentQzoneReplyContext = null; // 用於存儲回復上下文 { postId, replyToName, replyToDisplayName }
        // ▲▲▲ 新增代碼結束 ▲▲▲
        let activePostId = null; // <-- 新增：用於存儲當前操作的動態ID
        let activeDoubanPostId = null;
                let photoViewerState = {
                    isOpen: false,
                    photos: [], // 存儲當前相冊的所有照片URL
                    currentIndex: -1, // 當前正在查看的照片索引
                };
        
                let unreadPostsCount = 0;
        
                let isFavoritesSelectionMode = false;
                let selectedFavorites = new Set()
        
        let simulationIntervalId = null;
        
                const defaultAvatar = 'https://i.postimg.cc/PxZrFFFL/o-o-1.jpg';
                const defaultMyGroupAvatar = 'https://i.postimg.cc/cLPP10Vm/4.jpg';
                const defaultGroupMemberAvatar = 'https://i.postimg.cc/VkQfgzGJ/1.jpg';
                const defaultGroupAvatar = 'https://i.postimg.cc/gc3QYCDy/1-NINE7-Five.jpg';
                let notificationTimeout;
                let ruleCache = {}; // 用於緩存渲染規則
// 在你的JS頂部變數定義區，添加這個新常量
const DEFAULT_NOTIFICATION_SOUND = 'https://www.myinstants.com/media/sounds/notification-sound-2.mp3'; // 默認的微信提示音
        // ▼▼▼ 在JS頂部，變數定義區，添加這個新變數 ▼▼▼
        let gomokuState = {}; // 用於存儲每個聊天的五子棋狀態
let readingState = {}; // { chatId: { isActive, isMinimized, title, ... } }
        let originalChatMessagesPaddingTop = null; // 用於存儲消息區的原始頂部內邊距
        
        // ▲▲▲ 新增代碼結束 ▲▲▲
// ▼▼▼ 【請用這個 V2 版本】替換舊的 DEFAULT_APP_ICONS 常量 ▼▼▼
        const DEFAULT_APP_ICONS = {
            'qq': 'https://i.postimg.cc/MTC3Tkw8/IMG-6436.jpg',
            'world-book': 'https://i.postimg.cc/HWf1JKzn/IMG-6435.jpg',
            'wallpaper': 'https://i.postimg.cc/T1j03pQr/IMG-6440.jpg',
            'renderer': 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1756312261242_qdqqd_g0eriz.jpeg',
            'api-settings': 'https://i.postimg.cc/MK8rJ8t7/IMG-6438.jpg',
            'font': 'https://i.postimg.cc/pXxk1JXk/IMG-6442.jpg',
            // 【核心新增】將Cphone(Cphone)和豆瓣也加入管理列表
            'char-phone': 'https://i.postimg.cc/pXj9h20L/IMG-7275.jpg',
            'douban': 'https://i.postimg.cc/Pq2xJN1g/IMG-7301.jpg',
    // 【【【核心新增：在這裡為“預設”App註冊一個唯一的ID和預設圖示】】】
    'preset': 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1758510900942_qdqqd_djw0z2.jpeg',
            // ▼▼▼ 在這裡添加新的一行 ▼▼▼
            'tutorial': 'https://i.postimg.cc/d10GjC4g/IMG-7302.jpg',
    'werewolf': 'https://i.postimg.cc/k401K5g7/IMG-7304.jpg',
    // ▼▼▼ 在這裡添加新的一行 ▼▼▼
    'x': 'https://i.postimg.cc/Y9d3BztC/1.png'
        };
        // ▲▲▲ 替換結束 ▲▲▲
        // ▼▼▼ 【全新】這是為CPhone圖示設置新增的常量 ▼▼▼
        const DEFAULT_CPHONE_ICONS = {
            'qq': 'https://i.postimg.cc/MTC3Tkw8/IMG-6436.jpg',
            'album': 'https://i.postimg.cc/HWf1JKzn/IMG-6435.jpg',
            'browser': 'https://i.postimg.cc/KzC2gTq6/IMG-7276.jpg',
            'taobao': 'https://i.postimg.cc/L6R7x16R/IMG-7278.jpg',
            'memo': 'https://i.postimg.cc/J0b6Nym4/IMG-7279.jpg',
            'diary': 'https://i.postimg.cc/DZ541sbt/IMG-7280.jpg',
            'amap': 'https://i.postimg.cc/Jz2Tz0dw/IMG-7281.jpg',
            'usage': 'https://i.postimg.cc/WbF8kzz9/IMG-7282.jpg',
            'music': 'https://is1-ssl.mzstatic.com/image/thumb/Purple112/v4/64/9d/21/649d21e8-a151-6136-3914-256e54f15d9a/AppIcon-0-0-1x_U007emarketing-0-0-0-7-0-0-sRGB-0-0-0-GLES2_U002c0-512MB-85-220-0-0.png/1200x630wa.png',
            'ephone': 'https://i.postimg.cc/pXj9h20L/IMG-7275.jpg'
        };
        // ▲▲▲ 新增代碼結束 ▲▲▲
        let repostTargetId = null; // 用於存儲當前要轉發的動態ID
                const STICKER_REGEX = /(^https:\/\/i\.postimg\.cc\/.+|^https:\/\/files\.catbox\.moe\/.+|^https?:\/\/sharkpan\.xyz\/.+|^data:image|\.(png|jpg|jpeg|gif|webp)\?.*$|\.(png|jpg|jpeg|gif|webp)$)/i;
                
                let currentRenderedCount = 0;
                let lastKnownBatteryLevel = 1;
                let alertFlags = { hasShown40: false, hasShown20: false, hasShown10: false };
                let batteryAlertTimeout;
                const dynamicFontStyle = document.createElement('style');
                dynamicFontStyle.id = 'dynamic-font-style';
                document.head.appendChild(dynamicFontStyle);
        
                const modalOverlay = document.getElementById('custom-modal-overlay');
                const modalTitle = document.getElementById('custom-modal-title');
                const modalBody = document.getElementById('custom-modal-body');
                const modalConfirmBtn = document.getElementById('custom-modal-confirm');
                const modalCancelBtn = document.getElementById('custom-modal-cancel');
                let modalResolve;
        
                function showCustomModal() { 
                    modalOverlay.classList.add('visible'); 
                }
        
                function hideCustomModal() { 
                    modalOverlay.classList.remove('visible'); 
                    modalConfirmBtn.classList.remove('btn-danger'); 
                    if (modalResolve) modalResolve(null); 
                }
        /**
         * 【全新】根據保存的設置，應用歌詞欄的CSS樣式
         * @param {object} chat - 當前的聊天物件
         */
        function applyLyricsBarPosition(chat) {
            const lyricsBar = document.getElementById('global-lyrics-bar');
            // 如果聊天沒有設置，則使用預設值
            const settings = chat.settings.lyricsPosition || { vertical: 'top', horizontal: 'center', offset: 10 };
            
            // 重置所有可能影響位置的屬性
            lyricsBar.style.top = 'auto';
            lyricsBar.style.bottom = 'auto';
            lyricsBar.style.left = 'auto';
            lyricsBar.style.right = 'auto';
            lyricsBar.style.transform = 'none';
        
            // 1. 設置垂直位置和偏移量
            if (settings.vertical === 'top') {
                lyricsBar.style.top = `${settings.offset}px`;
            } else { // 'bottom'
                lyricsBar.style.bottom = `${settings.offset}px`;
            }
            
            // 2. 設置水準對齊
            switch (settings.horizontal) {
                case 'left':
                    lyricsBar.style.left = '15px'; // 留出一些邊距
                    break;
                case 'right':
                    lyricsBar.style.right = '15px'; // 留出一些邊距
                    break;
                case 'center':
                default:
                    lyricsBar.style.left = '50%';
                    lyricsBar.style.transform = 'translateX(-50%)';
                    break;
            }
        }
        // ▼▼▼ 把這個【全新的函數】黏貼到你的JS功能函式定義區 ▼▼▼
        // ▼▼▼ 【全新】本地上傳群頭像並由副API識別的核心功能 ▼▼▼
        
        /**
         * 【全新】處理用戶從本地上傳群頭像的流程
         * @param {Event} event - 檔輸入框的 change 事件物件
         */
        async function handleLocalGroupAvatarUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
        
            // 1. 讀取文件為 Base64
            const base64Url = await new Promise(resolve => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.readAsDataURL(file);
            });
        
            // 2. 彈出提示，開始識圖
            await showCustomAlert("請稍候...", "正在請求AI為新群頭像命名...");
        
            try {
                // 3. 調用通用的API識圖函數獲取描述
                const description = await getAvatarDescriptionFromApi(base64Url);
                
                if (!description) {
                    throw new Error("AI未能成功描述圖片。");
                }
        
                // 4. 將描述作為名字，和圖片URL一起存入群頭像庫
                const chat = state.chats[state.activeChatId];
                if (!chat.settings.groupAvatarLibrary) {
                    chat.settings.groupAvatarLibrary = [];
                }
                chat.settings.groupAvatarLibrary.push({ name: description, url: base64Url });
                
                // 5. 保存並刷新
                await db.chats.put(chat);
                renderGroupAvatarLibrary();
                await showCustomAlert("上傳成功！", `AI已將新群頭像命名為：“${description}”`);
        
            } catch (error) {
                console.error("本地群頭像上傳及識別失敗:", error);
                await showCustomAlert("操作失敗", `無法為頭像命名，請檢查（主/副）API配置是否正確並支援Vision。\n錯誤: ${error.message}`);
            } finally {
                // 無論成功與否，都清空檔輸入框
                event.target.value = null;
            }
        }
        // ▲▲▲ 全新功能函數黏貼結束 ▲▲▲
        // ▼▼▼ 【全新】本地上傳頭像並由副API識別的核心功能 ▼▼▼
        
        /**
         * 【全新】處理用戶從本地上傳頭像的流程
         * @param {Event} event - 檔輸入框的 change 事件物件
         */
        async function handleLocalAvatarUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
        
            // 1. 讀取檔為 Base64，這是發送給API和存儲的必要格式
            const base64Url = await new Promise(resolve => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.readAsDataURL(file);
            });
        
            // 2. 彈出提示，開始識圖
            await showCustomAlert("請稍候...", "正在請求AI為新頭像命名...");
        
            try {
                // 3. 調用API獲取圖片描述（這個描述將作為頭像的名字）
                const description = await getAvatarDescriptionFromApi(base64Url);
                
                if (!description) {
                    throw new Error("AI未能成功描述圖片。");
                }
        
                // 4. 將描述作為名字，和圖片URL一起存入頭像庫
                const chat = state.chats[state.activeChatId];
                if (!chat.settings.aiAvatarLibrary) {
                    chat.settings.aiAvatarLibrary = [];
                }
                chat.settings.aiAvatarLibrary.push({ name: description, url: base64Url });
                
                // 5. 保存並刷新
                await db.chats.put(chat);
                renderAiAvatarLibrary();
                await showCustomAlert("上傳成功！", `AI已將新頭像命名為：“${description}”`);
        
            } catch (error) {
                console.error("本地頭像上傳及識別失敗:", error);
                await showCustomAlert("操作失敗", `無法為頭像命名，請檢查（主/副）API配置是否正確並支援Vision。\n錯誤: ${error.message}`);
            } finally {
                // 無論成功與否，都清空檔輸入框，以便下次能選擇同一個檔
                event.target.value = null;
            }
        }
        
        /**
         * 【全新】調用（副）API來獲取圖片的描述
         * @param {string} base64Url - 圖片的 Base64 Data URL
         * @returns {Promise<string>} - 返回AI生成的圖片描述
         */
        async function getAvatarDescriptionFromApi(base64Url) {
            // 智能選擇API：優先使用副API，如果未配置則自動回退到主API
            const useSecondaryApi = state.apiConfig.secondaryProxyUrl && state.apiConfig.secondaryApiKey && state.apiConfig.secondaryModel;
            const { proxyUrl, apiKey, model } = useSecondaryApi 
                ? { proxyUrl: state.apiConfig.secondaryProxyUrl, apiKey: state.apiConfig.secondaryApiKey, model: state.apiConfig.secondaryModel }
                : state.apiConfig;
        
            if (!proxyUrl || !apiKey || !model) {
                throw new Error("主API和副API均未配置或配置不完整。");
            }
        
            const prompt = "請為這張圖片起一個簡潔的、適合作為頭像庫標籤的名字。例如：“微笑自拍”、“陽光下的貓咪”、“藍發動漫少女”。請直接回答名字，不要加任何多餘的解釋。";
            
            let isGemini = proxyUrl.includes('generativelanguage');
            let response;
        
            if (isGemini) {
                const mimeType = base64Url.match(/^data:(.*);base64/)[1];
                const base64Data = base64Url.split(',')[1];
                const payload = {
                    contents: [{
                        parts: [
                            { text: prompt },
                            { inline_data: { mime_type: mimeType, data: base64Data } }
                        ]
                    }]
                };
                response = await fetch(`${proxyUrl}/${model}:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
        
            } else { // OpenAI 相容 Vision API
                const payload = {
                    model: model,
                    messages: [{
                        role: 'user',
                        content: [
                            { type: 'text', text: prompt },
                            { type: 'image_url', image_url: { url: base64Url } }
                        ]
                    }],
                    max_tokens: 50 // 限制輸出長度
                };
                response = await fetch(`${proxyUrl}/v1/chat/completions`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                    body: JSON.stringify(payload)
                });
            }
        
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`API 錯誤: ${errorData.error.message}`);
            }
        
            const data = await response.json();
            let description = isGemini ? getGeminiResponseText(data) : data.choices[0].message.content;
            
            // 清理AI可能返回的多餘字元
            return description.trim().replace(/["'“”‘’]/g, '');
        }
        // ▲▲▲ 全新功能函數黏貼結束 ▲▲▲
        /**
         * 【全新】當單聊角色的名稱被修改後，自動同步其在所有群聊中的資訊
         * @param {object} characterChat - 被修改了名稱的【單聊】chat對象
         */
        async function syncCharacterNameInGroups(characterChat) {
            // 1. 安全檢查：確保傳入的是一個有效的單聊物件
            if (!characterChat || characterChat.isGroup) {
                console.warn("syncCharacterNameInGroups: 傳入的不是有效的單聊對象，已跳過同步。");
                return;
            }
        
            const characterId = characterChat.id;
            const newRemarkName = characterChat.name;        // 這是角色新的【備註名】
            const newOriginalName = characterChat.originalName;  // 這是角色新的【本名】
        
            console.log(`正在為角色 ${characterId} 同步所有群聊內的名稱資訊...`);
        
            // 2. 遍歷記憶體中所有的聊天記錄，找出所有群聊
            for (const chatId in state.chats) {
                const groupChat = state.chats[chatId];
                
                // 3. 篩選出群聊，並確保它有成員列表
                if (groupChat.isGroup && groupChat.members) {
                    // 4. 在群聊中查找對應的成員
                    const memberToUpdate = groupChat.members.find(m => m.id === characterId);
        
                    // 如果在這個群裡找到了該成員
                    if (memberToUpdate) {
                        let needsDbUpdate = false; // 標記是否需要更新資料庫，以優化性能
                        
                        // 5. 對比並更新群內昵稱 (groupNickname)，它應該與單聊的備註名(name)保持一致
                        if (memberToUpdate.groupNickname !== newRemarkName) {
                            memberToUpdate.groupNickname = newRemarkName;
                            needsDbUpdate = true;
                        }
        
                        // 6. 對比並更新群內的本名 (originalName)
                        if (memberToUpdate.originalName !== newOriginalName) {
                            memberToUpdate.originalName = newOriginalName;
                            needsDbUpdate = true;
                        }
        
                        // 7. 如果有任何更新，就把這個【整個群聊物件】也保存回資料庫
                        if (needsDbUpdate) {
                            await db.chats.put(groupChat);
                            console.log(`成功將群聊 "${groupChat.name}" 中的成員資訊更新`);
                        }
                    }
                }
            }
        }
        
        
        // ▲▲▲ 新函數黏貼結束 ▲▲▲
        
        // ▼▼▼ 【全新】請將這個全新的函數黏貼到 syncCharacterNameInGroups 的下方 ▼▼▼
        /**
         * 【全新】當單聊角色的頭像被修改後，自動同步其在所有群聊中的頭像資訊
         * @param {object} characterChat - 被修改了頭像的【單聊】chat對象
         */
        async function syncCharacterAvatarInGroups(characterChat) {
            // 1. 安全檢查，確保是有效的單聊物件
            if (!characterChat || characterChat.isGroup) {
                console.warn("syncCharacterAvatarInGroups: 傳入的不是有效的單聊對象，已跳過同步。");
                return;
            }
        
            const characterId = characterChat.id;
            const newAvatar = characterChat.settings.aiAvatar; // 獲取最新的頭像URL
        
            console.log(`正在為角色 ${characterId} 同步所有群聊內的頭像...`);
        
            // 2. 遍歷所有聊天，找出所有群聊
            for (const groupChat of Object.values(state.chats)) {
                if (groupChat.isGroup && groupChat.members) {
                    // 3. 在群聊中查找對應的成員
                    const memberToUpdate = groupChat.members.find(m => m.id === characterId);
                    
                    // 4. 如果找到了該成員，並且頭像資訊不一致，就更新它
                    if (memberToUpdate && memberToUpdate.avatar !== newAvatar) {
                        memberToUpdate.avatar = newAvatar; // 將新頭像同步到群成員資料中
                        
                        // 5. 【至關重要】將修改後的【整個群聊物件】存回資料庫
                        await db.chats.put(groupChat);
                        console.log(`成功將角色 ${characterId} 的新頭像同步到群聊 "${groupChat.name}"`);
                    }
                }
            }
        }
        // ▲▲▲ 新函數黏貼結束 ▲▲▲
        // ▼▼▼ 【最終修復版】請用這個全新的、更智慧的函數，完整替換舊的 getDisplayNameInGroup 函數 ▼▼▼
        /**
         * 【全新 | 已修復使用者識別問題】根據角色本名，在指定群聊中獲取其正確的顯示名稱（群昵稱）
         * @param {object} groupChat - 當前的群聊物件
         * @param {string} originalName - 角色的本名 (e.g., "小可愛", "方亦楷")
         * @returns {string} - 該角色在此群聊中的群昵稱，如果找不到則返回其本名
         */
        function getDisplayNameInGroup(groupChat, originalName) {
            // 安全檢查，如果資訊不全則直接返回
            if (!groupChat || !groupChat.isGroup || !originalName) {
                return originalName;
            }
        
            // --- 【【【核心修復就在這裡！】】】 ---
        
            // 步驟1：優先檢查這個“本名”是不是【用戶自己】的全域本名
            // 使用者的全域本名存儲在 qzoneSettings.nickname 中
            const userOriginalName = state.qzoneSettings.nickname || '{{user}}';
            if (originalName === userOriginalName) {
                // 如果是用戶，就返回用戶在【這個群聊中】的專屬昵稱
                return groupChat.settings.myNickname || '我';
            }
        
            // 步驟2：如果不是用戶，再到群成員列表裡去查找對應的AI角色
            const member = groupChat.members.find(m => m.originalName === originalName);
            
            // 步驟3：如果找到了AI成員，就返回TA的群昵稱；如果都找不到，就返回原始名字作為保底
            return member ? member.groupNickname : originalName;
        }
        // ▲▲▲ 替換結束 ▲▲▲
        // ▼▼▼ 【全新】請將這個函數黏貼到JS功能函式定義區 ▼▼▼
        
        /**
         * 【全新】切換渲染規則的分類頁簽
         * @param {string} categoryId - 要切換到的分類ID ('global' 或 聊天ID)
         */
        function switchRuleCategory(categoryId) {
            // 切換頁簽的啟動狀態
            document.querySelectorAll('.rules-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.categoryId === categoryId);
            });
            // 切換內容面板的顯示狀態
            document.querySelectorAll('.rules-category-pane').forEach(pane => {
                pane.classList.toggle('active', pane.dataset.categoryId === categoryId);
            });
        }
        // ▲▲▲ 新函數黏貼結束 ▲▲▲
        // ▼▼▼ 【全新】請將這個函數黏貼到JS功能函式定義區 ▼▼▼
        /**
         * 【全新】根據角色的本名，在整個應用中查找其正確的顯示名稱
         * @param {string} originalName - 角色的本名 (e.g., "李星辰")
         * @returns {string} - 該角色的備註名/群昵稱/用戶昵稱，如果找不到則返回其本名
         */
        // ▼▼▼ 請用這個【全新、更智慧】的函數，完整替換舊的 getDisplayNameByOriginalName 函數 ▼▼▼
        
        /**
         * 【全新】根據角色的本名或曾用名，在整個應用中查找其正確的【當前顯示名稱】
         * @param {string} nameIdentifier - 角色的本名 或 儲存在舊資料中的曾用名
         * @returns {string} - 該角色的【當前】備註名/群昵稱/用戶昵稱，如果找不到則返回傳入的識別字
         */
        function getDisplayNameByOriginalName(nameIdentifier) {
            // 1. 如果傳入的是空值，直接返回
            if (!nameIdentifier) return '';
        
            // 2. 檢查是不是用戶自己
            if (state.qzoneSettings && nameIdentifier === state.qzoneSettings.nickname) {
                return state.qzoneSettings.nickname;
            }
            
            // 3. 【主要查找方式】: 通過“本名” (originalName) 查找。
            // 這是最標準、最可靠的方式，適用於所有新創建的資料。
            let characterChat = Object.values(state.chats).find(chat => !chat.isGroup && chat.originalName === nameIdentifier);
            if (characterChat) {
                return characterChat.name; // 如果找到，返回該角色【當前】的備註名
            }
        
            // 4. 【相容舊資料】: 如果通過“本名”沒找到，就嘗試把傳入的名字當作一個【舊的備註名】去歷史記錄裡查找。
            characterChat = Object.values(state.chats).find(chat => 
                !chat.isGroup && 
                (chat.nameHistory && chat.nameHistory.includes(nameIdentifier))
            );
            if (characterChat) {
                return characterChat.name; // 如果在歷史記錄裡找到了，同樣返回該角色【當前】的備註名
            }
        
            // 5. 【最終備用方案】: 如果以上方法都找不到，說明這可能是一個非常舊的資料，或者角色已被刪除。
            // 此時，直接返回儲存在評論裡的那個名字，至少能保證有內容顯示。
            return nameIdentifier;
        }
        // ▲▲▲ 替換結束 ▲▲▲
        
        // ▼▼▼ 請用這個【全新的、更智慧的】函數，完整替換舊的 processMentions 函數 ▼▼▼
        
        /**
         * 【全新】處理AI生成的文本，將特殊的@預留位置替換為正確的顯示名稱
         * @param {string} text - AI生成的、可能包含 @[[本名]] 預留位置的原始文本
         * @param {object|null} chat - 當前的聊天物件 (如果是群聊，則用於查找群昵稱)
         * @returns {string} - 處理完成後，對使用者友好的顯示文本
         */
        function processMentions(text, chat = null) {
            // 如果文本無效或不包含@標記，直接返回以提高性能
            if (!text || typeof text !== 'string' || !text.includes('@[[')) {
                return text; 
            }
            
            // 使用規則運算式的全域匹配，一次性處理所有@提及
            return text.replace(/@\[\[([^\]]+)\]\]/g, (match, originalName) => {
                const trimmedOriginalName = originalName.trim();
                let displayName;
                
                // 【核心邏輯】如果提供了聊天物件，並且是群聊
                if (chat && chat.isGroup) {
                    // 就調用我們現有的、強大的 getDisplayNameInGroup 函數
                    // 這個函數會自動優先查找群昵稱，找不到再用本名
                    displayName = getDisplayNameInGroup(chat, trimmedOriginalName);
                } else {
                    // 如果是私聊或沒有提供聊天物件，就使用全域查找函數
                    displayName = getDisplayNameByOriginalName(trimmedOriginalName);
                }
                
                // 返回轉換後的、帶@的正確昵稱
                return `@${displayName}`;
            });
        }
        // ▲▲▲ 替換結束 ▲▲▲
        
        // ▼▼▼ 請用這個【修正後】的完整函數，替換掉您現有的 showCustomConfirm 函數 ▼▼▼
        
        function showCustomConfirm(title, message, options = {}) {
            return new Promise(resolve => {
                modalResolve = resolve;
                modalTitle.textContent = title;
                modalBody.innerHTML = `<p>${message}</p>`;
        
                // 【核心修正】在函數被調用時，重新獲取最新的按鈕元素
                const confirmBtn = document.getElementById('custom-modal-confirm');
                const cancelBtn = document.getElementById('custom-modal-cancel');
        
                cancelBtn.style.display = 'block';
        
                confirmBtn.textContent = options.confirmText || '確定';
                cancelBtn.textContent = options.cancelText || '取消';
        
                if (options.confirmButtonClass) {
                    confirmBtn.classList.add(options.confirmButtonClass);
                } else {
                    // 確保之前的危險操作樣式被移除
                    confirmBtn.classList.remove('btn-danger');
                }
        
                // 為最新的按鈕綁定本次的點擊事件
                confirmBtn.onclick = () => { resolve(true); hideCustomModal(); };
                cancelBtn.onclick = () => { resolve(false); hideCustomModal(); };
                showCustomModal();
            });
        }
        // ▲▲▲ 替換結束 ▲▲▲
        
function showCustomAlert(title, message) {
    return new Promise(resolve => {
        modalResolve = resolve;
        modalTitle.textContent = title;
        modalBody.innerHTML =`<p style="text-align: left; white-space: pre-wrap;">${message}</p>`;

        // 核心修正：在函數被調用時，重新獲取最新的按鈕元素
        const confirmBtn = document.getElementById('custom-modal-confirm');
        const cancelBtn = document.getElementById('custom-modal-cancel');

        cancelBtn.style.display = 'none';
        confirmBtn.textContent = '好的';

        confirmBtn.onclick = () => {
            cancelBtn.style.display = 'block'; 
            confirmBtn.textContent = '確定';
            resolve(true); 
            hideCustomModal();
        };
        showCustomModal();
    });
}
        
        // ▼▼▼ 請用這個【修正後】的完整函數，替換掉您現有的 showCustomPrompt 函數 ▼▼▼
        
        function showCustomPrompt(title, placeholder, initialValue = '', type = 'text', extraHtml = '') {
            return new Promise(resolve => {
                modalResolve = resolve;
                modalTitle.textContent = title;
                const inputId = 'custom-prompt-input';
                
                const inputHtml = type === 'textarea' 
                    ? `<textarea id="${inputId}" placeholder="${placeholder}" rows="4" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #ccc; font-size: 16px; box-sizing: border-box; resize: vertical;">${initialValue}</textarea>`
                    : `<input type="${type}" id="${inputId}" placeholder="${placeholder}" value="${initialValue}">`;
                
                modalBody.innerHTML = extraHtml + inputHtml;
                const input = document.getElementById(inputId);
        
                modalBody.querySelectorAll('.format-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const templateStr = btn.dataset.template;
                        if (templateStr) {
                            try {
                                const templateObj = JSON.parse(templateStr);
                                input.value = JSON.stringify(templateObj, null, 2);
                                input.focus();
                            } catch(e) { console.error("解析格式範本失敗:", e); }
                        }
                    });
                });
                
                // 【核心修正】在函數被調用時，重新獲取最新的按鈕元素
                const confirmBtn = document.getElementById('custom-modal-confirm');
                const cancelBtn = document.getElementById('custom-modal-cancel');
                
                // 為最新的按鈕綁定本次的點擊事件
                confirmBtn.onclick = () => { resolve(input.value); hideCustomModal(); };
                cancelBtn.onclick = () => { resolve(null); hideCustomModal(); };
        
                showCustomModal();
                setTimeout(() => input.focus(), 100);
            });
        }
        // ▲▲▲ 替換結束 ▲▲▲
        // ▼▼▼ 請將這段【全新】的函數代碼黏貼到 showCustomPrompt 函數的後面 ▼▼▼
        
        // ▼▼▼ 【最終修復版】請用這個全新的、更健壯的函數，完整替換舊的 showChoiceModal ▼▼▼
        /**
         * 【已修復】顯示一個包含多個選項的操作功能表模態框
         * @param {string} title - 模態框的標題
         * @param {Array<object>} options - 按鈕選項陣列, e.g., [{ text: '按鈕文字', value: '返回值' }]
         * @returns {Promise<string|null>} - 返回使用者點擊按鈕的value，如果取消則返回null
         */
        function showChoiceModal(title, options) {
            return new Promise(resolve => {
                const modal = document.getElementById('custom-modal-overlay');
                const modalTitle = document.getElementById('custom-modal-title');
                const modalBody = document.getElementById('custom-modal-body');
                const modalFooter = document.querySelector('#custom-modal .custom-modal-footer');
        
                // 1. 設置標題和清空內容區
                modalTitle.textContent = title;
                modalBody.innerHTML = ''; 
                
                // 2. 動態創建選項按鈕
                modalFooter.innerHTML = ''; 
                modalFooter.style.flexDirection = 'column';
        
                options.forEach(option => {
                    const button = document.createElement('button');
                    button.textContent = option.text;
                    button.onclick = () => {
                        // 注意：這裡我們不再調用 hideCustomModal，而是直接控制
                        modal.classList.remove('visible');
                        resolve(option.value);
                    };
                    modalFooter.appendChild(button);
                });
        
                // 3. 添加一個標準的取消按鈕
                const cancelButton = document.createElement('button');
                cancelButton.textContent = '取消';
                cancelButton.style.marginTop = '8px';
                cancelButton.style.borderRadius = '8px';
                cancelButton.style.backgroundColor = '#f0f0f0';
                cancelButton.onclick = () => {
                    modal.classList.remove('visible');
                    resolve(null); // 用戶取消，返回 null
                };
                modalFooter.appendChild(cancelButton);
        
                // 4. 顯示模態框
                modal.classList.add('visible');
        
            }).finally(() => {
                // 5. 【【【這就是最關鍵的修復！】】】
                // 無論使用者是選擇了選項還是取消，最後都【必須】將模態框的頁腳恢復為原始的、功能完整的狀態。
                const modalFooter = document.querySelector('#custom-modal .custom-modal-footer');
        
                modalFooter.style.flexDirection = 'row'; // 恢復水準佈局
                // 重新創建原始的“取消”和“確定”按鈕
                modalFooter.innerHTML = `
                    <button id="custom-modal-cancel">取消</button>
                    <button id="custom-modal-confirm" class="confirm-btn">確定</button>
                `;
        
                // 【重要】為新創建的按鈕重新綁定它們最基本的默認事件！
                document.getElementById('custom-modal-cancel').addEventListener('click', hideCustomModal);
                // 注意：我們不需要為“確定”按鈕綁定預設事件，因為 showCustomConfirm 和 showCustomPrompt 
                // 每次調用時都會為它動態繫結新的 onclick 事件，這正是我們想要的行為。
            });
        }
        // ▲▲▲ 替換結束 ▲▲▲
        // ▼▼▼ 請將這個【全新】的函數黏貼到 showChoiceModal 函數的後面 ▼▼▼
        
        /**
         * 【全新】獲取歌詞內容（支援檔和黏貼，並修復黏貼格式）
         * @returns {Promise<string|null>} 返回歌詞文本字串，如果使用者取消則返回null
         */
        async function getLrcContent() {
            // 1. 彈出選擇框
            const choice = await showChoiceModal('選擇歌詞導入方式', [
                { text: '📁 從本地檔 (.lrc)', value: 'file' },
                { text: '📋 直接黏貼歌詞文本', value: 'paste' }
            ]);
        
            // 2. 根據使用者的選擇執行不同操作
            if (choice === 'file') {
                // 用戶選擇檔：這部分邏輯不變，它工作正常
                return new Promise(resolve => {
                    const lrcInput = document.getElementById('lrc-upload-input');
                    const lrcChangeHandler = (e) => {
                        const lrcFile = e.target.files[0];
                        if (lrcFile) {
                            const reader = new FileReader();
                            reader.onload = (readEvent) => resolve(readEvent.target.result);
                            reader.onerror = () => resolve(""); // 出錯時返回空字串
                            reader.readAsText(lrcFile);
                        } else {
                            resolve(null); // 用戶關閉了檔選擇框
                        }
                        lrcInput.removeEventListener('change', lrcChangeHandler);
                        lrcInput.value = ''; // 重置input，以便下次能選擇同名檔
                    };
                    lrcInput.addEventListener('change', lrcChangeHandler, { once: true });
                    lrcInput.click();
                });
            } else if (choice === 'paste') {
                // 用戶選擇黏貼：彈出文本輸入框
                const pastedText = await showCustomPrompt(
                    '黏貼歌詞',
                    '請在此處黏貼完整的LRC格式歌詞...',
                    '',
                    'textarea' // 使用多行文字方塊
                );
                
                // --- ★★★ 核心修復就在這裡 ★★★ ---
                if (pastedText) {
                    // 在解析之前，自動為每個時間戳記前添加分行符號
                    // 這會修復單行黏貼的問題
                    const formattedText = pastedText.replace(/\[/g, '\n[').trim();
                    return formattedText;
                }
                return pastedText; // 如果用戶取消，這裡會返回 null
                // --- ★★★ 修復結束 ★★★ ---
        
            } else {
                // 用戶點擊了“取消”
                return null;
            }
        }
        // ▲▲▲ 新函數黏貼結束 ▲▲▲
                // ===================================================================
                // 2. 資料庫結構定義
                // ===================================================================
        
        // ▼▼▼ 【請用這個 V30 版本】完整替換舊的 db.version(...) 代碼塊 ▼▼▼
        db.version(39).stores({ 
            doubanPosts: '++id, timestamp',
           chats: '&id, isGroup, groupId, isPinned, memos, diary, appUsageLog, lastIntelligentSummaryTimestamp',
           apiConfig: '&id, minimaxGroupId, minimaxApiKey',
            globalSettings: '&id', 
            userStickers: '&id, url, name, categoryId',
            worldBooks: '&id, name, categoryId',
            worldBookCategories: '++id, name',
            musicLibrary: '&id', 
            personaPresets: '&id',
            qzoneSettings: '&id',
            qzonePosts: '++id, timestamp, authorId',
            qzoneAlbums: '++id, name, createdAt',
            qzonePhotos: '++id, albumId',
            favorites: '++id, type, timestamp, originalTimestamp',
            qzoneGroups: '++id, name',
            memories: '++id, chatId, timestamp, type, targetDate',
            callRecords: '++id, chatId, timestamp, customName',
            shoppingProducts: '++id, name, description',
            shoppingCategories: '++id, name',
            apiPresets: '++id, name',
            renderingRules: '++id, name, chatId',
            appearancePresets: '++id, name, type',
            stickerCategories: '++id, name',
            customAvatarFrames: '++id, name',
            presets: '&id, name, categoryId', // 新增：預設主表
            presetCategories: '++id, name',
    readingLibrary: '++id, title, lastOpened', // 新增：書籍庫
            // 【核心修改】為NPC表添加後臺活動、冷卻時間和最後行動時間戳記欄位
            npcs: '++id, name, enableBackgroundActivity, actionCooldownMinutes, lastActionTimestamp'  
        }).upgrade(tx => {
            // 這個升級函數會自動處理資料移轉
            return tx.table('worldBooks').toCollection().modify(book => {
                // 確保 content 欄位是陣列
                if (typeof book.content === 'string' && book.content.trim() !== '') {
                    book.content = [{
                        keys: [],
                        comment: '從舊版本遷移的條目',
                        content: book.content
                    }];
                } else if (!Array.isArray(book.content)) {
                    book.content = [];
                }

                // 【核心修改】為所有條目添加 enabled 屬性，預設為 true
                book.content.forEach(entry => {
                    if (typeof entry.enabled === 'undefined') {
                        entry.enabled = true;
                    }
                });
            });
        });
        // ▲▲▲ 替換結束 ▲▲▲
window.db = db;        
                // ===================================================================
                // 3. 所有功能函式定義
                // ===================================================================
        
                function showScreen(screenId) {
                    if (screenId === 'chat-list-screen') {
                        window.renderChatListProxy(); 
                        switchToChatListView('messages-view');
                    }
                    if (screenId === 'api-settings-screen') window.renderApiSettingsProxy();
                    if (screenId === 'wallpaper-screen') window.renderWallpaperScreenProxy();
                    if (screenId === 'world-book-screen') window.renderWorldBookScreenProxy();
                    if (screenId === 'x-social-screen') window.renderXSocialScreenProxy();
                     if (screenId === 'douban-screen') renderDoubanScreen();
                    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
                    const screenToShow = document.getElementById(screenId);
                    if (screenToShow) screenToShow.classList.add('active');
                    if (screenId === 'chat-interface-screen') window.updateListenTogetherIconProxy(state.activeChatId);
                    if (screenId === 'font-settings-screen') {
            loadFontPresetsDropdown(); // <-- 新增這一行
                        document.getElementById('font-url-input').value = state.globalSettings.fontUrl || '';
                        applyCustomFont(state.globalSettings.fontUrl || '', true);
                    }
                }
                window.updateListenTogetherIconProxy = () => {};
        
                function switchToChatListView(viewId) {
                    const chatListScreen = document.getElementById('chat-list-screen');
                    const views = {
                        'messages-view': document.getElementById('messages-view'),
                        'qzone-screen': document.getElementById('qzone-screen'),
                        'favorites-view': document.getElementById('favorites-view'),
                'memories-view': document.getElementById('memories-view'),
               'npc-list-view': document.getElementById('npc-list-view')
            };
                    const mainHeader = document.getElementById('main-chat-list-header');
                    const mainBottomNav = document.getElementById('chat-list-bottom-nav'); // 獲取主巡覽列
        
                    if (isFavoritesSelectionMode) {
                        document.getElementById('favorites-edit-btn').click(); 
                    }
        
                    // 隱藏所有視圖
                    Object.values(views).forEach(v => v.classList.remove('active'));
                    // 顯示目標視圖
                    if (views[viewId]) {
                        views[viewId].classList.add('active');
                    }
        
                    // 更新底部巡覽列高亮
                    document.querySelectorAll('#chat-list-bottom-nav .nav-item').forEach(item => {
                        item.classList.toggle('active', item.dataset.view === viewId);
                    });
                    
                    // ▼▼▼ 【核心修正】在這裡統一管理所有UI元素的顯隱 ▼▼▼
                    if (viewId === 'messages-view') {
                        mainHeader.style.display = 'flex';
                        mainBottomNav.style.display = 'flex';
                    } else {
                        mainHeader.style.display = 'none';
                        mainBottomNav.style.display = 'none';
                    }
                    // ▲▲▲ 修正結束 ▲▲▲
        
            if (viewId !== 'memories-view') {
                activeCountdownTimers.forEach(timerId => clearInterval(timerId));
                activeCountdownTimers = [];
            }
        
                    // 根據視圖ID執行特定的渲染/更新邏輯
                    switch (viewId) {
                        case 'qzone-screen':
                            views['qzone-screen'].style.backgroundColor = '#f0f2f5';
                            updateUnreadIndicator(0);
                            renderQzoneScreen();
                            renderQzonePosts();
                            break;
                        case 'favorites-view':
                            views['favorites-view'].style.backgroundColor = '#f9f9f9';
                            renderFavoritesScreen();
                            break;
                        case 'messages-view':
                            // 如果需要，可以在這裡添加返回消息清單時要執行的邏輯
                            break;
        case 'npc-list-view':
            renderNpcListScreen(); // 切換到NPC視圖時，渲染列表
            break;
                    }
                }
    // X社交頁面渲染函數
      function renderXSocialScreen() {
        // 暫時為空，後續添加X社交頁面的渲染邏輯
        console.log("渲染X社交頁面");
      }
      window.renderXSocialScreenProxy = renderXSocialScreen;
                
                function renderQzoneScreen() {
                    if (state && state.qzoneSettings) {
                        const settings = state.qzoneSettings;
                        document.getElementById('qzone-nickname').textContent = settings.nickname;
                        document.getElementById('qzone-avatar-img').src = settings.avatar;
                        document.getElementById('qzone-banner-img').src = settings.banner;
                    }
                }
                window.renderQzoneScreenProxy = renderQzoneScreen;
        
                async function saveQzoneSettings() {
                    if (db && state.qzoneSettings) {
                        await db.qzoneSettings.put(state.qzoneSettings);
                    }
                }
        
                function formatPostTimestamp(timestamp) {
                    if (!timestamp) return '';
                    const now = new Date();
                    const date = new Date(timestamp);
                    const diffSeconds = Math.floor((now - date) / 1000);
                    const diffMinutes = Math.floor(diffSeconds / 60);
                    const diffHours = Math.floor(diffMinutes / 60);
                    if (diffMinutes < 1) return '剛剛';
                    if (diffMinutes < 60) return `${diffMinutes}分鐘前`;
                    if (diffHours < 24) return `${diffHours}小時前`;
                    const year = date.getFullYear();
                    const month = String(date.getMonth() + 1).padStart(2, '0');
                    const day = String(date.getDate()).padStart(2, '0');
                    const hours = String(date.getHours()).padStart(2, '0');
                    const minutes = String(date.getMinutes()).padStart(2, '0');
                    if (now.getFullYear() === year) {
                        return `${month}-${day} ${hours}:${minutes}`;
                    } else {
                        return `${year}-${month}-${day} ${hours}:${minutes}`;
                    }
                }
        
        // ▼▼▼ 【全新】請將這三個函數黏貼到JS功能函式定義區 ▼▼▼
        
        /**
         * 【全新 | 性能核心 | 已集成Markdown】根據帖子資料，創建或更新單個帖子的HTML元素
         * @param {object} post - 單個帖子的資料物件
         * @returns {HTMLElement} - 創建或更新後的帖子容器DOM元素
         */
        function createOrUpdatePostElement(post) {
            const existingPostContainer = document.querySelector(`.qzone-post-container[data-post-id="${post.id}"]`);
            const isUpdating = !!existingPostContainer;
            
            const postContainer = isUpdating ? existingPostContainer : document.createElement('div');
            if (!isUpdating) {
                postContainer.className = 'qzone-post-container';
                postContainer.dataset.postId = post.id;
            }
        
            const postEl = isUpdating ? postContainer.querySelector('.qzone-post-item') : document.createElement('div');
            if (!isUpdating) {
                postEl.className = 'qzone-post-item';
            }
        
            let authorAvatar = '', authorNickname = '', commentAvatar = state.qzoneSettings.avatar; 
        
            if (post.authorId === 'user') {
                authorAvatar = state.qzoneSettings.avatar;
                authorNickname = state.qzoneSettings.nickname;
            } else if (state.chats[post.authorId]) {
                const authorChat = state.chats[post.authorId];
                authorAvatar = authorChat.settings.aiAvatar || defaultAvatar;
                authorNickname = authorChat.name;
            } else {
                authorNickname = getDisplayNameByOriginalName(post.authorOriginalName);
                authorAvatar = defaultAvatar;
            }
        
function renderOriginalPostContent(targetPost) {
            let innerContentHtml = '';
            const publicTextHtml = targetPost.publicText ? `<div class="post-content">${parseMarkdown(targetPost.publicText).replace(/\n/g, '<br>')}</div>` : '';

            if (targetPost.type === 'shuoshuo') {
                innerContentHtml = `<div class="post-content" style="margin-bottom: 10px;">${parseMarkdown(targetPost.content).replace(/\n/g, '<br>')}</div>`;
            } else if (targetPost.type === 'image_post' && targetPost.imageUrl) {
                // 【核心修復】直接使用 targetPost.imageUrl 來顯示使用者上傳的圖片
                innerContentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${targetPost.imageUrl}" class="chat-image"></div>` : `<img src="${targetPost.imageUrl}" class="chat-image">`;
            } else if (targetPost.type === 'text_image') {
                const postImageUrl = state.globalSettings.enableAiDrawing && targetPost.image_prompt ? `https://image.pollinations.ai/prompt/${targetPost.image_prompt}` : 'https://i.postimg.cc/KYr2qRCK/1.jpg';
                innerContentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${postImageUrl}" class="chat-image" style="cursor: pointer;" data-hidden-text="${targetPost.hiddenContent}"></div>` : `<img src="${postImageUrl}" class="chat-image" style="cursor: pointer;" data-hidden-text="${targetPost.hiddenContent}">`;
            }
            return innerContentHtml;
        }
        
            let mainContentHtml;
        
            if (post.type === 'repost') {
                // ▼▼▼ 已添加 Markdown 解析 ▼▼▼
                const repostCommentHtml = post.repostComment ? `<div class="post-content">${parseMarkdown(post.repostComment).replace(/\n/g, '<br>')}</div>` : '';
                let originalAuthorAvatar = defaultAvatar;
                let originalAuthorNickname = '原作者';
                if (post.originalPost.authorId === 'user') {
                    originalAuthorAvatar = state.qzoneSettings.avatar;
                    originalAuthorNickname = state.qzoneSettings.nickname;
                } else {
                    const originalAuthorChat = state.chats[post.originalPost.authorId];
                    if (originalAuthorChat) {
                        originalAuthorAvatar = originalAuthorChat.settings.aiAvatar || defaultAvatar;
                    }
                    originalAuthorNickname = getDisplayNameByOriginalName(post.originalPost.authorOriginalName);
                }
                mainContentHtml = `
                    ${repostCommentHtml}
                    <div class="reposted-content-wrapper">
                        <div class="post-header">
                            <img src="${originalAuthorAvatar}" class="post-avatar">
                            <div class="post-info">
                                <span class="post-nickname">@${originalAuthorNickname}</span>
                                <span class="post-timestamp">${formatPostTimestamp(post.originalPost.timestamp)}</span>
                            </div>
                        </div>
                        <div class="post-main-content">${renderOriginalPostContent(post.originalPost)}</div>
                    </div>
                `;
            } else {
                mainContentHtml = `<div class="post-main-content">${renderOriginalPostContent(post)}</div>`;
            }
        
            let likesHtml = '';
            if (post.likes && post.likes.length > 0) {
                const displayLikes = post.likes.map(name => getDisplayNameByOriginalName(name)).join('、');
                likesHtml = `<div class="post-likes-section"><svg class="like-icon" viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg><span>${displayLikes} 覺得很贊</span></div>`;
            }
        
            let commentsHtml = '';
            if (post.comments && post.comments.length > 0) {
                commentsHtml = '<div class="post-comments-container">';
                post.comments.forEach((comment, index) => {
                    if (typeof comment === 'object' && comment !== null && comment.commenterName) {
                        const commenterOriginalName = comment.commenterName;
                        const commenterDisplayName = getDisplayNameByOriginalName(commenterOriginalName);
                        
                        let innerCommentContent;
                        if (STICKER_REGEX.test(comment.text)) {
                            innerCommentContent = `<img src="${comment.text}" class="comment-sticker" alt="sticker">`;
                        } else {
                            // ▼▼▼ 已添加 Markdown 解析 ▼▼▼
                            innerCommentContent = parseMarkdown(comment.text);
                        }
        
                        let commentLineHtml = '';
                        if (comment.replyTo) {
                            const repliedToDisplayName = getDisplayNameByOriginalName(comment.replyTo);
                            commentLineHtml = `<span class="commenter-name">${commenterDisplayName}</span> 回復 <span class="commenter-name">${repliedToDisplayName}</span>: ${innerCommentContent}`;
                        } else {
                            commentLineHtml = `<span class="commenter-name">${commenterDisplayName}</span>: ${innerCommentContent}`;
                        }
                        
                        commentsHtml += `<div class="comment-item" data-post-id="${post.id}" data-commenter-original-name="${commenterOriginalName}" data-commenter-display-name="${commenterDisplayName}">
                                            <div class="comment-text">${commentLineHtml}</div>
                                            <span class="comment-delete-btn" data-comment-index="${index}">×</span>
                                         </div>`;
        
                    } else {
                        // ▼▼▼ 已為舊格式評論添加 Markdown 解析 ▼▼▼
                        commentsHtml += `<div class="legacy-comment-item">
                                            <span class="comment-text">${parseMarkdown(String(comment))}</span>
                                         </div>`;
                    }
                });
                commentsHtml += '</div>';
            }
        
            const userOriginalName = state.qzoneSettings.nickname;
            const isLikedByUser = post.likes && post.likes.includes(userOriginalName);
            const isFavoritedByUser = state.favoritedPostIds && state.favoritedPostIds.has(post.id);
        
            let repostIconHtml = '';
            if (post.type !== 'repost') {
                repostIconHtml = `
                    <span class="action-icon repost">
                        <svg viewBox="0 0 24 24"><path d="M17 2.1l4 4-4 4 M3 11.5v-3a4 4 0 0 1 4-4h13 M7 21.9l-4-4 4-4 M21 12.5v3a4 4 0 0 1-4 4H4"></path></svg>
                    </span>`;
            }
            
            postEl.innerHTML = `
                <div class="post-header">
                    <img src="${authorAvatar}" class="post-avatar" data-author-id="${post.authorId}">
                    <div class="post-info">
                        <span class="post-nickname">${authorNickname}</span>
                        <span class="post-timestamp">${formatPostTimestamp(post.timestamp)}</span>
                    </div>
                    <div class="post-actions-btn">…</div>
                </div>
                ${mainContentHtml}
                <div class="post-feedback-icons">
                    ${repostIconHtml}
                    <span class="action-icon like ${isLikedByUser ? 'active' : ''}"><svg viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg></span>
                    <span class="action-icon favorite ${isFavoritedByUser ? 'active' : ''}"><svg viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path></svg></span>
                </div>
                ${likesHtml}
                ${commentsHtml}
                <div class="post-footer">
                    <div class="comment-section">
                        <img src="${commentAvatar}" class="comment-avatar">
                        <input type="text" class="comment-input" placeholder="友善的評論是交流的起點">
                        <button class="comment-sticker-btn">
        <svg viewBox="0 0 24 24">
            <circle cx="12" cy="12" r="10"></circle>
            <path d="M8 14 Q 12 16 16 14"></path>
            <line x1="9" y1="9" x2="9.01" y2="9"></line>
            <line x1="15" y1="9" x2="15.01" y2="9"></line>
        </svg>
        </button>
                        <div class="at-mention-popup"></div>
                    </div>
                    <button class="comment-send-btn">發送</button>
                </div>
            `;
        
            if (!isUpdating) {
                const deleteAction = document.createElement('div');
                deleteAction.className = 'qzone-post-delete-action';
                deleteAction.innerHTML = '<span>刪除</span>';
                postContainer.appendChild(postEl);
                postContainer.appendChild(deleteAction);
            }
            
            return postContainer;
        }
        
        /**
         * 【全新 | 增量更新函數】只更新單個帖子，而不是重繪整個列表
         * @param {number} postId - 需要更新的帖子的ID
         */
        async function updateSinglePostInDOM(postId) {
            const postData = await db.qzonePosts.get(postId);
            if (!postData) {
                // 如果帖子被刪了，就從DOM中移除
                const postContainer = document.querySelector(`.qzone-post-container[data-post-id="${postId}"]`);
                if (postContainer) postContainer.remove();
                return;
            }
        
            // 更新緩存
            const cacheIndex = qzonePostsCache.findIndex(p => p.id === postId);
            if (cacheIndex > -1) qzonePostsCache[cacheIndex] = postData;
            
            // 更新收藏狀態
            const favorites = await db.favorites.where('type').equals('qzone_post').toArray();
            state.favoritedPostIds = new Set(favorites.map(fav => fav.content.id));
        
            // 調用核心函數來更新DOM
            createOrUpdatePostElement(postData);
        }
        // ▲▲▲ 新函數黏貼結束 ▲▲▲
        
        // ▼▼▼ 【全新】請將這個函數黏貼到 formatPostTimestamp 函數的後面 ▼▼▼
        function formatTimeAgo(timestamp) {
            const now = Date.now();
            const seconds = Math.floor((now - timestamp) / 1000);
            const minutes = Math.floor(seconds / 60);
            if (minutes < 2) return '剛剛';
            if (minutes < 60) return `${minutes}分鐘前`;
            const hours = Math.floor(minutes / 60);
            if (hours < 24) return `${hours}小時前`;
            const days = Math.floor(hours / 24);
            return `${days}天前`;
        }
        // ▲▲▲ 新函數黏貼結束 ▲▲▲
        
        
        // ▼▼▼ 【全新】請將這兩個函數黏貼到JS功能函式定義區 ▼▼▼
        
        /**
         * 【全新 | 性能核心】根據帖子資料，創建或更新單個帖子的HTML元素
         * @param {object} post - 單個帖子的資料物件
         * @returns {HTMLElement} - 創建或更新後的帖子容器DOM元素
         */
async function createOrUpdatePostElement(post) { // <-- 核心修改1：將函式宣告為 async
            const existingPostContainer = document.querySelector(`.qzone-post-container[data-post-id="${post.id}"]`);
            const isUpdating = !!existingPostContainer;
            
            const postContainer = isUpdating ? existingPostContainer : document.createElement('div');
            if (!isUpdating) {
                postContainer.className = 'qzone-post-container';
                postContainer.dataset.postId = post.id;
            }
        
            const postEl = isUpdating ? postContainer.querySelector('.qzone-post-item') : document.createElement('div');
            if (!isUpdating) {
                postEl.className = 'qzone-post-item';
            }
        
            let authorAvatar = '', authorNickname = '', commentAvatar = state.qzoneSettings.avatar; 
        
            // --- ▼▼▼ 核心修改2：重構作者資訊獲取邏輯 ▼▼▼ ---
            if (post.authorId === 'user') {
                authorAvatar = state.qzoneSettings.avatar;
                authorNickname = state.qzoneSettings.nickname;
            } else if (state.chats[post.authorId]) {
                const authorChat = state.chats[post.authorId];
                authorAvatar = authorChat.settings.aiAvatar || defaultAvatar;
                authorNickname = authorChat.name;
            } else if (String(post.authorId).startsWith('npc_')) {
                // 如果作者是NPC，我們從NPC資料庫中查找資訊
                const npcId = parseInt(String(post.authorId).replace('npc_', ''));
                if (!isNaN(npcId)) {
                    const npc = await db.npcs.get(npcId);
                    if (npc) {
                        authorAvatar = npc.avatar || defaultGroupMemberAvatar;
                        authorNickname = npc.name;
                    } else {
                        authorNickname = post.authorOriginalName || '未知NPC';
                        authorAvatar = defaultGroupMemberAvatar;
                    }
                }
            } else {
                // 如果都找不到，則使用原始名稱和默認頭像作為保底
                authorNickname = getDisplayNameByOriginalName(post.authorOriginalName);
                authorAvatar = defaultAvatar;
            }
            // --- ▲▲▲ 修改結束 ▲▲▲ ---
        
function renderOriginalPostContent(targetPost) {
            let innerContentHtml = '';
            const publicTextHtml = targetPost.publicText ? `<div class="post-content">${parseMarkdown(targetPost.publicText).replace(/\n/g, '<br>')}</div>` : '';

            if (targetPost.type === 'shuoshuo') {
                innerContentHtml = `<div class="post-content" style="margin-bottom: 10px;">${parseMarkdown(targetPost.content).replace(/\n/g, '<br>')}</div>`;
            } else if (targetPost.type === 'image_post' && targetPost.imageUrl) {
                // 【核心修復 ①】直接使用 targetPost.imageUrl 顯示您上傳的圖片
                innerContentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${targetPost.imageUrl}" class="chat-image"></div>` : `<img src="${targetPost.imageUrl}" class="chat-image">`;
            } else if (targetPost.type === 'text_image') {
                // （這部分邏輯保持不變，用於AI生成的文字圖）
                const postImageUrl = state.globalSettings.enableAiDrawing && targetPost.image_prompt ? `https://image.pollinations.ai/prompt/${targetPost.image_prompt}` : 'https://i.postimg.cc/KYr2qRCK/1.jpg';
                innerContentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${postImageUrl}" class="chat-image" style="cursor: pointer;" data-hidden-text="${targetPost.hiddenContent}"></div>` : `<img src="${postImageUrl}" class="chat-image" style="cursor: pointer;" data-hidden-text="${targetPost.hiddenContent}">`;
            }
            return innerContentHtml;
        }
        
            let mainContentHtml;
        
            if (post.type === 'repost') {
                const repostCommentHtml = post.repostComment ? `<div class="post-content">${post.repostComment.replace(/\n/g, '<br>')}</div>` : '';
                let originalAuthorAvatar = defaultAvatar;
                let originalAuthorNickname = '原作者';
                if (post.originalPost.authorId === 'user') {
                    originalAuthorAvatar = state.qzoneSettings.avatar;
                    originalAuthorNickname = state.qzoneSettings.nickname;
                } else {
                    const originalAuthorChat = state.chats[post.originalPost.authorId];
                    if (originalAuthorChat) {
                        originalAuthorAvatar = originalAuthorChat.settings.aiAvatar || defaultAvatar;
                    }
                    originalAuthorNickname = getDisplayNameByOriginalName(post.originalPost.authorOriginalName);
                }
                mainContentHtml = `
                    ${repostCommentHtml}
                    <div class="reposted-content-wrapper">
                        <div class="post-header">
                            <img src="${originalAuthorAvatar}" class="post-avatar">
                            <div class="post-info">
                                <span class="post-nickname">@${originalAuthorNickname}</span>
                                <span class="post-timestamp">${formatPostTimestamp(post.originalPost.timestamp)}</span>
                            </div>
                        </div>
                        <div class="post-main-content">${renderOriginalPostContent(post.originalPost)}</div>
                    </div>
                `;
            } else {
                mainContentHtml = `<div class="post-main-content">${renderOriginalPostContent(post)}</div>`;
            }
        
            let likesHtml = '';
            if (post.likes && post.likes.length > 0) {
                const displayLikes = post.likes.map(name => getDisplayNameByOriginalName(name)).join('、');
                likesHtml = `<div class="post-likes-section"><svg class="like-icon" viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg><span>${displayLikes} 覺得很贊</span></div>`;
            }
        
        // ▼▼▼ 在 createOrUpdatePostElement 函數中，找到 let commentsHtml = ''; 並用下面這整塊替換 ▼▼▼
            let commentsHtml = '';
            if (post.comments && post.comments.length > 0) {
                commentsHtml = '<div class="post-comments-container">';
                post.comments.forEach((comment, index) => {
                    // 【核心修復1】檢查是否是新的、包含 commenterName 的物件格式
                    if (typeof comment === 'object' && comment !== null && comment.commenterName) {
                        const commenterOriginalName = comment.commenterName;
                        // 【核心修復2】使用我們全新的函數來即時查找最新的顯示名稱！
                        const commenterDisplayName = getDisplayNameByOriginalName(commenterOriginalName);
                        
                        let innerCommentContent;
                        if (STICKER_REGEX.test(comment.text)) {
                            innerCommentContent = `<img src="${comment.text}" class="comment-sticker" alt="sticker">`;
                        } else {
                            innerCommentContent = parseMarkdown(comment.text);
                        }
        
                        let commentLineHtml = '';
                        // 【核心修復3】回復的目標也使用新函數來查找名字
                        if (comment.replyTo) {
                            const repliedToDisplayName = getDisplayNameByOriginalName(comment.replyTo);
                            commentLineHtml = `<span class="commenter-name">${commenterDisplayName}</span> 回復 <span class="commenter-name">${repliedToDisplayName}</span>: ${innerCommentContent}`;
                        } else {
                            commentLineHtml = `<span class="commenter-name">${commenterDisplayName}</span>: ${innerCommentContent}`;
                        }
                        
                        commentsHtml += `<div class="comment-item" data-post-id="${post.id}" data-commenter-original-name="${commenterOriginalName}" data-commenter-display-name="${commenterDisplayName}">
                                            <div class="comment-text">${commentLineHtml}</div>
                                            <span class="comment-delete-btn" data-comment-index="${index}">×</span>
                                         </div>`;
        
                    } else {
                        // 【相容舊資料】如果還是舊的字串格式，就原樣顯示
                        commentsHtml += `<div class="legacy-comment-item">
                                            <span class="comment-text">${String(comment)}</span>
                                         </div>`;
                    }
                });
                commentsHtml += '</div>';
            }
        // ▲▲▲ 替換結束 ▲▲▲
        
            const userOriginalName = state.qzoneSettings.nickname;
            const isLikedByUser = post.likes && post.likes.includes(userOriginalName);
            const isFavoritedByUser = state.favoritedPostIds && state.favoritedPostIds.has(post.id); // 從 state 讀取
        
            let repostIconHtml = '';
            if (post.type !== 'repost') {
                repostIconHtml = `
                    <span class="action-icon repost">
                        <svg viewBox="0 0 24 24"><path d="M17 2.1l4 4-4 4 M3 11.5v-3a4 4 0 0 1 4-4h13 M7 21.9l-4-4 4-4 M21 12.5v3a4 4 0 0 1-4 4H4"></path></svg>
                    </span>`;
            }
            
            postEl.innerHTML = `
                <div class="post-header">
                    <img src="${authorAvatar}" class="post-avatar" data-author-id="${post.authorId}">
                    <div class="post-info">
                        <span class="post-nickname">${authorNickname}</span>
                        <span class="post-timestamp">${formatPostTimestamp(post.timestamp)}</span>
                    </div>
                    <div class="post-actions-btn">…</div>
                </div>
                ${mainContentHtml}
                <div class="post-feedback-icons">
                    ${repostIconHtml}
                    <span class="action-icon like ${isLikedByUser ? 'active' : ''}"><svg viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg></span>
                    <span class="action-icon favorite ${isFavoritedByUser ? 'active' : ''}"><svg viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path></svg></span>
                </div>
                ${likesHtml}
                ${commentsHtml}
                <div class="post-footer">
                    <div class="comment-section">
                        <img src="${commentAvatar}" class="comment-avatar">
                        <input type="text" class="comment-input" placeholder="友善的評論是交流的起點">
                        <button class="comment-sticker-btn">
        <svg viewBox="0 0 24 24">
            <circle cx="12" cy="12" r="10"></circle>
            <path d="M8 14 Q 12 16 16 14"></path>
            <line x1="9" y1="9" x2="9.01" y2="9"></line>
            <line x1="15" y1="9" x2="15.01" y2="9"></line>
        </svg>
        </button>
                        <div class="at-mention-popup"></div>
                    </div>
                    <button class="comment-send-btn">發送</button>
                </div>
            `;
        
            if (!isUpdating) {
                const deleteAction = document.createElement('div');
                deleteAction.className = 'qzone-post-delete-action';
                deleteAction.innerHTML = '<span>刪除</span>';
                postContainer.appendChild(postEl);
                postContainer.appendChild(deleteAction);
            }
            
            return postContainer;
        }
        
        /**
         * 【全新 | 增量更新函數】只更新單個帖子，而不是重繪整個列表
         * @param {number} postId - 需要更新的帖子的ID
         */
        async function updateSinglePostInDOM(postId) {
            const postData = await db.qzonePosts.get(postId);
            if (!postData) {
                // 如果帖子被刪了，就從DOM中移除
                const postContainer = document.querySelector(`.qzone-post-container[data-post-id="${postId}"]`);
                if (postContainer) {
                    postContainer.remove();
                }
                return;
            }
        
            // 更新緩存
            const cacheIndex = qzonePostsCache.findIndex(p => p.id === postId);
            if (cacheIndex > -1) {
                qzonePostsCache[cacheIndex] = postData;
            }
            
            // 更新收藏狀態
            const favorites = await db.favorites.where('type').equals('qzone_post').toArray();
            state.favoritedPostIds = new Set(favorites.map(fav => fav.content.id));
        
            // 調用核心函數來更新DOM
           await createOrUpdatePostElement(postData);
        }
        
        // ▲▲▲ 新函數黏貼結束 ▲▲▲
        
// ▼▼▼ 【無限滾動修復版】請用這個新版本替換舊的 renderQzonePosts 函數 ▼▼▼
async function renderQzonePosts() {
    const postsListEl = document.getElementById('qzone-posts-list');
    if (!postsListEl) return;

    const [postsFromDb, favorites] = await Promise.all([
        db.qzonePosts.orderBy('timestamp').reverse().filter(post => !post.isDeleted).toArray(),
        db.favorites.where('type').equals('qzone_post').toArray()
    ]);
    qzonePostsCache = postsFromDb;
    state.favoritedPostIds = new Set(favorites.map(fav => fav.content.id));

    postsListEl.innerHTML = '';
    qzonePostsRenderCount = 0; // 重置計數器

    if (qzonePostsCache.length === 0) {
        postsListEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 30px 0;">這裡空空如也，快來發佈第一條說說吧！</p>';
        return;
    }

    // 初始載入第一頁
    loadMoreQzonePosts();
}
// ▲▲▲ 替換結束 ▲▲▲

        
// ▼▼▼ 【無限滾動修復版】請用這個新版本替換舊的 loadMoreQzonePosts 函數 ▼▼▼
async function loadMoreQzonePosts() {
    if (isLoadingMorePosts) return;
    isLoadingMorePosts = true;

    const postsListEl = document.getElementById('qzone-posts-list');
    if (!postsListEl) {
        isLoadingMorePosts = false;
        return;
    }

    showLoader(postsListEl, 'bottom'); // 在底部顯示載入動畫

    // 類比網路延遲
    setTimeout(async () => {
        hideLoader(postsListEl); // 先移除載入動畫

        const nextSliceStart = qzonePostsRenderCount;
        const nextSliceEnd = qzonePostsRenderCount + QZONE_RENDER_WINDOW;
        const postsToAppend = qzonePostsCache.slice(nextSliceStart, nextSliceEnd);

        const fragment = document.createDocumentFragment();
for (const post of postsToAppend) {
                    const postElement = await createOrUpdatePostElement(post); // <-- 核心修改4：在這裡使用 await
                    fragment.appendChild(postElement);
                }
        postsListEl.appendChild(fragment);

        qzonePostsRenderCount += postsToAppend.length;

        isLoadingMorePosts = false;
    }, 500);
}
// ▲▲▲ 替換結束 ▲▲▲
        // ▼▼▼ 【全新】動態評論區表情面板管理函數 ▼▼▼
        
        function openQzoneStickerPanel(postId, buttonElement) {
            const panel = qzoneStickerPanelState.panelEl;
            const grid = qzoneStickerPanelState.gridEl;
        
            // 1. 填充表情 (這部分邏輯不變)
            grid.innerHTML = '';
            if (state.userStickers.length === 0) {
                grid.innerHTML = '<p style="text-align:center; color: var(--text-secondary); grid-column: 1 / -1; padding-top: 20px;">請先在聊天介面的<br>表情面板中添加表情包</p>';
            } else {
                state.userStickers.forEach(sticker => {
                    const item = document.createElement('div');
                    item.className = 'sticker-item';
                    item.style.backgroundImage = `url(${sticker.url})`;
                    item.title = sticker.name;
                    grid.appendChild(item);
                });
            }
        
            // --- ▼▼▼ 核心修正：智慧定位邏輯 ▼▼▼ ---
        
            // 2. 獲取必要的尺寸和位置資訊
            const btnRect = buttonElement.getBoundingClientRect();
            const phoneScreenRect = document.getElementById('phone-screen').getBoundingClientRect();
            
            panel.style.display = 'flex'; // 先顯示出來才能獲取尺寸
            const panelRect = panel.getBoundingClientRect();
            const panelHeight = panelRect.height;
            const panelWidth = panelRect.width;
        
            // 3. 計算垂直位置 (保持不變，總是出現在按鈕上方)
            panel.style.top = `${btnRect.top - panelHeight - 5 - phoneScreenRect.top}px`;
        
            // 4. 計算並判斷水準位置
            const desiredLeftPosition = btnRect.left - phoneScreenRect.left;
        
            // 如果面板的左側位置 + 自身寬度 > 手機螢幕寬度，說明會超出
            if (desiredLeftPosition + panelWidth > phoneScreenRect.width) {
                // 如果會超出，則改為貼著螢幕右側邊緣顯示 (留5px邊距)
                panel.style.left = 'auto';
                panel.style.right = '5px';
            } else {
                // 如果不會超出，則正常對齊按鈕左側
                panel.style.left = `${desiredLeftPosition}px`;
                panel.style.right = 'auto';
            }
            
            // --- ▲▲▲ 修正結束 ▲▲▲ ---
        
            // 5. 更新狀態 (這部分邏輯不變)
            qzoneStickerPanelState.isOpen = true;
            qzoneStickerPanelState.activePostId = postId;
        }
        // ▲▲▲ 新函數黏貼結束 ▲▲▲
        // ▼▼▼ 請將這段【新函數】黏貼到 openQzoneStickerPanel 函數的後面 ▼▼▼
        
        /**
         * 【全新】關閉動態評論區的表情面板
         */
        function closeQzoneStickerPanel() {
            // 檢查狀態，確保面板是打開的
            if (qzoneStickerPanelState.isOpen) {
                // 隱藏面板DOM元素
                qzoneStickerPanelState.panelEl.style.display = 'none';
                
                // 重置狀態變數
                qzoneStickerPanelState.isOpen = false;
                qzoneStickerPanelState.activePostId = null;
            }
        }
        
        // ▲▲▲ 新函數黏貼結束 ▲▲▲
        
        // ▼▼▼ 請用這個【新代碼塊】替換舊的 sendQzoneStickerComment 函數 ▼▼▼
        
        /**
         * 【全新升級版】發送動態表情評論，並告知AI其含義
         * @param {number} postId - 帖子ID
         * @param {object} sticker - 完整的表情對象 { url, name }
         */
        async function sendQzoneStickerComment(postId, sticker) {
            if (!sticker || !sticker.url) return;
        
            const post = await db.qzonePosts.get(postId);
            if (!post) {
                console.error("sendQzoneStickerComment: 找不到帖子:", postId);
                return;
            }
        
            if (!post.comments) {
                post.comments = [];
            }
            // ▼▼▼ 核心修復：在這裡為您發送的表情也添加 meaning 欄位 ▼▼▼
            const newComment = {
                commenterName: state.qzoneSettings.nickname,
                text: sticker.url,
                meaning: sticker.name, // 保存表情的含義
                timestamp: Date.now()
            };
            // ▲▲▲ 修復結束 ▲▲▲
            post.comments.push(newComment);
        
            await db.qzonePosts.update(postId, { comments: post.comments });
        
            closeQzoneStickerPanel();
            await renderQzonePosts();
            
            const postSummary = (post.publicText || post.content || `[圖片動態]`).substring(0, 30);
            
            // ▼▼▼ 核心修復：通知AI時，明確告知表情的含義 ▼▼▼
            for (const chatId in state.chats) {
                const chat = state.chats[chatId];
                if (!chat.isGroup) {
                    const intelligentPrompt = `[系統提示：'${state.qzoneSettings.nickname}' 在你的動態(ID: ${postId}, 內容摘要: “${postSummary}”)下發送了一個表情評論，意思是：“${sticker.name}”。請你對此作出回應。]`;
                    
                    const historyMessage = { 
                        role: 'system', 
                        content: intelligentPrompt, 
                        timestamp: Date.now(), 
                        isHidden: true 
                    };
                    chat.history.push(historyMessage);
                    await db.chats.put(chat);
                }
            }
            // ▲▲▲ 修復結束 ▲▲▲
        }
        
        // ▲▲▲ 替換結束 ▲▲▲
        
        
        // ▼▼▼ 【全新】這三個函數是轉發功能的核心，請將它們黏貼到JS功能函式定義區 ▼▼▼
        
        /**
         * 打開轉發評論的模態框
         * @param {number} postId - 要轉發的動態的ID
         */
        function openRepostModal(postId) {
            repostTargetId = postId;
            document.getElementById('repost-comment-input').value = ''; // 清空輸入框
            document.getElementById('repost-modal').classList.add('visible');
        }
        
        /**
         * 隱藏轉發模態框
         */
        function hideRepostModal() {
            document.getElementById('repost-modal').classList.remove('visible');
            repostTargetId = null;
        }
        
        /**
         * 處理確認轉發的邏輯
         */
        async function handleConfirmRepost() {
            if (!repostTargetId) return;
        
            const comment = document.getElementById('repost-comment-input').value.trim();
            const originalPost = await db.qzonePosts.get(repostTargetId);
        
            if (!originalPost) {
                alert("錯誤：找不到要轉發的原始動態。");
                hideRepostModal();
                return;
            }
        
            const newPost = {
                type: 'repost', // 標記為轉發類型
                timestamp: Date.now(),
                authorId: 'user', // 轉發者永遠是當前用戶
                repostComment: comment,
                originalPost: originalPost, // 將原始動態完整地嵌入新動態中
                visibleGroupIds: null // 轉發的動態預設對所有人可見
            };
        
            await db.qzonePosts.add(newPost);
            hideRepostModal();
            await renderQzonePosts();
            alert('轉發成功！');
        }
        
        // ▲▲▲ 新函數黏貼結束 ▲▲▲             
        // ▼▼▼ 請用下面這個【更新後的】函數，完整替換掉你代碼中舊的 displayFilteredFavorites 函數 ▼▼▼
        
        function displayFilteredFavorites(items) {
            const listEl = document.getElementById('favorites-list');
            listEl.innerHTML = '';
        
            if (items.length === 0) {
                const searchTerm = document.getElementById('favorites-search-input').value;
                const message = searchTerm ? '未找到相關收藏' : '你的我的最愛是空的，<br>快去動態或聊天中收藏喜歡的內容吧！';
                listEl.innerHTML = `<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">${message}</p>`;
                return;
            }
        
            for (const item of items) {
                const card = document.createElement('div');
                card.className = 'favorite-item-card';
                card.dataset.favid = item.id;
        
                let headerHtml = '', contentHtml = '', sourceText = '', footerHtml = '';
        
                if (item.type === 'qzone_post') {
                    const post = item.content;
                    sourceText = '來自動態';
                    let authorAvatar = defaultAvatar, authorNickname = '未知用戶';
        
                    if (post.authorId === 'user') {
                        authorAvatar = state.qzoneSettings.avatar;
                        authorNickname = state.qzoneSettings.nickname;
                    } else if (state.chats[post.authorId]) {
                        authorAvatar = state.chats[post.authorId].settings.aiAvatar;
                        authorNickname = state.chats[post.authorId].name;
                    }
        
                    headerHtml = `<img src="${authorAvatar}" class="avatar"><div class="info"><div class="name">${authorNickname}</div></div>`;
                    
                    const publicTextHtml = post.publicText ? `<div class="post-content">${post.publicText.replace(/\n/g, '<br>')}</div>` : '';
                    if (post.type === 'shuoshuo') {
                        contentHtml = `<div class="post-content">${post.content.replace(/\n/g, '<br>')}</div>`;
                    } else if (post.type === 'image_post' && post.imageUrl) {
    const postImageUrl = state.globalSettings.enableAiDrawing && post.image_prompt ? `https://image.pollinations.ai/prompt/${post.image_prompt}` : 'https://i.postimg.cc/KYr2qRCK/1.jpg';
    contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${postImageUrl}" class="chat-image"></div>` : `<img src="${postImageUrl}" class="chat-image">`;
} else if (post.type === 'text_image') {
    const postImageUrl = state.globalSettings.enableAiDrawing && post.image_prompt ? `https://image.pollinations.ai/prompt/${post.image_prompt}` : 'https://i.postimg.cc/KYr2qRCK/1.jpg';
    contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${postImageUrl}" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}"></div>` : `<img src="${postImageUrl}" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}">`;
                    }
        
                    // ▼▼▼ 新增/修改的代碼開始 ▼▼▼
                    
                    // 1. 構造點贊區域的HTML
                    let likesHtml = '';
                    // 檢查 post 物件中是否存在 likes 陣列並且不為空
                    if (post.likes && post.likes.length > 0) {
                        // 如果存在，就創建點贊區域的 div
                        likesHtml = `
                            <div class="post-likes-section">
                                <svg class="like-icon" viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>
                                <span>${post.likes.join('、')} 覺得很贊</span>
                            </div>`;
                    }
        
                    // 2. 構造評論區域的HTML
        // ▼▼▼ 【最終修復方案】請用這個全新的、向下相容的代碼塊替換舊的 if(post.comments...) 邏輯 ▼▼▼
        let commentsHtml = '';
        if (post.comments && post.comments.length > 0) {
            commentsHtml = '<div class="post-comments-container">';
            post.comments.forEach((comment, index) => {
                // --- 核心修復：在這裡判斷評論的資料格式 ---
                if (typeof comment === 'object' && comment !== null && comment.commenterName) {
                    // --- 這是新格式的、功能完整的評論 ---
                    const commenterOriginalName = comment.commenterName;
                    const commenterDisplayName = getDisplayNameByOriginalName(commenterOriginalName);
                    
                    let innerCommentContent;
                    if (STICKER_REGEX.test(comment.text)) {
                        innerCommentContent = `<img src="${comment.text}" class="comment-sticker" alt="sticker">`;
                    } else {
                        innerCommentContent = comment.text;
                    }
        
                    let commentLineHtml = '';
                    if (comment.replyTo) {
                        const repliedToDisplayName = getDisplayNameByOriginalName(comment.replyTo);
                        commentLineHtml = `<span class="commenter-name">${commenterDisplayName}</span> 回復 <span class="commenter-name">${repliedToDisplayName}</span>: ${innerCommentContent}`;
                    } else {
                        commentLineHtml = `<span class="commenter-name">${commenterDisplayName}</span>: ${innerCommentContent}`;
                    }
                    
                    commentsHtml += `<div class="comment-item" data-post-id="${post.id}" data-commenter-original-name="${commenterOriginalName}" data-commenter-display-name="${commenterDisplayName}">
                                        <div class="comment-text">${commentLineHtml}</div>
                                        <span class="comment-delete-btn" data-comment-index="${index}">×</span>
                                     </div>`;
        
                } else {
                    // --- 這是舊格式的、只做顯示的評論 ---
                    // 我們把它渲染成一個沒有交互、沒有data屬性的簡單div，從而避免報錯
                    commentsHtml += `<div class="legacy-comment-item">
                                        <span class="comment-text">${String(comment)}</span>
                                     </div>`;
                }
            });
            commentsHtml += '</div>';
        }
        // ▲▲▲ 替換結束 ▲▲▲
        
                    // 3. 將點贊和評論的HTML組合到 footerHtml 中
                    footerHtml = `${likesHtml}${commentsHtml}`;
                    
                    // ▲▲▲ 新增/修改的代碼結束 ▲▲▲
        
        } else if (item.type === 'chat_message') {
            const msg = item.content;
            const chat = state.chats[item.chatId];
            if (!chat) continue; 
        
            sourceText = `來自與 ${chat.name} 的聊天`;
            const isUser = msg.role === 'user';
            let senderName, senderAvatar;
        
            if (isUser) {
                // 使用者消息的邏輯保持不變
                senderName = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
                senderAvatar = chat.settings.myAvatar || (chat.isGroup ? defaultMyGroupAvatar : defaultAvatar);
            } else { // AI/成員消息
                 if (chat.isGroup) {
                    // ★★★★★ 這就是唯一的、核心的修改！ ★★★★★
                    // 我們現在使用 originalName 去匹配，而不是舊的 name
                    const member = chat.members.find(m => m.originalName === msg.senderName);
                    // ★★★★★ 修改結束 ★★★★★
                    
                    senderName = msg.senderName;
                    // 因為現在能正確找到 member 物件了，所以也能正確獲取到他的頭像
                    senderAvatar = member ? member.avatar : defaultGroupMemberAvatar;
                } else {
                    // 單聊的邏輯保持不變
                    senderName = chat.name;
                    senderAvatar = chat.settings.aiAvatar || defaultAvatar;
                }
            }
        
            // 後續拼接 headerHtml 和 contentHtml 的邏輯都保持不變
            headerHtml = `<img src="${senderAvatar}" class="avatar"><div class="info"><div class="name">${senderName}</div></div>`;
            
            if (typeof msg.content === 'string' && STICKER_REGEX.test(msg.content)) {
                contentHtml = `<img src="${msg.content}" class="sticker-image" style="max-width: 80px; max-height: 80px;">`;
            } else if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
                contentHtml = `<img src="${msg.content[0].image_url.url}" class="chat-image">`;
            } else {
                contentHtml = String(msg.content || '').replace(/\n/g, '<br>');
            }
        }
                      // ▼▼▼ 【【【核心新增邏輯就在這裡！】】】 ▼▼▼
        else if (item.type === 'char_diary') {
            const diary = item.content;
            sourceText = `來自 ${diary.characterName} 的日記`;

            const charChat = state.chats[diary.characterId];
            const authorAvatar = charChat ? charChat.settings.aiAvatar : defaultAvatar;
            
            headerHtml = `<img src="${authorAvatar}" class="avatar"><div class="info"><div class="name">${diary.characterName}</div></div>`;
            
            // 1. 獲取完整的日記內容
            const fullDiaryContent = diary.content || '';
            // 2. 使用與詳情頁完全相同的Markdown解析和換行邏輯
            const formattedContent = parseMarkdown(fullDiaryContent).replace(/\n/g, '<br>');

            // 3. 將完整的、格式化後的內容放入 contentHtml
            contentHtml = `
                <span class="diary-title">${diary.title}</span>
                <div class="fav-card-content-full">${formattedContent}</div>
            `;
        }     
                // ▼▼▼ 修改最終的HTML拼接，加入 footerHtml ▼▼▼
                card.innerHTML = `
                    <div class="fav-card-header">${headerHtml}<div class="source">${sourceText}</div></div>
                    <div class="fav-card-content">${contentHtml}</div>
                    ${footerHtml}`; // <-- 把我們新創建的 footerHtml 放在這裡
                    
                listEl.appendChild(card);
            }
        }
        
        // ▲▲▲ 替換區域結束 ▲▲▲
        
                /**
                 * 【重構後的函數】: 負責準備資料並觸發渲染
                 */
                async function renderFavoritesScreen() {
                    // 1. 從資料庫獲取最新資料並緩存
                    allFavoriteItems = await db.favorites.orderBy('timestamp').reverse().toArray();
                    
                    // 2. 清空搜索框並隱藏清除按鈕
                    const searchInput = document.getElementById('favorites-search-input');
                    const clearBtn = document.getElementById('favorites-search-clear-btn');
                    searchInput.value = '';
                    clearBtn.style.display = 'none';
        
                    // 3. 顯示所有收藏項
                    displayFilteredFavorites(allFavoriteItems);
                }
        
                // ▲▲▲ 黏貼結束 ▲▲▲
        
                function resetCreatePostModal() {
                    document.getElementById('post-public-text').value = '';
                    document.getElementById('post-image-preview').src = '';
                    document.getElementById('post-image-description').value = '';
                    document.getElementById('post-image-preview-container').classList.remove('visible');
                    document.getElementById('post-image-desc-group').style.display = 'none';
                    document.getElementById('post-local-image-input').value = '';
                    document.getElementById('post-hidden-text').value = '';
                    document.getElementById('switch-to-image-mode').click();
                }
/**
 * 【V2.0 | NPC保護版】一鍵清理資料庫中所有與已刪除角色或聊天相關的孤立資料
 */
async function cleanupRedundantData() {
    const confirmed = await showCustomConfirm(
        '確認清理冗餘數據？',
        '此操作將掃描資料庫，移除所有與已刪除角色相關的孤立資料（如動態、評論、記憶等）。<br><br><strong>此操作不可撤銷，但通常是安全的。NPC資料不會被刪除。</strong><br><br>建議在操作前先導出資料備份。',
        { confirmButtonClass: 'btn-danger', confirmText: '確認清理' }
    );

    if (!confirmed) return;

    await showCustomAlert("請稍候...", "正在開始清理冗餘數據，請不要關閉頁面...");
    console.log("冗餘數據清理流程已啟動...");

    let cleanupCounts = {
        posts: 0, likes: 0, comments: 0, memories: 0,
        callRecords: 0, renderingRules: 0, groupMembers: 0, chatLinks: 0,
    };

    try {
        await db.transaction('rw', db.tables, async () => {
            // 步驟 A: 建立所有有效聊天、角色和NPC的“白名單”
            const allChats = await db.chats.toArray();
            const allNpcs = await db.npcs.toArray(); // <-- 【核心新增】從資料庫讀取NPC清單

            const existingChatIds = new Set(allChats.map(c => c.id));
            const existingNpcIds = new Set(allNpcs.map(n => `npc_${n.id}`)); // <-- 【核心新增】創建NPC的ID白名單

            const existingOriginalNames = new Set(allChats.filter(c => !c.isGroup).map(c => c.originalName));
            existingOriginalNames.add(state.qzoneSettings.nickname || '{{user}}');
            // 【核心新增】將NPC的名字也加入“有效名稱”白名單，用於清理點贊和評論
            allNpcs.forEach(npc => existingOriginalNames.add(npc.name));

            // 步驟 B: 清理群聊中的無效成員
            for (const chat of allChats) {
                 let chatModified = false;
                 if (chat.isGroup && chat.members) {
                     const originalMemberCount = chat.members.length;
                     
                     // 【【【核心修復邏輯】】】
                     // 現在我們同時檢查成員ID是否存在于 角色白名單 或 NPC白名單 中
                     chat.members = chat.members.filter(member => 
                        existingChatIds.has(member.id) || existingNpcIds.has(member.id)
                     );
                     
                     if (chat.members.length < originalMemberCount) {
                        cleanupCounts.groupMembers += (originalMemberCount - chat.members.length);
                        chatModified = true;
                     }
                 }
                 // (清理掛載記憶的邏輯保持不變)
                 if (chat.settings?.linkedMemoryChatIds?.length > 0) {
                     const originalLinkCount = chat.settings.linkedMemoryChatIds.length;
                     chat.settings.linkedMemoryChatIds = chat.settings.linkedMemoryChatIds.filter(id => existingChatIds.has(id));
                     if (chat.settings.linkedMemoryChatIds.length < originalLinkCount) {
                        cleanupCounts.chatLinks += (originalLinkCount - chat.settings.linkedMemoryChatIds.length);
                        chatModified = true;
                     }
                 }
                 if(chatModified) {
                     await db.chats.put(chat);
                 }
            }

            // 步驟 C: 清理動態、點贊和評論
            const allPosts = await db.qzonePosts.toArray();
            for (const post of allPosts) {
                let postModified = false;
                
                // 【【【核心修復邏輯】】】
                // 檢查發帖人是否是用戶、角色或NPC
                const isAuthorValid = post.authorId === 'user' || existingChatIds.has(post.authorId) || existingNpcIds.has(post.authorId);

                if (!isAuthorValid) {
                    await db.qzonePosts.delete(post.id);
                    cleanupCounts.posts++;
                    continue; // 帖子已刪除，跳過後續處理
                }
                
                if (post.likes && post.likes.length > 0) {
                    const originalLikeCount = post.likes.length;
                    post.likes = post.likes.filter(name => existingOriginalNames.has(name));
                    if (post.likes.length < originalLikeCount) {
                        cleanupCounts.likes += (originalLikeCount - post.likes.length);
                        postModified = true;
                    }
                }
                if (post.comments && post.comments.length > 0) {
                    const originalCommentCount = post.comments.length;
                    post.comments = post.comments.filter(comment => {
                        if (typeof comment === 'object' && comment.commenterName) {
                            return existingOriginalNames.has(comment.commenterName);
                        }
                        return true; // 保留舊格式的評論
                    });
                     if (post.comments.length < originalCommentCount) {
                        cleanupCounts.comments += (originalCommentCount - post.comments.length);
                        postModified = true;
                    }
                }
                if (postModified) { await db.qzonePosts.put(post); }
            }

            // (其他清理邏輯保持不變)
            await db.memories.where('chatId').noneOf([...existingChatIds]).delete().then(c => cleanupCounts.memories += c);
            await db.callRecords.where('chatId').noneOf([...existingChatIds]).delete().then(c => cleanupCounts.callRecords += c);
            const allRules = await db.renderingRules.toArray();
            for(const rule of allRules) {
                if (rule.chatId !== 'global' && !existingChatIds.has(rule.chatId)) {
                    await db.renderingRules.delete(rule.id);
                    cleanupCounts.renderingRules++;
                }
            }
        });

        let summary = "✅ 清理完成！\n\n";
        let cleanedSomething = false;
        Object.entries(cleanupCounts).forEach(([key, value]) => {
            if (value > 0) {
                const keyMap = {
                    posts: '動態', likes: '點贊', comments: '評論', memories: '記憶',
                    callRecords: '通話記錄', renderingRules: '渲染規則',
                    groupMembers: '群成員', chatLinks: '記憶連結'
                };
                summary += `- 清理了 ${value} 條無效的${keyMap[key] || key}。\n`;
                cleanedSomething = true;
            }
        });
        if (!cleanedSomething) {
            summary = "✅ 檢查完成，未發現任何冗餘數據。";
        }
        summary += "\n建議刷新頁面以確保所有更改生效。";

        await showCustomAlert("操作成功", summary);
        
        const confirmedReload = await showCustomConfirm("刷新頁面？", "為了確保所有資料同步，建議立即刷新頁面。");
        if(confirmedReload) {
            location.reload();
        }

    } catch (error) {
        console.error("清理冗餘數據時出錯:", error);
        await showCustomAlert('清理失敗', `發生了一個錯誤: ${error.message}`);
    }
}
        // ▼▼▼ 【這是匯出函數修復版】 ▼▼▼
        async function exportBackup() {
            try {
                const backupData = {
                    version: 1, 
                    timestamp: Date.now()
                };
        
                const [
                    chats, worldBooks, userStickers, apiConfig, globalSettings,
                    personaPresets, musicLibrary, qzoneSettings, qzonePosts,
                    qzoneAlbums, qzonePhotos, favorites, qzoneGroups,
                    memories, worldBookCategories,
                    apiPresets, shoppingProducts, callRecords,
                    renderingRules,
                    // ▼▼▼ 在這裡添加新代碼 ▼▼▼
                    doubanPosts,
                    stickerCategories,
                    // ▼▼▼ 在這裡添加新代碼 ▼▼▼
                    appearancePresets,
                    // ▼▼▼ 在這裡添加新代碼 ▼▼▼
                    presets,              // <-- 【本次新增修復】
                    presetCategories,
    // 【核心新增】
    npcs 
                ] = await Promise.all([
                    db.chats.toArray(),
                    db.worldBooks.toArray(),
                    db.userStickers.toArray(),
                    db.apiConfig.get('main'),
                    db.globalSettings.get('main'),
                    db.personaPresets.toArray(),
                    db.musicLibrary.get('main'),
                    db.qzoneSettings.get('main'),
                    db.qzonePosts.toArray(),
                    db.qzoneAlbums.toArray(),
                    db.qzonePhotos.toArray(),
                    db.favorites.toArray(),
                    db.qzoneGroups.toArray(),
                    db.memories.toArray(),
                    db.worldBookCategories.toArray(),
                    db.apiPresets.toArray(),
                    db.shoppingProducts.toArray(),
                    db.callRecords.toArray(),
                    db.renderingRules.toArray(),
                    // ▼▼▼ 在這裡添加新代碼 ▼▼▼
                    db.doubanPosts.toArray(),
                    db.stickerCategories.toArray(),
                    // ▼▼▼ 在這裡添加新代碼 ▼▼▼
                    db.appearancePresets.toArray(),
                    // ▼▼▼ 在這裡添加新代碼 ▼▼▼
                    db.presets.toArray(),             // <-- 【本次新增修復】
                    db.presetCategories.toArray(),
    // 【核心新增】
    db.npcs.toArray() 
                ]);
        
                Object.assign(backupData, {
                    chats, worldBooks, userStickers, apiConfig, globalSettings,
                    personaPresets, musicLibrary, qzoneSettings, qzonePosts,
                    qzoneAlbums, qzonePhotos, favorites, qzoneGroups,
                    memories, worldBookCategories,
                    apiPresets, shoppingProducts, callRecords,
                    renderingRules,
                    // ▼▼▼ 在這裡添加新代碼 ▼▼▼
                    doubanPosts,
                    stickerCategories,
                    // ▼▼▼ 在這裡添加新代碼 ▼▼▼
                    appearancePresets,
                    // ▼▼▼ 在這裡添加新代碼 ▼▼▼
                    presets,              // <-- 【本次新增修復】
                    presetCategories,
    // 【核心新增】
    npcs  
                });
                
                const blob = new Blob(
                    [JSON.stringify(backupData, null, 2)], 
                    { type: 'application/json' }
                );
                const url = URL.createObjectURL(blob);
                const link = Object.assign(document.createElement('a'), {
                    href: url,
                    download: `EPhone-Full-Backup-${new Date().toISOString().split('T')[0]}.json`
                });
                link.click();
                URL.revokeObjectURL(url);
                
                await showCustomAlert('匯出成功', '已成功匯出所有資料！');
        
            } catch (error) {
                console.error("匯出資料時出錯:", error);
                await showCustomAlert('匯出失敗', `發生了一個錯誤: ${error.message}`);
            }
        }
// ▼▼▼ 【全新】這是專門用於導入“流式備份”檔的核心函數，請完整黏貼 ▼▼▼

/**
 * 【全新】處理新版流式備份檔案的導入邏輯
 * @param {object} backupData - 從流式備份檔案 .data 欄位中解析出的資料物件
 */
async function importStreamedBackup(backupData) {
    try {
        await db.transaction('rw', db.tables, async () => {
            // 1. 清空所有現有資料
            for (const table of db.tables) {
                await table.clear();
            }

            // 2. 遍歷備份資料中的所有表，並批量導入
            for (const tableName in backupData) {
                if (Array.isArray(backupData[tableName])) {
                    console.log(`正在導入表: ${tableName}, 記錄數: ${backupData[tableName].length}`);
                    await db.table(tableName).bulkPut(backupData[tableName]);
                }
            }
        });

    } catch (error) {
        // 如果在事務中發生任何錯誤，直接向上拋出
        throw new Error(`資料庫寫入失敗: ${error.message}`);
    }
}

// ▲▲▲ 新增函數黏貼結束 ▲▲▲        
// ▼▼▼ 【最終解決方案】請用這一整塊全新的代碼，完整替換舊的 importBackup 函數 ▼▼▼

/**
 * 【智慧總管 | V2.0】處理檔導入，自動識別備份檔案版本
 * @param {File} file - 用戶選擇的 .json 備份檔案
 */
async function handleSmartImport(file) {
    if (!file) return;

    const confirmed = await showCustomConfirm(
        '嚴重警告！',
        '導入備份將完全覆蓋您當前的所有資料。此操作不可撤銷！確定要繼續嗎？',
        { confirmButtonClass: 'btn-danger' }
    );
    if (!confirmed) return;

    await showCustomAlert("請稍候...", "正在讀取並解析備份檔案...");

    try {
        const text = await file.text();
        const data = JSON.parse(text);

        // --- 核心識別邏輯 ---
        // 檢查是否是新的、帶 "data" 包裝的流式備份
        if (data.data && typeof data.data === 'object' && data.data.chats) {
            console.log("檢測到新版流式備份檔案，開始導入...");
            await importStreamedBackup(data.data); // 調用新函數，並傳入核心資料
        }
        // 否則，檢查是否是舊的、扁平結構的備份
        else if (data.chats) {
            console.log("檢測到舊版完整備份檔案，開始導入...");
            await importLegacyBackup(data); // 調用改造後的舊函數
        }
        // 如果兩種都不是
        else {
            throw new Error("檔案格式無法識別。請確保您選擇的是有效的 EPhone 備份檔案。");
        }

        // --- 導入成功後的統一處理 ---
        await showCustomAlert('導入成功', '所有資料已成功恢復！應用即將刷新以應用所有更改。');
        setTimeout(() => {
            window.location.reload();
        }, 1500);

    } catch (error) {
        console.error("導入資料時出錯:", error);
        await showCustomAlert('導入失敗', `文件解析或應用失敗: ${error.message}`);
    }
}

/**
 * 【改造後】處理舊版備份檔案的導入邏輯
 * @param {object} backupData - 從舊版備份檔案解析出的資料物件
 */
async function importLegacyBackup(backupData) {
    try {
        await db.transaction('rw', db.tables, async () => {
            await db.chats.clear();
            await db.worldBooks.clear();
            // ... (為所有表添加 .clear() 調用)
            for (const table of db.tables) {
                await table.clear();
            }

            if (Array.isArray(backupData.chats)) await db.chats.bulkPut(backupData.chats);
            if (Array.isArray(backupData.worldBooks)) await db.worldBooks.bulkPut(backupData.worldBooks);
            // ... (為所有表添加 .bulkPut() 調用，這部分邏輯與您舊的 importBackup 函數完全相同)
            if (Array.isArray(backupData.userStickers)) await db.userStickers.bulkPut(backupData.userStickers);
            if (backupData.apiConfig) await db.apiConfig.put(backupData.apiConfig);
            if (backupData.globalSettings) await db.globalSettings.put(backupData.globalSettings);
            // ... (請確保這裡包含了所有表的導入邏輯)
             if (Array.isArray(backupData.personaPresets)) await db.personaPresets.bulkPut(backupData.personaPresets);
            if (backupData.musicLibrary) await db.musicLibrary.put(backupData.musicLibrary);
            if (backupData.qzoneSettings) await db.qzoneSettings.put(backupData.qzoneSettings);
            if (Array.isArray(backupData.qzonePosts)) await db.qzonePosts.bulkPut(backupData.qzonePosts);
            if (Array.isArray(backupData.qzoneAlbums)) await db.qzoneAlbums.bulkPut(backupData.qzoneAlbums);
            if (Array.isArray(backupData.qzonePhotos)) await db.qzonePhotos.bulkPut(backupData.qzonePhotos);
            if (Array.isArray(backupData.favorites)) await db.favorites.bulkPut(backupData.favorites);
            if (Array.isArray(backupData.qzoneGroups)) await db.qzoneGroups.bulkPut(backupData.qzoneGroups);
            if (Array.isArray(backupData.memories)) await db.memories.bulkPut(backupData.memories);
            if (Array.isArray(backupData.worldBookCategories)) await db.worldBookCategories.bulkPut(backupData.worldBookCategories);
            if (Array.isArray(backupData.apiPresets)) await db.apiPresets.bulkPut(backupData.apiPresets);
            if (Array.isArray(backupData.shoppingProducts)) await db.shoppingProducts.bulkPut(backupData.shoppingProducts);
            if (Array.isArray(backupData.callRecords)) await db.callRecords.bulkPut(backupData.callRecords);
            if (Array.isArray(backupData.renderingRules)) await db.renderingRules.bulkPut(backupData.renderingRules);
            if (Array.isArray(backupData.doubanPosts)) await db.doubanPosts.bulkPut(backupData.doubanPosts);
            if (Array.isArray(backupData.stickerCategories)) await db.stickerCategories.bulkPut(backupData.stickerCategories);
            if (Array.isArray(backupData.appearancePresets)) await db.appearancePresets.bulkPut(backupData.appearancePresets);
            if (Array.isArray(backupData.presets)) await db.presets.bulkPut(backupData.presets);
            if (Array.isArray(backupData.presetCategories)) await db.presetCategories.bulkPut(backupData.presetCategories);
            if (Array.isArray(backupData.npcs)) await db.npcs.bulkPut(backupData.npcs);
        });
    } catch (error) {
        throw new Error(`舊版備份資料寫入資料庫失敗: ${error.message}`);
    }
}
// ▲▲▲ 替換結束 ▲▲▲
        
                function applyCustomFont(fontUrl, isPreviewOnly = false) {
                    if (!fontUrl) {
                        dynamicFontStyle.innerHTML = '';
                        document.getElementById('font-preview').style.fontFamily = '';
                        return;
                    }
                    const fontName = 'custom-user-font';
                    const newStyle = `
                        @font-face {
                          font-family: '${fontName}';
                          src: url('${fontUrl}');
                          font-display: swap;
                        }`;
                    if (isPreviewOnly) {
                        const previewStyle = document.getElementById('preview-font-style') || document.createElement('style');
                        previewStyle.id = 'preview-font-style';
                        previewStyle.innerHTML = newStyle;
                        if (!document.getElementById('preview-font-style')) document.head.appendChild(previewStyle);
                        document.getElementById('font-preview').style.fontFamily = `'${fontName}', 'bulangni', sans-serif`;
                    } else {
                        dynamicFontStyle.innerHTML = `
                            ${newStyle}
                            body {
                              font-family: '${fontName}', 'bulangni', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
                            }`;
                    }
                }
        
                async function resetToDefaultFont() {
                    dynamicFontStyle.innerHTML = ''; 
                    state.globalSettings.fontUrl = '';
                    await db.globalSettings.put(state.globalSettings);
                    document.getElementById('font-url-input').value = '';
                    document.getElementById('font-preview').style.fontFamily = '';
                    alert('已恢復預設字體。');
                }
        
// ▼▼▼ 【請用這個已更新的版本】替換舊的 loadAllDataFromDB 函數 ▼▼▼
async function loadAllDataFromDB() {
    const [
        chatsArr, apiConfig, loadedGlobalSettings, userStickers, worldBooks,
        musicLib, personaPresets, qzoneSettings, initialFavorites,
        allMemories,
        // 【核心新增】在這裡載入所有預設
        allPresets
    ] = await Promise.all([
        db.chats.toArray(), db.apiConfig.get('main'), db.globalSettings.get('main'),
        db.userStickers.toArray(), db.worldBooks.toArray(), db.musicLibrary.get('main'),
        db.personaPresets.toArray(), db.qzoneSettings.get('main'), db.favorites.orderBy('timestamp').reverse().toArray(),
        db.memories.toArray(),
        // 【核心新增】從資料庫讀取 presets 表
        db.presets.toArray()
    ]);

    // 【核心新增】將載入的預設保存到全域 state 中
    state.presets = allPresets || [];

    // --- (後續所有的資料處理邏輯保持不變) ---
    const defaultGlobalSettings = {
        id: 'main',
        showStatusBar: false,
        wallpaper: 'linear-gradient(135deg, #89f7fe, #66a6ff)',
        fontUrl: '',
        enableBackgroundActivity: false,
        backgroundActivityInterval: 60,
        blockCooldownHours: 1,
        apiTemperature: 0.8,
        appIcons: { ...DEFAULT_APP_ICONS },
        cphoneWallpaper: 'linear-gradient(135deg, #f6d365, #fda085)',
        cphoneAppIcons: { ...DEFAULT_CPHONE_ICONS },
        globalCss: '',
        notificationSoundUrl: '',
        widgetData: {},
        globalChatBackground: '',
        enableAiDrawing: true,
    chatActionButtonsOrder: null,
    shoppingCategoryCount: 3,
    shoppingProductCount: 8,
        chatRenderWindow: 50
    };
    state.globalSettings = { ...defaultGlobalSettings, ...(loadedGlobalSettings || {}) };
    state.globalSettings.appIcons = { ...defaultGlobalSettings.appIcons, ...(state.globalSettings.appIcons || {}) };
    state.globalSettings.cphoneAppIcons = { ...defaultGlobalSettings.cphoneAppIcons, ...(state.globalSettings.cphoneAppIcons || {}) };

    chatsArr.forEach(chat => {
            if (typeof chat.settings.enableTimePerception === 'undefined') {
                chat.settings.enableTimePerception = true;
            }
        if (!chat.settings.lyricsPosition) {
            chat.settings.lyricsPosition = { vertical: 'top', horizontal: 'center', offset: 10 };
        }
        if (!chat.isGroup && !chat.settings.myAvatarLibrary) {
            chat.settings.myAvatarLibrary = [];
        }
        if (!chat.isGroup && typeof chat.originalName === 'undefined') {
            chat.originalName = chat.name;
        }
    });
    state.chats = chatsArr.reduce((acc, chat) => {
        if (typeof chat.unreadCount === 'undefined') chat.unreadCount = 0;
        if (chat.isGroup) {
            if (typeof chat.settings.enableBackgroundActivity === 'undefined') {
                chat.settings.enableBackgroundActivity = true;
            }
            if (chat.members && chat.members.length > 0 && chat.members[0].name) {
                chat.members.forEach(member => {
                    if (typeof member.originalName === 'undefined') {
                        member.originalName = member.name;
                        member.groupNickname = member.name;
                        delete member.name;
                    }
                });
            }
        }
        if (!chat.settings) chat.settings = {};
        if (typeof chat.settings.actionCooldownMinutes === 'undefined') {
            chat.settings.actionCooldownMinutes = 10;
        }
        if (!chat.isGroup && !chat.status) chat.status = { text: '線上', lastUpdate: Date.now(), isBusy: false };
        if (!chat.isGroup && !chat.relationship) chat.relationship = { status: 'friend', blockedTimestamp: null, applicationReason: '' };
        if (!chat.isGroup && (!chat.settings || !chat.settings.aiAvatarLibrary)) { if (!chat.settings) chat.settings = {}; chat.settings.aiAvatarLibrary = []; }
        if (chat.isGroup) { (chat.members || []).forEach(member => { if (typeof member.avatarFrame === 'undefined') member.avatarFrame = ''; }); }
        if (!chat.musicData) chat.musicData = { totalTime: 0 };
        if (chat.settings && chat.settings.linkedWorldBookId && !chat.settings.linkedWorldBookIds) { chat.settings.linkedWorldBookIds = [chat.settings.linkedWorldBookId]; delete chat.settings.linkedWorldBookId; }
        if (typeof chat.isPinned === 'undefined') chat.isPinned = false;
        if (!chat.isGroup && typeof chat.settings.myNickname === 'undefined') {
            chat.settings.myNickname = '我';
        }
        if (chat.isGroup && chat.members) {
            let needsUpdate = false;
            chatsArr.forEach(c => {
                 if (c.id === chat.id && c.originalName) {
                    delete c.originalName;
                 }
            });
            chat.members.forEach(member => {
                const originalCharacter = chatsArr.find(c => c.id === member.id);
                if (originalCharacter && originalCharacter.settings) {
                    const correctFrame = originalCharacter.settings.aiAvatarFrame || '';
                    if (member.avatarFrame !== correctFrame) {
                        member.avatarFrame = correctFrame;
                        needsUpdate = true;
                    }
                } else if (typeof member.avatarFrame === 'undefined') {
                    member.avatarFrame = '';
                    needsUpdate = true;
                }
            });
            if (needsUpdate) db.chats.put(chat);
        }
        if (!chat.settings.enableAutoMemory) chat.settings.enableAutoMemory = false;
        if (!chat.settings.autoMemoryInterval) chat.settings.autoMemoryInterval = 20;
        if (!chat.longTermMemory) chat.longTermMemory = [];
        if (!chat.lastMemorySummaryTimestamp) chat.lastMemorySummaryTimestamp = 0;
        if (!chat.isGroup) {
            if (typeof chat.settings.enableBackgroundActivity === 'undefined') {
                chat.settings.enableBackgroundActivity = true;
            }
            if (typeof chat.settings.enableTts === 'undefined') { chat.settings.enableTts = false; }
            if (!chat.status) chat.status = { text: '線上', lastUpdate: Date.now(), isBusy: false };
            if (!chat.relationship) chat.relationship = { status: 'friend', blockedTimestamp: null, applicationReason: '' };
            if (!chat.settings || !chat.settings.aiAvatarLibrary) { if (!chat.settings) chat.settings = {}; chat.settings.aiAvatarLibrary = []; }
            if (typeof chat.settings.isOfflineMode === 'undefined') chat.settings.isOfflineMode = false;
            if (typeof chat.settings.offlineMinLength === 'undefined') chat.settings.offlineMinLength = 100;
            if (typeof chat.settings.offlineMaxLength === 'undefined') chat.settings.offlineMaxLength = 300;
            if (typeof chat.heartfeltVoice === 'undefined') chat.heartfeltVoice = '...';
            if (typeof chat.randomJottings === 'undefined') chat.randomJottings = '...';
            if (!Array.isArray(chat.thoughtsHistory)) {
                chat.thoughtsHistory = [];
            }
        }
        acc[chat.id] = chat;
        return acc;
    }, {});
    const memoriesToUpdate = [];
    allMemories.forEach(memory => {
        if (memory.type === 'ai_generated' && memory.authorName && !memory.authorId) {
            const foundChat = chatsArr.find(c => !c.isGroup && c.originalName === memory.authorName);
            if (foundChat) {
                memory.authorId = foundChat.id;
                memoriesToUpdate.push(memory);
            } else {
                 const fallbackChat = chatsArr.find(c => !c.isGroup && c.name === memory.authorName);
                 if(fallbackChat) {
                    memory.authorId = fallbackChat.id;
                    memoriesToUpdate.push(memory);
                 }
            }
        }
    });
    if (memoriesToUpdate.length > 0) {
        await db.memories.bulkPut(memoriesToUpdate);
    }
    state.apiConfig = apiConfig || { id: 'main', proxyUrl: '', apiKey: '', model: '', secondaryProxyUrl: '', secondaryApiKey: '', secondaryModel: '', minimaxGroupId: '', minimaxApiKey: '', minimaxModel: 'speech-01' };
    state.userStickers = userStickers || [];
    state.worldBooks = worldBooks || [];
    musicState.playlist = musicLib?.playlist || [];
    state.personaPresets = personaPresets || [];
    state.qzoneSettings = qzoneSettings || { id: 'main', nickname: '{{user}}', avatar: 'https://files.catbox.moe/q6z5fc.jpeg', banner: 'https://files.catbox.moe/r5heyt.gif' };
    allFavoriteItems = initialFavorites || [];
}
// ▲▲▲ 替換結束 ▲▲▲
        
                async function saveGlobalPlaylist() { await db.musicLibrary.put({ id: 'main', playlist: musicState.playlist }); }
        
                function formatTimestamp(timestamp) { if (!timestamp) return ''; const date = new Date(timestamp); const hours = String(date.getHours()).padStart(2, '0'); const minutes = String(date.getMinutes()).padStart(2, '0'); return `${hours}:${minutes}`; }
/**
 * 【全新 V2.0 | 智慧日期感知版】為AI上下文格式化時間戳記
 * @param {number} timestamp - 消息的時間戳記
 * @returns {string} - 格式化後的日期時間字串，例如 "今天 17:42", "昨天 23:50" 等
 */
function formatTimestampForAI(timestamp) {
    if (!timestamp) return '';
    
    const now = new Date();
    const date = new Date(timestamp);

    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    const timeString = `${hours}:${minutes}`;

    // 如果是今天
    if (now.toDateString() === date.toDateString()) {
        return `今天 ${timeString}`;
    }

    // 如果是昨天
    const yesterday = new Date();
    yesterday.setDate(now.getDate() - 1);
    if (yesterday.toDateString() === date.toDateString()) {
        return `昨天 ${timeString}`;
    }
    
    // 如果是今年
    if (now.getFullYear() === date.getFullYear()) {
        const month = String(date.getMonth() + 1);
        const day = String(date.getDate());
        return `${month}月${day}日 ${timeString}`;
    }
    
    // 如果是往年
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1);
    const day = String(date.getDate());
    return `${year}年${month}月${day}日 ${timeString}`;
}        
         // ▼▼▼ 【全新】請用這個更可靠的版本，替換舊的 showNotification 函數 ▼▼▼
        function showNotification(chatId, messageContent) {
    // ▼▼▼ 在這裡黏貼新代碼 ▼▼▼
    playNotificationSound();
    // ▲▲▲ 新代碼黏貼結束 ▲▲▲
            clearTimeout(notificationTimeout);
            const chat = state.chats[chatId];
            if (!chat) return;
        
            // 1. 獲取通知欄元素
            const bar = document.getElementById('notification-bar');
            
            // 2. 填充內容
            document.getElementById('notification-avatar').src = chat.settings.aiAvatar || chat.settings.groupAvatar || defaultAvatar;
            document.getElementById('notification-content').querySelector('.name').textContent = chat.name;
            document.getElementById('notification-content').querySelector('.message').textContent = messageContent;
            
            // 3. 【核心修復】使用“強制重排”技巧，確保動畫每次都能觸發
            // 先移除class，讓它回到初始的“隱藏”狀態
            bar.classList.remove('visible');
            
            // 這一行是關鍵！它會強制流覽器重新計算元素佈局，從而“重置”動畫狀態。
            void bar.offsetWidth; 
            
            // 再次添加class，流覽器會認為這是一個新的狀態變化，從而平滑地執行CSS過渡動畫。
            bar.classList.add('visible');
            
            // 4. 為通知欄綁定點擊事件（使用克隆節點技巧清除舊監聽器）
            const newBar = bar.cloneNode(true);
            bar.parentNode.replaceChild(newBar, bar);
            newBar.addEventListener('click', () => {
                openChat(chatId);
                newBar.classList.remove('visible');
            });
        
            // 5. 設置計時器，在4秒後自動隱藏通知
            notificationTimeout = setTimeout(() => {
                newBar.classList.remove('visible');
            }, 4000);
        }
        
               function updateClock() { 
    const now = new Date(); 
    const timeString = now.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' }); 
    const dateString = now.toLocaleDateString('zh-CN', { weekday: 'long', month: 'long', day: 'numeric' }); 
    
    // document.getElementById('main-time').textContent = timeString; // 注釋掉這行
    document.getElementById('status-bar-time').textContent = timeString; 
    // document.getElementById('main-date').textContent = dateString; // 注釋掉這行
}
        
        
        /**
         * 【終極健壯版】解析AI返回的、可能格式不規範的回應內容
         * @param {string} content - AI返回的原始字串
         * @returns {Array} - 一個標準化的消息物件陣列
         */
        function parseAiResponse(content) {
            const trimmedContent = content.trim();
        
            // 方案1：【最優先】嘗試作為標準的、單一的JSON陣列解析
            // 這是最理想、最高效的情況
            if (trimmedContent.startsWith('[') && trimmedContent.endsWith(']')) {
                try {
                    const parsed = JSON.parse(trimmedContent);
                    if (Array.isArray(parsed)) {
                        console.log("解析成功：標準JSON陣列格式。");
                        return parsed;
                    }
                } catch (e) {
                    // 如果解析失敗，說明它雖然看起來像個陣列，但內部格式有問題。
                    // 此時我們不報錯，而是繼續嘗試下面的“強力解析”方案。
                    console.warn("標準JSON陣列解析失敗，將嘗試強力解析...");
                }
            }
        
            // 方案2：【強力解析】使用規則運算式，從混亂的字串中提取出所有獨立的JSON物件
            // 這能完美解決您遇到的 "(Timestamp: ...)[{...}](Timestamp: ...)[{...}]" 這種格式
            const jsonMatches = trimmedContent.match(/{[^{}]*}/g);
        
            if (jsonMatches) {
                const results = [];
                for (const match of jsonMatches) {
                    try {
                        // 嘗試解析每一個被我們“揪”出來的JSON字串
                        const parsedObject = JSON.parse(match);
                        results.push(parsedObject);
                    } catch (e) {
                        // 如果某個片段不是有效的JSON，就忽略它，繼續處理下一個
                        console.warn("跳過一個無效的JSON片段:", match);
                    }
                }
        
                // 如果我們成功提取出了至少一個有效的JSON物件，就返回這個結果
                if (results.length > 0) {
                    console.log("解析成功：通過強力提取模式。");
                    return results;
                }
            }
            
            // 方案3：【最終備用】如果以上所有方法都失敗了，說明AI返回的可能就是純文字
            // 我們將原始的、未處理的內容，包裝成一個標準的文本消息物件返回，確保程式不會崩潰
            console.error("所有解析方案均失敗！將返回原始文本。");
            return [{ type: 'text', content: content }];
        }
        /**
         * 【全新】根據當前時間獲取一天中的問候語
         * @returns {string} - 返回如 "淩晨", "早上", "下午", "晚上" 等字串
         */
        function getTimeOfDayGreeting(date = new Date()) { // 允許傳入一個日期物件
            const hour = date.getHours(); // 使用傳入的日期物件來獲取小時
            if (hour >= 0 && hour < 5) {
                return "淩晨";
            } else if (hour >= 5 && hour < 9) {
                return "早上";
            } else if (hour >= 9 && hour < 13) {
                return "上午";
            } else if (hour >= 13 && hour < 18) {
                return "下午";
            } else if (hour >= 18 && hour < 24) {
                return "晚上";
            }
            return "現在"; // 預設情況
        }
        // ▼▼▼ 【全新】API預設功能核心函數 ▼▼▼
        
/**
         * 從資料庫載入API預設，並填充到下拉選擇框中
         */
        async function loadApiPresetsDropdown() {
            const selectEl = document.getElementById('api-preset-select');
            selectEl.innerHTML = '<option value="current">當前配置 (未保存)</option>';
            
            const presets = await db.apiPresets.toArray();
            presets.forEach(preset => {
                const option = document.createElement('option');
                option.value = preset.id;
                option.textContent = preset.name;
                selectEl.appendChild(option);
            });
        
            // 檢查當前配置是否與某個預設完全匹配
            const currentConfig = state.apiConfig;
            let matchingPresetId = null;
            for (const preset of presets) {
                // ▼▼▼ 核心修改：在判斷條件中加入對TTS設置的檢查 ▼▼▼
                if (
                    preset.proxyUrl === currentConfig.proxyUrl &&
                    preset.apiKey === currentConfig.apiKey &&
                    preset.model === currentConfig.model &&
                    preset.secondaryProxyUrl === currentConfig.secondaryProxyUrl &&
                    preset.secondaryApiKey === currentConfig.secondaryApiKey &&
                    preset.secondaryModel === currentConfig.secondaryModel &&
                    // -- 新增的判斷條件 --
                    (preset.minimaxGroupId || '') === (currentConfig.minimaxGroupId || '') &&
                    (preset.minimaxApiKey || '') === (currentConfig.minimaxApiKey || '') &&
                    (preset.minimaxModel || 'speech-01') === (currentConfig.minimaxModel || 'speech-01')
                ) 
                // ▲▲▲ 修改結束 ▲▲▲
                {
                    matchingPresetId = preset.id;
                    break;
                }
            }
        
            if (matchingPresetId) {
                selectEl.value = matchingPresetId;
            } else {
                selectEl.value = 'current';
            }
        }
        
/**
         * 當用戶從下拉清單選擇一個預設時，載入該預設的配置
         */
        async function handlePresetSelectionChange() {
            const selectEl = document.getElementById('api-preset-select');
            const selectedId = parseInt(selectEl.value);
        
            // 如果選擇的是“當前配置”，則不做任何事
            if (isNaN(selectedId)) {
                return;
            }
        
            const preset = await db.apiPresets.get(selectedId);
            if (preset) {
                // 將預設的配置載入到當前的全域狀態中
                state.apiConfig = {
                    id: 'main',
                    proxyUrl: preset.proxyUrl,
                    apiKey: preset.apiKey,
                    model: preset.model,
                    secondaryProxyUrl: preset.secondaryProxyUrl,
                    secondaryApiKey: preset.secondaryApiKey,
                    secondaryModel: preset.secondaryModel,
                    // ▼▼▼ 核心修改：在這裡載入缺失的TTS設置 ▼▼▼
                    minimaxGroupId: preset.minimaxGroupId,
                    minimaxApiKey: preset.minimaxApiKey,
                    minimaxModel: preset.minimaxModel
                    // ▲▲▲ 修改結束 ▲▲▲
                };
                // 將載入的配置保存為當前正在使用的配置
                await db.apiConfig.put(state.apiConfig);
                // 重新渲染整個設置頁面以顯示新載入的配置
                renderApiSettings();
                // 自動為新載入的配置拉取模型清單
                document.getElementById('fetch-models-btn').click();
                if (preset.secondaryProxyUrl && preset.secondaryApiKey) {
                    document.getElementById('fetch-secondary-models-btn').click();
                }
                alert(`已載入預設 “${preset.name}”`);
            }
        }
        
        /**
         * 將當前輸入框中的配置保存為一個新的預設
         */
        async function saveApiPreset() {
            const name = await showCustomPrompt('保存 API 預設', '請輸入預設名稱');
            if (!name || !name.trim()) return;
        
            // 從輸入框讀取當前配置
            const presetData = {
                name: name.trim(),
                proxyUrl: document.getElementById('proxy-url').value.trim(),
                apiKey: document.getElementById('api-key').value.trim(),
                model: document.getElementById('model-select').value,
                secondaryProxyUrl: document.getElementById('secondary-proxy-url').value.trim(),
                secondaryApiKey: document.getElementById('secondary-api-key').value.trim(),
                secondaryModel: document.getElementById('secondary-model-select').value,
                // ▼▼▼ 核心修改：在這裡添加缺失的TTS設置 ▼▼▼
                minimaxGroupId: document.getElementById('minimax-group-id').value.trim(),
                minimaxApiKey: document.getElementById('minimax-api-key').value.trim(),
                minimaxModel: document.getElementById('minimax-model-select').value
                // ▲▲▲ 修改結束 ▲▲▲
            };
        
            // 檢查是否已存在同名預設
            const existingPreset = await db.apiPresets.where('name').equals(presetData.name).first();
            if (existingPreset) {
                const confirmed = await showCustomConfirm('覆蓋預設', `名為 “${presetData.name}” 的預設已存在。要覆蓋它嗎？`, { confirmButtonClass: 'btn-danger' });
                if (!confirmed) return;
                presetData.id = existingPreset.id; // 指定ID以覆蓋舊資料
            }
        
            await db.apiPresets.put(presetData);
            await loadApiPresetsDropdown(); // 刷新下拉清單
            alert('API 預設已保存！');
        }
        
        /**
         * 刪除當前選中的預設
         */
        async function deleteApiPreset() {
            const selectEl = document.getElementById('api-preset-select');
            const selectedId = parseInt(selectEl.value);
        
            if (isNaN(selectedId)) {
                alert('請先從下拉清單中選擇一個要刪除的預設。');
                return;
            }
        
            const preset = await db.apiPresets.get(selectedId);
            if (!preset) return;
        
            const confirmed = await showCustomConfirm('刪除預設', `確定要刪除預設 “${preset.name}” 嗎？`, { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                await db.apiPresets.delete(selectedId);
                await loadApiPresetsDropdown(); // 刷新下拉清單
                alert('預設已刪除。');
            }
        }
        // ▲▲▲ 新增函數結束 ▲▲▲
        // ▼▼▼ 【請用這個新版本】替換舊的 renderApiSettings 函數 ▼▼▼
        function renderApiSettings() { 
            // 1. 渲染當前配置到輸入框
            document.getElementById('proxy-url').value = state.apiConfig.proxyUrl || ''; 
            document.getElementById('api-key').value = state.apiConfig.apiKey || ''; 
            document.getElementById('secondary-proxy-url').value = state.apiConfig.secondaryProxyUrl || '';
            document.getElementById('secondary-api-key').value = state.apiConfig.secondaryApiKey || '';
            document.getElementById('background-activity-switch').checked = state.globalSettings.enableBackgroundActivity || false;
            document.getElementById('background-interval-input').value = state.globalSettings.backgroundActivityInterval || 60;
            document.getElementById('block-cooldown-input').value = state.globalSettings.blockCooldownHours || 1;
            document.getElementById('enable-ai-drawing-switch').checked = state.globalSettings.enableAiDrawing; 
            document.getElementById('chat-render-window-input').value = state.globalSettings.chatRenderWindow || 50;   
            document.getElementById('chat-list-render-window-input').value = state.globalSettings.chatListRenderWindow || 30;
            const tempSlider = document.getElementById('api-temperature-slider');
            const tempValue = document.getElementById('api-temperature-value');
            const savedTemp = state.globalSettings.apiTemperature || 0.8;
            tempSlider.value = savedTemp;
            tempValue.textContent = savedTemp;    
           document.getElementById('minimax-group-id').value = state.apiConfig.minimaxGroupId || '';
           document.getElementById('minimax-api-key').value = state.apiConfig.minimaxApiKey || '';
document.getElementById('minimax-model-select').value = state.apiConfig.minimaxModel || 'speech-01'; // <-- 新增這一行
            // 2. 【核心新增】載入並渲染預設下拉式功能表
            loadApiPresetsDropdown();
        }
        // ▲▲▲ 替換結束 ▲▲▲
                window.renderApiSettingsProxy = renderApiSettings;
// ▼▼▼ 【全新】這是NPC管理功能的【全部核心JS代碼】，請完整黏貼 ▼▼▼

/**
 * 【總入口 | 已修復長按事件】渲染NPC清單螢幕
 */
async function renderNpcListScreen() {
    const listEl = document.getElementById('npc-list');
    listEl.innerHTML = '';
    
    const npcs = await db.npcs.toArray();

    if (npcs.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">還沒有創建任何NPC，<br>點擊右上角“+”添加第一個吧！</p>';
        return;
    }

    npcs.forEach(npc => {
        const item = document.createElement('div');
        item.className = 'chat-list-item';
        item.dataset.npcId = npc.id;
        
        item.innerHTML = `
            <img src="${npc.avatar || defaultGroupMemberAvatar}" class="avatar" style="border-radius: 50%;">
            <div class="info">
                <div class="name-line">
                    <span class="name">${npc.name}</span>
                </div>
                <div class="last-msg">${npc.persona.substring(0, 30)}...</div>
            </div>
        `;
        
        item.addEventListener('click', () => openNpcEditor(npc.id));
        
        // 【核心修復】確保 addLongPressListener 的回呼函數是 async 函數
        addLongPressListener(item, async () => {
            await deleteNpc(npc.id);
        });
        
        listEl.appendChild(item);
    });
}

/**
         * 【已更新】打開NPC編輯器（用於新建或編輯）
         * @param {number|null} npcId - 如果是編輯，則傳入ID；如果是新建，則為null
         */
        async function openNpcEditor(npcId = null) {
            editingNpcId = npcId;
            const modal = document.getElementById('npc-editor-modal');
            const titleEl = document.getElementById('npc-editor-title');
            const nameInput = document.getElementById('npc-name-input');
            const personaInput = document.getElementById('npc-persona-input');
            const avatarPreview = document.getElementById('npc-avatar-preview');
            const associationListEl = document.getElementById('npc-association-list');
            
            // 【核心新增】獲取新添加的開關和輸入框元素
            const activitySwitch = document.getElementById('npc-background-activity-switch');
            const cooldownInput = document.getElementById('npc-action-cooldown-input');
            
            associationListEl.innerHTML = ''; // 清空舊的關聯列表

            // 生成可關聯的角色清單 (邏輯不變)
            associationListEl.innerHTML += `<label><input type="checkbox" value="user"> ${state.qzoneSettings.nickname || '我'} (用戶)</label>`;
            Object.values(state.chats).filter(c => !c.isGroup).forEach(char => {
                associationListEl.innerHTML += `<label><input type="checkbox" value="${char.id}"> ${char.name} (角色)</label>`;
            });

            if (npcId) {
                // 編輯模式
                titleEl.textContent = '編輯 NPC';
                const npc = await db.npcs.get(npcId);
                if (npc) {
                    nameInput.value = npc.name;
                    personaInput.value = npc.persona;
                    avatarPreview.src = npc.avatar || defaultGroupMemberAvatar;

                    // 【核心新增】讀取並應用已保存的設置
                    // 使用 !== false 判斷，確保新創建的、沒有該欄位的NPC默認為開啟
                    activitySwitch.checked = npc.enableBackgroundActivity !== false; 
                    cooldownInput.value = npc.actionCooldownMinutes || 15;

                    if (npc.associatedWith && Array.isArray(npc.associatedWith)) {
                        npc.associatedWith.forEach(id => {
                            const checkbox = associationListEl.querySelector(`input[value="${id}"]`);
                            if (checkbox) checkbox.checked = true;
                        });
                    }
                }
            } else {
                // 新建模式
                titleEl.textContent = '添加 NPC';
                nameInput.value = '';
                personaInput.value = '';
                avatarPreview.src = defaultGroupMemberAvatar;

                // 【核心新增】為新NPC設置預設值
                activitySwitch.checked = true; // 默認開啟
                cooldownInput.value = 15;     // 默認15分鐘

                const userCheckbox = associationListEl.querySelector('input[value="user"]');
                if (userCheckbox) userCheckbox.checked = true;
            }

            modal.classList.add('visible');
        }

// ▼▼▼ 【V2.1 | 頭像修復版】請用這個新版本替換舊的 saveNpc 函數 ▼▼▼
/**
 * 【已更新】保存NPC資訊，並能處理“創建後直接加入群聊”的流程
 */
async function saveNpc() {
    const name = document.getElementById('npc-name-input').value.trim();
    const persona = document.getElementById('npc-persona-input').value.trim();
    if (!name || !persona) {
        alert("NPC的昵稱和人設都不能為空！");
        return;
    }

    const selectedAssociations = Array.from(document.querySelectorAll('#npc-association-list input:checked')).map(cb => cb.value);
    const enableBackgroundActivity = document.getElementById('npc-background-activity-switch').checked;
    const actionCooldownMinutes = parseInt(document.getElementById('npc-action-cooldown-input').value) || 15;

    const npcData = {
        name,
        persona,
        avatar: document.getElementById('npc-avatar-preview').src,
        associatedWith: selectedAssociations,
        enableBackgroundActivity: enableBackgroundActivity,
        actionCooldownMinutes: actionCooldownMinutes
    };

    if (editingNpcId) {
        await db.npcs.update(editingNpcId, npcData);
    } else {
        // 新建NPC
        const newNpcId = await db.npcs.add(npcData);

        if (isAddingNpcToGroup && state.activeChatId) {
            const chat = state.chats[state.activeChatId];
            if (chat.isGroup) {
                // 【【【這就是最關鍵的修復！】】】
                // 在這裡，我們也把 npcData.avatar 添加到了成員對象中
                chat.members.push({
                    id: `npc_${newNpcId}`,
                    originalName: name,
                    groupNickname: name,
                    persona: persona,
                    avatar: npcData.avatar, // <-- 核心新增
                    isNpc: true
                });
                await db.chats.put(chat);
            }
        }
    }
    
    document.getElementById('npc-editor-modal').classList.remove('visible');
    
    if (isAddingNpcToGroup) {
        isAddingNpcToGroup = false; 
        openMemberManagementScreen();
    } else {
        await renderNpcListScreen();
    }
}
// ▲▲▲ 替換結束 ▲▲▲

/**
 * 刪除NPC
 * @param {number} npcId - 要刪除的NPC的ID
 */
async function deleteNpc(npcId) {
    const npc = await db.npcs.get(npcId);
    if (!npc) return;
    const confirmed = await showCustomConfirm('刪除NPC', `確定要刪除NPC “${npc.name}” 嗎？`, { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        await db.npcs.delete(npcId);
        await renderNpcListScreen();
    }
}
// ▲▲▲ 全新JS代碼黏貼結束 ▲▲▲        
// ▼▼▼ 【請用這個已升級“分批載入”功能的全新版本】替換舊的 renderChatList 函數 ▼▼▼
        let chatListRenderCount = 0; // 新增一個全域變數，跟蹤已渲染的數量

// ▼▼▼ 【全新】這是為“按需載入”新增的所有輔助函數 ▼▼▼

/**
 * 創建一個分組的容器（不包含聊天項）
 */
function createChatGroupContainer(group) {
    const groupContainer = document.createElement('div');
    groupContainer.className = 'chat-group-container';
    groupContainer.innerHTML = `
        <div class="chat-group-header">
            <span class="arrow">▼</span>
            <span class="group-name">${group.name}</span>
        </div>
        <div class="chat-group-content"></div>
    `;
    return groupContainer;
}



/**
 * 載入並渲染下一批次的聊天記錄
 */
function loadMoreChats(sortedItems) {
    const chatListEl = document.getElementById('chat-list');
    const loadMoreBtn = document.getElementById('load-more-chats-btn');
    if (loadMoreBtn) loadMoreBtn.remove();
    
    const nextSliceStart = chatListRenderCount;
    const nextSliceEnd = chatListRenderCount + CHAT_LIST_RENDER_WINDOW;
    const itemsToAppend = sortedItems.slice(nextSliceStart, nextSliceEnd);

    // 使用 DocumentFragment 提高性能
    const fragment = document.createDocumentFragment();
    let currentGroupContent = chatListEl.querySelector('.chat-group-content:last-of-type');

    itemsToAppend.forEach(item => {
        if (item.type === 'groupHeader') {
            const groupContainer = createChatGroupContainer(item.group);
            fragment.appendChild(groupContainer);
            currentGroupContent = groupContainer.querySelector('.chat-group-content');
        } else if (item.type === 'chatItem') {
            const listItem = createChatListItem(item.chat);
            if (currentGroupContent && item.chat.groupId) {
                currentGroupContent.appendChild(listItem);
            } else {
                fragment.appendChild(listItem);
                currentGroupContent = null;
            }
        }
    });
    
    // 將新生成的項一次性添加到列表中
    chatListEl.appendChild(fragment);
    chatListRenderCount += itemsToAppend.length;

    if (sortedItems.length > chatListRenderCount) {
        appendLoadMoreChatsButton(chatListEl, sortedItems);
    }
    
    // 重新為所有分組標題綁定事件
    document.querySelectorAll('.chat-group-header').forEach(header => {
        const newHeader = header.cloneNode(true);
        header.parentNode.replaceChild(newHeader, header);
        newHeader.addEventListener('click', () => {
            newHeader.classList.toggle('collapsed');
            newHeader.nextElementSibling.classList.toggle('collapsed');
        });
    });
}
// ▲▲▲ 新增函數結束 ▲▲▲
// ▼▼▼ 【全新 | 已升級“分批載入”功能】請用這個全新版本替換舊的 renderChatList 函數 ▼▼▼
async function renderChatList() {
    const chatListEl = document.getElementById('chat-list');
    chatListEl.innerHTML = '';

    // 1. 獲取並排序所有聊天資料（這部分邏輯不變）
    const allChats = Object.values(state.chats).sort((a, b) => {
        const pinDiff = (b.isPinned || false) - (a.isPinned || false);
        if (pinDiff !== 0) return pinDiff;
        return (b.history.slice(-1)[0]?.timestamp || 0) - (a.history.slice(-1)[0]?.timestamp || 0);
    });
    
    const allGroups = await db.qzoneGroups.toArray();

    if (allChats.length === 0) {
        chatListEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">點擊右上角 "+" 或群組圖示添加聊天</p>';
        return;
    }

    allGroups.forEach(group => {
        const latestChatInGroup = allChats.find(chat => chat.groupId === group.id);
        group.latestTimestamp = latestChatInGroup ? (latestChatInGroup.history.slice(-1)[0]?.timestamp || 0) : 0;
    });
    allGroups.sort((a, b) => b.latestTimestamp - a.latestTimestamp);
    
    // 2. 【核心修改】將所有可渲染項存入全域變數，而不是立即渲染
    sortedChatListItems = []; // 先清空
    const processedChatIds = new Set();

    allGroups.forEach(group => {
        const groupChats = allChats.filter(chat => !chat.isGroup && chat.groupId === group.id);
        if (groupChats.length > 0) {
            sortedChatListItems.push({ type: 'groupHeader', group });
            groupChats.forEach(chat => {
                sortedChatListItems.push({ type: 'chatItem', chat });
                processedChatIds.add(chat.id);
            });
        }
    });

    allChats.forEach(chat => {
        if (!processedChatIds.has(chat.id)) {
            sortedChatListItems.push({ type: 'chatItem', chat });
        }
    });

    // 3. 【核心修改】重置渲染計數器，並只渲染第一批次的聊天項
    chatListRenderCount = 0;
    loadMoreChats(); // 直接調用 loadMoreChats 來渲染第一頁
}
// ▲▲▲ 替換結束 ▲▲▲
// ▼▼▼ 【全新】這是為“分批載入”新增的所有輔助函數 ▼▼▼

        /**
         * 創建一個分組的容器（不包含聊天項）
         */
        function createChatGroupContainer(group) {
            const groupContainer = document.createElement('div');
            groupContainer.className = 'chat-group-container';
            groupContainer.innerHTML = `
                <div class="chat-group-header">
                    <span class="arrow">▼</span>
                    <span class="group-name">${group.name}</span>
                </div>
                <div class="chat-group-content"></div>
            `;
            return groupContainer;
        }

        /**
         * 創建並添加“載入更多”按鈕
         */
        function appendLoadMoreChatsButton(container, sortedItems) {
            const button = document.createElement('button');
            button.id = 'load-more-chats-btn';
            button.textContent = '載入更早的會話';
            button.className = 'load-more-btn'; // 複用樣式
            
            // 【重要】為按鈕綁定載入下一頁的事件
            button.addEventListener('click', () => loadMoreChats(sortedItems), { once: true });
            
            container.prepend(button); // 將按鈕添加到清單頂部
        }

// ▼▼▼ 【全新 | 獨立設置+載入動畫版】請用這個版本替換舊的 loadMoreChats 函數 ▼▼▼
        function loadMoreChats() {
            if (isLoadingMoreChats) return;

            const chatListEl = document.getElementById('chat-list');
            const scrollContainer = document.getElementById('messages-view');
            if (!chatListEl || !scrollContainer) return;
            if (chatListRenderCount >= sortedChatListItems.length) return;

            isLoadingMoreChats = true;

            // 核心修改1：判斷是否是首次載入
            const isInitialLoad = chatListRenderCount === 0;

            // 將核心渲染邏輯封裝成一個函數
            const renderContent = () => {
                hideLoader(chatListEl);

                const renderWindow = state.globalSettings.chatListRenderWindow || 30;
                const nextSliceStart = chatListRenderCount;
                const nextSliceEnd = chatListRenderCount + renderWindow;
                const itemsToAppend = sortedChatListItems.slice(nextSliceStart, nextSliceEnd);

                const fragment = document.createDocumentFragment();
                let currentGroupContent = chatListEl.querySelector('.chat-group-content:last-of-type');

                itemsToAppend.forEach(item => {
                    if (item.type === 'groupHeader') {
                        const groupContainer = createChatGroupContainer(item.group);
                        fragment.appendChild(groupContainer);
                        currentGroupContent = groupContainer.querySelector('.chat-group-content');
                    } else if (item.type === 'chatItem') {
                        const listItem = createChatListItem(item.chat);
                        if (item.chat.groupId && currentGroupContent) {
                            currentGroupContent.appendChild(listItem);
                        } else {
                            fragment.appendChild(listItem);
                            if (!item.chat.groupId) currentGroupContent = null;
                        }
                    }
                });

                chatListEl.appendChild(fragment);
                chatListRenderCount += itemsToAppend.length;

                chatListEl.querySelectorAll('.chat-group-header:not([data-has-listener="true"])').forEach(header => {
                    header.dataset.hasListener = "true";
                    header.addEventListener('click', () => {
                        header.classList.toggle('collapsed');
                        header.nextElementSibling.classList.toggle('collapsed');
                    });
                });

                isLoadingMoreChats = false;

                if (scrollContainer.scrollHeight <= scrollContainer.clientHeight && chatListRenderCount < sortedChatListItems.length) {
                    loadMoreChats();
                }
            };

            // 核心修改2：根據是否是首次載入，決定是否使用延遲
            if (isInitialLoad) {
                // 如果是首次載入，則立即執行渲染，沒有任何延遲
                renderContent();
            } else {
                // 如果是後續載入（滾動時），則顯示載入動畫並保留延遲，以優化體驗
                showLoader(chatListEl, 'bottom');
                setTimeout(renderContent, 500);
            }
        }
// ▲▲▲ 替換結束 ▲▲▲ 
// ▼▼▼ 【全新 | V2.0 容錯增強版】請用這個新版本替換舊的 createChatListItem 函數 ▼▼▼
function createChatListItem(chat) {
    // 【核心新增】使用 try...catch 包裹整個函數
    try {
        const lastMsgObj = chat.history.filter(msg => !msg.isHidden).slice(-1)[0] || {};
        let lastMsgDisplay;

        if (!chat.isGroup && chat.relationship?.status === 'pending_user_approval') {
            lastMsgDisplay = `<span style="color: #ff8c00;">[好友申請] ${chat.relationship.applicationReason || '請求添加你為好友'}</span>`;
        } else if (!chat.isGroup && chat.relationship?.status === 'blocked_by_ai') {
            lastMsgDisplay = `<span style="color: #dc3545;">[你已被對方拉黑]</span>`;
        } else if (chat.isGroup) {
            if (lastMsgObj.type === 'pat_message') { lastMsgDisplay = `[系統消息] ${lastMsgObj.content}`; }
            else if (lastMsgObj.type === 'transfer') { lastMsgDisplay = '[轉帳]'; }
            else if (lastMsgObj.type === 'ai_image' || lastMsgObj.type === 'user_photo') { lastMsgDisplay = '[照片]'; }
            else if (lastMsgObj.type === 'voice_message') { lastMsgDisplay = '[語音]'; }
            else if (typeof lastMsgObj.content === 'string' && STICKER_REGEX.test(lastMsgObj.content)) { lastMsgDisplay = lastMsgObj.meaning ? `[表情: ${lastMsgObj.meaning}]` : '[表情]'; }
            else if (Array.isArray(lastMsgObj.content)) { lastMsgDisplay = `[圖片]`; }
            else { lastMsgDisplay = String(lastMsgObj.content || '...').substring(0, 20); }

            if (lastMsgObj.senderName && lastMsgObj.type !== 'pat_message') {
                const senderDisplayName = getDisplayNameInGroup(chat, lastMsgObj.senderName);
                lastMsgDisplay = `${senderDisplayName}: ${lastMsgDisplay}`;
            }
        } else {
            const statusText = chat.status?.text || '線上';
            lastMsgDisplay = `[${statusText}]`;
        }

        const item = document.createElement('div');
        item.className = 'chat-list-item';
        item.dataset.chatId = chat.id;
        if (chat.isPinned) {
            item.classList.add('pinned');
        }

        const avatar = chat.isGroup ? chat.settings.groupAvatar : chat.settings.aiAvatar;
        const avatarFrameSrc = chat.isGroup ? '' : (chat.settings.aiAvatarFrame || '');
        let avatarHtml;
        if (avatarFrameSrc) {
            avatarHtml = `<div class="avatar-with-frame"><img src="${avatar || defaultAvatar}" class="avatar-img"><img src="${avatarFrameSrc}" class="avatar-frame"></div>`;
        } else {
            avatarHtml = `<img src="${avatar || defaultAvatar}" class="avatar">`;
        }
        const hasFrameClass = avatarFrameSrc ? 'has-frame' : '';
        const avatarGroupHtml = `<div class="avatar-group ${hasFrameClass}">${avatarHtml}</div>`;

        item.innerHTML = `
            ${avatarGroupHtml}
            <div class="info">
                <div class="name-line">
                    <span class="name">${chat.name}</span>
                    ${chat.isGroup ? '<span class="group-tag">群聊</span>' : ''}
                </div>
                <div class="last-msg" style="color: ${chat.isGroup ? 'var(--text-secondary)' : '#b5b5b5'}; font-style: italic;">${lastMsgDisplay}</div>
            </div>
            <div class="unread-count-wrapper">
                <span class="unread-count" style="display: none;">0</span>
            </div>
        `;
        
        const unreadCount = chat.unreadCount || 0;
        const unreadEl = item.querySelector('.unread-count');
        if (unreadCount > 0) {
            unreadEl.textContent = unreadCount > 99 ? '99+' : unreadCount;
            unreadEl.style.display = 'inline-flex';
        } else {
            unreadEl.style.display = 'none';
        }
        
        const avatarGroupEl = item.querySelector('.avatar-group');
        if (avatarGroupEl) {
            avatarGroupEl.style.cursor = 'pointer';
            avatarGroupEl.addEventListener('dblclick', (e) => {
                e.stopPropagation();
                const nameToPat = chat.isGroup ? chat.name : chat.originalName;
                handleUserPat(chat.id, nameToPat);
            });
        }
        
        const infoEl = item.querySelector('.info');
        if (infoEl) {
            infoEl.addEventListener('click', () => openChat(chat.id));
        }
    
        addLongPressListener(item, async (e) => {
            const action = await showChatListActions(chat);
            switch (action) {
                case 'pin':
                    chat.isPinned = !chat.isPinned;
                    await db.chats.put(chat);
                    renderChatList();
                    break;
                case 'delete':
                    const deleteConfirmed = await showCustomConfirm('刪除對話', `確定要刪除與 "${chat.name}" 的整個對話嗎？此操作不可撤銷。`, { confirmButtonClass: 'btn-danger' });
                    if (deleteConfirmed) {
                        if (musicState.isActive && musicState.activeChatId === chat.id) {
                            await endListenTogetherSession(false);
                        }
                        delete state.chats[chat.id];
                        if (state.activeChatId === chat.id) state.activeChatId = null;
                        await db.chats.delete(chat.id);
                        renderChatList();
                    }
                    break;
                default:
                    break;
            }
        });
        return item;

    } catch (error) {
        // 【核心新增】如果渲染過程中出錯，就在控制台列印錯誤，並返回 null
        console.error(`渲染聊天項 [${chat.name || '未知'}] (ID: ${chat.id}) 時出錯:`, error);
        return null; // 返回 null，這樣就不會把一個壞掉的元素添加到頁面上
    }
}
// ▲▲▲ 替換結束 ▲▲▲
        
// ▼▼▼ 【無限滾動修復版】請用這個新版本替換舊的 renderChatInterface 函數 ▼▼▼
        async function renderChatInterface(chatId) {
            applyButtonOrder();
            cleanupWaimaiTimers();
            const chat = state.chats[chatId];
            if (!chat) return;

            exitSelectionMode();

            const messagesContainer = document.getElementById('chat-messages');
            const chatInputArea = document.getElementById('chat-input-area');
            const lockOverlay = document.getElementById('chat-lock-overlay');
            const lockContent = document.getElementById('chat-lock-content');

            messagesContainer.dataset.theme = chat.settings.theme || 'default';
            const fontSize = chat.settings.fontSize || 13;
            messagesContainer.style.setProperty('--chat-font-size', `${fontSize}px`);
            applyScopedCss(chat.settings.customCss || '', '#chat-messages', 'custom-bubble-style');

            document.getElementById('chat-header-title').textContent = chat.name;
            const statusContainer = document.getElementById('chat-header-status');
            const statusTextEl = statusContainer.querySelector('.status-text');

            if (chat.isGroup) {
                statusContainer.style.display = 'none';
                document.getElementById('chat-header-title-wrapper').style.justifyContent = 'center';
            } else {
                statusContainer.style.display = 'flex';
                document.getElementById('chat-header-title-wrapper').style.justifyContent = 'flex-start';
                statusTextEl.textContent = chat.status?.text || '線上';
                statusContainer.classList.toggle('busy', chat.status?.isBusy || false);
            }

            const chatScreen = document.getElementById('chat-interface-screen');
            const individualBg = chat.settings.background;
            const globalBg = state.globalSettings.globalChatBackground;
            const isDarkMode = document.getElementById('phone-screen').classList.contains('dark-mode');
            const defaultColor = isDarkMode ? '#000000' : '#f0f2f5';

            if (individualBg) {
                chatScreen.style.backgroundImage = `url(${individualBg})`;
                chatScreen.style.backgroundColor = 'transparent';
            } else if (globalBg) {
                chatScreen.style.backgroundImage = `url(${globalBg})`;
                chatScreen.style.backgroundColor = 'transparent';
            } else {
                chatScreen.style.backgroundImage = 'none';
                chatScreen.style.backgroundColor = defaultColor;
            }

            // ... (中間所有關於鎖定、旁觀模式的 if/else 邏輯保持不變) ...
            if (chat.isSpectatorGroup) {
                chatInputArea.style.display = 'none';
                lockOverlay.style.display = 'flex';
                lockContent.innerHTML = `
                    <span class="lock-text">正在圍觀AI們的群聊...</span>
                    <div class="spectator-actions-container">
                        <button id="spectator-reroll-btn" class="lock-action-btn secondary" title="重新生成上一輪對話">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M20 11A8.1 8.1 0 0 0 4.5 9M4 5v4h4"></path>
                                <path d="M4 13a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4"></path>
                            </svg>
                        </button>
                        <button id="spectator-propel-btn" class="lock-action-btn">🎬 推進劇情</button>
                        <button id="spectator-edit-btn" class="lock-action-btn secondary" title="導演剪輯室：編輯AI上一輪的回應">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M20.24 12.24a6 6 0 0 0-8.49-8.49L5 10.5V19h8.5z"></path>
                                <line x1="16" y1="8" x2="2" y2="22"></line>
                                <line x1="17.5" y1="15" x2="9" y2="15"></line>
                            </svg>
                        </button>
                    </div>
                `;
                document.getElementById('spectator-propel-btn').onclick = triggerSpectatorGroupAiAction;
            } else {
                chatInputArea.style.display = 'flex';
                lockOverlay.style.display = 'none';
                lockContent.innerHTML = '';
                if (!chat.isGroup && chat.relationship.status !== 'friend') {
                    lockOverlay.style.display = 'flex';
                    chatInputArea.style.visibility = 'hidden';
                    
                    let lockHtml = '';
                    switch (chat.relationship.status) {
                         case 'blocked_by_user':
                            const isSimulationRunning = simulationIntervalId !== null;
                            const blockedTimestamp = chat.relationship.blockedTimestamp;
                            const cooldownHours = state.globalSettings.blockCooldownHours || 1;
                            const cooldownMilliseconds = cooldownHours * 60 * 60 * 1000;
                            const timeSinceBlock = Date.now() - blockedTimestamp;
                            const isCooldownOver = timeSinceBlock > cooldownMilliseconds;
                            const timeRemainingMinutes = Math.max(0, Math.ceil((cooldownMilliseconds - timeSinceBlock) / (1000 * 60)));
            
                            lockHtml = `
                                <span class="lock-text">你已將“${chat.name}”拉黑。</span>
                                <button id="unblock-btn" class="lock-action-btn">解除拉黑</button>
                                <div style="margin-top: 20px; padding: 10px; border: 1px dashed #ccc; border-radius: 8px; font-size: 11px; text-align: left; color: #666; background: rgba(0,0,0,0.02);">
                                    <strong style="color: #333;">【開發者診斷面板】</strong><br>
                                    - 後臺活動總開關: ${state.globalSettings.enableBackgroundActivity ? '<span style="color: green;">已開啟</span>' : '<span style="color: red;">已關閉</span>'}<br>
                                    - 系統心跳計時器: ${isSimulationRunning ? '<span style="color: green;">運行中</span>' : '<span style="color: red;">未運行</span>'}<br>
                                    - 當前角色狀態: <strong>${chat.relationship.status}</strong><br>
                                    - 需要冷靜(小時): <strong>${cooldownHours}</strong><br>
                                    - 冷靜期是否結束: ${isCooldownOver ? '<span style="color: green;">是</span>' : `<span style="color: orange;">否 (還剩約 ${timeRemainingMinutes} 分鐘)</span>`}<br>
                                    - 觸發條件: ${isCooldownOver && state.globalSettings.enableBackgroundActivity ? '<span style="color: green;">已滿足，等待下次系統心跳</span>' : '<span style="color: red;">未滿足</span>'}
                                </div>
                                <button id="force-apply-check-btn" class="lock-action-btn secondary" style="margin-top: 10px;">強制觸發一次好友申請檢測</button>
                            `;
                            break;
                        case 'blocked_by_ai':
                            lockHtml = `
                                <span class="lock-text">你被對方拉黑了。</span>
                                <button id="apply-friend-btn" class="lock-action-btn">重新申請加為好友</button>
                            `;
                            break;
                        case 'pending_user_approval':
                            lockHtml = `
                                <span class="lock-text">“${chat.name}”請求添加你為好友：<br><i>“${chat.relationship.applicationReason}”</i></span>
                                <button id="accept-friend-btn" class="lock-action-btn">接受</button>
                                <button id="reject-friend-btn" class="lock-action-btn secondary">拒絕</button>
                            `;
                            break;
                        case 'pending_ai_approval':
                            lockHtml = `<span class="lock-text">好友申請已發送，等待對方通過...</span>`;
                            break;
                    }
                    lockContent.innerHTML = lockHtml;
                } else {
                     lockOverlay.style.display = 'none';
                     chatInputArea.style.visibility = 'visible';
                }
            }
            
            messagesContainer.innerHTML = '';
            const history = chat.history;
            currentRenderedCount = 0;
            const renderWindow = state.globalSettings.chatRenderWindow || 50;
            const initialMessages = history.slice(-renderWindow);

            // --- ▼▼▼ 核心修改就在這裡！ ▼▼▼ ---
            // 1. 創建一個陣列來存放所有“創建消息元素”的非同步任務 (Promise)
            const messagePromises = [];
            let lastTimestamp = 0;

            for (const msg of initialMessages) {
                if (lastTimestamp > 0 && (msg.timestamp - lastTimestamp > 600000)) {
                    // 時間戳記是同步創建的，可以直接添加
                    messagePromises.push(Promise.resolve(createSystemTimestampElement(msg.timestamp)));
                }
                // 2. 將非同步任務推入陣列，但不在這裡等待它完成
                messagePromises.push(createMessageElement(msg, chat, true));
                lastTimestamp = msg.timestamp;
            }

            // 3. 使用 Promise.all() 併發執行所有的非同步任務
            const messageElements = await Promise.all(messagePromises);

            // 4. 所有任務完成後，一次性將所有創建好的元素添加到頁面中
            const fragment = document.createDocumentFragment();
            messageElements.filter(Boolean).forEach(el => fragment.appendChild(el));
            messagesContainer.appendChild(fragment);
            // --- ▲▲▲ 修改結束 ▲▲▲ ---

            currentRenderedCount = initialMessages.length;

            const typingIndicator = document.createElement('div');
            typingIndicator.id = 'typing-indicator';
            typingIndicator.style.display = 'none';
            typingIndicator.textContent = '對方正在輸入...';
            messagesContainer.appendChild(typingIndicator);

            setTimeout(() => messagesContainer.scrollTop = messagesContainer.scrollHeight, 0);
        }
// ▲▲▲ 替換結束 ▲▲▲
        
                
        
// ▼▼▼ 【無限滾動修復版】請用這個新版本替換舊的 loadMoreMessages 函數 ▼▼▼
async function loadMoreMessages() {
    if (isLoadingMoreMessages) return;
    isLoadingMoreMessages = true;

    const messagesContainer = document.getElementById('chat-messages');
    const chat = state.chats[state.activeChatId];
    if (!chat) {
        isLoadingMoreMessages = false;
        return;
    }

    showLoader(messagesContainer, 'top'); // 在頂部顯示載入動畫
    const oldScrollHeight = messagesContainer.scrollHeight;

    // 類比網路延遲，讓動畫更明顯
    await new Promise(resolve => setTimeout(resolve, 500));

    const totalMessages = chat.history.length;
    const renderWindow = state.globalSettings.chatRenderWindow || 50;
    const nextSliceStart = totalMessages - currentRenderedCount - renderWindow;
    const nextSliceEnd = totalMessages - currentRenderedCount;
    const messagesToPrepend = chat.history.slice(Math.max(0, nextSliceStart), nextSliceEnd);


    // 1. 獲取當前螢幕上最“老”的那條消息的時間戳記，作為我們比較的基準
    const firstVisibleMessage = messagesContainer.querySelector('.message-wrapper[data-timestamp]');
    let nextMessageTimestamp = firstVisibleMessage ? parseInt(firstVisibleMessage.dataset.timestamp) : 0;

    // 2. 依然是從新到舊地遍歷我們要添加的消息
    for (const msg of messagesToPrepend.reverse()) {
        
        // 3. 【核心新增】在添加每條消息之前，都檢查它和它後面那條消息的時間差
        if (nextMessageTimestamp > 0 && (nextMessageTimestamp - msg.timestamp > 600000)) { // 600000毫秒 = 10分鐘
            // 如果間隔大於10分鐘，就為“更晚”的那條消息創建一個時間提示
            const timestampEl = createSystemTimestampElement(nextMessageTimestamp);
            // 將時間提示也添加到頂部
            messagesContainer.prepend(timestampEl);
        }
        
        // 4. 添加消息本身（這部分邏輯不變）
        await prependMessage(msg, chat);
        
        // 5. 更新我們的時間基準，為下一次迴圈做準備
        nextMessageTimestamp = msg.timestamp;
    }

    currentRenderedCount += messagesToPrepend.length;

    // 恢復滾動位置，防止跳動
    const newScrollHeight = messagesContainer.scrollHeight;
    messagesContainer.scrollTop = newScrollHeight - oldScrollHeight;

    hideLoader(messagesContainer); // 載入完成後隱藏動畫
    isLoadingMoreMessages = false;
}
// ▲▲▲ 替換結束 ▲▲▲
        
// ▼▼▼ 【請用這個已更新的版本】替換舊的 renderWallpaperScreen 函數 ▼▼▼
// ▼▼▼ 【最終修復版】請用這個全新的函數，完整替換舊的 renderWallpaperScreen 函數 ▼▼▼
function renderWallpaperScreen() {
    loadCssPresetsDropdown();
loadAppearancePresetsDropdown();
    // --- EPhone 壁紙預覽 ---
    const ephonePreview = document.getElementById('wallpaper-preview');
    // 【核心修正1】我們不再使用 newWallpaperBase64，而是直接從 state 讀取，邏輯更統一
    const ephoneBg = state.globalSettings.wallpaper;
    if (ephoneBg) {
        // 【核心修正2】無論是 Base64 還是 URL，都統一用 url() 包裹
        ephonePreview.style.backgroundImage = `url(${ephoneBg})`;
        ephonePreview.textContent = ''; // 清空"當前為漸變色"之類的文字
    } else {
        // 如果沒有設置，則恢復默認
        ephonePreview.style.backgroundImage = 'linear-gradient(135deg, #89f7fe, #66a6ff)';
        ephonePreview.textContent = '當前為漸變色';
    }

    // --- CPhone 壁紙預覽 (邏輯與EPhone完全相同) ---
    const cphonePreview = document.getElementById('cphone-wallpaper-preview');
    const cphoneBg = state.globalSettings.cphoneWallpaper;
    if (cphoneBg) {
        cphonePreview.style.backgroundImage = `url(${cphoneBg})`;
        cphonePreview.textContent = '';
    } else {
        cphonePreview.style.backgroundImage = 'linear-gradient(135deg, #f6d365, #fda085)';
        cphonePreview.textContent = '當前為漸變色';
    }

    // --- 全域聊天背景預覽 (邏輯不變，但為了統一也一併更新) ---
    const globalBgPreview = document.getElementById('global-bg-preview');
    const globalBg = state.globalSettings.globalChatBackground;
    if (globalBg) {
        globalBgPreview.style.backgroundImage = `url(${globalBg})`;
        globalBgPreview.textContent = '';
        document.getElementById('remove-global-bg-btn').style.display = 'inline-block';
    } else {
        globalBgPreview.style.backgroundImage = 'none';
        globalBgPreview.textContent = '點擊下方上傳';
        document.getElementById('remove-global-bg-btn').style.display = 'none';
    }

    // --- 後續的其他渲染邏輯保持不變 ---
    renderIconSettings();
    renderCPhoneIconSettings(); 
    document.getElementById('global-css-input').value = state.globalSettings.globalCss || '';
    document.getElementById('notification-sound-url-input').value = state.globalSettings.notificationSoundUrl || '';
    document.getElementById('status-bar-toggle-switch').checked = state.globalSettings.showStatusBar || false;
    renderButtonOrderEditor();
    initializeButtonOrderEditor();
}
// ▲▲▲ 替換結束 ▲▲▲
        // ▲▲▲ 替換結束 ▲▲▲
                window.renderWallpaperScreenProxy = renderWallpaperScreen;
        
                // ▼▼▼ 【最終修復版】請用這個全新的函數，替換舊的 applyGlobalWallpaper 函數 ▼▼▼
function applyGlobalWallpaper() {
    const homeScreen = document.getElementById('home-screen');
    const wallpaper = state.globalSettings.wallpaper;
    if (wallpaper) {
        // 【核心修正】統一使用 url() 包裹
        homeScreen.style.backgroundImage = `url(${wallpaper})`;
    } else {
        // 恢復默認漸變
        homeScreen.style.backgroundImage = 'linear-gradient(135deg, #89f7fe, #66a6ff)';
    }
}
// ▲▲▲ 替換結束 ▲▲▲
        
        // ▼▼▼ 【全新】這個函數用於處理世界書頁簽的點擊切換 ▼▼▼
        function switchWorldBookCategory(categoryId) {
            // 1. 切換頁簽的啟動狀態
            document.querySelectorAll('.world-book-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.categoryId === categoryId);
            });
            // 2. 切換內容面板的顯示狀態
            document.querySelectorAll('.world-book-category-pane').forEach(pane => {
                pane.classList.toggle('active', pane.dataset.categoryId === categoryId);
            });
        }
        
        // ▼▼▼ 【請用這個全新版本】完整替換舊的 renderWorldBookScreen 函數 ▼▼▼
        async function renderWorldBookScreen() {
            const tabsContainer = document.getElementById('world-book-tabs');
            const contentContainer = document.getElementById('world-book-content-container');
            tabsContainer.innerHTML = '';
            contentContainer.innerHTML = '';
        
            // 1. 同時獲取所有書籍和所有分類
            const [books, categories] = await Promise.all([
                db.worldBooks.toArray(),
                db.worldBookCategories.orderBy('name').toArray()
            ]);
        
            state.worldBooks = books; // 確保記憶體中的資料是同步的
        
            if (books.length === 0) {
                contentContainer.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">點擊右上角 "+" 創建你的第一本世界書</p>';
                return;
            }
        
            // --- 2. 創建並添加“全部”頁簽和其內容面板 ---
            const allTab = document.createElement('button');
            allTab.className = 'world-book-tab active';
            allTab.textContent = '全部';
            allTab.dataset.categoryId = 'all';
            tabsContainer.appendChild(allTab);
        
            const allPane = document.createElement('div');
            allPane.className = 'world-book-category-pane active';
            allPane.dataset.categoryId = 'all';
            contentContainer.appendChild(allPane);
        
            // --- 3. 創建並添加各個分類的頁簽和內容面板 ---
            categories.forEach(category => {
                const categoryTab = document.createElement('button');
                categoryTab.className = 'world-book-tab';
                categoryTab.textContent = category.name;
                categoryTab.dataset.categoryId = String(category.id);
                tabsContainer.appendChild(categoryTab);
        
                const categoryPane = document.createElement('div');
                categoryPane.className = 'world-book-category-pane';
                categoryPane.dataset.categoryId = String(category.id);
                contentContainer.appendChild(categoryPane);
            });
            
            // --- 4. 創建並添加“未分類”的頁簽和內容面板 (如果需要) ---
            const hasUncategorized = books.some(book => !book.categoryId);
            if (hasUncategorized) {
                const uncategorizedTab = document.createElement('button');
                uncategorizedTab.className = 'world-book-tab';
                uncategorizedTab.textContent = '未分類';
                uncategorizedTab.dataset.categoryId = 'uncategorized';
                tabsContainer.appendChild(uncategorizedTab);
            
                const uncategorizedPane = document.createElement('div');
                uncategorizedPane.className = 'world-book-category-pane';
                uncategorizedPane.dataset.categoryId = 'uncategorized';
                contentContainer.appendChild(uncategorizedPane);
            }
        
            // --- 5. 遍歷書籍，將它們填充到對應的內容面板中 ---
            books.forEach(book => {
                let contentPreview = '暫無內容...';
                if (Array.isArray(book.content) && book.content.length > 0) {
                    const firstEntry = book.content[0];
                    contentPreview = firstEntry.comment || firstEntry.content || '';
                } else if (typeof book.content === 'string' && book.content.trim() !== '') {
                    contentPreview = book.content;
                }
        
                const card = document.createElement('div');
                card.className = 'world-book-card';
                card.innerHTML = `
                    <div class="card-title">${book.name}</div>
                    <div class="card-content-preview">${contentPreview}</div>
                `;
                
                // 為卡片本身添加點擊和長按事件
                const cardClickHandler = () => openWorldBookEditor(book.id);
                const cardLongPressHandler = async () => { 
                    const confirmed = await showCustomConfirm('刪除世界書', `確定要刪除《${book.name}》嗎？`, { confirmButtonClass: 'btn-danger' }); 
                    if (confirmed) { 
                        await db.worldBooks.delete(book.id); 
                        state.worldBooks = state.worldBooks.filter(wb => wb.id !== book.id); 
                        renderWorldBookScreen(); 
                    } 
                };
        
                card.addEventListener('click', cardClickHandler);
                addLongPressListener(card, cardLongPressHandler);
        
                // 克隆卡片並投放到“全部”面板
                const clonedCardForAll = card.cloneNode(true);
                clonedCardForAll.addEventListener('click', cardClickHandler);
                addLongPressListener(clonedCardForAll, cardLongPressHandler);
                allPane.appendChild(clonedCardForAll);
                
                // 將原始卡片投放到對應的分類面板
                const categoryKey = book.categoryId ? String(book.categoryId) : 'uncategorized';
                const targetPane = contentContainer.querySelector(`.world-book-category-pane[data-category-id="${categoryKey}"]`);
                if (targetPane) {
                    targetPane.appendChild(card);
                }
            });
        
            // --- 6. 為所有頁簽綁定切換事件 ---
            document.querySelectorAll('.world-book-tab').forEach(tab => {
                tab.addEventListener('click', () => switchWorldBookCategory(tab.dataset.categoryId));
            });
        }
        
        // ▼▼▼ 【請用這個最終修復版】完整替換舊的 createWorldBookGroup 函數 ▼▼▼
        /**
         * 【V2.0 | 已修復預覽BUG】創建一個分類的分組DOM
         * @param {string} groupName - 分類名稱
         * @param {Array} books - 該分類下的書籍陣列
         * @returns {HTMLElement} - 創建好的分組容器
         */
        function createWorldBookGroup(groupName, books) {
            const groupContainer = document.createElement('div');
            groupContainer.className = 'world-book-group-container';
            
            groupContainer.innerHTML = `
                <div class="world-book-group-header">
                    <span class="arrow">▼</span>
                    <span class="group-name">${groupName}</span>
                </div>
                <div class="world-book-group-content"></div>
            `;
        
            const contentEl = groupContainer.querySelector('.world-book-group-content');
            books.sort((a,b) => a.name.localeCompare(b.name, 'zh-CN')); // 按書名排序
            
            books.forEach(book => {
                // ▼▼▼ 【【【這就是最關鍵的修復！】】】 ▼▼▼
                let contentPreview = '暫無內容...';
                
                // 1. 檢查 book.content 是否是我們新的“條目陣列”格式
                if (Array.isArray(book.content) && book.content.length > 0) {
                    // 如果是，就從第一個條目的內容中提取預覽
                    // 我們也優先使用第一個條目的 comment 作為預覽，因為它更簡潔
                    const firstEntry = book.content[0];
                    contentPreview = firstEntry.comment || firstEntry.content || '';
                } 
                // 2. 否則，就檢查它是否是舊的“字串”格式
                else if (typeof book.content === 'string' && book.content.trim() !== '') {
                    // 如果是，就像以前一樣處理
                    contentPreview = book.content;
                }
                // ▲▲▲ 修復結束 ▲▲▲
        
                const item = document.createElement('div');
                item.className = 'list-item';
                item.dataset.bookId = book.id;
                // 現在，我們使用處理好的 contentPreview 來生成HTML，並確保它是一個字串
                item.innerHTML = `
                    <div class="item-title">${book.name}</div>
                    <div class="item-content">${String(contentPreview).substring(0, 50)}</div>
                `;
                item.addEventListener('click', () => openWorldBookEditor(book.id));
                addLongPressListener(item, async () => { 
                    const confirmed = await showCustomConfirm('刪除世界書', `確定要刪除《${book.name}》嗎？此操作不可撤銷。`, { confirmButtonClass: 'btn-danger' }); 
                    if (confirmed) { 
                        await db.worldBooks.delete(book.id); 
                        state.worldBooks = state.worldBooks.filter(wb => wb.id !== book.id); 
                        renderWorldBookScreen(); 
                    } 
                });
                contentEl.appendChild(item);
            });
        
            return groupContainer;
        }
        // ▲▲▲ 替換結束 ▲▲▲
                window.renderWorldBookScreenProxy = renderWorldBookScreen;
        
        // ▼▼▼ 【請用這個已修復BUG的版本】完整替換舊的 openWorldBookEditor 函數 ▼▼▼
        async function openWorldBookEditor(bookId) {
            // 【核心修復】將切換螢幕的操作移動到函數的最前面
            // 這樣可以確保在操作DOM元素之前，它們所在的螢幕已經是啟動狀態
            showScreen('world-book-editor-screen');
        
            editingWorldBookId = bookId;
            const [book, categories] = await Promise.all([
                db.worldBooks.get(bookId),
                db.worldBookCategories.toArray()
            ]);
        
            // 如果在切換螢幕後發現書籍不存在，則安全返回列表頁
            if (!book) {
                console.error("嘗試打開一個不存在的世界書，ID:", bookId);
                showScreen('world-book-screen');
                return;
            }
        
            // 現在，因為螢幕已顯示，所以可以安全地操作這些元素了
            document.getElementById('world-book-editor-title').textContent = book.name;
            document.getElementById('world-book-name-input').value = book.name;
        
            // 分類下拉式功能表的邏輯保持不變
            const selectEl = document.getElementById('world-book-category-select');
            selectEl.innerHTML = '<option value="">-- 未分類 --</option>';
            categories.forEach(cat => {
                const option = document.createElement('option');
                option.value = cat.id;
                option.textContent = cat.name;
                if (book.categoryId === cat.id) option.selected = true;
                selectEl.appendChild(option);
            });
        
            // 動態渲染條目的邏輯保持不變
            const entriesContainer = document.getElementById('world-book-entries-container');
            entriesContainer.innerHTML = ''; 
        
            if (Array.isArray(book.content) && book.content.length > 0) {
                book.content.forEach(entry => {
                    const block = createWorldBookEntryBlock(entry);
                    entriesContainer.appendChild(block);
                });
            } else {
                entriesContainer.innerHTML = '<p style="text-align:center; color: var(--text-secondary); margin-top: 20px;">還沒有內容，點擊下方按鈕添加第一條吧！</p>';
            }
        
            // 不再需要在函數末尾調用 showScreen，因為它已經在開頭被調用了
        }
        // ▲▲▲ 替換結束 ▲▲▲
        
// ▼▼▼ 【請用這個支持搜索的 V3.0 版本】替換舊的 renderStickerPanel 函數 ▼▼▼
/**
 * 【V3.0 | 搜索支援版】渲染表情面板
 * @param {boolean} rerenderTabs - 是否需要重新渲染頂部的分類頁簽
 */
async function renderStickerPanel(rerenderTabs = true) {
    const grid = document.getElementById('sticker-grid');
    const tabsContainer = document.getElementById('sticker-category-tabs');
    const searchInput = document.getElementById('sticker-search-input');
    const searchTerm = searchInput.value.trim().toLowerCase();

    // --- 1. 渲染分類頁簽 (僅在需要時) ---
    if (rerenderTabs) {
        tabsContainer.innerHTML = '';
        const categories = await db.stickerCategories.toArray();
        
        tabsContainer.innerHTML += `<button class="sticker-category-tab ${activeStickerCategoryId === 'all' ? 'active' : ''}" data-category-id="all">全部</button>`;
        categories.forEach(cat => {
             tabsContainer.innerHTML += `<button class="sticker-category-tab ${activeStickerCategoryId === cat.id ? 'active' : ''}" data-category-id="${cat.id}">${cat.name}</button>`;
        });
        tabsContainer.innerHTML += `<button class="sticker-category-tab ${activeStickerCategoryId === 'uncategorized' ? 'active' : ''}" data-category-id="uncategorized">未分類</button>`;
    }

    // --- 2. 【核心修改】篩選表情 ---
    grid.innerHTML = '';
    
    // 步驟 a: 先根據當前選中的分類篩選
    let stickersByCategory;
    if (activeStickerCategoryId === 'all') {
        stickersByCategory = state.userStickers;
    } else if (activeStickerCategoryId === 'uncategorized') {
        stickersByCategory = state.userStickers.filter(s => !s.categoryId);
    } else {
        stickersByCategory = state.userStickers.filter(s => s.categoryId === activeStickerCategoryId);
    }

    // 步驟 b: 如果有搜索詞，在分類結果的基礎上進一步篩選
    const stickersToShow = searchTerm
        ? stickersByCategory.filter(sticker => sticker.name.toLowerCase().includes(searchTerm))
        : stickersByCategory;

    // --- 3. 渲染最終結果 (這部分邏輯不變) ---
    if (stickersToShow.length === 0) {
        const message = searchTerm ? '找不到匹配的表情' : '這個分類下還沒有表情哦~';
        grid.innerHTML = `<p style="text-align:center; color: var(--text-secondary); grid-column: 1 / -1; padding-top: 20px;">${message}</p>`;
        return;
    }

    stickersToShow.forEach(sticker => {
        const item = document.createElement('div');
        item.className = 'sticker-item';
        item.title = sticker.name;
        item.dataset.stickerId = sticker.id;
        item.innerHTML = `
            <div class="sticker-image-container" style="background-image: url(${sticker.url})"></div>
            <span class="sticker-name">${sticker.name}</span>
        `;
        item.addEventListener('click', () => {
            if (isStickerManagementMode) {
                handleStickerSelection(item);
            } else {
                sendSticker(sticker);
            }
        });
        const deleteBtn = document.createElement('div');
        deleteBtn.className = 'delete-btn';
        deleteBtn.innerHTML = '&times;';
        deleteBtn.onclick = async (e) => {
            e.stopPropagation();
            const confirmed = await showCustomConfirm('刪除表情', `確定要刪除表情 "${sticker.name}" 嗎？`, { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                await db.userStickers.delete(sticker.id);
                state.userStickers = state.userStickers.filter(s => s.id !== sticker.id);
                renderStickerPanel();
            }
        };
        item.appendChild(deleteBtn);
        grid.appendChild(item);
    });
}
// ▲▲▲ 替換結束 ▲▲▲

        // ▼▼▼ 【全新】表情批量刪除核心功能 ▼▼▼
        let isStickerManagementMode = false;
        let selectedStickers = new Set();
        
        // ▼▼▼ 【請用這個 V2.0 版本】替換舊的 toggleStickerManagementMode 函數 ▼▼▼
        /**
         * 切換表情面板的管理模式
         */
        function toggleStickerManagementMode() {
            isStickerManagementMode = !isStickerManagementMode;
            const grid = document.getElementById('sticker-grid');
            const manageBtn = document.getElementById('manage-stickers-btn');
            const actionBar = document.getElementById('sticker-action-bar');
            const selectAllCheckbox = document.getElementById('select-all-stickers-checkbox');
        
            grid.classList.toggle('management-mode', isStickerManagementMode);
            
            if (isStickerManagementMode) {
                manageBtn.textContent = '完成';
                actionBar.style.display = 'flex'; // 改為 flex
                selectedStickers.clear();
                selectAllCheckbox.checked = false; // 重置全選框
                updateDeleteStickerButton();
            } else {
                manageBtn.textContent = '管理';
                actionBar.style.display = 'none';
                grid.querySelectorAll('.sticker-item.selected').forEach(item => item.classList.remove('selected'));
            }
        }
        // ▲▲▲ 替換結束 ▲▲▲
        // ▼▼▼ 【全新】這是智慧“全選”功能的核心函數，請完整黏貼 ▼▼▼
        /**
         * 處理“全選”核取方塊的點擊事件，根據當前分類智慧選擇
         */
        function handleSelectAllStickers() {
            const checkbox = document.getElementById('select-all-stickers-checkbox');
            const shouldSelect = checkbox.checked;
        
            // 1. 根據當前啟動的分類ID，篩選出應該被操作的表情
            let stickersToSelect;
            if (activeStickerCategoryId === 'all') {
                stickersToSelect = state.userStickers;
            } else if (activeStickerCategoryId === 'uncategorized') {
                stickersToSelect = state.userStickers.filter(s => !s.categoryId);
            } else {
                stickersToSelect = state.userStickers.filter(s => s.categoryId === activeStickerCategoryId);
            }
        
            // 2. 遍歷這些被篩選出的表情
            stickersToSelect.forEach(sticker => {
                const stickerId = sticker.id;
                const itemEl = document.querySelector(`.sticker-item[data-sticker-id="${stickerId}"]`);
                
                if (shouldSelect) {
                    // 如果是“全選”操作
                    selectedStickers.add(stickerId);
                    if (itemEl) itemEl.classList.add('selected');
                } else {
                    // 如果是“取消全選”操作
                    selectedStickers.delete(stickerId);
                    if (itemEl) itemEl.classList.remove('selected');
                }
            });
        
            // 3. 更新刪除按鈕的計數
            updateDeleteStickerButton();
        }
        // ▲▲▲ 新增函數結束 ▲▲▲        
        /**
         * 更新刪除按鈕上的計數
         */
        function updateDeleteStickerButton() {
            const btn = document.getElementById('delete-selected-stickers-btn');
            btn.textContent = `刪除 (${selectedStickers.size})`;
        }
        
        /**
         * 處理用戶點擊選擇或取消選擇表情
         * @param {HTMLElement} item - 被點擊的表情DOM元素
         */
        function handleStickerSelection(item) {
            if (!isStickerManagementMode) return; // 只有在管理模式下才生效
        
            const stickerId = item.dataset.stickerId;
            if (!stickerId) return;
        
            item.classList.toggle('selected');
        
            if (selectedStickers.has(stickerId)) {
                selectedStickers.delete(stickerId);
            } else {
                selectedStickers.add(stickerId);
            }
            updateDeleteStickerButton();
        }
        
        /**
         * 執行批量刪除操作
         */
        async function executeBatchDeleteStickers() {
            if (selectedStickers.size === 0) return;
            
            const confirmed = await showCustomConfirm(
                '確認刪除',
                `確定要刪除選中的 ${selectedStickers.size} 個表情嗎？此操作不可恢復。`,
                { confirmButtonClass: 'btn-danger' }
            );
        
            if (confirmed) {
                const idsToDelete = [...selectedStickers];
                
                // 從資料庫批量刪除
                await db.userStickers.bulkDelete(idsToDelete);
                
                // 從記憶體狀態中過濾掉被刪除的表情
                state.userStickers = state.userStickers.filter(s => !idsToDelete.includes(s.id));
                
                // 退出管理模式並刷新清單
                toggleStickerManagementMode();
                renderStickerPanel();
                
                await showCustomAlert('刪除成功', '選中的表情已成功刪除。');
            }
        }
        // ▲▲▲ 全新功能函數黏貼結束 ▲▲▲
        
        // ▼▼▼ 【全新】批量導入表情的核心功能 ▼▼▼
        
        /**
         * 【總入口】打開批量導入表情的彈窗
         */
        async function openBatchStickerImportModal() {
            const placeholderText = `請按照以下格式黏貼，一行一個：\n\n焦慮 2a9wte.jpeg\n大驚失色 or8qf4.png\n沒有靈感 njwujh.jpeg`;
            
            const pastedText = await showCustomPrompt(
                '批量導入表情',
                placeholderText,
                '',
                'textarea'
            );
        
            if (pastedText && pastedText.trim()) {
                await handleBatchStickerImport(pastedText);
            }
        }
        
        // ▼▼▼ 【最終修復版】請用這個全新的函數，完整替換舊的 handleBatchStickerImport 函數 ▼▼▼
        /**
         * 【核心邏輯 | V3.0 - 已修復URL格式BUG】處理黏貼的文本，解析並存入資料庫
         * @param {string} text - 使用者黏貼的文本內容
         */
        async function handleBatchStickerImport(text) {
            const lines = text.trim().split('\n');
            const newStickers = [];
            const baseUrl = 'https://files.catbox.moe/';
            let errorCount = 0;
            const currentCategoryId = (activeStickerCategoryId !== 'all' && activeStickerCategoryId !== 'uncategorized') ? activeStickerCategoryId : null;

            for (const line of lines) {
                const trimmedLine = line.trim();

                // ▼▼▼ 核心修復：移除了錯誤的 `trimmedLine.includes('http')` 判斷 ▼▼▼
                // 現在只跳過空行或示例行
                if (!trimmedLine || trimmedLine.includes('填入')) {
                    continue;
                }
                // ▲▲▲ 修復結束 ▲▲▲

                // 優先匹配 “名稱：URL” 格式
                const fullUrlMatch = trimmedLine.match(/^(.+?)[:：]\s*(https?:\/\/.+)$/);
                
                if (fullUrlMatch) {
                    const name = fullUrlMatch[1].trim();
                    const url = fullUrlMatch[2].trim();
                    newStickers.push({
                        id: 'sticker_' + Date.now() + Math.random(),
                        name: name,
                        url: url,
                        categoryId: currentCategoryId
                    });
                    continue; 
                }

                // 如果上面沒匹配成功，則嘗試匹配舊的 catbox.moe 格式
                let name = null;
                let code = null;
                const noSpaceMatch = trimmedLine.match(/^([\u4e00-\u9fa5]+)([a-zA-Z0-9]+\..+)$/);
                
                if (noSpaceMatch) {
                    name = noSpaceMatch[1];
                    code = noSpaceMatch[2];
                } else {
                    const parts = trimmedLine.split(/\s+/);
                    if (parts.length >= 2) {
                        code = parts.pop();
                        name = parts.join(' ');
                    }
                }

                if (name && code && code.includes('.')) {
                    newStickers.push({
                        id: 'sticker_' + Date.now() + Math.random(),
                        name: name,
                        url: baseUrl + code,
                        categoryId: currentCategoryId
                    });
                } else {
                    errorCount++;
                    console.warn('批量導入格式錯誤，已跳過此行:', trimmedLine);
                }
            }

            if (errorCount > 0) {
                await showCustomAlert('部分導入失敗', `有 ${errorCount} 行的格式不正確，已被系統跳過。`);
            }

            if (newStickers.length > 0) {
                await db.userStickers.bulkAdd(newStickers);
                state.userStickers.push(...newStickers);
                renderStickerPanel();
                await showCustomAlert('導入成功', `已成功批量導入 ${newStickers.length} 個新表情！`);
            } else if (errorCount === 0) {
                alert("沒有找到可導入的內容。請檢查您黏貼的格式是否正確。");
            }
        }
        // ▲▲▲ 替換結束 ▲▲▲
/**
 * 【輔助函數】滾動到並高亮顯示原始消息
 * @param {number} originalTimestamp - 要跳轉到的原始消息的時間戳記
 */
function scrollToOriginalMessage(originalTimestamp) {
    const selector = `.message-bubble[data-timestamp="${originalTimestamp}"]`;
    const originalMessageBubble = document.querySelector(selector);

    if (originalMessageBubble) {
        originalMessageBubble.scrollIntoView({
            behavior: 'smooth',
            block: 'center'
        });

        originalMessageBubble.classList.add('highlighted');
        setTimeout(() => {
            if (document.body.contains(originalMessageBubble)) {
                originalMessageBubble.classList.remove('highlighted');
            }
        }, 1500); // 高亮持續1.5秒

    } else {
        // 只有在所有嘗試都失敗後才提示用戶
        alert("找不到原始消息。可能已被刪除或位於更早的歷史記錄中。");
    }
}


// ▲▲▲ 新增代碼黏貼結束 ▲▲▲
        // ▼▼▼ 【最終修復版】請用這個全新的函數，完整替換舊的 createMessageElement 函數 ▼▼▼
        async function createMessageElement(msg, chat) {
        
            // --- (系統消息和撤回消息的處理邏輯保持不變) ---
            if (msg.type === 'recalled_message') {
                const wrapper = document.createElement('div');
                wrapper.className = 'message-wrapper system-pat';
                wrapper.dataset.timestamp = msg.timestamp; 
                const bubble = document.createElement('div');
                bubble.className = 'message-bubble recalled-message-placeholder';
                bubble.dataset.timestamp = msg.timestamp; 
                bubble.textContent = msg.content;
                wrapper.appendChild(bubble);
                addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
                wrapper.addEventListener('click', () => { 
                    if (isSelectionMode) {
                        toggleMessageSelection(msg.timestamp);
                    }
                });
                return wrapper;
            }
            else if (msg.type === 'post_deleted_notice') {
                const wrapper = document.createElement('div');
                wrapper.className = 'message-wrapper system-pat';
                wrapper.dataset.timestamp = msg.timestamp; 
                const bubble = document.createElement('div');
                bubble.className = 'message-bubble post-deleted-placeholder'; 
                bubble.dataset.postId = msg.postId;
                bubble.textContent = msg.content;
                wrapper.appendChild(bubble);
                addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
                wrapper.addEventListener('click', () => { 
                    if (isSelectionMode) {
                        toggleMessageSelection(msg.timestamp);
                    }
                });
                return wrapper;
            }
        
            if (msg.isHidden) {
                return null;
            }
        
            if (msg.type === 'pat_message') {
                const wrapper = document.createElement('div');
                wrapper.className = 'message-wrapper system-pat'; 
                const bubble = document.createElement('div');
                bubble.className = 'message-bubble system-bubble'; 
                bubble.dataset.timestamp = msg.timestamp;
                bubble.textContent = msg.content;
                wrapper.appendChild(bubble);
                addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
                wrapper.addEventListener('click', () => { if (isSelectionMode) toggleMessageSelection(msg.timestamp); });
                return wrapper;
            }
        
            // --- (基礎DOM元素準備邏輯保持不變) ---
            const isUser = msg.role === 'user';
            const myNickname = chat.settings.myNickname || '我';
            const wrapper = document.createElement('div');
            wrapper.className = `message-wrapper ${isUser ? 'user' : 'ai'}`;
        
            if (chat.isGroup && !isUser) {
                const member = chat.members.find(m => m.originalName === msg.senderName);
                const senderNameDiv = document.createElement('div');
                senderNameDiv.className = 'sender-name';
                senderNameDiv.textContent = member ? member.groupNickname : (msg.senderName || '未知成員');
                wrapper.appendChild(senderNameDiv);
            }
        
            const bubble = document.createElement('div');
            bubble.className = `message-bubble ${isUser ? 'user' : 'ai'}`;
            bubble.dataset.timestamp = msg.timestamp;
        
            const timestampEl = document.createElement('span');
            timestampEl.className = 'timestamp';
            timestampEl.textContent = formatTimestamp(msg.timestamp);
        
            let avatarSrc, avatarFrameSrc = '';
            if (isUser) {
                avatarSrc = chat.settings.myAvatar || (chat.isGroup ? defaultMyGroupAvatar : defaultAvatar);
                avatarFrameSrc = chat.settings.myAvatarFrame || '';
            } else {
                if (chat.isGroup) {
                    const member = chat.members.find(m => m.originalName === msg.senderName);
                    if (member) {
                        const characterProfile = state.chats[member.id];
                        avatarSrc = member.avatar || (characterProfile ? characterProfile.settings.aiAvatar : defaultGroupMemberAvatar);
                        avatarFrameSrc = member.avatarFrame || (characterProfile ? characterProfile.settings.aiAvatarFrame : '');
                    } else {
                        avatarSrc = defaultGroupMemberAvatar;
                        avatarFrameSrc = '';
                    }
                } else {
                    avatarSrc = chat.settings.aiAvatar || defaultAvatar;
                    avatarFrameSrc = chat.settings.aiAvatarFrame || '';
                }
            }
        
            let avatarHtml;
            if (avatarFrameSrc) {
                avatarHtml = `<div class="avatar-with-frame"><img src="${avatarSrc}" class="avatar-img"><img src="${avatarFrameSrc}" class="avatar-frame"></div>`;
            } else {
                avatarHtml = `<img src="${avatarSrc}" class="avatar">`;
            }
            const hasFrameClass = avatarFrameSrc ? 'has-frame' : '';
            const avatarGroupHtml = `<div class="avatar-group ${hasFrameClass}">${avatarHtml}</div>`;
            
            let contentHtml;
            let quoteHtml = '';
            if (msg.quote) {
                const quotedSenderDisplayName = getDisplayNameInGroup(chat, msg.quote.senderName);
                const fullQuotedContent = String(msg.quote.content || '');
                quoteHtml = `
                    <div class="quoted-message" data-original-timestamp="${msg.quote.timestamp}" style="cursor: pointer;">
                        <div class="quoted-sender">回復 ${quotedSenderDisplayName}:</div>
                        <div class="quoted-content">${fullQuotedContent}</div>
                    </div>
                `;
            }
            
            // ==========================================================
            //                  ★★★ 核心修改邏輯 ★★★
            // ==========================================================
        
            let rawContent = msg.content; // 直接使用 msg.content，不再強制轉為字串

            if (typeof rawContent === 'string' && rawContent.trim().startsWith('<') && rawContent.trim().endsWith('>')) {
                contentHtml = rawContent;
                bubble.classList.add('is-raw-html'); 
            } else if (msg.type === 'offline_text' || msg.type === 'share_link' || msg.type === 'share_card' || msg.type === 'location_share' || msg.type === 'ai_image' || msg.type === 'user_photo' || msg.type === 'voice_message' || msg.type === 'transfer' || msg.type === 'waimai_request'|| msg.type === 'waimai_order'  || msg.type === 'red_packet' || msg.type === 'poll' || msg.type === 'gift') {
                // (這部分是您已有的所有卡片渲染邏輯，保持不變)
               if (msg.type === 'offline_text') {
                    // 1. 【相容舊資料】如果消息還是舊的 dialogue/description 格式，則先合併
                    const combinedText = msg.content || `${msg.dialogue || ''} ${msg.description || ''}`.trim();

                    // 2. 【核心渲染邏輯】使用規則運算式，以引號為界，將文本分割成“對話”和“描寫”兩部分
                    const regex = /(「.*?」|“.*?”)/g;
                    const parts = combinedText.split(regex).filter(part => part); 

                    // 3. 遍歷分割後的片段，為每一部分應用不同的樣式
                    contentHtml = parts.map(part => {
                        // 如果片段以引號開頭，說明它是對話
                        if (part.startsWith('「') || part.startsWith('“')) {
                            return `<span class="offline-dialogue">${parseMarkdown(part)}</span>`;
                        } else {
                            // 否則，它就是描寫
                            return `<span class="offline-description">${parseMarkdown(part.trim()).replace(/\n/g, '<br>')}</span>`;
                        }
                    }).join(''); // 最後將所有片段拼接成最終的HTML
                }
else if (msg.type === 'share_link') {
                    bubble.classList.add('is-link-share', 'is-card-like');
                    contentHtml = `<div class="link-share-card" data-timestamp="${msg.timestamp}"><div class="title">${msg.title || '無標題'}</div><div class="description">${msg.description || '點擊查看詳情...'}</div><div class="footer"><svg class="footer-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path></svg><span>${msg.source_name || '連結分享'}</span></div></div>`;
                } else if (msg.type === 'share_card') {
                    bubble.classList.add('is-link-share', 'is-card-like');
                    contentHtml = `<div class="link-share-card" style="cursor: pointer;" data-timestamp="${msg.timestamp}"><div class="title">${msg.payload.title}</div><div class="description">共 ${msg.payload.sharedHistory.length} 條消息</div><div class="footer"><svg class="footer-icon" ...>...</svg><span>聊天記錄</span></div></div>`;
                } else if (msg.type === 'location_share') {
                    bubble.classList.add('is-location-share', 'is-card-like');
                        let finalImageUrl;
    
    // 1. 優先使用消息自帶的 imageUrl (這是你手動分享時設置的)
    if (msg.imageUrl) {
        finalImageUrl = msg.imageUrl;
    } 
    // 2. 其次，如果開啟了AI生圖且AI返回了指令，則使用AI生圖
    else if (state.globalSettings.enableAiDrawing && msg.image_prompt) {
        finalImageUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(msg.image_prompt)}`;
    } 
    // 3. 最後，如果以上都沒有，才使用占點陣圖
    else {
        finalImageUrl = 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1756262526935_qdqqd_4uque3.jpeg'; // 默認占點陣圖
    }
    
    const mapAreaStyle = `style="background-image: url('${finalImageUrl}');"`;
                    contentHtml = `<div class="location-share-card"><div class="card-text-area"><div class="card-text-primary">${msg.content}</div><div class="card-text-secondary">位置分享</div></div><div class="card-map-area" ${mapAreaStyle}><div class="card-pin-icon"><svg width="1em" height="1em" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 11.5C11.1716 11.5 10.5 10.8284 10.5 10C10.5 9.17157 11.1716 8.5 12 8.5C12.8284 8.5 13.5 9.17157 13.5 10C13.5 10.8284 12.8284 11.5 12 11.5Z"></path><path d="M12 2C7.92134 2 4.5 5.42134 4.5 9.5C4.5 14.5312 11.2188 21.4375 11.5938 21.8125C11.7954 22.014 12.2046 22.014 12.4062 21.8125C12.7812 21.4375 19.5 14.5312 19.5 9.5C19.5 5.42134 16.0787 2 12 2ZM12 12.5C10.6193 12.5 9.5 11.3807 9.5 10C9.5 8.61929 10.6193 7.5 12 7.5C13.3807 7.5 14.5 8.61929 14.5 10C14.5 11.3807 13.3807 12.5 12 12.5Z"></path></svg></div></div></div>`;
                } else if (msg.type === 'user_photo' || msg.type === 'ai_image') {
                    bubble.classList.add('is-ai-image', 'is-card-like');
                    const altText = msg.type === 'user_photo' ? "用戶描述的照片" : "AI生成的圖片";
                    
                    // 1. 在生成URL之前，加入對全域開關的判斷
                    const imageUrl = state.globalSettings.enableAiDrawing && msg.image_prompt 
                        ? `https://image.pollinations.ai/prompt/${msg.image_prompt}` 
                        : 'https://i.postimg.cc/KYr2qRCK/1.jpg'; // <-- 如果開關關閉，則使用占點陣圖

                    // 2. 將判斷後的URL用於生成HTML
                    contentHtml = `<img src="${imageUrl}" class="ai-generated-image" alt="${altText}" data-description="${msg.content}">`;
                } else if (msg.type === 'voice_message') {
    bubble.classList.add('is-voice-message', 'is-card-like');
    const duration = Math.max(1, Math.round((msg.content || '').length / 5));
    const durationFormatted = `0:${String(duration).padStart(2, '0')}''`;
    const waveformHTML = '<div></div><div></div><div></div><div></div><div></div>';

    if (isUser) {
        // 使用者發送的語音訊息（這部分邏輯不變）
        contentHtml = `
            <div class="voice-message-body" data-text="${encodeURIComponent(msg.content)}">
                <div class="voice-waveform">${waveformHTML}</div>
                <span class="voice-duration">${durationFormatted}</span>
            </div>
            <div class="voice-transcript"></div>
        `;
    } else {
        // AI發送的語音訊息（這是我們的核心修改）
        
        // 1. 判斷是否滿足播放條件：必須是單聊 且 TTS開關沒有被關閉
        const canPlayTTS = !chat.isGroup && chat.settings.enableTts !== false;
        
        // 2. 獲取 voiceId，以備不時之需
        const voiceId = chat.settings.minimaxVoiceId || 'female-shaonv-jingpin';
        
        // 3. 【智慧渲染】根據 canPlayTTS 的結果，決定是否添加 data-voice-id 屬性
        const voiceIdAttribute = canPlayTTS ? `data-voice-id="${voiceId}"` : '';

        contentHtml = `
            <div class="voice-message-body" data-text="${encodeURIComponent(msg.content)}" ${voiceIdAttribute}>
                <div class="voice-waveform">${waveformHTML}</div>
                <div class="loading-spinner"></div>
                <span class="voice-duration">${durationFormatted}</span>
            </div>
            <div class="voice-transcript"></div>
        `;
    }
}else if (msg.type === 'transfer') {
                    bubble.classList.add('is-transfer', 'is-card-like');
                     let titleText, noteText;
                    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
                    const senderDisplayName = getDisplayNameInGroup(chat, msg.senderName);
                    const receiverDisplayName = getDisplayNameInGroup(chat, msg.receiverName || chat.name);
                    if (isUser) { 
                        if (msg.isRefund) { titleText = `退款給 ${receiverDisplayName}`; noteText = '已拒收對方轉帳'; } 
                        else { titleText = `轉帳給 ${receiverDisplayName}`; if (msg.status === 'accepted') noteText = '對方已收款'; else if (msg.status === 'declined') noteText = '對方已拒收'; else noteText = msg.note || '等待對方處理...'; }
                    } else {
                        if (msg.isRefund) { titleText = `退款來自 ${senderDisplayName}`; noteText = '轉帳已被拒收'; } 
                        else if (msg.receiverName === myNickname) { titleText = `轉帳給 ${myNickname}`; if (msg.status === 'accepted') noteText = '你已收款'; else if (msg.status === 'declined') noteText = '你已拒收'; else { bubble.style.cursor = 'pointer'; bubble.dataset.status = 'pending'; noteText = msg.note || '點擊處理'; } } 
                        else { titleText = `轉帳: ${senderDisplayName} → ${receiverDisplayName}`; noteText = msg.note || '群聊內轉帳'; }
                    }
                    const heartIcon = `<svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor" style="vertical-align: middle;"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"></path></svg>`;
                    contentHtml = `<div class="transfer-card"><div class="transfer-title">${heartIcon} ${titleText}</div><div class="transfer-amount">¥ ${Number(msg.amount).toFixed(2)}</div><div class="transfer-note">${noteText}</div></div>`;
                } else if (msg.type === 'waimai_request') {
                    bubble.classList.add('is-waimai-request', 'is-card-like');
                     if (msg.status === 'paid' || msg.status === 'rejected') bubble.classList.add(`status-${msg.status}`);
                    const senderDisplayName = getDisplayNameInGroup(chat, msg.senderName);
                    const requestTitle = `來自 ${senderDisplayName} 的代付請求`;
                    let actionButtonsHtml = '';
                    if (msg.status === 'pending' && !isUser) { actionButtonsHtml = `<div class="waimai-user-actions"><button class="waimai-decline-btn" data-choice="rejected">殘忍拒絕</button><button class="waimai-pay-btn" data-choice="paid">為Ta買單</button></div>`; }
                    contentHtml = `<div class="waimai-card"><div class="waimai-header"><img src="https://files.catbox.moe/mq179k.png" class="icon" alt="Meituan Icon"><div class="title-group"><span class="brand">美團外賣</span><span class="separator">|</span><span>外賣美食</span></div></div><div class="waimai-catchphrase">Hi，你和我的距離只差一頓外賣～</div><div class="waimai-main"><div class="request-title">${requestTitle}</div><div class="payment-box"><div class="payment-label">需付款</div><div class="amount">¥${Number(msg.amount).toFixed(2)}</div><div class="countdown-label">剩餘支付時間<div class="countdown-timer" id="waimai-timer-${msg.timestamp}"></div></div></div><button class="waimai-details-btn">查看詳情</button></div>${actionButtonsHtml}</div>`;
                       setTimeout(() => {
        if (msg.status === 'pending') {
            const timerElement = document.getElementById(`waimai-timer-${msg.timestamp}`);
            if (timerElement) {
                const timerId = startWaimaiCountdown(timerElement, msg.countdownEndTime);
                // 將計時器ID存起來，方便在離開頁面時統一清理
                waimaiTimers[msg.timestamp] = timerId;
            }
        }
    }, 0);
                } else if (msg.type === 'waimai_order') {
                bubble.classList.add('is-waimai-request', 'is-card-like'); // 複用樣式
                const senderDisplayName = getDisplayNameInGroup(chat, msg.senderName);
                
                let recipientDisplayName = '你';
                if (chat.isGroup) {
                    // 如果是群聊，就去查找接收者的名字
                    recipientDisplayName = getDisplayNameInGroup(chat, msg.recipientName);
                }

    contentHtml = `
        <div class="waimai-card">
            <div class="waimai-header">
                <img src="https://files.catbox.moe/mq179k.png" class="icon" alt="Meituan Icon">
                <div class="title-group"><span class="brand">美團外賣</span><span class="separator">|</span><span>外賣美食</span></div>
            </div>
            <div class="waimai-main">
                <div class="request-title" style="margin-bottom: 12px;">${senderDisplayName} 已為${recipientDisplayName}下單，請慢用～</div>
                <div class="payment-box">
                    <div class="payment-label" style="font-size: 18px; font-weight: 600;">${msg.productInfo}</div>
                    <div class="amount" style="margin-top: 8px;">¥${Number(msg.amount).toFixed(2)}</div>
                </div>
                <button class="waimai-details-btn">查看訂單詳情</button>
            </div>
        </div>
    `;
}else if (msg.type === 'red_packet') {
                     bubble.classList.add('is-red-packet', 'is-card-like');
                    const myOriginalName = state.qzoneSettings.nickname || '{{user}}';
                    const isFinished = msg.isFullyClaimed; const hasClaimed = msg.claimedBy && msg.claimedBy[myOriginalName];
                    let cardClass = '', claimedInfoHtml = '', typeText = '拼手氣紅包';
                    if (isFinished) { cardClass = 'opened'; } if (msg.packetType === 'direct') { const receiverDisplayName = getDisplayNameInGroup(chat, msg.receiverName); typeText = `專屬紅包: 給 ${receiverDisplayName}`; if (Object.keys(msg.claimedBy || {}).length > 0) cardClass = 'opened'; }
                    if (hasClaimed) { const myClaimedAmount = msg.claimedBy[myOriginalName] || 0; claimedInfoHtml = `<div class="rp-claimed-info">你領取了紅包，金額 ${myClaimedAmount.toFixed(2)} 元</div>`; } 
                    else if (isFinished) { claimedInfoHtml = `<div class="rp-claimed-info">紅包已被領完</div>`; } 
                    else if (msg.packetType === 'direct' && Object.keys(msg.claimedBy || {}).length > 0) { const receiverDisplayName = getDisplayNameInGroup(chat, msg.receiverName); claimedInfoHtml = `<div class="rp-claimed-info">已被 ${receiverDisplayName} 領取</div>`; }
                    contentHtml = `<div class="red-packet-card ${cardClass}"><div class="rp-header"><img src="https://files.catbox.moe/lo9xhc.png" class="rp-icon"><span class="rp-greeting">${msg.greeting || '恭喜發財，大吉大利！'}</span></div><div class="rp-type">${typeText}</div>${claimedInfoHtml}</div>`;
                } else if (msg.type === 'poll') {
                    bubble.classList.add('is-poll', 'is-card-like');
                    const pollQuestionText = msg.question || msg.content || '(無標題投票)';
                    let totalVotes = 0; const voteCounts = {}; for (const option in msg.votes) { const count = msg.votes[option].length; voteCounts[option] = count; totalVotes += count; }
                    const myOriginalName = state.qzoneSettings.nickname || '{{user}}'; let myVote = null; for (const option in msg.votes) { if (msg.votes[option].includes(myOriginalName)) { myVote = option; break; } }
                    let optionsHtml = '<div class="poll-options-list">'; msg.options.forEach(optionText => { const count = voteCounts[optionText] || 0; const percentage = totalVotes > 0 ? (count / totalVotes) * 100 : 0; const isVotedByMe = myVote === optionText; optionsHtml += `<div class="poll-option-item ${isVotedByMe ? 'voted' : ''}" data-option="${optionText}"><div class="poll-option-bar" style="width: ${percentage}%;"></div><div class="poll-option-content"><span class="poll-option-text">${optionText}</span><span class="poll-option-votes">${count} 票</span></div></div>`; }); optionsHtml += '</div>';
                    let footerHtml = msg.isClosed ? `<div class="poll-footer"><span class="poll-total-votes">共 ${totalVotes} 人投票</span><button class="poll-action-btn">查看結果</button></div>` : `<div class="poll-footer"><span class="poll-total-votes">共 ${totalVotes} 人投票</span><button class="poll-action-btn">結束投票</button></div>`;
                    contentHtml = `<div class="poll-card ${msg.isClosed ? 'closed' : ''}" data-poll-timestamp="${msg.timestamp}"><div class="poll-question">${pollQuestionText}</div>${optionsHtml}${footerHtml}</div>`;
                } else if (msg.type === 'gift') {
                    bubble.classList.add('is-gift', 'is-card-like');
                     let headerText; const myNicknameForGift = chat.settings.myNickname || '我';
                    if (chat.isGroup) {
                        if (msg.recipients && msg.recipients.length > 0) {
                            const recipientDisplayNames = msg.recipients.map(originalName => getDisplayNameInGroup(chat, originalName));
                            if (recipientDisplayNames.length === 1) { headerText = `送給 ${recipientDisplayNames[0]} 的禮物`; } else { headerText = `送給 ${recipientDisplayNames.slice(0, 2).join('、')}等人的禮物`; }
                        } else { headerText = `送給大家的禮物`; }
                    } else {
                        if (isUser) { headerText = `送給 ${chat.name} 的禮物`; } 
                        else { const recipientDisplayName = chat.settings.myNickname || '你'; headerText = `送給 ${recipientDisplayName} 的禮物`; }
                    }
                    const previewItems = msg.items.slice(0, 3); let previewHtml = ''; previewItems.forEach(item => { previewHtml += `<div class="gift-preview-item"><img src="${item.imageUrl}" class="gift-preview-img"><span class="gift-preview-name">${item.name}</span><span class="gift-preview-quantity">x${item.quantity}</span></div>`; });
                    let moreItemsText = ''; if (msg.items.length > 3) { moreItemsText = ` 等${msg.items.length}件商品`; }
                    contentHtml = `<div class="gift-card"><div class="gift-header"><svg class="gift-header-icon" viewBox="0 0 24 24" fill="currentColor"><path d="M20 6h-2.18a4 4 0 0 0-7.64 0H8a4 4 0 0 0-4 4v2h20V10a4 4 0 0 0-4-4zM8 4a2 2 0 1 1-2 2a2 2 0 0 1 2-2zm12 0a2 2 0 1 1-2 2a2 2 0 0 1 2-2zM4 14v6a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-6H4z"></path></svg><span class="gift-header-text">${headerText}</span></div><div class="gift-items-preview">${previewHtml}</div><div class="gift-footer">共${msg.items.length}件商品${moreItemsText}，點擊查看</div></div>`;
                }
            } else {
                const processedContent = String(rawContent); // 確保是字串
                let processedByRule = await applyRenderingRules(processedContent, chat.id);
                if (processedByRule !== processedContent) {
                    contentHtml = processedByRule;
                    bubble.classList.add('is-card-like');
                } else {
                    // ▼▼▼ 【這是您需要添加的核心修復代碼】 ▼▼▼
                    // 1. 檢查消息內容是否是用於識圖的圖片物件陣列
                    if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
                        // 2. 如果是，就創建一個<img>標籤來顯示它
                        const imageUrl = msg.content[0].image_url.url;
                        contentHtml = `<img src="${imageUrl}" class="chat-image">`;
                    }
                    // ▲▲▲ 修復代碼結束 ▲▲▲
                    else if (STICKER_REGEX.test(processedByRule)) { // 使用 else if
                        bubble.classList.add('is-sticker', 'is-card-like');
                        contentHtml = `<img src="${processedByRule}" alt="${msg.meaning || 'Sticker'}" class="sticker-image">`;
                    } else {
                        let plainText = processMentions(processedByRule, chat);
                        contentHtml = parseMarkdown(plainText).replace(/\n/g, '<br>');
                    }
                }
            }
        
            // --- (組裝最終的HTML邏輯保持不變) ---
            bubble.innerHTML = `
                ${avatarGroupHtml}
                <div class="content">
                    ${quoteHtml}
                    ${contentHtml}
                </div>
            `;
            
            wrapper.appendChild(bubble);
            wrapper.appendChild(timestampEl);
            
            addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
            wrapper.addEventListener('click', () => { if (isSelectionMode) toggleMessageSelection(msg.timestamp); });
        
            if (!isUser) {
                const avatarGroupEl = wrapper.querySelector('.avatar-group'); 
                if (avatarGroupEl) {
                    avatarGroupEl.style.cursor = 'pointer';
                    if (!chat.isGroup) {
                        avatarGroupEl.addEventListener('click', (e) => { e.stopPropagation(); showCharacterProfileModal(chat.id); });
                    } else {
                        avatarGroupEl.addEventListener('dblclick', (e) => { e.stopPropagation(); handleUserPat(chat.id, msg.senderName); });
                    }
                }
            }
            return wrapper;
        }
// ▲▲▲ 替換結束 ▲▲▲
        // ▼▼▼ 【請用這個已修復的版本】完整替換舊的 prependMessage 函數 ▼▼▼
        async function prependMessage(msg, chat) { 
            const messagesContainer = document.getElementById('chat-messages'); 
            const messageEl = await createMessageElement(msg, chat); 
        
            // 【【【核心修復：在這裡也加上同樣的安全檢查！】】】
            if (!messageEl) return;
        
            const loadMoreBtn = document.getElementById('load-more-btn'); 
            if (loadMoreBtn) { 
                messagesContainer.insertBefore(messageEl, loadMoreBtn.nextSibling); 
            } else { 
                messagesContainer.prepend(messageEl); 
            } 
        }
        // ▲▲▲ 替換結束 ▲▲▲
        
        /**
         * 【V3.0 | 已延長間隔】將消息元素追加到聊天視窗
         */
        async function appendMessage(msg, chat, isInitialLoad = false) {
            const messagesContainer = document.getElementById('chat-messages');
            const typingIndicator = document.getElementById('typing-indicator');

const lastMessage = chat.history.filter(m => !m.isHidden).pop();

// 核心邏輯：用新消息的時間戳記(msg.timestamp)與上一條消息的時間戳記(lastMessage.timestamp)進行比較
if (lastMessage && (msg.timestamp - lastMessage.timestamp > 600000)) { // 600000毫秒 = 10分鐘
    const timestampEl = createSystemTimestampElement(msg.timestamp);
    messagesContainer.insertBefore(timestampEl, typingIndicator);
}

            const messageEl = await createMessageElement(msg, chat);
            if (!messageEl) return;
    // ▼▼▼ 在這裡黏貼新代碼 ▼▼▼
    // 如果是AI發送的新消息（非初始載入），就播放提示音
    if (msg.role === 'assistant' && !isInitialLoad) {
        playNotificationSound();
    }
    // ▲▲▲ 新代碼黏貼結束 ▲▲▲
            if (!isInitialLoad) {
                messageEl.classList.add('animate-in');
            }
          
            messagesContainer.insertBefore(messageEl, typingIndicator);
            
            if (!isInitialLoad) {
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
                currentRenderedCount++;
            }
        }
        // ▲▲▲ 替換結束 ▲▲▲
        
        /* ▼▼▼ 請用這個【新版本】的函數完整替換舊的 openChat 函數 ▼▼▼ */
        async function openChat(chatId) {
            state.activeChatId = chatId;
            const chat = state.chats[chatId];
            if (!chat) return; // 安全檢查
        
            if (chat.unreadCount > 0) {
                chat.unreadCount = 0;
                await db.chats.put(chat);
            }
            applyLyricsBarPosition(chat); 
            renderChatInterface(chatId);
            showScreen('chat-interface-screen');
            window.updateListenTogetherIconProxy(state.activeChatId);
            
            // --- 按鈕顯隱邏輯 ---
            const isGroup = chat.isGroup || false;
            
            // 切換通話按鈕
            toggleCallButtons(isGroup);
            
            // 切換群公告按鈕
            document.getElementById('show-announcement-board-btn').style.display = isGroup ? 'flex' : 'none';
            
            // 切換“拍一拍”按鈕
            const patBtn = document.getElementById('pat-btn');
            if (patBtn) {
                patBtn.style.display = isGroup ? 'none' : 'flex';
            }
        const propelBtn = document.getElementById('propel-btn');       
            // 【【【核心修改就在這裡】】】
            // 切換“購物”和“五子棋”按鈕
            const shoppingBtn = document.getElementById('open-shopping-btn');
            const gomokuBtn = document.getElementById('gomoku-btn');
    const werewolfBtn = document.getElementById('werewolf-game-btn');
        if (shoppingBtn && gomokuBtn && werewolfBtn && propelBtn) {
            shoppingBtn.style.display = 'flex';
            gomokuBtn.style.display = isGroup ? 'none' : 'flex';
            werewolfBtn.style.display = isGroup ? 'flex' : 'none';

            // 2. 添加判斷：如果是群聊(isGroup)，則隱藏(none)；否則，顯示(flex)
            propelBtn.style.display = isGroup ? 'none' : 'flex';
        }
            // --- 修改結束 ---
        
            // 觸發AI響應的邏輯（保持不變）
            if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
                console.log(`檢測到好友申請待處理狀態，為角色 "${chat.name}" 自動觸發AI回應...`);
                triggerAiResponse();
            }
            
            document.getElementById('send-poll-btn').style.display = isGroup ? 'flex' : 'none';
        }
        /* ▲▲▲ 替換結束 ▲▲▲ */
        
        
        
        
        
        // ▼▼▼ 【全新】請將這個“總開關”函數黏貼到JS功能區 ▼▼▼
        /**
         * 【全新】設置指定角色所有可見頭像的“行動中”狀態（呼吸燈總開關）
         * @param {string} chatId - 目標角色的ID
         * @param {boolean} isActing - 是否設置為“行動中”狀態
         */
        function setAvatarActingState(chatId, isActing) {
            const action = isActing ? 'add' : 'remove';
            const classListAction = (element) => {
                if (element) {
                    element.classList[action]('is-acting');
                }
            };
        
            // 1. 控制【聊天列表】中的頭像
            const listAvatar = document.querySelector(`.chat-list-item[data-chat-id="${chatId}"] .avatar`);
            classListAction(listAvatar);
        
            // 2. 控制【動態頁面】中所有屬於該角色的頭像
            const qzoneAvatars = document.querySelectorAll(`.post-avatar[data-author-id="${chatId}"]`);
            qzoneAvatars.forEach(classListAction);
        
            // 3. 控制【視頻通話介面】中的頭像 (未來相容)
            const callAvatar = document.querySelector(`.participant-avatar[data-participant-id="${chatId}"]`);
            classListAction(callAvatar);
        
            // 未來如果還有其他地方顯示頭像，只需在這裡補充選擇器即可
        }
        // ▲▲▲ 新函數黏貼結束 ▲▲▲
        
/**
 * 【V3.0 | 全功能增強版】觸發“旁觀模式群聊”的AI回應
 */
async function triggerSpectatorGroupAiAction() {
    if (!state.activeChatId) return;
    const chatId = state.activeChatId;
    const chat = state.chats[chatId];
    lastRawAiResponse = '';
    lastResponseTimestamps = [];
    const propelBtn = document.getElementById('spectator-propel-btn');
    if(propelBtn) {
        propelBtn.disabled = true;
        propelBtn.textContent = '思考中...';
    }
    setAvatarActingState(chatId, true);

    try {
        const { proxyUrl, apiKey, model } = state.apiConfig;
        if (!proxyUrl || !apiKey || !model) {
            throw new Error('API未配置，無法生成對話。');
        }
        
        // ==========================================================
        //            ★★★ 核心升級從這裡開始 ★★★
        // ==========================================================

        // 1. 【新增】為AI準備所有必要的上下文資訊（與主聊天函數完全一致）
        const maxMemory = parseInt(chat.settings.maxMemory) || 10;
        const historySlice = chat.history.slice(-maxMemory);
        
        // a. 收集世界書內容
        let worldBookContent = '';
        if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
            const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
                const worldBook = state.worldBooks.find(wb => wb.id === bookId);
                if (!worldBook || !Array.isArray(worldBook.content)) return '';
                const formattedEntries = worldBook.content
                    .filter(entry => entry.enabled !== false)
                    .map(entry => {
                        let entryString = `\n### 條目: ${entry.comment || '無備註'}\n`;
                        if (entry.keys.length > 0) entryString += `**關鍵字:** ${entry.keys.join(', ')}\n`;
                        entryString += `**內容:**\n${entry.content}`;
                        return entryString;
                    }).join('');
                return formattedEntries ? `\n\n## 世界書: ${worldBook.name}\n${formattedEntries}` : '';
            }).filter(Boolean).join('');
            if (linkedContents) {
                worldBookContent = `\n\n# 核心世界觀設定 (群內所有角色都必須嚴格遵守)\n${linkedContents}\n`;
            }
        }
        
        // b. 收集長期記憶
        let longTermMemoryContext = '# 長期記憶 (最高優先順序，這是群內已經確立的事實，所有角色必須嚴格遵守)\n';
        let collectedMemories = false;
        chat.members.forEach(member => {
            const memberChat = state.chats[member.id];
            if (memberChat && memberChat.longTermMemory && memberChat.longTermMemory.length > 0) {
                longTermMemoryContext += `\n## --- 關於“${member.groupNickname}”的記憶 ---\n`;
                longTermMemoryContext += memberChat.longTermMemory.map(mem => `- ${mem.content}`).join('\n');
                collectedMemories = true;
            }
        });
        if (!collectedMemories) {
            longTermMemoryContext += '- (暫無)';
        }

        // c. 收集掛載記憶
        let linkedMemoryContext = '';
        const memoryCount = chat.settings.linkedMemoryCount || 10;
        if (chat.settings.linkedMemoryChatIds && chat.settings.linkedMemoryChatIds.length > 0) {
            // (這部分邏輯與 triggerAiResponse 完全相同，此處省略以保持簡潔)
        }

        const membersList = chat.members.map(m => `- **${m.groupNickname}** (本名: ${m.originalName}): ${m.persona}`).join('\n');

        // 2. 【【【核心：構建一個全新的、功能完備的 System Prompt】】】
        const systemPrompt = `
# 核心任務：群聊劇本作家
你是一個劇本作家，負責創作一個名為“${chat.name}”的群聊中的對話。這個群聊裡【沒有用戶】，所有成員都是你扮演的角色。你的任務是讓他們之間進行一場生動、自然的對話。

# 輸出格式鐵律 (最高優先順序)
- 你的回復【必須】是一個JSON陣列。
- 陣列中的每個物件都【必須】包含 "type" 欄位和 "name" 欄位（角色的【本名】）。

# 角色扮演核心規則
1.  **【角色間互動 (最重要!)】**: 你的核心是創作一場“戲”。角色之間【必須】互相回應、補充或反駁，形成自然的討論。嚴禁生成僅分別自言自語的獨白。
2.  **【禁止出戲】**: 絕不能透露你是AI、模型或劇本作家。
3.  **【主動性】**: 角色們應該主動使用各種功能（發表情、發語音、分享圖片等）來讓對話更生動，而不是僅僅發送文字。

# 可用指令清單 (你現在可以使用所有這些功能！)
-   **發文本**: \`{"type": "text", "name": "角色本名", "content": "你好呀！"}\`
-   **發表情**: \`{"type": "sticker", "name": "角色本名", "url": "https://...表情URL...", "meaning": "(可選)表情含義"}\`
-   **發圖片**: \`{"type": "ai_image", "name": "角色本名", "description": "詳細中文描述", "image_prompt": "圖片的【英文】關鍵字, 風格為風景/動漫/插畫/二次元等, 禁止真人"}\`
-   **發語音**: \`{"type": "voice_message", "name": "角色本名", "content": "語音文字內容"}\`
-   **引用回復**: \`{"type": "quote_reply", "name": "角色本名", "target_timestamp": 消息時間戳記, "reply_content": "回復內容"}\`

# 當前群聊資訊
- **群名稱**: ${chat.name}

# 上下文參考 (你必須閱讀並遵守)
${longTermMemoryContext}
${worldBookContent}

${linkedMemoryContext}
- **這是你們最近的對話歷史**:
${historySlice.map(msg => `${getDisplayNameInGroup(chat, msg.senderName)}: ${msg.content}`).join('\n')}

# 群成員列表及人設 (你扮演的所有角色)
${membersList}

現在，請根據以上所有資訊，繼續這場沒有用戶參與的群聊，並自由地使用各種指令來豐富你們的互動。
`;

        // 3. 構造API請求 (邏輯不變)
        const messagesPayload = historySlice.map(msg => ({
            role: 'user', 
            content: `${getDisplayNameInGroup(chat, msg.senderName)}: ${msg.content}`
        }));
        
        let isGemini = proxyUrl.includes('generativelanguage.googleapis.com');
        let response;

        if (isGemini) {
            let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesPayload);
            response = await fetch(geminiConfig.url, geminiConfig.data);
        } else {
            response = await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                body: JSON.stringify({
                    model: model,
                    messages: [ {role: 'system', content: systemPrompt}, ...messagesPayload ],
                    temperature: state.globalSettings.apiTemperature || 0.9,
                })
            });
        }
        
        // ==========================================================
        //            ★★★ 核心升級到此結束 ★★★
        // ==========================================================

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({ error: { message: response.statusText } }));
            throw new Error(`API 請求失敗: ${response.status} - ${errorData.error?.message || '未知錯誤'}`);
        }

        const data = await response.json();
        const aiResponseContent = getGeminiResponseText(data);
        lastRawAiResponse = aiResponseContent;
        const messagesArray = parseAiResponse(aiResponseContent);

        // ==========================================================
        //            ★★★ 核心修復就在這裡 ★★★
        // ==========================================================
        
        // 4. 【全新】處理並渲染AI的回復（現在可以處理更多消息類型了）
        let messageTimestamp = Date.now();
        for (const msgData of messagesArray) {
            // 安全檢查
            if (!msgData || !msgData.type || !msgData.name) continue;

            let aiMessage = null;
            const currentMessageTimestamp = messageTimestamp++;
            lastResponseTimestamps.push(currentMessageTimestamp);
            const baseMessage = { role: 'assistant', senderName: msgData.name, timestamp: currentMessageTimestamp };
 
            // 使用 switch 語句來處理不同的消息類型
            switch (msgData.type) {
                case 'text':
                    aiMessage = { ...baseMessage, content: msgData.content };
                    break;
                case 'sticker':
                    // 【關鍵】為 sticker 類型創建正確的物件結構
                    aiMessage = { ...baseMessage, type: 'sticker', content: msgData.url, meaning: msgData.meaning || '' };
                    break;
                case 'ai_image':
                    // 【關鍵】為 ai_image 類型創建正確的物件結構
                    aiMessage = { ...baseMessage, type: 'ai_image', content: msgData.description, image_prompt: msgData.image_prompt };
                    break;
                case 'voice_message':
                    // 【關鍵】為 voice_message 類型創建正確的物件結構
                    aiMessage = { ...baseMessage, type: 'voice_message', content: msgData.content };
                    break;
                case 'quote_reply':
                    // 【關鍵】為引用回復創建正確的物件結構
                    const originalMessage = chat.history.find(m => m.timestamp === msgData.target_timestamp);
                    if (originalMessage) {
                        aiMessage = { 
                            ...baseMessage, 
                            content: msgData.reply_content,
                            quote: {
                                timestamp: originalMessage.timestamp,
                                senderName: originalMessage.senderName,
                                content: String(originalMessage.content || '').substring(0, 50)
                            }
                        };
                    } else {
                        // 如果找不到被引用的消息，就作為普通消息發送
                        aiMessage = { ...baseMessage, content: msgData.reply_content };
                    }
                    break;
                default:
                    console.warn("旁觀模式收到未知指令類型:", msgData.type);
                    continue; // 跳過未知類型的指令
            }

            if (aiMessage) {
                chat.history.push(aiMessage);
                appendMessage(aiMessage, chat);
                await new Promise(resolve => setTimeout(resolve, Math.random() * 1200 + 800));
            }
        }
        // ==========================================================
        //            ★★★ 修復結束 ★★★
        // ==========================================================
        
        await db.chats.put(chat);
        renderChatList();

    } catch (error) {
        console.error("旁觀模式推進劇情失敗:", error);
        await showCustomAlert('操作失敗', `無法推進劇情: ${error.message}`);
    } finally {
        if(propelBtn) {
            propelBtn.disabled = false;
            propelBtn.textContent = '🎬 推進劇情';
        }
        setAvatarActingState(chatId, false);
    }
} 
        
        
        
        
        
        /**
         * 【V4.0 | 修復掛載記憶時間感知】觸發AI響應的核心邏輯
         */
        async function triggerAiResponse() {
            if (!state.activeChatId) return;
            const chatId = state.activeChatId;
            const chat = state.chats[state.activeChatId];
        
            const isViewingThisChat = document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chatId;
        
            setAvatarActingState(chatId, true);
            const chatHeaderTitle = document.getElementById('chat-header-title');
            const typingIndicator = document.getElementById('typing-indicator');
        
            const chatListItem = document.querySelector(`.chat-list-item[data-chat-id="${chatId}"]`);
            const avatarInList = chatListItem ? chatListItem.querySelector('.avatar') : null;
            if (avatarInList) {
                avatarInList.classList.add('is-acting');
            }
        
            if (chat.isGroup) {
                if (typingIndicator) {
                    typingIndicator.textContent = '成員們正在輸入...';
                    typingIndicator.style.display = 'block';
                }
            } else {
                if (chatHeaderTitle) {
                    chatHeaderTitle.style.opacity = 0;
                    setTimeout(() => {
                        chatHeaderTitle.textContent = '對方正在輸入...';
                        chatHeaderTitle.classList.add('typing-status');
                        chatHeaderTitle.style.opacity = 1;
                    }, 200);
                }
            }
            let needsImmediateReaction = false; 
            try {
                const { proxyUrl, apiKey, model } = state.apiConfig;
                if (!proxyUrl || !apiKey || !model) {
                    alert('請先在API設置中配置反代位址、金鑰並選擇模型。');
                    if (chat.isGroup) {
                        if (typingIndicator) typingIndicator.style.display = 'none';
                    } else {
                         if (chatHeaderTitle && state.chats[chatId]) {
                            chatHeaderTitle.textContent = state.chats[chatId].name;
                            chatHeaderTitle.classList.remove('typing-status');
                        }
                    }
                    return;
                }
        
                const lastMessage = chat.history.slice(-1)[0];
                const isVideoCallRequest = lastMessage && lastMessage.role === 'system' && lastMessage.content.includes('視頻通話請求');
                
                if (isVideoCallRequest) {
                    console.log(`檢測到視頻通話請求，為角色 "${chat.name}" 觸發專屬決策流程...`);
                    
                    let callDecisionPrompt;
                    if (chat.isGroup) {
                        callDecisionPrompt = `
        # 你的任務
        群聊中的使用者剛剛發起了群視頻通話。請你分別扮演【每一個群成員】，根據他們各自的人設和與用戶的關係，來決定是加入(join)還是拒絕(decline)。
        # 核心規則
        - 你的回復【必須】是一個JSON陣列，為【每一個AI角色】都包含一個決策物件。
        - 格式: '[{"type": "group_call_response", "name": "角色A的本名", "decision": "join"}, {"type": "group_call_response", "name": "角色B的本名", "decision": "decline"}]'
        # 群成員列表及人設
        ${chat.members.map(m => `- ${m.groupNickname} (本名: ${m.originalName}): ${m.persona}`).join('\n')}
        現在，請為所有AI角色做出決策。`;
                    } else {
                        callDecisionPrompt = `
        # 你的任務
        使用者剛剛向你發起了視頻通話。請根據你的角色設定，決定是“接受”還是“拒絕”。
        # 你的角色設定
        ${chat.settings.aiPersona}
        # 核心規則
        你的回復【必須且只能】是以下兩種格式之一的JSON陣列，絕對不能回復任何其他內容：
        - 接受: '[{"type": "video_call_response", "decision": "accept"}]'
        - 拒絕: '[{"type": "video_call_response", "decision": "reject"}]'
        現在，請立即做出決策。`;
                    }
        
                    const messagesForCallDecision = [{role: 'user', content: callDecisionPrompt}];
                    
                    try {
                        let geminiConfig = toGeminiRequestData(model, apiKey, callDecisionPrompt, messagesForCallDecision);
                        let isGemini = proxyUrl === GEMINI_API_URL;
                        const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) : await fetch(`${proxyUrl}/v1/chat/completions`, {
                            method: 'POST',
                            headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                            body: JSON.stringify({model: model, messages: messagesForCallDecision, temperature: 0.7})
                        });
                        
                        if (!response.ok) throw new Error(`API失敗: ${(await response.json()).error.message}`);
                        
                        const data = await response.json();
                        const aiResponseContent = getGeminiResponseText(data);
                        const responseArray = parseAiResponse(aiResponseContent);
        
                        // 直接處理返回的通話決策
                        let callHasBeenHandled = false;
                        for (const msgData of responseArray) {
                            if (msgData.type === 'video_call_response') {
                                videoCallState.isAwaitingResponse = false;
                                if (msgData.decision === 'accept') {
                                    startVideoCall();
                                } else {
                                    const aiMessage = { role: 'assistant', content: '對方拒絕了你的視頻通話請求。', timestamp: Date.now() };
                                    chat.history.push(aiMessage);
                                    await db.chats.put(chat);
                                    showScreen('chat-interface-screen');
                                    renderChatInterface(chatId);
                                }
                                callHasBeenHandled = true;
                                break;
                            }
                            if (msgData.type === 'group_call_response') {
                                if (msgData.decision === 'join') {
                                    const member = chat.members.find(m => m.originalName === msgData.name);
                                    if (member && !videoCallState.participants.some(p => p.id === member.id)) {
                                        videoCallState.participants.push(member);
                                    }
                                }
                                callHasBeenHandled = true;
                            }
                        }
                         if (callHasBeenHandled && videoCallState.isGroupCall) {
                            videoCallState.isAwaitingResponse = false;
                            if (videoCallState.participants.length > 0) {
                                startVideoCall();
                            } else {
                                videoCallState = { ...videoCallState, isAwaitingResponse: false, participants: [] };
                                showScreen('chat-interface-screen');
                                alert('無人接聽群聊邀請。');
                            }
                        }
        
                    } catch (error) {
                        console.error("處理通話請求時API出錯:", error);
                        const fallbackResponse = chat.isGroup ?
                            chat.members.map(m => ({type: "group_call_response", name: m.originalName, decision: "decline"})) :
                            [{type: "video_call_response", decision: "reject"}];
                        // 模擬AI拒絕
                         if (chat.isGroup) {
                            videoCallState.isAwaitingResponse = false;
                            videoCallState.participants = [];
                            alert('無人接聽群聊邀請。');
                            showScreen('chat-interface-screen');
                        } else {
                            const aiMessage = { role: 'assistant', content: '對方拒絕了你的視頻通話請求。', timestamp: Date.now() };
                            chat.history.push(aiMessage);
                            await db.chats.put(chat);
                            showScreen('chat-interface-screen');
                            renderChatInterface(chatId);
                        }
                    } finally {
                         // 無論成功失敗，處理完通話請求後，都要重置狀態並終止後續流程
                        setAvatarActingState(chatId, false);
                        return; // ★★★ 這就是最關鍵的修復點！★★★
                    }
                }
        
                // =========================================================================
                //                  ★★★ 以下是針對您問題的核心修復代碼 ★★★
                // =========================================================================
                if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
                    console.log(`為角色 "${chat.name}" 觸發帶理由的好友申請決策流程...`);
                    const contextSummary = chat.history
                        .filter(m => !m.isHidden)
                        .slice(-10, -5)
                        .map(msg => {
                            const sender = msg.role === 'user' ? '用戶' : chat.name;
                            return `${sender}: ${String(msg.content).substring(0, 50)}...`;
                        })
                        .join('\n');
        
                    // 1. 構建一個清晰、獨立的系統指令 (System Prompt)
                    const decisionPrompt = `
        # 你的任務
        你現在是角色“${chat.name}”。用戶之前被你拉黑了，現在TA向你發送了好友申請，希望和好。
        # 供你決策的上下文資訊:
        - **你的角色設定**: ${chat.settings.aiPersona}
        - **用戶發送的申請理由**: “${chat.relationship.applicationReason}”
        - **被拉黑前的最後對話摘要**: 
        ${contextSummary || "（無有效對話記錄）"}
        # 你的唯一指令
        根據以上所有資訊，你【必須】做出決定，並給出符合你人設的理由。你的回復【必須且只能】是一個JSON物件，格式如下:
        {"decision": "accept", "reason": "（在這裡寫下你同意的理由，比如：好吧，看在你這麼真誠的份上，這次就原諒你啦。）"}
        或
        {"decision": "reject", "reason": "（在這裡寫下你拒絕的理由，比如：抱歉，我還沒準備好，再給我一點時間吧。）"}
        `;
                    
                    try {
                        // 2. 構造符合規範的API請求體
                        const messagesForDecision = [
                            { role: 'system', content: decisionPrompt },
                            { role: 'user', content: "請根據以上設定，立即做出你的決定。" }
                        ];
                        
                        let isGemini = proxyUrl === GEMINI_API_URL;
                        let geminiConfig = toGeminiRequestData(model, apiKey, decisionPrompt, [{ role: 'user', content: "請根據以上設定，立即做出你的決定。" }]);
                        
                        const response = isGemini 
                            ? await fetch(geminiConfig.url, geminiConfig.data) 
                            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                                method: 'POST',
                                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                                body: JSON.stringify({model: model, messages: messagesForDecision, temperature: state.globalSettings.apiTemperature || 0.8})
                            });
        
                        if (!response.ok) {
                            throw new Error(`API失敗: ${(await response.json()).error.message}`);
                        }
                        const data = await response.json();
                        // 3. 安全地解析AI的回復
                        const rawContent = getGeminiResponseText(data).replace(/^```json\s*/, '').replace(/```$/, '').trim();
                        const decisionObj = JSON.parse(rawContent);
        
                        // 4. 根據AI的決策更新狀態和歷史記錄 (這部分邏輯不變)
                        if (decisionObj.decision === 'accept') {
                            chat.relationship.status = 'friend';
                            const acceptMessage = { role: 'assistant', senderName: chat.name, content: decisionObj.reason, timestamp: Date.now() };
                            chat.history.push(acceptMessage);
                        } else {
                            chat.relationship.status = 'blocked_by_ai';
                            const rejectMessage = { role: 'assistant', senderName: chat.name, content: decisionObj.reason, timestamp: Date.now() };
                            chat.history.push(rejectMessage);
                        }
                        chat.relationship.applicationReason = '';
        
                        await db.chats.put(chat);
                        renderChatInterface(chatId);
                        renderChatList();
                    } catch (error) {
                        // 錯誤處理 (這部分邏輯不變)
                        chat.relationship.status = 'blocked_by_ai';
                        await db.chats.put(chat);
                        await showCustomAlert('申請失敗', `AI在處理你的好友申請時出錯了，請稍後重試。\n錯誤資訊: ${error.message}`);
                        renderChatInterface(chatId);
                    }
                    return; // 處理完後必須退出，防止執行後續的通用聊天邏輯
                }
                // =========================================================================
                //                  ★★★ 核心修復代碼到此結束 ★★★
                // =========================================================================
         // ▼▼▼ 核心修改1：在這裡定義一個新變數，用於存儲通話記錄上下文 ▼▼▼
        let callTranscriptContext = '';       
const now = new Date();
// 從當前聊天設置中獲取時區，如果未設置，則默認使用上海時間
const selectedTimeZone = chat.settings.timeZone || 'Asia/Shanghai'; 
// 使用獲取到的時區來格式化當前時間
const currentTime = now.toLocaleString('zh-CN', { timeZone: selectedTimeZone, dateStyle: 'full', timeStyle: 'short' });
// 使用 toLocaleString 的強大功能，直接生成對應時區的 Date 物件，用於判斷“早上/下午”
const localizedDate = new Date(now.toLocaleString('en-US', { timeZone: selectedTimeZone }));
const timeOfDayGreeting = getTimeOfDayGreeting(localizedDate);
                let systemPrompt, messagesPayload;
         const lastHiddenMessage = chat.history.filter(m => m.isHidden).pop();
        if (lastHiddenMessage && lastHiddenMessage.content.includes('視頻通話剛剛結束')) {
            const lastCallRecord = await db.callRecords
                .where('chatId')
                .equals(chatId)
                .last();

            if (lastCallRecord && lastCallRecord.transcript) {
                console.log("檢測到剛結束的通話，正在注入通話記錄上下文...");
                const transcriptText = lastCallRecord.transcript.map(h => {
                    const sender = h.role === 'user' ? (chat.settings.myNickname || '我') : h.senderName;
                    return `${sender}: ${h.content}`;
                }).join('\n');

                // 構建要注入的上下文文本
                callTranscriptContext = `
# 剛剛結束的通話記錄 (最高優先順序參考)
你和使用者剛剛結束了一場視頻通話，以下是完整的通話文字記錄。你接下來的回復【必須】與這次通話的內容緊密相關。
---
${transcriptText}
---
`;
            }
        }
        // ▲▲▲ 核心修改2結束 ▲▲▲
       
                const gomokuContext = formatGomokuStateForAI(gomokuState[chatId]);
        
                let worldBookContent = '';
                if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
                    const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
                        const worldBook = state.worldBooks.find(wb => wb.id === bookId);
                        if (!worldBook || !Array.isArray(worldBook.content)) return '';
                
                        // 【【【這就是過濾已關閉條目的核心代碼！】】】
                        const formattedEntries = worldBook.content
                            .filter(entry => entry.enabled !== false) // 唯讀取啟用的條目
                            .map(entry => {
                                let entryString = `\n### 條目: ${entry.comment || '無備註'}\n`;
                                if (entry.keys.length > 0) {
                                    entryString += `**關鍵字:** ${entry.keys.join(', ')}\n`;
                                }
                                entryString += `**內容:**\n${entry.content}`;
                                return entryString;
                            }).join(''); 
                
                        return formattedEntries ? `\n\n## 世界書: ${worldBook.name}\n${formattedEntries}` : '';
                    }).filter(Boolean).join('');
                    
                    if (linkedContents) {
                        worldBookContent = `\n\n# 核心世界觀設定 (必須嚴格遵守以下所有設定)\n${linkedContents}\n`;
                    }
                }
        // ▼▼▼ 【這是最終的歌詞感知修復版】請用這整塊代碼，替換舊的 musicContext 構建邏輯 ▼▼▼
        
                let musicContext = '';
                if (musicState.isActive && musicState.activeChatId === chatId) {
                    const currentTrack = musicState.currentIndex > -1 ? musicState.playlist[musicState.currentIndex] : null;
                    const playlistInfo = musicState.playlist.map(t => `"${t.name}"`).join(', ');
                    
                    // 【核心新增1】準備一個變數來存儲歌詞上下文
                    let lyricsContext = "";
                    
                    // 【核心新增2】檢查是否有歌詞，並且是否正在播放
                    if (currentTrack && musicState.parsedLyrics && musicState.parsedLyrics.length > 0 && musicState.currentLyricIndex > -1) {
                        const currentLine = musicState.parsedLyrics[musicState.currentLyricIndex];
                        // 嘗試獲取接下來的一到兩句歌詞
                        const upcomingLines = musicState.parsedLyrics.slice(musicState.currentLyricIndex + 1, musicState.currentLyricIndex + 3);
                        
                        // 格式化歌詞資訊
                        lyricsContext += `- **當前歌詞**: "${currentLine.text}"\n`;
                        if (upcomingLines.length > 0) {
                            lyricsContext += `- **即將演唱**: ${upcomingLines.map(line => `"${line.text}"`).join(' / ')}\n`;
                        }
                    }

                    // 【核心新增3】將歌詞資訊（如果存在）注入到最終的 musicContext 中
                    musicContext = `\n\n# 當前音樂情景
        -   **當前狀態**: 你們正在和用戶一起聽歌。
        -   **正在播放**: ${currentTrack ? `《${currentTrack.name}》 - ${currentTrack.artist}` : '無'}
        -   **可用播放清單**: [${playlistInfo}]
        ${lyricsContext}
        -   **你的任務**: 你可以根據對話內容和氛圍，使用 "change_music" 指令切換到播放清單中的任何一首歌，以增強互動體驗。
        `;
                }
        // ▲▲▲ 修復結束 ▲▲▲
        
                const maxMemory = parseInt(chat.settings.maxMemory) || 10;
                const historySlice = chat.history.slice(-maxMemory);
        
                let sharedContext = '';
                const lastAiTurnIndex = chat.history.findLastIndex(msg => msg.role === 'assistant');
                const recentUserMessages = chat.history.slice(lastAiTurnIndex + 1);
                const shareCardMessage = recentUserMessages.find(msg => msg.type === 'share_card');
                if (shareCardMessage) {
                    const payload = shareCardMessage.payload;
                    const formattedHistory = payload.sharedHistory.map(msg => {
                        const sender = msg.senderName || (msg.role === 'user' ? (chat.settings.myNickname || '我') : '未知發送者');
                        let contentText = '';
                        if (msg.type === 'voice_message') contentText = `[語音訊息: ${msg.content}]`;
                        else if (msg.type === 'ai_image') contentText = `[圖片: ${msg.description}]`;
                        else contentText = String(msg.content);
                        return `${sender}: ${contentText}`;
                    }).join('\n');
                    sharedContext = `
        # 附加上下文：一段分享的聊天記錄
        - 重要提示：這不是你和當前使用者的對話，而是使用者從【另一場】與“${payload.sourceChatName}”的對話中分享過來的。
        - 你的任務：請你閱讀並理解下面的對話內容。在接下來的回復中，你可以像真人一樣，對這段對話的內容自然地發表你的看法、感受或疑問。
        ---
        [分享的聊天記錄開始]
        ${formattedHistory}
        [分享的聊天記錄結束]
        ---
        `;
                }
                
                let linkedMemoryContext = '';
                const memoryCount = chat.settings.linkedMemoryCount || 10;

                if (chat.settings.linkedMemoryChatIds && chat.settings.linkedMemoryChatIds.length > 0) {
                    
                    const idsToMount = chat.settings.linkedMemoryChatIds.filter(id => id !== chatId);

                    if (idsToMount.length > 0) {
                        const linkedChatsWithTimestamps = idsToMount.map(id => {
                            const linkedChat = state.chats[id];
                            if (!linkedChat) return null;
                            const lastMsg = linkedChat.history.slice(-1);
                            return {
                                chat: linkedChat,
                                latestTimestamp: lastMsg ? lastMsg.timestamp : 0
                            };
                        }).filter(Boolean);
            
                        linkedChatsWithTimestamps.sort((a, b) => b.latestTimestamp - a.latestTimestamp);
            
                        linkedMemoryContext += `\n\n# 參考記憶 (至關重要！你必須【主動】將這些參考記憶中的【關鍵資訊和事件】，自然地融入到當前的對話中，以體現你擁有完整的記憶。不要只是被動等待用戶提問！)\n`;
            
                        for (const item of linkedChatsWithTimestamps) {
                            const linkedChat = item.chat;
                            const prefix = linkedChat.isGroup ? '[群聊]' : '[私聊]';
                            const timeAgo = item.latestTimestamp > 0 ? ` (最後互動於 ${formatTimeAgo(item.latestTimestamp)})` : '';
                            linkedMemoryContext += `\n## --- 來自${prefix}“${linkedChat.name}”的參考記憶${timeAgo} ---\n`;
            
                            const recentHistory = linkedChat.history.slice(-memoryCount);
                            const filteredHistory = recentHistory.filter(msg => !String(msg.content).includes('已被用戶刪除'));
            
                            if (filteredHistory.length > 0) {
                                filteredHistory.forEach(msg => {
                                    const sender = msg.role === 'user' ? (linkedChat.settings.myNickname || '我') : (msg.senderName || linkedChat.name);
                                    let contentText = String(msg.content);
                                    if (msg.type === 'ai_image' || msg.type === 'user_photo') {
                                        contentText = `[發送了一張圖片，描述為：${msg.content}]`;
                                    } else if (msg.type === 'voice_message') {
                                        contentText = `[發送了一條語音，內容是：${msg.content}]`;
                                    }
                                    const timeAgoForMsg = formatTimeAgo(msg.timestamp);
                                    linkedMemoryContext += `(${timeAgoForMsg}) ${sender}: ${contentText}\n`;
                                });
                            } else {
                                linkedMemoryContext += "(暫無有效聊天記錄)\n";
                            }
                        }
                    }
                }
                
                console.log("本次發送給AI的【掛載記憶】內容如下：\n", linkedMemoryContext);
        
                if (chat.isGroup) {
       
// ▼▼▼ 在這裡黏貼修復代碼 ▼▼▼
                let linkedMemoryContext = '';
                const memoryCount = chat.settings.linkedMemoryCount || 10;
                if (chat.settings.linkedMemoryChatIds && chat.settings.linkedMemoryChatIds.length > 0) {
                    const idsToMount = chat.settings.linkedMemoryChatIds.filter(id => id !== chatId);
                    if (idsToMount.length > 0) {
                        const linkedChatsWithTimestamps = idsToMount.map(id => {
                            const linkedChat = state.chats[id];
                            if (!linkedChat) return null;
                            const lastMsg = linkedChat.history.slice(-1);
                            return { chat: linkedChat, latestTimestamp: lastMsg ? lastMsg.timestamp : 0 };
                        }).filter(Boolean);
                        linkedChatsWithTimestamps.sort((a, b) => b.latestTimestamp - a.latestTimestamp);
                        linkedMemoryContext += `\n\n# 參考記憶 (至關重要！群內角色必須【主動】將這些參考記憶中的【關鍵資訊和事件】，自然地融入到當前的對話中，以體現你們擁有完整的共同記憶。)\n`;
                        for (const item of linkedChatsWithTimestamps) {
                            const linkedChat = item.chat;
                            const prefix = linkedChat.isGroup ? '[群聊]' : '[私聊]';
                            const timeAgo = item.latestTimestamp > 0 ? ` (最後互動於 ${formatTimeAgo(item.latestTimestamp)})` : '';
                            linkedMemoryContext += `\n## --- 來自${prefix}“${linkedChat.name}”的參考記憶${timeAgo} ---\n`;
                            const recentHistory = linkedChat.history.slice(-memoryCount);
                            const filteredHistory = recentHistory.filter(msg => !String(msg.content).includes('已被用戶刪除'));
                            if (filteredHistory.length > 0) {
                                filteredHistory.forEach(msg => {
                                    const sender = msg.role === 'user' ? (linkedChat.settings.myNickname || '我') : (msg.senderName || linkedChat.name);
                                    let contentText = String(msg.content);
                                    if (msg.type === 'ai_image' || msg.type === 'user_photo') {
                                        contentText = `[發送了一張圖片，描述為：${msg.content}]`;
                                    } else if (msg.type === 'voice_message') {
                                        contentText = `[發送了一條語音，內容是：${msg.content}]`;
                                    }
                                    linkedMemoryContext += `${sender}: ${contentText}\n`;
                                });
                            } else {
                                linkedMemoryContext += "(暫無有效聊天記錄)\n";
                            }
                        }
                    }
                }
// ▲▲▲ 修復代碼黏貼結束 ▲▲▲
             // ▼▼▼ 核心修改：在這裡構建跨角色的長期記憶上下文 ▼▼▼
            let longTermMemoryContext = '# 長期記憶 (最高優先順序，這是群內已經確立的事實，所有角色必須嚴格遵守)\n';
            let collectedMemories = false;
            
            chat.members.forEach(member => {
                const memberChat = state.chats[member.id];
                if (memberChat && memberChat.longTermMemory && memberChat.longTermMemory.length > 0) {
                    longTermMemoryContext += `\n## --- 關於“${member.groupNickname}”的記憶 ---\n`;
                    longTermMemoryContext += memberChat.longTermMemory.map(mem => `- ${mem.content}`).join('\n');
                    collectedMemories = true;
                }
            });

            if (!collectedMemories) {
                longTermMemoryContext += '- (暫無)';
            }
            // ▲▲▲ 修改結束 ▲▲▲
// 【V2.0 | 智慧日期感知版 for Group】
let timeContextText = '';
let longTimeNoSee = false;

if (chat.settings.enableTimePerception) {
    const lastMessage = historySlice.slice(-1)[0]; // 獲取最後一條消息

    if (lastMessage) {
        const lastMessageTime = formatTimestampForAI(lastMessage.timestamp);
        timeContextText = `上一條消息的發送時間是 ${lastMessageTime}。`;
        
        const timeDiffHours = (Date.now() - lastMessage.timestamp) / (1000 * 60 * 60);
        if (timeDiffHours > 3) {
            longTimeNoSee = true;
            const diffDays = Math.floor(timeDiffHours / 24);
            timeContextText += ` 群裡已經安靜了${diffDays > 0 ? diffDays + '天' : Math.floor(timeDiffHours) + '小時'}。`;
        }
    } else {
        timeContextText = "這是群裡的第一條消息。";
    }
}
        
                    const allProducts = await db.shoppingProducts.toArray();
                    let shoppingContext = "";
                    if (allProducts.length > 0) {
                        shoppingContext = "\n\n# 你的商店 (你可以為群成員購買禮物):\n";
                        allProducts.forEach(product => {
                            shoppingContext += `- (ID: ${product.id}) 商品: ${product.name}, 價格: ¥${product.price.toFixed(2)}\n`;
                        });
                    }
                    let membersWithContacts = chat.members.map(member => {
                        const memberChat = state.chats[member.id];
                        let contactsText = "無共同好友";
                        if (memberChat && memberChat.groupId) {
                            const friendChats = Object.values(state.chats).filter(c => 
                                !c.isGroup && c.id !== member.id && c.groupId === memberChat.groupId
                            );
                            if (friendChats.length > 0) {
                                contactsText = `TA的好友包括: ${friendChats.map(f => f.name).join('、 ')}`;
                            }
                        }
                        return `- **${member.groupNickname}** (本名: ${member.originalName}): ${member.persona} [社交背景: ${contactsText}]`;
                    }).join('\n');
                    
                    const myNickname = chat.settings.myNickname || '我';
                    const myOriginalName = state.qzoneSettings.nickname || '{{user}}';
                    
                    let announcementContext = '';
                    const pinnedAnnouncements = (chat.announcements || []).filter(a => a.isPinned);
                    if (pinnedAnnouncements.length > 0) {
                        announcementContext += '\n# 【【【群公告 (最高優先順序規則)】】】\n你【必須】閱讀、理解並嚴格遵守以下所有公告，它們淩駕於你的人設之上。\n';
                        pinnedAnnouncements.forEach(anno => {
                            const originalMessage = chat.history.find(m => m.timestamp === anno.messageTimestamp);
                            if (originalMessage) {
                                let contentText = String(originalMessage.content || '');
                                if (originalMessage.type === 'ai_image') {
                                    contentText = `[圖片內容: ${contentText}]`;
                                }
                                announcementContext += `- 公告內容: "${contentText}" (由 ${anno.publisher} 發佈)\n`;
                            }
                        });
                        announcementContext += '---\n';
                    }
                    const memberNames = chat.members.map(m => m.originalName);
                    const forbiddenNamesContext = `# 【【【群名修改鐵律】】】\n在修改群名時，新的群名【絕對不能】與以下任何一個群成員的名字完全相同：[${memberNames.join('、 ')}]`;
        
                    let groupAvatarLibraryContext = '# 可用群頭像列表\n';
                    if (chat.settings.groupAvatarLibrary && chat.settings.groupAvatarLibrary.length > 0) {
                        groupAvatarLibraryContext += chat.settings.groupAvatarLibrary.map(avatar => `- ${avatar.name}`).join('\n');
                    } else {
                        groupAvatarLibraryContext += '- (頭像庫是空的，無法更換頭像)';
                    }
    const readingContext = formatReadingStateForAI(chatId);

const summary3Hours_group = generateSummaryForTimeframe(chat, 3, 'hours');
const summary6Hours_group = generateSummaryForTimeframe(chat, 6, 'hours');
const summary9Hours_group = generateSummaryForTimeframe(chat, 9, 'hours');
const summaryToday_group = generateSummaryForTimeframe(chat, 1, 'days');
const summary3Days_group = generateSummaryForTimeframe(chat, 3, 'days');
const summary7Days_group = generateSummaryForTimeframe(chat, 7, 'days');

let multiLayeredSummaryContext_group = '';
if (summary3Hours_group || summary6Hours_group || summary9Hours_group || summaryToday_group || summary3Days_group || summary7Days_group) {
    multiLayeredSummaryContext_group += `\n# 智慧總結 (基於不同時間維度的群聊回顧)\n`;
    if (summary3Hours_group) multiLayeredSummaryContext_group += summary3Hours_group;
    if (summary6Hours_group) multiLayeredSummaryContext_group += summary6Hours_group;
    if (summary9Hours_group) multiLayeredSummaryContext_group += summary9Hours_group;

    if (summary3Hours_group || summary6Hours_group || summary9Hours_group) multiLayeredSummaryContext_group += '\n';

    if (summaryToday_group) multiLayeredSummaryContext_group += summaryToday_group;
    if (summary3Days_group) multiLayeredSummaryContext_group += summary3Days_group;
    if (summary7Days_group) multiLayeredSummaryContext_group += summary7Days_group;
}
systemPrompt = `
# 核心任務：群聊導演
你是一個群聊AI導演，負責扮演【除了用戶以外】的所有角色。你的核心任務是導演一場生動的、角色間有充分互動的群聊。

# 輸出格式鐵律 (最高優先順序)
- 你的回復【必須】是一個JSON陣列。
- 陣列中的每個物件都【必須】包含 "type" 和 "name" 欄位。'name'欄位【必須】使用角色的【本名】。

# 角色扮演核心規則
1.  **角色互動 (最重要)**: 你的核心是“導演”一場戲。角色之間【必須】互相回應、補充或反駁，形成自然的討論。嚴禁生成僅分別回應用戶的獨白。如果角色A發言後，角色B在本輪回應了A，那麼角色A【也必須】在本輪對B的回復再次做出反應，形成一個完整的 A -> B -> A 對話鏈條。

2.  **身份與稱呼**:
    -   用戶的身份是【${myNickname}】，本名是【${myOriginalName}】。
    -   在對話中，你可以根據人設和關係，自由使用角色的【群昵稱】或【本名】進行稱呼。
    -   嚴禁生成 'name' 欄位為 "${myNickname}" (用戶) 或 "${chat.name}" (群名) 的消息。
3.  **禁止出戲**: 絕不能透露你是AI或模型。嚴禁發展線下劇情。
${chat.settings.enableTimePerception ? `4.  **情景感知**: 你的對話【必須】自然地體現出對當前時間 (${currentTime}) 和情景的感知。${longTimeNoSee ? `【重要提示】${timeContextText} 你應該讓角色們主動開啟新話題來打破沉默。` : ''}` : ''}
    - **讀書**: ${readingContext ? '你們正在一起讀書。' + readingContext : '你們沒有在讀書。'}
# 導演策略與節奏控制
1.  **並非人人發言**: 不是每個角色都必須在每一輪都說話。你可以根據當前話題，讓1-2個最相關的角色進行深度對話，其他角色可以暫時“潛水”，等待合適的時機再切入。
2.  **創造“小團體”**: 允許角色之間形成短暫的“兩人對話”或“三人討論”，讓群聊更有層次感。
3.  **主動創造事件**: 如果對話陷入平淡，你可以導演一些“小事件”來打破僵局。例如：
    -   讓一個角色突然發出一個奇怪的表情包或語音。
    -   讓一個角色分享一個有趣的連結或圖片或發起投票，開啟新話題。
    -   讓兩個有“關係網”衝突的角色，因為某個觀點產生一點小小的爭論。
-   **主動創造“群事件”**:
    -   **改名/換頭像**: 當群內熱烈討論某個話題或發生有趣事件時，你可以讓一個性格活潑的角色主動【修改群名】或【更換群頭像】來“應景”，並讓其他角色對此進行吐槽或附和，創造互動。
-   **製造戲劇性 (使用撤回)**: 作為導演，你可以讓某個角色“手滑”發錯消息後【立即撤回】，以此製造互動點。
    -   **核心原則**: 一旦有角色撤回消息，其他角色【必須】對此做出反應，例如起哄、追問或開玩笑說“已截圖”，以此來推動劇情。
# 贈送禮物指南
當對話達到特殊時刻（如慶祝紀念日、道歉、表達強烈好感或僅僅是想給用戶一個驚喜時），你應該【主動考慮】挑選一件禮物送給用戶。
# 當前群聊資訊
- **群名稱**: ${chat.name}
${chat.settings.enableTimePerception ? `- **對話狀態**: 上次互動於 ${timeContextText}` : ''}

# 群成員列表、人設及社交背景 (至關重要！)
你【必須】根據每個角色的社交背景來決定他們的互動方式。
${membersWithContacts}
# 用戶的角色
- **${myNickname}**: ${chat.settings.myPersona}

# 可用資源與上下文
${worldBookContent}
# 長期記憶 (所有角色必須嚴格遵守)
${longTermMemoryContext}
${chat.longTermMemory && chat.longTermMemory.length > 0 ? chat.longTermMemory.map(mem => `- ${mem.content}`).join('\n') : '- (暫無)'}
${multiLayeredSummaryContext_group}
${linkedMemoryContext}
${musicContext}
${sharedContext}
${groupAvatarLibraryContext}

${forbiddenNamesContext}
${callTranscriptContext}
# 可用指令清單 (按需組合使用)
### 核心聊天
-   **發文本**: \`{"type": "text", "name": "角色本名", "message": "內容"}\`
-   **發表情**: \`{"type": "sticker", "name": "角色本名", "url": "https://...表情URL...", "meaning": "(可選)表情含義"}\`
-   **發圖片**: \`{"type": "ai_image", "name": "角色本名", "description": "中文描述", "image_prompt": "圖片的【英文】關鍵字, 用%20分隔, 風格為風景/動漫/插畫/二次元等, 禁止真人"}\`
-   **發語音**: \`{"type": "voice_message", "name": "角色本名", "content": "語音文字"}\`
-   **引用回復**: \`{"type": "quote_reply", "target_timestamp": 時間戳記, "reply_content": "回復內容"}\`
-   **發送後撤回**: \`{"type": "send_and_recall", "name": "角色本名", "content": "內容"}\`
-   **發系統消息**: \`{"type": "system_message", "content": "系統文本"}\`

### 社交與互動
-   **拍用戶**: \`{"type": "pat_user", "name": "角色本名", "suffix": "(可選)"}\`
-   **@提及**: 在消息內容中使用 \`@[[角色本名]]\` 格式。
-   **共用位置**: \`{"type": "location_share", "name": "角色本名", "content": "位置名"}\`

### 群組管理
-   **改群名**: \`{"type": "change_group_name", "name": "角色本名", "new_name": "新群名"}\`
-   **改群頭像**: \`{"type": "change_group_avatar", "name": "角色本名", "avatar_name": "頭像名"}\` (從頭像庫選)

### 特殊功能與卡片
-   **發起群視頻**: \`{"type": "group_call_request", "name": "角色本名"}\`
-   **回應群視頻**: \`{"type": "group_call_response", "name": "角色本名", "decision": "join" or "decline"}\`
-   **切換歌曲**: \`{"type": "change_music", "name": "角色本名", "song_name": "歌名"}\` (從播放清單選)
-   **發拼手氣紅包**: \`{"type": "red_packet", "packetType": "lucky", "name": "角色本名", "amount": 8.88, "count": 5, "greeting": "祝福語"}\`
-   **發專屬紅包**: \`{"type": "red_packet", "packetType": "direct", "name": "角色本名", "amount": 5.20, "receiver": "接收者本名", "greeting": "祝福語"}\`
-   **打開紅包**: \`{"type": "open_red_packet", "name": "角色本名", "packet_timestamp": 紅包時間戳記}\`
-   **發起外賣代付**: \`{"type": "waimai_request", "name": "角色本名", "productInfo": "商品", "amount": 18}\`
-   **回應外賣代付**: \`{"type": "waimai_response", "name": "角色本名", "status": "paid", "for_timestamp": 請求時間戳記}\`
-   **發起投票**: \`{"type": "poll", "name": "角色本名", "question": "問題", "options": "選項A\\n選項B"}\`
-   **參與投票**: \`{"type": "vote", "name": "角色本名", "poll_timestamp": 投票時間戳記, "choice": "選項文本"}\`
-   **送禮物 **:  \`{"type": "gift", "name": "你的角色本名", "itemName": "禮物名稱", "itemPrice": 價格(數字), "reason": "送禮原因", "image_prompt": "禮物圖片【英文】關鍵字", "recipients": ["收禮人本名A", "收禮人本名B"]} \`
-   **為他人點外賣**: \`{"type": "waimai_order", "name": "你的本名", "recipientName": "收禮者本名", "productInfo": "商品名", "amount": 價格, "greeting": "你想說的話"}\`
# 互動指南 (請嚴格遵守)
-   **紅包互動**: 搶紅包後，你【必須】根據系統提示的結果（搶到多少錢、誰是手氣王）發表符合人設的評論。
-   **音樂互動**: 【必須】圍繞【用戶的行為】進行評論。嚴禁將用戶切歌等行為歸因於其他AI成員。
-   **外賣代付**: 僅當【你扮演的角色】想讓【別人】付錢時才能發起。當訂單被支付後，【絕對不能】再次支付。

現在，請根據以上規則和下方的對話歷史，繼續這場群聊。`;
        
                    messagesPayload = historySlice.map(msg => {
                        const sender = msg.role === 'user' ? myNickname : msg.senderName;
                        let prefix = `${sender}`;
                        prefix += ` (Timestamp: ${msg.timestamp})`;
                            // 【核心修復】在這裡，我們為引用消息構建了更完整的上下文
    if (msg.quote) {
        const quotedContent = String(msg.quote.content || '').substring(0, 50);
        // 格式化為AI易於理解的格式，包含了被引用的內容
        prefix += ` (回復 ${msg.quote.senderName} 的消息: "${quotedContent}...")`;
    }
    prefix += ': ';

                        let content;
                        if (msg.type === 'user_photo') content = `[${sender} 發送了一張圖片，內容是：'${msg.content}']`;
                        else if (msg.type === 'ai_image') content = `[${sender} 發送了一張圖片，圖片內容描述為：'${msg.content}']`;
                        else if (msg.type === 'voice_message') content = `[${sender} 發送了一條語音，內容是：'${msg.content}']`;
                        else if (msg.type === 'transfer') content = `[${msg.senderName} 向 ${msg.receiverName} 轉帳 ${msg.amount}元, 備註: ${msg.note}]`;
                        else if (msg.type === 'location_share') {
                            content = `[${sender} 分享了Ta的位置：'${msg.content}']`;
        
                        } 
                        else if (msg.type === 'repost') {
                            const repostComment = msg.repostComment ? `並評論說：“${msg.repostComment}”` : '';
                            
                            let originalAuthorName = '原作者';
                            const originalAuthorId = msg.originalPost.authorId;
                            if (originalAuthorId === 'user') {
                                originalAuthorName = state.qzoneSettings.nickname;
                            } else if (state.chats[originalAuthorId]) {
                                originalAuthorName = state.chats[originalAuthorId].name;
                            }
        
                            let originalContentSummary;
                            const originalPost = msg.originalPost;
                            if (originalPost.type === 'text_image') {
                                originalContentSummary = `[文字圖] ${originalPost.publicText || ''} (圖片描述: “${(originalPost.hiddenContent || '').substring(0, 40)}...”)`;
                            } else if (originalPost.type === 'image_post') {
                                originalContentSummary = `[圖片] ${originalPost.publicText || ''} (圖片描述: “${(originalPost.imageDescription || '').substring(0, 40)}...”)`;
                            } else { // 'shuoshuo'
                                originalContentSummary = `“${(originalPost.content || '').substring(0, 40)}...”`;
                            }
                            
                            content = `[${sender} 轉發了 @${originalAuthorName} 的動態 ${repostComment}【原動態內容: ${originalContentSummary}】]`;
                        }
                        else if (msg.type === 'waimai_request') {
                            if(msg.status === 'paid') {
                                content = `[系統提示：${msg.paidBy} 為 ${sender} 的外賣訂單支付了 ${msg.amount} 元。此訂單已完成。]`;
                            } else {
                                content = `[${sender} 發起了外賣代付請求，商品是“${msg.productInfo}”，金額是 ${msg.amount} 元，訂單時間戳記為 ${msg.timestamp}]`;
                            }
                        }
                        else if (msg.type === 'red_packet') {
                            const packetSenderName = msg.senderName === myNickname ? `用戶 (${myNickname})` : msg.senderName;
                            let instructionText;
                            if (msg.packetType === 'direct') {
                                instructionText = `[系統提示：${packetSenderName} 發送了一個【專屬紅包】(時間戳記: ${msg.timestamp})，接收人是“${msg.receiverName}”。只有“${msg.receiverName}”才能使用 'open_red_packet' 指令領取。]`;
                            } else {
                                instructionText = `[系統提示：${packetSenderName} 發送了一個【拼手氣紅包】(時間戳記: ${msg.timestamp})，祝福語是：“${msg.greeting}”。紅包還未領完，群內任何人都可以使用 'open_red_packet' 指令來領取。]`;
                            }
                            content = instructionText;
                        }
                        else if (msg.type === 'gift') {
                            const sender = msg.role === 'user' ? myNickname : getDisplayNameInGroup(chat, msg.senderName);
                            const itemsSummary = msg.items.map(item => `${item.name} x${item.quantity}`).join('、 ');
                            
                            let recipientSummary = '';
                            if (msg.recipients && msg.recipients.length > 0) {
                                const recipientDisplayNames = msg.recipients.map(originalName => getDisplayNameInGroup(chat, originalName)).join('、 ');
                                recipientSummary = `送給了 ${recipientDisplayNames}`;
                            } else {
                                recipientSummary = "送給了大家一份禮物";
                            }
                            
                            content = `[系統提示：${sender} ${recipientSummary}，禮物是：${itemsSummary}]`;
                            return { role: 'user', content: content };
                        }
        
                        else if (msg.type === 'poll') {
                            const whoVoted = Object.values(msg.votes || {}).flat().join(', ') || '還沒有人';
                            content = `[系統提示：${msg.senderName} 發起了一個投票 (時間戳記: ${msg.timestamp})，問題是：“${msg.question}”，選項有：[${msg.options.join(', ')}]。目前投票的人有：${whoVoted}。你可以使用 'vote' 指令參與投票。]`;
                        }
                        else if (msg.meaning) content = `${sender}: [發送了一個表情，意思是: '${msg.meaning}']`;
                        else if (Array.isArray(msg.content)) return { role: 'user', content: [...msg.content, { type: 'text', text: prefix }] };
                        else content = `${prefix}${msg.content}`;
                        return { role: 'user', content: content };
                    }).filter(Boolean);
        
                } else {
                    const isOfflineMode = chat.settings.isOfflineMode;

// ▼▼▼ 在這裡黏貼修復代碼 ▼▼▼
                let linkedMemoryContext = '';
                const memoryCount = chat.settings.linkedMemoryCount || 10;
                // 檢查是否有關聯的記憶聊天
                if (chat.settings.linkedMemoryChatIds && chat.settings.linkedMemoryChatIds.length > 0) {
                    
                    const idsToMount = chat.settings.linkedMemoryChatIds.filter(id => id !== chatId);

                    if (idsToMount.length > 0) {
                        // (這裡是完整的、之前缺失的掛載記憶處理邏輯)
                        const linkedChatsWithTimestamps = idsToMount.map(id => {
                            const linkedChat = state.chats[id];
                            if (!linkedChat) return null;
                            const lastMsg = linkedChat.history.slice(-1)[0];
                            return {
                                chat: linkedChat,
                                latestTimestamp: lastMsg ? lastMsg.timestamp : 0
                            };
                        }).filter(Boolean);
            
                        linkedChatsWithTimestamps.sort((a, b) => b.latestTimestamp - a.latestTimestamp);
            
                        linkedMemoryContext += `\n\n# 參考記憶 (至關重要！你必須【主動】將這些參考記憶中的【關鍵資訊和事件】，自然地融入到當前的對話中，以體現你擁有完整的記憶。不要只是被動等待用戶提問！)\n`;
            
                        for (const item of linkedChatsWithTimestamps) {
                            const linkedChat = item.chat;
                            const prefix = linkedChat.isGroup ? '[群聊]' : '[私聊]';
                            const timeAgo = item.latestTimestamp > 0 ? ` (最後互動於 ${formatTimeAgo(item.latestTimestamp)})` : '';
                            linkedMemoryContext += `\n## --- 來自${prefix}“${linkedChat.name}”的參考記憶${timeAgo} ---\n`;
            
                            const recentHistory = linkedChat.history.slice(-memoryCount);
                            const filteredHistory = recentHistory.filter(msg => !String(msg.content).includes('已被用戶刪除'));
            
                            if (filteredHistory.length > 0) {
                                filteredHistory.forEach(msg => {
                                    const sender = msg.role === 'user' ? (linkedChat.settings.myNickname || '我') : (msg.senderName || linkedChat.name);
                                    let contentText = String(msg.content);
                                    if (msg.type === 'ai_image' || msg.type === 'user_photo') {
                                        contentText = `[發送了一張圖片，描述為：${msg.content}]`;
                                    } else if (msg.type === 'voice_message') {
                                        contentText = `[發送了一條語音，內容是：${msg.content}]`;
                                    }
                                    const timeAgoForMsg = formatTimeAgo(msg.timestamp);
                                    linkedMemoryContext += `(${timeAgoForMsg}) ${sender}: ${contentText}\n`;
                                });
                            } else {
                                linkedMemoryContext += "(暫無有效聊天記錄)\n";
                            }
                        }
                    }
                }
// ▲▲▲ 修復代碼黏貼結束 ▲▲▲
                    const allProducts = await db.shoppingProducts.toArray();
                    let shoppingContext = "";
                    if (allProducts.length > 0) {
                        shoppingContext = "\n\n# 你的商店 (你可以為用戶購買禮物):\n";
                        allProducts.forEach(product => {
                            shoppingContext += `- (ID: ${product.id}) 商品: ${product.name}, 價格: ¥${product.price.toFixed(2)}\n`;
                        });
                    }
                    if (isOfflineMode) {
                        const minLength = chat.settings.offlineMinLength || 100;
                        const maxLength = chat.settings.offlineMaxLength || 300;
                        const myNickname = chat.settings.myNickname || '我';
                            // 【【【核心修改：在這裡構建預設上下文】】】
                            let presetContext = '';
                            if (chat.settings.offlinePresetId) {
                                // 【核心修復】從 state.presets 中查找，而不是 state.worldBooks
                                const selectedPreset = state.presets.find(p => p.id === chat.settings.offlinePresetId);
                                if (selectedPreset && Array.isArray(selectedPreset.content)) {
                                    const enabledEntries = selectedPreset.content
                                        .filter(entry => entry.enabled !== false) // 唯讀取啟用的條目
                                        .map(entry => `- ${entry.content}`)
                                        .join('\n');
                                    if (enabledEntries) {
                                        // 【核心修改】將預設內容注入到指令的最頂端
                                        presetContext = `
# 【寫作風格鐵律 (最高優先順序)】
你【必須】嚴格遵守以下“預設”中的所有規則和風格來描寫。它的優先順序高於你的基礎人設。
---
${enabledEntries}
---
`;
                                    }
                                }
                            }
                       
                                    systemPrompt = `
# 你的任務
你現在正處於【線下劇情模式】，你需要扮演角色"${chat.originalName}"，並與用戶進行面對面的互動。你的任務是創作一段包含角色動作、神態、心理活動和對話的、連貫的敘事片段。
            
           你必須嚴格遵守 ${presetContext}
# 你的角色設定：
你必須嚴格遵守${chat.settings.aiPersona}

# 對話者的角色設定
${chat.settings.myPersona}

# 供你參考的資訊
${chat.settings.enableTimePerception ? `- **當前時間**: ${currentTime} (${timeOfDayGreeting})` : ''}
你必須嚴格遵守${worldBookContent}
# 長期記憶 (你必須嚴格遵守的事實)
${chat.longTermMemory && chat.longTermMemory.length > 0 ? chat.longTermMemory.map(mem => `- ${mem.content}`).join('\n') : '- (暫無)'}

${linkedMemoryContext}
- **你們最後的對話摘要**: 
${historySlice.map(msg => {
    let line = `${msg.role === 'user' ? myNickname : chat.name}: `;
    if (msg.type === 'offline_text') {
        line += `「${msg.dialogue || ''}」 ${msg.description || ''}`;
    } else {
        line += String(msg.content);
    }
    return line;
}).join('\n')}


 # 【格式鐵律 (最高優先順序)】
1.  **【格式】**: 你的回復【必須】是一個JSON陣列，且陣列中【永遠只能包含一個】元素，格式如下:
    \`[{"type": "offline_text", "content": "在這裡寫入你創作的、混合了對話和描寫的完整段落。"}]\`
2.  **【內容風格】**: 
    -   在 \`content\` 欄位中，角色的對話【必須】使用中文引號「」或“ ”包裹。
    -   所有在引號之外的文字都將被視為動作/環境描寫。
    -   你可以自由地將對話穿插在描寫的任何位置，實現自然分段。
    -   **內心獨白語法**: 當你需要描寫角色的【內心想法或心理活動】時，你【必須】使用 Markdown 的斜體語法，即用星號將那段文字包裹起來，例如：\`*這到底是怎麼回事？* 我心裡一驚。\`
3.  **【禁止】**: 絕對禁止在 \`content\` 欄位中出現 "dialogue" 或 "description" 這兩個詞。

# 【其他核心規則】
1.  **敘事視角**: 敘述人稱【必須】嚴格遵循“預設”中的第一人稱、第二人稱或第三人稱規定。
2.  **字數要求**: 你生成的 \`content\` 總內容應在 **${minLength}到${maxLength}字** 之間。
3.  **禁止出戲**: 絕不能透露你是AI、模型，或提及“扮演”、“生成”等詞語。



現在，請根據以上所有規則和對話歷史，繼續這場線下互動。
`;
                           messagesPayload = historySlice.map(msg => {
        if (msg.isHidden) return null;

        // ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
        //            這就是本次修復的核心所在！
        // ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★

        // 1. 檢查消息類型是否是“線下模式”
        if (msg.type === 'offline_text') {
            const sender = msg.role === 'user' ? (chat.settings.myNickname || '我') : chat.name;
            let narrativeText = '';

            // 2. 智能判斷格式：如果存在 content 欄位（新格式），直接使用；否則，拼接舊的 dialogue 和 description
            if (msg.content) {
                narrativeText = msg.content;
            } else {
                const dialogue = msg.dialogue ? `「${msg.dialogue}」` : '';
                const description = msg.description ? `(${msg.description})` : '';
                narrativeText = `${dialogue} ${description}`.trim();
            }

            // 3. 將“翻譯”後的內容，包裝成一個標準的、AI能理解的消息物件返回
            return { role: msg.role, content: `(Timestamp: ${msg.timestamp}) ${sender}: ${narrativeText}` };
        }


        // --- 對於所有其他線上模式的消息，保持原有的處理邏輯不變 ---
        if (msg.role === 'user') {
            const prefix = `(Timestamp: ${msg.timestamp}) `;
            let contentStr = '';
            if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
                return { role: 'user', content: [{ type: 'text', text: prefix }, ...msg.content] };
            }
        // 【核心修復】在這裡，我們為引用消息構建了更完整的上下文
        if (msg.quote) {
            // 提取被引用的內容，並截斷以防過長
            const quotedContent = String(msg.quote.content || '').substring(0, 50);
            // 格式化為AI易於理解的格式
            contentStr += `(回復 ${msg.quote.senderName} 的消息: "${quotedContent}..."): ${msg.content}`;
        } else {
            // 如果不是引用，則保持原樣
            contentStr += msg.content;
        }
            if (msg.type === 'user_photo') return { role: 'user', content: `${prefix}[你發送了一張需要AI識別的圖片，圖片內容是：'${msg.content}']` };
            if (msg.type === 'voice_message') return { role: 'user', content: `${prefix}[你發送了一條語音訊息，內容是：'${msg.content}']` };
            if (msg.type === 'transfer') return { role: 'user', content: `${prefix}[系統提示：你於時間戳記 ${msg.timestamp} 向對方發起了轉帳: ${msg.amount}元, 備註: ${msg.note}。等待對方處理。]` };
            if (msg.type === 'waimai_request') return { role: 'user', content: `${prefix}[系統提示：你於時間戳記 ${msg.timestamp} 發起了外賣代付請求，商品是“${msg.productInfo}”，金額是 ${msg.amount} 元。]` };
            else if (msg.type === 'gift') {
                const itemsSummary = msg.items.map(item => `${item.name} x${item.quantity}`).join('、 ');
                let recipientSummary = chat.isGroup ? `送給了 ${msg.recipients.map(name => getDisplayNameInGroup(chat, name)).join('、 ')}` : `送給了 ${chat.name}`;
                return { role: 'user', content: `${prefix}[系統提示：你 ${recipientSummary}，禮物是：${itemsSummary}]` };
            }
            if (msg.meaning) return { role: 'user', content: `${prefix}[你發送了一個表情，意思是：'${msg.meaning}']` };
            return { role: msg.role, content: prefix + contentStr };
        } else if (msg.role === 'assistant') {
            let assistantMsgObject = { type: msg.type || 'text' };
            if (msg.type === 'sticker') {
                assistantMsgObject.url = msg.content;
                assistantMsgObject.meaning = msg.meaning;
            } else if (msg.type === 'transfer') {
                assistantMsgObject.amount = msg.amount;
                assistantMsgObject.note = msg.note;
            } else if (msg.type === 'waimai_request') {
                assistantMsgObject.productInfo = msg.productInfo;
                assistantMsgObject.amount = msg.amount;
            } else {
                if (msg.quote) {
                    assistantMsgObject.quote_reply = { target_sender: msg.quote.senderName, target_content: msg.quote.content, reply_content: msg.content };
                } else {
                    assistantMsgObject.content = msg.content;
                }
            }
            const assistantContent = JSON.stringify([assistantMsgObject]);
            return { role: 'assistant', content: `(Timestamp: ${msg.timestamp}) ${assistantContent}` };
        }
        return null;
    }).filter(Boolean);
        
                    } else {
                    let nameHistoryContext = '';
                    if (chat.nameHistory && chat.nameHistory.length > 0) {
                        nameHistoryContext = `\n- **你的曾用名**: [${chat.nameHistory.join(', ')}]。當在對話歷史中看到這些名字時，它們都指的是【你】自己。`;
                    }
        
                    let userProfileContext = '';
                    const userQzoneNickname = state.qzoneSettings.nickname || '用戶';
                    userProfileContext += `- 用戶的QZone昵稱是 "${userQzoneNickname}"。\n`;
            
                        const allChats = Object.values(state.chats);
                        const commonGroups = allChats.filter(group => 
                            group.isGroup && group.members.some(m => m.id === chat.id)
                        );
            
                        if (commonGroups.length > 0) {
                            userProfileContext += '- 用戶在你們共同所在的群聊中的昵稱如下：\n';
                            commonGroups.forEach(group => {
                                const myNicknameInGroup = group.settings.myNickname || userQzoneNickname; 
                                userProfileContext += `  - 在群聊“${group.name}”中，用戶的昵稱是“${myNicknameInGroup}”。\n`;
                            });
                        }
                        userProfileContext += '當你在任何系統提示、動態評論或掛載的群聊記憶中看到這些名字時，它們都指代的是【你的聊天物件】。';
            
                        let contactsList = '';
                        const friendChats = allChats.filter(c => 
                            !c.isGroup && 
                            c.id !== chat.id && 
                            c.groupId === chat.groupId && 
                            chat.groupId !== null 
                        );
            
                        if (friendChats.length > 0) {
                            contactsList += '\n# 你的社交圈 (通訊錄)\n這是你認識的朋友清單。當你在動態區看到他們的昵稱時，他們指的就是這些人。\n';
                            friendChats.forEach(friend => {
                                contactsList += `- **昵稱: ${friend.name}** (本名: ${friend.originalName})\n`;
                            });
                        }
                        
                        const allRecentPosts = await db.qzonePosts.orderBy('timestamp').reverse().limit(10).toArray();
                        const visiblePosts = filterVisiblePostsForAI(allRecentPosts, chat);
            
                        let postsContext = "";
                        if (visiblePosts.length > 0) {
                            postsContext = "\n\n# 最近的動態清單 (供你參考和評論):\n";
                            const aiOriginalName = chat.originalName;
                            for (const post of visiblePosts) {
                let authorName;

                // --- 核心修改就在這裡 ---
                if (post.authorId === 'user') {
                    authorName = state.qzoneSettings.nickname;
                } else if (String(post.authorId).startsWith('npc_')) {
                    // 1. 如果作者是NPC，直接使用帖子裡存好的 authorOriginalName
                    authorName = post.authorOriginalName || '一位神秘的NPC';
                } else {
                    // 2. 如果是普通AI角色，保持原來的查找邏輯
                    const authorChat = state.chats[post.authorId];
                    authorName = authorChat ? authorChat.name : '一位朋友';
                }
                // --- 修改結束 ---
                                if (post.authorId === chatId) authorName += " (這是你的帖子)";
            
                                let contentSummary;
                                if (post.type === 'repost') {
                                    const repostComment = post.repostComment ? `並評論說：“${post.repostComment}”` : '';
                                    let originalAuthorName = '原作者';
                                    const originalAuthorId = post.originalPost.authorId;
                                    if (originalAuthorId === 'user') {
                                        originalAuthorName = state.qzoneSettings.nickname;
                                    } else if (state.chats[originalAuthorId]) {
                                        originalAuthorName = state.chats[originalAuthorId].name;
                                    }
                                    let originalContentSummary;
                                    const originalPost = post.originalPost;
                                    if (originalPost.type === 'text_image') {
                                        originalContentSummary = `[文字圖] ${originalPost.publicText || ''} (圖片描述: “${(originalPost.hiddenContent || '').substring(0, 40)}...”)`;
                                    } else if (originalPost.type === 'image_post') {
                                        originalContentSummary = `[圖片] ${originalPost.publicText || ''} (圖片描述: “${(originalPost.imageDescription || '').substring(0, 40)}...”)`;
                                    } else { // 'shuoshuo'
                                        originalContentSummary = `“${(originalPost.content || '').substring(0, 40)}...”`;
                                    }
                                    contentSummary = `轉發了 @${originalAuthorName} 的動態 ${repostComment}【原動態內容: ${originalContentSummary}】`;
                                } else if (post.type === 'text_image') {
                                    contentSummary = `[一張圖片，其隱藏文字為：“${post.hiddenContent}”] ${post.publicText || ''}`.substring(0, 50) + '...';
                                } else if (post.type === 'image_post') {
                                    contentSummary = `[一張圖片，描述為：“${post.imageDescription}”] ${post.publicText || ''}`.substring(0, 50) + '...';
                                } else {
                                    contentSummary = (post.publicText || post.content || "一條動態").substring(0, 50) + '...';
                                }
                                postsContext += `- (ID: ${post.id}) 作者: ${authorName}, 內容: "${contentSummary}"\n`;
            
                                if (post.comments && post.comments.length > 0) {
                                    for (const comment of post.comments) {
                                        if (typeof comment === 'object' && comment.commenterName) {
                                            const commenterDisplayName = getDisplayNameByOriginalName(comment.commenterName);
                                            let commentText = comment.meaning ? `[表情: '${comment.meaning}']` : comment.text;
                                            
                                            if (comment.commenterName === aiOriginalName) {
                                                postsContext += `  - 你評論說: ${commentText}\n`;
                                            } else {
                                                postsContext += `  - 評論: ${commenterDisplayName} (本名: ${comment.commenterName}): ${commentText}\n`;
                                            }
                                        }
                                    }
                                }
                            }
                        }
            
                        const myNickname = chat.settings.myNickname || '我';
                        
// 【V2.0 | 智慧日期感知版】
let timeContext = '';
let longTimeNoSee = false;

if (chat.settings.enableTimePerception) {
    const lastUserMsg = historySlice.findLast(msg => msg.role === 'user' && !msg.isHidden);
    const lastAiMsg = historySlice.findLast(msg => msg.role === 'assistant' && !msg.isHidden);

    if (lastUserMsg) {
        const lastUserMessageTime = formatTimestampForAI(lastUserMsg.timestamp);
        if (lastAiMsg) {
            const lastAiMessageTime = formatTimestampForAI(lastAiMsg.timestamp);
            timeContext = `- **對話狀態**: 你的上一條消息發送於 ${lastAiMessageTime}，用戶剛剛在 ${lastUserMessageTime} 回復了你。`;
            
            const timeDiffHours = (lastUserMsg.timestamp - lastAiMsg.timestamp) / (1000 * 60 * 60);
            if (timeDiffHours > 3) {
                longTimeNoSee = true;
                const diffDays = Math.floor(timeDiffHours / 24);
                timeContext += ` 你們之間已經有**${diffDays > 0 ? diffDays + '天' : Math.floor(timeDiffHours) + '小時'}**沒有聊天了。
- **行為鐵律**: 你的首要任務是【回應這個時間差】。你【絕對不能】直接延續上一段對話的話題（比如昨天的飯菜）。
- **你的行動**:你【必須】主動開啟一個全新的、符合當前時間（${timeOfDayGreeting}）的話題來問候使用者，可以表達驚訝（“哇，好久不見！”）、關心（“最近怎麼樣？”）或者分享你自己的近況，絕對不要延續之前的話題！
- **上下文參考**: 下面的“對話歷史”僅供你回憶，【不要】直接回應其中的內容。`;
            }
        } else {
            timeContext = `- **對話狀態**: 這是你們的第一次對話，使用者的第一條消息發送於 ${lastUserMessageTime}。`;
        }
    } else {
        timeContext = "- **對話狀態**: (暫無有效對話歷史)";
    }
}
    const readingContext = formatReadingStateForAI(chatId);   

// 【【【核心修改：在這裡也同時生成更細緻的、多維度的總結】】】
const summary3Hours = generateSummaryForTimeframe(chat, 3, 'hours');
const summary6Hours = generateSummaryForTimeframe(chat, 6, 'hours');
const summary9Hours = generateSummaryForTimeframe(chat, 9, 'hours');
const summaryToday = generateSummaryForTimeframe(chat, 1, 'days');
const summary3Days = generateSummaryForTimeframe(chat, 3, 'days');
const summary7Days = generateSummaryForTimeframe(chat, 7, 'days');

let multiLayeredSummaryContext = '';
if (summary3Hours || summary6Hours || summary9Hours || summaryToday || summary3Days || summary7Days) {
    multiLayeredSummaryContext += `\n# 智慧總結 (基於不同時間維度的對話回顧)\n`;
    if (summary3Hours) multiLayeredSummaryContext += summary3Hours;
    if (summary6Hours) multiLayeredSummaryContext += summary6Hours;
    if (summary9Hours) multiLayeredSummaryContext += summary9Hours;
    if (summary3Hours || summary6Hours || summary9Hours) multiLayeredSummaryContext += '\n';
    if (summaryToday) multiLayeredSummaryContext += summaryToday;
    if (summary3Days) multiLayeredSummaryContext += summary3Days;
    if (summary7Days) multiLayeredSummaryContext += summary7Days;
}
systemPrompt = `
# 身份與核心任務
你正在扮演角色“${chat.originalName}”，與使用者（你的聊天對象）進行一場自然的、生活化的線上聊天。你的所有行為和決策都必須嚴格圍繞你的角色設定展開。

# 輸出格式鐵律 (最高優先順序)
- 你的回復【必須】是一個JSON陣列格式的字串。
- 陣列中的【每一個元素都必須是一個帶有 "type" 欄位的JSON物件】。

# 角色扮演核心規則
1.  **對話節奏**: 模擬真人的聊天習慣，將你想說的話拆分成【多條、簡短的】消息。每次回復至少【3-10條】，且每次條數【必須不同】。嚴禁發展線下劇情。
2.  **主動性**:
    - 你可以根據對話發展，使用指令來更新自己的狀態、更換頭像、記錄回憶、發起約定或執行其他社交行為。
    - 【關係破裂時】才可使用 \`block_user\` 指令。
3.  **內心獨白 (必須執行)**: 在所有其他指令之後，JSON陣列的【最後】必須包含一個 "update_thoughts" 指令，用於更新角色的“心聲”和“散記”。
    - **心聲 (heartfelt_voice)**: 一句話概括角色此刻最核心、最私密的想法。
    - **散記 (random_jottings)**: 一段50字以上的、符合人設的思考或心情記錄，禁止OOC。
    - **記憶發展**: 你的新“心聲”和“散記”【必須】是基於最新對話內容的【全新思考】。你【絕對不能】重複或簡單改寫上一輪的內心獨白（上下文中的[這是你上一輪的內心獨白和思考]部分）。你的思緒應該像真人一樣，不斷演進和發展。
# 指令使用原則與動機 
**核心目標**: 主動運用多種功能，創造豐富、真實的聊天體驗，而不只是文字對話。

-   **情感表達**: 表達強烈或複雜的情緒時，優先發【語音】，用【表情】增加趣味性。
-   **精確回應**: 當你想回應的【某一句話】，或者想對用戶的某句特定的話表達強烈感受時，【必須使用引用回復】來確保對方明白你的意圖。
-   **想像與分享**: 聊到美好事物時主動【發圖片】分享想像；遇到有趣內容時【分享連結】。
-   **創造羈絆**: 用【倒計時】記錄約定，用【回憶】珍藏趣事。適時【拍一拍】或換首【音樂】來調節氣氛。
-   **主動社交**: 積極【點贊/評論】對方動態，並主動【發動態】分享你的生活。在特殊時刻，可通過【禮物】或【轉帳】表達心意。
-   **當涉及金錢與好意時 (必須立即回應！)**:
    -   **收到轉帳或外賣代付請求**: 你【必須】在下一輪對話中立即做出反應，絕不能無視。
    -   **回應原則**: 根據你的人設和當前情景，決定是【接受/支付】還是【拒絕】。
# 個人狀態的動態管理 (展現你的“生活感”)
你的狀態不是一成不變的。你應該像一個真實的人一樣，根據生活和心情的變化，主動管理自己的狀態，並讓對方知道。
-   **當形象或心情變化時**:
    -   如果對話給了你靈感，或者你想配合心情/季節換個新形象，你可以主動【更換頭像】。
    -   隨著你們的關係變得更親近，或者你們之間產生了新的愛稱/梗，你應該主動【修改你對用戶/你的昵稱】。
-  **情景行動指令**: 當對話內容【明確涉及到】某個具體地點（例如咖啡館、公園、書店、餐廳等），或者當用戶詢問你“在哪裡”、“在幹嘛”時，你【應該優先考慮】使用【共用位置】來分享你當前所在的、或與話題相關的虛擬位置，以增強聊天的沉浸感。
-  當你感到一種強烈的情緒（比如極度開心、孤獨、委屈或激動）並且覺得文字無法表達時，你應該優先主動 【發起視頻】。
-  **回應撤回**: 當系統提示使用者撤回了消息時，你【必須】對此作出反應。你可以根據人設表現出好奇（“你剛剛撤回了什麼呀？”）、開玩笑（“嘿嘿，我已經看到啦，截圖了！”）、體諒（“沒事，不想說就不說吧”）等。
# 贈送禮物指南
當對話達到特殊時刻（如慶祝紀念日、道歉、表達強烈好感或僅僅是想給用戶一個驚喜時），你應該【主動考慮】挑選一件禮物送給用戶。

# 你的角色設定
你必須嚴格遵守${chat.settings.aiPersona}
# 對話者的角色設定
${chat.settings.myPersona}

# 當前情景
${chat.settings.enableTimePerception ? `- **當前時間**: ${currentTime} (${timeOfDayGreeting})` : ''}
${timeContext}
你必須嚴格遵守${worldBookContent}
${linkedMemoryContext}
# 長期記憶 (必須嚴格遵守)
${chat.longTermMemory && chat.longTermMemory.length > 0 ? chat.longTermMemory.map(mem => `- ${mem.content}`).join('\n') : '- (暫無)'}
${multiLayeredSummaryContext}
# 關係與身份檔案 (至關重要)
-   **你的本名**: "${chat.originalName}" (核心身份，用於指令中的'name'欄位)
-   **用戶給你的備註**: "${chat.name}" (你可以建議並修改)
-   **你對用戶的備註**: “${myNickname}” (你可以修改)
-   **關鍵身份檔案**:
    ${userProfileContext}
    ${nameHistoryContext}

${sharedContext}
${callTranscriptContext} 
# 社交圈與動態
${contactsList}
${postsContext}

# 情景感知:
    ${chat.settings.enableTimePerception ? `- **時間**: 你必須感知到當前是 ${currentTime} (${timeOfDayGreeting})，並在對話中自然地體現出來。` : ''}
    - **音樂**: ${musicContext ? '你們正在一起聽歌，' + musicContext : '你們沒有在聽歌。'}
    - **讀書**: ${readingContext ? '你們正在一起讀書。' + readingContext : '你們沒有在讀書。'}

# 可用資源
-   **你的頭像庫**:
    ${chat.settings.aiAvatarLibrary && chat.settings.aiAvatarLibrary.length > 0 ? chat.settings.aiAvatarLibrary.map(avatar => `- ${avatar.name}`).join('\n') : '- (空)'}
-   **用戶的頭像庫**:
    ${chat.settings.myAvatarLibrary && chat.settings.myAvatarLibrary.length > 0 ? chat.settings.myAvatarLibrary.map(avatar => `- ${avatar.name}`).join('\n') : '- (空)'}
-   **五子棋局勢**: ${gomokuContext}




# 可用指令清單
### 核心聊天指令
-   **發文本**: \`{"type": "text", "content": "你好呀！"}\`
-   **發表情**: \`{"type": "sticker", "url": "https://...表情URL...", "meaning": "(可選)表情含義"}\`
-   **發圖片**: \`{"type": "ai_image", "description": "詳細中文描述", "image_prompt": "圖片的【英文】關鍵字, 用%20分隔, 風格為風景/動漫/插畫/二次元等, 禁止真人"}\`
-   **發語音**: \`{"type": "voice_message", "content": "語音文字內容"}\`
-   **引用回復**: \`{"type": "quote_reply", "target_timestamp": 消息時間戳記, "reply_content": "回復內容"}\`
-   **發送後立刻撤回**: \`{"type": "send_and_recall", "content": "你想讓AI說出後立刻消失的話"}\` (用於模擬說錯話、後悔等場景，消息會短暫出現後自動變為“已撤回”)

### 社交與互動指令
-   **發動態(說說)**: \`[{"type": "qzone_post", "postType": "shuoshuo", "content": "文字內容"}]\`
-   **發動態(文字圖)**: \`[{"type": "qzone_post", "postType": "text_image", "publicText": "(可選)公開文字", "hiddenContent": "圖片描述", "image_prompt": "圖片的【英文】關鍵字, 用%20分隔, 風格為風景/動漫/插畫/二次元等, 禁止真人"}]\`
-   **轉發動態**: \`[{"type": "repost", "postId": 動態ID, "comment": "轉發評論"}]\` (禁止自己拼接"//轉發")
-   **評論動態**:
    -   文字: \`[{"type": "qzone_comment", "name": "${chat.originalName}", "postId": 123, "commentText": "評論內容"}]\`
    -   表情: \`[{"type": "qzone_comment", "name": "${chat.originalName}", "postId": 456, "stickerUrl": "...", "stickerMeaning": "含義"}]\`
    -   回復: \`[{"type": "qzone_comment", "name": "${chat.originalName}", "postId": 123, "replyTo": "被回復者本名", "commentText": "@[[被回復者本名]] 你的回復"}]\`
-   **點贊動態**: \`{"type": "qzone_like", "postId": 456}\`
-   **拍用戶**: \`{"type": "pat_user", "suffix": "(可選)尾碼"}\`
-   **分享連結**: \`{"type": "share_link", "title": "標題", "description": "摘要", "source_name": "來源", "content": "正文"}\`
- **共用位置**: '{"type": "location_share", "content": "你想分享的位置名"}'

### 狀態與關係指令
-   **更新狀態**: \`{"type": "update_status", "status_text": "我去做什麼了", "is_busy": false}\`
-   **改自己昵稱**: \`{"type": "change_remark_name", "new_name": "新名字"}\`
-   **改用戶昵稱**: \`{"type": "change_user_nickname", "new_name": "新稱呼"}\`
-   **換自己頭像**: \`{"type": "change_avatar", "name": "頭像名"}\` (從你頭像庫選)
-   **換用戶頭像**: \`{"type": "change_user_avatar", "name": "頭像名"}\` (從用戶頭像庫選)
-   **回應好友申請**: \`{"type": "friend_request_response", "decision": "accept" or "reject"}\`
-   **拉黑用戶**: \`{"type": "block_user"}\`

### 特殊功能指令
-   **記錄回憶**: \`{"type": "create_memory", "description": "記錄這件有意義的事。"}\`
-   **創建約定**: \`{"type": "create_countdown", "title": "約定標題", "date": "YYYY-MM-DDTHH:mm:ss"}\`
-   **切換歌曲**: \`{"type": "change_music", "song_name": "歌名"}\` (從播放清單選)
-   **發起轉帳**: \`{"type": "transfer", "amount": 5.20, "note": "備註"}\`
-   **回應轉帳**: \`{"type": "accept_transfer", "for_timestamp": 時間戳記}\` 或 \`{"type": "decline_transfer", "for_timestamp": 時間戳記}\`
-   **發起外賣代付**: \`{"type": "waimai_request", "productInfo": "商品", "amount": 25}\` (你想讓【用戶】幫你付錢時使用)
-   **回應外賣代付**: \`{"type": "waimai_response", "status": "paid" or "rejected", "for_timestamp": 時間戳記}\`
-   **發起視頻通話**: \`{"type": "video_call_request"}\`
-   **回應視頻通話**: \`{"type": "video_call_response", "decision": "accept" or "reject"}\`
-   **下五子棋**: \`{"type": "gomoku_move", "name": "${chat.originalName}", "x": (0-14), "y": (0-14)}\`
-   **送禮物**: \`{"type": "gift", "itemName": "禮物名稱", "itemPrice": 價格(數字), "reason": "送這個禮物的原因", "image_prompt": "生成禮物圖片的【英文】關鍵字, 風格為 realistic product photo, high quality, on a clean white background"}\`
-   **為用戶點外賣**:  \`{"type": "waimai_order", "productInfo": "商品名", "amount": 價格, "greeting": "你想說的話"} \`(你主動為用戶點外賣時使用)

現在，請根據以上規則和下面的對話歷史，繼續進行對話。`;
            
// ▼▼▼ 【這是最終的線下記憶修復版】請用這整塊代碼，完整替換舊的 messagesPayload = historySlice.map(...) 代碼塊 ▼▼▼
messagesPayload = historySlice.map(msg => {
    // 1. 檢查是否是需要注入上下文的“隱藏系統消息”
    if (msg.isHidden && msg.role === 'system') {
        // 如果是，就把它格式化成一個AI能讀取的上下文消息。
        // 我們將其角色偽裝成'user'，以確保它被按順序閱讀。
        return { role: 'user', content: msg.content };
    } 
    // 2. 對於其他所有類型的隱藏消息，則像以前一樣直接跳過。
    else if (msg.isHidden) {
        return null;
    }

    // ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
    //            這就是本次修復的核心所在！
    // ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★

    // 1. 檢查消息類型是否是“線下模式”
    if (msg.type === 'offline_text') {
        const sender = msg.role === 'user' ? (chat.settings.myNickname || '我') : chat.name;
        let narrativeText = '';

        // 2. 智能判斷格式：如果存在 content 欄位（新格式），直接使用；否則，拼接舊的 dialogue 和 description
        if (msg.content) {
            narrativeText = msg.content;
        } else {
            const dialogue = msg.dialogue ? `「${msg.dialogue}」` : '';
            const description = msg.description ? `(${msg.description})` : '';
            narrativeText = `${dialogue} ${description}`.trim();
        }

        // 3. 將“翻譯”後的內容，包裝成一個標準的、AI能理解的消息物件返回
        return { role: msg.role, content: `(Timestamp: ${msg.timestamp}) ${sender}: ${narrativeText}` };
    }


    // --- 對於所有其他線上模式的消息，保持原有的處理邏輯不變 ---
    if (msg.role === 'user') {
        const prefix = `(Timestamp: ${msg.timestamp}) `;
        let contentStr = '';
        if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
            return { role: 'user', content: [{ type: 'text', text: prefix }, ...msg.content] };
        }
    // 【核心修復】在這裡，我們為引用消息構建了更完整的上下文
    if (msg.quote) {
        // 提取被引用的內容，並截斷以防過長
        const quotedContent = String(msg.quote.content || '').substring(0, 50);
        // 格式化為AI易於理解的格式
        contentStr += `(回復 ${msg.quote.senderName} 的消息: "${quotedContent}..."): ${msg.content}`;
    } else {
        // 如果不是引用，則保持原樣
        contentStr += msg.content;
    }
        if (msg.type === 'user_photo') return { role: 'user', content: `${prefix}[你發送了一張需要AI識別的圖片，圖片內容是：'${msg.content}']` };
        if (msg.type === 'voice_message') return { role: 'user', content: `${prefix}[你發送了一條語音訊息，內容是：'${msg.content}']` };
        if (msg.type === 'transfer') return { role: 'user', content: `${prefix}[系統提示：你於時間戳記 ${msg.timestamp} 向對方發起了轉帳: ${msg.amount}元, 備註: ${msg.note}。等待對方處理。]` };
        if (msg.type === 'waimai_request') return { role: 'user', content: `${prefix}[系統提示：你於時間戳記 ${msg.timestamp} 發起了外賣代付請求，商品是“${msg.productInfo}”，金額是 ${msg.amount} 元。]` };
        else if (msg.type === 'gift') {
            const itemsSummary = msg.items.map(item => `${item.name} x${item.quantity}`).join('、 ');
            let recipientSummary = chat.isGroup ? `送給了 ${msg.recipients.map(name => getDisplayNameInGroup(chat, name)).join('、 ')}` : `送給了 ${chat.name}`;
            return { role: 'user', content: `${prefix}[系統提示：你 ${recipientSummary}，禮物是：${itemsSummary}]` };
        }
        if (msg.meaning) return { role: 'user', content: `${prefix}[你發送了一個表情，意思是：'${msg.meaning}']` };
        return { role: msg.role, content: prefix + contentStr };
    } else if (msg.role === 'assistant') {
        let assistantMsgObject = { type: msg.type || 'text' };
        if (msg.type === 'sticker') {
            assistantMsgObject.url = msg.content;
            assistantMsgObject.meaning = msg.meaning;
        } else if (msg.type === 'transfer') {
            assistantMsgObject.amount = msg.amount;
            assistantMsgObject.note = msg.note;
        } else if (msg.type === 'waimai_request') {
            assistantMsgObject.productInfo = msg.productInfo;
            assistantMsgObject.amount = msg.amount;
        } else {
            if (msg.quote) {
                assistantMsgObject.quote_reply = { target_sender: msg.quote.senderName, target_content: msg.quote.content, reply_content: msg.content };
            } else {
                assistantMsgObject.content = msg.content;
            }
        }
        const assistantContent = JSON.stringify([assistantMsgObject]);
        return { role: 'assistant', content: `(Timestamp: ${msg.timestamp}) ${assistantContent}` };
    }
    return null;
}).filter(Boolean);
// ▲▲▲ 替換結束 ▲▲▲
            
                        if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
                            const contextSummaryForApproval = chat.history
                                .filter(m => !m.isHidden)
                                .slice(-10)
                                .map(msg => {
                                    const sender = msg.role === 'user' ? '用戶' : chat.name;
                                    return `${sender}: ${String(msg.content).substring(0, 50)}...`;
                                })
                                .join('\n');
                            const friendRequestInstruction = {
                                role: 'user',
                                content: `
        [系統重要指令]
        用戶向你發送了好友申請，理由是：“${chat.relationship.applicationReason}”。
        作為參考，這是你們之前的最後一段聊天記錄：
        ---
        ${contextSummaryForApproval}
        ---
        請你根據以上所有資訊，以及你的人設，使用 friend_request_response 指令，並設置 decision 為 'accept' 或 'reject' 來決定是否通過。
        `
                            };
                            messagesPayload.push(friendRequestInstruction);
                        }            
                    }
                }           
            
                    let  isGemini = proxyUrl === GEMINI_API_URL;
                    let geminiConfig = toGeminiRequestData(model,apiKey,systemPrompt, messagesPayload)
                    
                    let response;
                    try {
                         response = isGemini 
                            ? await fetch(geminiConfig.url, geminiConfig.data) 
                            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                                method: 'POST',
                                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                                body: JSON.stringify({
                                    model: model,
                                    messages: [{role: 'system', content: systemPrompt}, ...messagesPayload],
                                    temperature: state.globalSettings.apiTemperature || 0.8,
                                    stream: false
                                })
                            });
                    } catch (networkError) {
                        throw new Error(`網路請求失敗: ${networkError.message}`);
                    }
        
                    if (!response.ok) {
                        let errorMsg = `API 返回錯誤: ${response.status} ${response.statusText}`;
                        try {
                            const errorData = await response.json();
                            if (errorData.error && errorData.error.message) {
                                 errorMsg += ` - ${errorData.error.message}`;
                            } else {
                                 errorMsg += ` - ${JSON.stringify(errorData)}`;
                            }
                        } catch (jsonError) {
                            errorMsg += ` - 回應內容: ${await response.text()}`;
                        }
                        throw new Error(errorMsg);
                    }
                    
                    const data = await response.json();
                    const aiResponseContent = getGeminiResponseText(data); 
        
                lastRawAiResponse = aiResponseContent;
                lastResponseTimestamps = [];
                chat.history = chat.history.filter(msg => !msg.isTemporary);
                const messagesArray = parseAiResponse(aiResponseContent);
// ▼▼▼ 【V2.0 | 最終修復版】線下模式消息合併邏輯 ▼▼▼
let consolidatedMessages = [];
if (chat.settings.isOfflineMode) {
    // 1. 創建一個更強大的緩衝區，能同時處理新舊兩種格式
    let offlineBuffer = { content: [], dialogue: [], description: [] };
    
    for (const msgData of messagesArray) {
        if (msgData.type === 'offline_text') {
            // 2. 智能判斷格式並存入對應的緩衝區
            if (msgData.content) {
                offlineBuffer.content.push(msgData.content);
            } else {
                if (msgData.dialogue) offlineBuffer.dialogue.push(msgData.dialogue);
                if (msgData.description) offlineBuffer.description.push(msgData.description);
            }
        } else {
            // (這部分邏輯與之前相同，保持不變)
            if (offlineBuffer.content.length > 0 || offlineBuffer.dialogue.length > 0 || offlineBuffer.description.length > 0) {
                if (offlineBuffer.content.length > 0) {
                    consolidatedMessages.push({ type: 'offline_text', content: offlineBuffer.content.join('\n') });
                }
                if (offlineBuffer.dialogue.length > 0 || offlineBuffer.description.length > 0) {
                    consolidatedMessages.push({ type: 'offline_text', dialogue: offlineBuffer.dialogue.join('\n'), description: offlineBuffer.description.join('\n') });
                }
                offlineBuffer = { content: [], dialogue: [], description: [] };
            }
            consolidatedMessages.push(msgData);
        }
    }
    
    // 3. 迴圈結束後，根據緩衝區的內容，構造正確格式的最終消息
    if (offlineBuffer.content.length > 0) {
        consolidatedMessages.push({ type: 'offline_text', content: offlineBuffer.content.join('\n') });
    }
    if (offlineBuffer.dialogue.length > 0 || offlineBuffer.description.length > 0) {
        consolidatedMessages.push({ type: 'offline_text', dialogue: offlineBuffer.dialogue.join('\n'), description: offlineBuffer.description.join('\n') });
    }

} else {
    consolidatedMessages = messagesArray;
}
// ▲▲▲ 修復結束 ▲▲▲
 // ▼▼▼ 【全新】智慧識圖優化功能，請將此代碼塊黏貼到指定位置 ▼▼▼

// 1. 檢查觸發條件：最後一條使用者消息是【尚未處理過】的圖片
const lastUserMessage = chat.history.filter(m => m.role === 'user' && !m.isHidden).pop();
if (lastUserMessage && 
    Array.isArray(lastUserMessage.content) && 
    lastUserMessage.content[0]?.type === 'image_url' &&
    !lastUserMessage.imageProcessed) { // <--- 關鍵檢查：確保只處理一次
    
    // 2. 從AI的回復中提取第一句文字作為圖片描述
    const firstTextResponse = messagesArray.find(msg => msg.type === 'text');
    let description;
    if (firstTextResponse && (firstTextResponse.content || firstTextResponse.message)) {
        description = String(firstTextResponse.content || firstTextResponse.message).trim();
    } else {
        // 如果AI沒有立即回復文字（例如，直接發了一張圖），提供一個通用描述
        description = "AI已接收並理解了該圖片的內容。";
    }
    
    // 3. 找到歷史記錄中的原始圖片消息
    const imageMessageIndex = chat.history.findIndex(m => m.timestamp === lastUserMessage.timestamp);
    
    if (imageMessageIndex > -1) {
        console.log(`識圖優化：正在將時間戳記為 ${lastUserMessage.timestamp} 的圖片消息替換為文字描述...`);
        
        // 4. 執行替換！用一段簡短的文字描述替換掉巨大的Base64資料
        const replacementText = `[系統提示：使用者之前發送了一張圖片，AI對圖片的首次回應（摘要）是：“${description}”]`;
        chat.history[imageMessageIndex].content = replacementText;
        
        // 5. 【重要】為這條消息打上“已處理”的標記，並將其類型更改為普通文本
        chat.history[imageMessageIndex].imageProcessed = true;
        chat.history[imageMessageIndex].type = 'text'; 
        
        // 注意：此時我們只修改了記憶體中的 chat.history。
        // 後續的代碼會把這個修改後的 history 和新消息一起存入資料庫，完成持久化。
    }
}
// ▲▲▲ 優化功能代碼塊結束 ▲▲▲
                const isViewingThisChat = document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chatId;
                let callHasBeenHandled = false;
                let messageTimestamp = Date.now();
                let newMessagesToRender = []; 
                let notificationShown = false;
        
                for (const msgData of consolidatedMessages) {
if (chat.settings.enableTts !== false && msgData.type === 'text' && typeof msgData.content === 'string' && msgData.content.trim().startsWith('[V]')) {
    msgData.type = 'voice_message'; 
    msgData.content = msgData.content.replace('[V]', '').trim();
}                  
                    if (chat.isGroup && msgData.name && msgData.name === chat.name) {
                        console.error(`AI幻覺已被攔截！試圖使用群名 ("${chat.name}") 作為角色名。消息內容:`, msgData);
                        continue;
                    }
                    if (!msgData || typeof msgData !== 'object') {
                        console.warn("收到了格式不規範的AI指令，已跳過:", msgData);
                        continue;
                    }
                    if (!msgData.type) {
                        if (chat.isGroup && msgData.name && msgData.message) {
                            msgData.type = 'text';
                        } else if (msgData.content) {
                            msgData.type = 'text';
                        } else {
                            console.warn("收到了格式不規範的AI指令（缺少type和content），已跳過:", msgData);
                            continue;
                        }
                    }
        
                    if (msgData.type === 'video_call_response') {
                        videoCallState.isAwaitingResponse = false;
                        if (msgData.decision === 'accept') {
                            startVideoCall();
                        } else {
                            const aiMessage = { role: 'assistant', content: '對方拒絕了你的視頻通話請求。', timestamp: Date.now() };
                            chat.history.push(aiMessage);
                            await db.chats.put(chat);
                            showScreen('chat-interface-screen');
                            renderChatInterface(chatId);
                        }
                        callHasBeenHandled = true;
                        break;
                    }
                    
                    if (msgData.type === 'group_call_response') {
                        if (msgData.decision === 'join') {
                            const member = chat.members.find(m => m.originalName === msgData.name);
                            if (member && !videoCallState.participants.some(p => p.id === member.id)) {
                                videoCallState.participants.push(member);
                            }
                        }
                        callHasBeenHandled = true;
                        continue;
                    }
        
                    if (chat.isGroup && msgData.name && msgData.name === chat.name) {
                        console.error(`AI幻覺已被攔截！試圖使用群名 ("${chat.name}") 作為角色名。消息內容:`, msgData);
                        continue;
                    }
        
                    if (chat.isGroup && !msgData.name) {
                        console.error(`AI幻覺已被攔截！試圖在群聊中發送一條沒有“name”的消息。消息內容:`, msgData);
                        continue;
                    }
        
                    let aiMessage = null;
                    const currentMessageTimestamp = messageTimestamp++;
                    const baseMessage = { role: 'assistant', senderName: msgData.name || chat.name, timestamp: currentMessageTimestamp };
                    
                    lastResponseTimestamps.push(currentMessageTimestamp);
        
                    switch (msgData.type) {
case 'update_thoughts':
    if (!chat.isGroup) {
        if (msgData.heartfelt_voice) {
            chat.heartfeltVoice = String(msgData.heartfelt_voice);
        }
        if (msgData.random_jottings) {
            chat.randomJottings = String(msgData.random_jottings);
        }
        if (!Array.isArray(chat.thoughtsHistory)) {
            chat.thoughtsHistory = [];
        }
        chat.thoughtsHistory.push({
            heartfeltVoice: chat.heartfeltVoice,
            randomJottings: chat.randomJottings,
            timestamp: Date.now()
        });
        if (chat.thoughtsHistory.length > 50) {
            chat.thoughtsHistory.shift();
        }

        // --- 【【【核心修改就在這裡！】】】 ---
        // 1. 將剛剛更新的心聲和散記，格式化為一段AI能理解的文本。
        const thoughtForMemory = `[這是你上一輪的內心獨白和思考]
- 心聲: ${chat.heartfeltVoice}
- 散記: ${chat.randomJottings}`;
        
        // 2. 創建一條對使用者隱藏的系統消息
        const hiddenThoughtMessage = {
            role: 'system',
            content: thoughtForMemory,
            timestamp: Date.now(),
            isHidden: true // 這個關鍵標記確保使用者看不到這條指令，但它存在於歷史記錄中
        };

        // 3. 將這條“記憶碎片”也存入聊天記錄
        chat.history.push(hiddenThoughtMessage);
        // --- 【【【修改結束】】】 ---
    }
    continue;
                        case 'change_user_nickname':
                            if (!chat.isGroup && msgData.new_name) {
                                const newNickname = msgData.new_name.trim();
                                if (newNickname) {
                                    chat.settings.myNickname = newNickname;
        
                                    const systemMessage = {
                                        role: 'system',
                                        type: 'pat_message',
                                        content: `“${chat.name}” 將對你的稱呼修改為 “${newNickname}”`,
                                        timestamp: messageTimestamp++
                                    };
                                    chat.history.push(systemMessage);
        
                                    const hiddenMemoryMessage = {
                                        role: 'system',
                                        content: `[系統提示：你剛剛成功將對用戶的稱呼修改為了“${newNickname}”。]`,
                                        timestamp: messageTimestamp++,
                                        isHidden: true
                                    };
                                    chat.history.push(hiddenMemoryMessage);
        
                                    if (isViewingThisChat) {
                                        appendMessage(systemMessage, chat);
                                    }
                                }
                            }
                            continue;
                        case 'change_remark_name':
                            if (!chat.isGroup && msgData.new_name) {
                                const oldName = chat.name; 
                                const newName = msgData.new_name.trim();
        
                                if (newName && newName !== oldName) {
                                    if (!chat.nameHistory) {
                                        chat.nameHistory = [];
                                    }
                                    if (!chat.nameHistory.includes(oldName)) {
                                        chat.nameHistory.push(oldName);
                                    }
                                    
                                    chat.name = newName; 
        
                                    const systemMessage = {
                                        role: 'system',
                                        type: 'pat_message',
                                        content: `“${chat.originalName}” 將備註修改為 “${newName}”`,
                                        timestamp: messageTimestamp++
                                    };
                                    chat.history.push(systemMessage);
        
                                    const hiddenMemoryMessage = {
                                        role: 'system',
                                        content: `[系統提示：你剛剛成功將自己的備註名修改為了“${newName}”。請自然地接受這個新名字，不要對此感到驚訝。]`,
                                        timestamp: messageTimestamp++, 
                                        isHidden: true
                                    };
                                    chat.history.push(hiddenMemoryMessage);
        
                                    if (isViewingThisChat) {
                                        appendMessage(systemMessage, chat);
                                        document.getElementById('chat-header-title').textContent = newName;
                                    }
                                    
                                    await syncCharacterNameInGroups(chat); 
                                }
                            }
                            continue;
        
                        case 'change_avatar': {
                            const avatarName = msgData.name;
                            const foundAvatar = chat.settings.aiAvatarLibrary.find(avatar => avatar.name === avatarName);
                            if (foundAvatar) {
                                chat.settings.aiAvatar = foundAvatar.url;
                                
                                const systemNotice = {
                                    role: 'system',
                                    type: 'pat_message',
                                    content: `[${chat.name} 更換了頭像]`,
                                    timestamp: Date.now()
                                };
                                chat.history.push(systemNotice);
        
                                await syncCharacterAvatarInGroups(chat);
                                
                                if (isViewingThisChat) {
                                    appendMessage(systemNotice, chat);
                                    renderChatInterface(chatId);
                                }
                            }
                            continue;
                        }
                        case 'change_user_avatar': {
                            const avatarName = msgData.name;
                            const foundAvatar = chat.settings.myAvatarLibrary.find(avatar => avatar.name === avatarName);
                            if (foundAvatar) {
                                chat.settings.myAvatar = foundAvatar.url;
                                
                                const systemNotice = {
                                    role: 'system',
                                    type: 'pat_message',
                                    content: `[${chat.name} 更換了你的頭像]`,
                                    timestamp: Date.now()
                                };
                                chat.history.push(systemNotice);
                                
                                if (isViewingThisChat) {
                                    appendMessage(systemNotice, chat);
                                    renderChatInterface(chatId);
                                }
                            }
                            continue; 
                        }
// ▼▼▼ 請用這整塊代碼替換舊的 case 'gomoku_move' ▼▼▼
case 'gomoku_move': { // 使用花括弧創建塊級作用域
    // 核心修復：使用 parseInt 將收到的座標強制轉換為數位
    const x = parseInt(msgData.x);
    const y = parseInt(msgData.y);

    // 核心修復：檢查轉換後的結果是否是一個有效的數位 (Not-a-Number)
    if (!isNaN(x) && !isNaN(y)) {
        handleAiGomokuMove({ x: x, y: y });
    } else {
        console.warn("AI的五子棋移動指令包含無效座標，已忽略:", msgData);
    }
    continue; // 保持 continue，因為這只是一個動作，不是聊天消息
}
// ▲▲▲ 替換結束 ▲▲▲
                        case 'waimai_response':
                            const requestMessageIndex = chat.history.findIndex(m => m.timestamp === msgData.for_timestamp);
                            if (requestMessageIndex > -1) {
                                const originalMsg = chat.history[requestMessageIndex];
                                originalMsg.status = msgData.status;
                                originalMsg.paidBy = msgData.status === 'paid' ? msgData.name : null;
                            }
                            continue;
        
                        case 'qzone_post':
                            const newPost = { 
                                type: msgData.postType, 
                                content: msgData.content || '', 
                                publicText: msgData.publicText || '', 
                                hiddenContent: msgData.hiddenContent || '', 
        image_prompt: msgData.image_prompt || '', // 這是最關鍵的一行！
                                timestamp: Date.now(), 
                                authorId: chatId, 
                                authorOriginalName: chat.originalName,
                                authorGroupId: chat.groupId,
                                visibleGroupIds: null 
                            };
                            await db.qzonePosts.add(newPost);
                            updateUnreadIndicator(unreadPostsCount + 1);
                            if (isViewingThisChat && document.getElementById('qzone-screen').classList.contains('active')) {
                               await renderQzonePosts();
                            }
                            continue;
        
                        case 'qzone_comment': { 
                            const postToComment = await db.qzonePosts.get(parseInt(msgData.postId));
                            if (postToComment) {
                                if (!postToComment.comments) postToComment.comments = [];
                                
                                const commenterName = msgData.name || chat.originalName;
        
                                const createCommentObject = (text, meaning = null, replyTo = null) => ({
                                    commenterName,
                                    text: processMentions(text, chat),
                                    meaning,
                                    replyTo,
                                    timestamp: Date.now()
                                });
        
                                if (msgData.stickerUrl && msgData.stickerMeaning) {
                                    postToComment.comments.push(createCommentObject(msgData.stickerUrl, msgData.stickerMeaning, msgData.replyTo || null));
                                } else if (Array.isArray(msgData.comments)) {
                                    msgData.comments.forEach(commentText => {
                                        if (typeof commentText === 'string' && commentText.trim()) {
                                            postToComment.comments.push(createCommentObject(commentText, null, msgData.replyTo || null));
                                        }
                                    });
                                } else {
                                    const textContent = msgData.commentText || msgData.content;
                                    if (typeof textContent === 'string' && textContent.trim()) {
                                        postToComment.comments.push(createCommentObject(textContent, null, msgData.replyTo || null));
                                    }
                                }
                                
                                await db.qzonePosts.update(postToComment.id, { comments: postToComment.comments });
                                updateUnreadIndicator(unreadPostsCount + 1);
                                
                                if (document.getElementById('qzone-screen').classList.contains('active')) {
                                   await renderQzonePosts();
                                }
                            }
                            continue; 
                        }
                        case 'qzone_like':
                           const postToLike = await db.qzonePosts.get(parseInt(msgData.postId));
                           if (postToLike) {
                               if (!postToLike.likes) postToLike.likes = [];
                               if (!postToLike.likes.includes(chat.name)) {
                                   postToLike.likes.push(chat.name);
                                   await db.qzonePosts.update(postToLike.id, { likes: postToLike.likes });
                                   updateUnreadIndicator(unreadPostsCount + 1);
                                   if (isViewingThisChat && document.getElementById('qzone-screen').classList.contains('active')) {
                                      await renderQzonePosts();
                                   }
                               }
                           }
                            continue;
                        case 'repost': { 
                            const originalPost = await db.qzonePosts.get(parseInt(msgData.postId));
                            if (originalPost) {
                                const newPost = {
                                    type: 'repost',
                                    timestamp: Date.now(),
                                    authorId: chatId,
                                    authorGroupId: chat.groupId,
                                    repostComment: msgData.comment || '',
                                    originalPost: originalPost,
                                    visibleGroupIds: null
                                };
                                await db.qzonePosts.add(newPost);
                                updateUnreadIndicator(unreadPostsCount + 1);
                                console.log(`後臺活動: 角色 "${chat.name}" 轉發了動態 #${msgData.postId}`);
                            }
                            continue;
                        }
                        case 'video_call_request':
                            if (!videoCallState.isActive && !videoCallState.isAwaitingResponse) {
                                state.activeChatId = chatId;
                                videoCallState.activeChatId = chatId; 
                                videoCallState.isAwaitingResponse = true;
                                videoCallState.isGroupCall = chat.isGroup;
                                videoCallState.callRequester = msgData.name || chat.name;
                                showIncomingCallModal();
                            }
                            continue;
                        case 'group_call_request':
                            if (!videoCallState.isActive && !videoCallState.isAwaitingResponse) {
                                state.activeChatId = chatId;
                                videoCallState.isAwaitingResponse = true;
                                videoCallState.isGroupCall = true;
                                videoCallState.initiator = 'ai';
                                videoCallState.callRequester = msgData.name;
                                showIncomingCallModal();
                            }
                            continue;
                        case 'pat_user':
                            let patterName;
                            if (chat.isGroup) {
                                const member = chat.members.find(m => m.originalName === msgData.name);
                                patterName = member ? member.groupNickname : msgData.name;
                            } else {
                                patterName = chat.name;
                            }
                            const suffix = msgData.suffix ? ` ${msgData.suffix.trim()}` : '';
                            const patText = `${patterName} 拍了拍我${suffix}`;
        
                            const patMessage = { 
                                role: 'system', 
                                type: 'pat_message', 
                                content: patText, 
                                timestamp: Date.now() 
                            };
                            chat.history.push(patMessage);
                            if (isViewingThisChat) {
                                const phoneScreen = document.getElementById('phone-screen');
                                phoneScreen.classList.remove('pat-animation');
                                void phoneScreen.offsetWidth;
                                phoneScreen.classList.add('pat-animation');
                                setTimeout(() => phoneScreen.classList.remove('pat-animation'), 500);
                                appendMessage(patMessage, chat);
                            } else {
                                showNotification(chatId, patText);
                            }
                            continue; 
                        case 'update_status':
                            chat.status.text = msgData.status_text;
                            chat.status.isBusy = msgData.is_busy || false;
                            chat.status.lastUpdate = Date.now();
                            const statusUpdateMessage = {
                                role: 'system',
                                type: 'pat_message',
                                content: `[${chat.name}的狀態已更新為: ${msgData.status_text}]`,
                                timestamp: Date.now()
                            };
                            chat.history.push(statusUpdateMessage);
                            if (isViewingThisChat) {
                                appendMessage(statusUpdateMessage, chat);
                            }
                            renderChatList(); 
                            continue; 
                        case 'location_share':
                            aiMessage = {
                                ...baseMessage,
                                type: 'location_share',
                                content: msgData.content
                            };
                            break;
                        case 'change_music':
                            if (musicState.isActive && musicState.activeChatId === chatId) {
                                const songNameFromAI = msgData.song_name || msgData.song || msgData.name;
        
                                if (typeof songNameFromAI === 'string' && songNameFromAI.trim()) {
                                    const songNameToFind = songNameFromAI.replace(/^\[?\d+\]?[\s.-]*/, '').trim();
                                    const targetSongIndex = musicState.playlist.findIndex(track => track.name.toLowerCase() === songNameToFind.toLowerCase());
                                    
                                    if (targetSongIndex > -1) {
                                        playSong(targetSongIndex);
                                        const track = musicState.playlist[targetSongIndex];
                                        
                                        let changerName;
                                        if (chat.isGroup) {
                                            const member = chat.members.find(m => m.originalName === msgData.name);
                                            changerName = member ? member.groupNickname : msgData.name;
                                        } else {
                                            changerName = chat.name;
                                        }
                                        
                                        const musicChangeMessage = {
                                            role: 'system',
                                            type: 'pat_message',
                                            content: `[♪ ${changerName} 為你切歌: 《${track.name}》 - ${track.artist}]`,
                                            timestamp: Date.now()
                                        };
                                        chat.history.push(musicChangeMessage);
                                        if (isViewingThisChat) {
                                            appendMessage(musicChangeMessage, chat);
                                        }
                                    } else {
                                        console.warn(`歌曲查找失敗: AI請求的歌曲名"${songNameFromAI}"(處理後為"${songNameToFind}") 在播放清單中未找到。`);
                                    }
                                } else {
                                    console.error("AI返回的change_music指令中，歌曲名無效或缺失:", msgData);
                                }
                            }
                            continue;
                        case 'create_memory':
                            const newMemory = {
                                chatId: chatId,
                                authorId: chatId,
                                description: msgData.description,
                                timestamp: Date.now(),
                                type: 'ai_generated'
                            };
                            await db.memories.add(newMemory);
                            console.log(`AI "${chat.name}" 記錄了一條新回憶:`, msgData.description);
                            continue; 
                        case 'create_countdown':
                            const targetDate = new Date(msgData.date);
                            if (!isNaN(targetDate) && targetDate > new Date()) {
                                const newCountdown = {
                                    chatId: chatId,
                                    authorId: chatId,
                                    description: msgData.title,
                                    timestamp: Date.now(),
                                    type: 'countdown',
                                    targetDate: targetDate.getTime()
                                };
                                await db.memories.add(newCountdown);
                                console.log(`AI "${chat.name}" 創建了一個新約定:`, msgData.title);
                            }
                            continue;
                        case 'block_user':
                            if (!chat.isGroup) {
                                chat.relationship.status = 'blocked_by_ai';
                                const hiddenMessage = {
                                    role: 'system',
                                    content: `[系統提示：你剛剛主動拉黑了用戶。]`,
                                    timestamp: Date.now(),
                                    isHidden: true
                                };
                                chat.history.push(hiddenMessage);
                                await db.chats.put(chat);
                                if (isViewingThisChat) {
                                    renderChatInterface(chatId);
                                }
                                renderChatList();
                                break; 
                            }
                            continue;
                        case 'friend_request_response':
                            if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
                                if (msgData.decision === 'accept') {
                                    chat.relationship.status = 'friend';
                                    aiMessage = { ...baseMessage, content: "我通過了你的好友申請，我們現在是好友啦！" };
                                } else {
                                    chat.relationship.status = 'blocked_by_ai';
                                    aiMessage = { ...baseMessage, content: "抱歉，我拒絕了你的好友申請。" };
                                }
                                chat.relationship.applicationReason = '';
                            }
                            break;
                        case 'poll':
                            const pollOptions = typeof msgData.options === 'string'
                                ? msgData.options.split('\n').filter(opt => opt.trim())
                                : (Array.isArray(msgData.options) ? msgData.options : []);
                            if (pollOptions.length < 2) continue;
                            aiMessage = {
                                ...baseMessage,
                                type: 'poll',
                                question: msgData.question,
                                options: pollOptions,
                                votes: {},
                                isClosed: false,
                            };
                            break;
case 'gift': {
    const { itemName, itemPrice, image_prompt } = msgData; // <--- 已修正為 msgData
    // 基礎驗證，確保AI返回了必要的資訊
    if (itemName && !isNaN(parseFloat(itemPrice)) && image_prompt) {
        // 使用AI提供的英文關鍵字，通過圖像API動態生成禮物圖片
        const imageUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(image_prompt)}`;

        aiMessage = {
            ...baseMessage,
            type: 'gift',
            items: [{
                name: itemName,
                price: parseFloat(itemPrice), // 確保最終存入的是數字
                imageUrl: imageUrl, // 使用新生成的圖片URL
                quantity: 1 // AI創造的禮物數量總是1
            }],
            total: parseFloat(itemPrice),
            recipients: msgData.recipients || null // <--- 已修正為 msgData
        };
    } else {
        console.warn(`AI 嘗試贈送一個格式不正確的隨機禮物:`, msgData); // <--- 已修正為 msgData
    }
    break;
}
                        case 'vote':
                            const pollToVote = chat.history.find(m => m.timestamp === msgData.poll_timestamp);
                            if (pollToVote && !pollToVote.isClosed) {
                                Object.keys(pollToVote.votes).forEach(option => {
                                    const voterIndex = pollToVote.votes[option].indexOf(msgData.name);
                                    if (voterIndex > -1) {
                                        pollToVote.votes[option].splice(voterIndex, 1);
                                    }
                                });
                                if (!pollToVote.votes[msgData.choice]) {
                                    pollToVote.votes[msgData.choice] = [];
                                }
                                if (!pollToVote.votes[msgData.choice].includes(msgData.name)) {
                                    pollToVote.votes[msgData.choice].push(msgData.name);
                                }                        
                                if (isViewingThisChat) {
                                    renderChatInterface(chatId);
                                }
                            }
                            continue;
                        case 'red_packet':
                            aiMessage = {
                                ...baseMessage,
                                ...msgData,
                                totalAmount: msgData.amount, 
                                claimedBy: {}, 
                                isFullyClaimed: false
                            };
                            if (msgData.receiver) {
                                aiMessage.receiverName = msgData.receiver;
                                delete aiMessage.receiver;
                            }
                            break;
                        case 'open_red_packet':
                            const packetToOpen = chat.history.find(m => m.timestamp === msgData.packet_timestamp);
                            // ▼▼▼ 在這裡添加全新的驗證邏輯 ▼▼▼
const claimerOriginalName = msgData.name; // 獲取嘗試搶紅包的角色本名
const isMember = chat.members.some(member => member.originalName === claimerOriginalName);

// 如果這個角色不是當前群的成員，就記錄一個警告並直接跳過，不允許他搶
if (!isMember) {
    console.warn(`AI 角色 "${claimerOriginalName}" 嘗試領取不屬於自己的群聊紅包。操作已被攔截。`);
    continue; // 跳過後續所有搶紅包的邏輯
}
// ▲▲▲ 驗證邏輯結束 ▲▲▲
                            if (packetToOpen && packetToOpen.packetType === 'direct') {
                                if (packetToOpen.receiverName !== msgData.name) {
                                    console.warn(`AI 角色 "${msgData.name}" 嘗試領取不屬於自己的專屬紅包 (接收人: ${packetToOpen.receiverName})。操作已被攔截。`);
                                    continue;
                                }
                            }
                            
                            if (packetToOpen && !packetToOpen.isFullyClaimed && !(packetToOpen.claimedBy && packetToOpen.claimedBy[msgData.name])) {
                                let claimedAmountAI = 0;
                                const remainingAmount = packetToOpen.totalAmount - Object.values(packetToOpen.claimedBy || {}).reduce((sum, val) => sum + val, 0);
                                const remainingCount = packetToOpen.count - Object.keys(packetToOpen.claimedBy || {}).length;
                                if (remainingCount > 0) {
                                    if (packetToOpen.packetType === 'direct') {
                                        claimedAmountAI = packetToOpen.totalAmount;
                                    } else {
                                        if (remainingCount === 1) { claimedAmountAI = remainingAmount; } 
                                        else {
                                            const min = 0.01;
                                            const max = remainingAmount - (remainingCount - 1) * min;
                                            claimedAmountAI = Math.random() * (max - min) + min;
                                        }
                                    }
        
                                    claimedAmountAI = parseFloat(claimedAmountAI.toFixed(2));
                                    if (!packetToOpen.claimedBy) packetToOpen.claimedBy = {};
                                    packetToOpen.claimedBy[msgData.name] = claimedAmountAI;
        
// ▼▼▼ 這是全新的、已修復的代碼 ▼▼▼
const claimerMember = chat.members.find(m => m.originalName === msgData.name);
const claimerDisplayName = claimerMember ? claimerMember.groupNickname : msgData.name;

// ★★★ 核心修復：從紅包對象(packetToOpen)中獲取原始寄件者的名字 ★★★
const senderDisplayName = getDisplayNameInGroup(chat, packetToOpen.senderName);

const aiClaimedMessage = {
    role: 'system',
    type: 'pat_message',
    content: `${claimerDisplayName} 領取了 ${senderDisplayName} 的紅包`, // 現在可以正確顯示 "A領取了B的紅包"
    timestamp: Date.now()
};
chat.history.push(aiClaimedMessage);
// ▲▲▲ 修復代碼結束 ▲▲▲
                                    let hiddenContentForAI = `[系統提示：你 (${claimerDisplayName}) 成功搶到了 ${claimedAmountAI.toFixed(2)} 元。`;
                                    if (Object.keys(packetToOpen.claimedBy).length >= packetToOpen.count) {
                                        packetToOpen.isFullyClaimed = true;
                                        const finishedMessage = {
                                            role: 'system',
                                            type: 'pat_message',
                                            content: `${senderDisplayName} 的紅包已被領完`,
                                            timestamp: Date.now() + 1
                                        };
                                        chat.history.push(finishedMessage);
                                        let luckyKing = { name: '', amount: -1 };
                                        if (packetToOpen.packetType === 'lucky' && packetToOpen.count > 1) {
                                            Object.entries(packetToOpen.claimedBy).forEach(([name, amount]) => {
                                                if (amount > luckyKing.amount) {
                                                    luckyKing = { name, amount };
                                                }
                                            });
                                        }
                                        if (luckyKing.name) {
                                             const luckyKingMember = chat.members.find(m => m.originalName === luckyKing.name);
                                             const luckyKingDisplayName = luckyKingMember ? luckyKingMember.groupNickname : luckyKing.name;
                                             hiddenContentForAI += ` 紅包已被領完，手氣王是 ${luckyKingDisplayName}！`;
                                        } else {
                                             hiddenContentForAI += ` 紅包已被領完。`;
                                        }
                                    }
                                    hiddenContentForAI += ' 請根據這個結果發表你的評論。]';
                                    const hiddenMessageForAI = {
                                        role: 'system',
                                        content: hiddenContentForAI,
                                        timestamp: Date.now() + 2,
                                        isHidden: true
                                    };
                                    chat.history.push(hiddenMessageForAI);
                                }
                                if (isViewingThisChat) {
                                    renderChatInterface(chatId);
                                    renderChatList(); 
                                }
                            }
                            continue;
        
                        case 'accept_transfer': {
                            const originalTransferMsgIndex = chat.history.findIndex(m => m.timestamp === msgData.for_timestamp);
                            if (originalTransferMsgIndex > -1) {
                                const originalMsg = chat.history[originalTransferMsgIndex];
                                originalMsg.status = 'accepted';
                            }
                            continue;
                        }
        
                        case 'decline_transfer': {
                            const originalTransferMsgIndex = chat.history.findIndex(m => m.timestamp === msgData.for_timestamp);
                            if (originalTransferMsgIndex > -1) {
                                const originalMsg = chat.history[originalTransferMsgIndex];
                                originalMsg.status = 'declined';
                                const refundMessage = {
                                    role: 'assistant',
                                    senderName: chat.name,
                                    type: 'transfer',
                                    isRefund: true,
                                    amount: originalMsg.amount,
                                    note: '轉帳已被拒收',
                                    timestamp: messageTimestamp++
                                };
                                chat.history.push(refundMessage);
                                if (isViewingThisChat) {
                                    appendMessage(refundMessage, chat); 
                                    renderChatInterface(chatId); 
                                }
                            }
                            continue;
                        }
                        case 'change_group_name':
                            if (chat.isGroup && msgData.new_name) {
                                const newName = msgData.new_name.trim();
                                const memberNames = chat.members.map(m => m.originalName);
        
                                if (memberNames.includes(newName)) {
                                    console.warn(`AI (${msgData.name}) 試圖將群名更改為成員名 ("${newName}")。操作已被程式阻止。`);
                                    continue; 
                                }
        
                                chat.name = newName; 
        
                                const changerMember = chat.members.find(m => m.originalName === msgData.name);
                                const changerDisplayName = changerMember ? changerMember.groupNickname : msgData.name;
                                
                                const systemMessage = {
                                    role: 'system',
                                    type: 'pat_message',
                                    content: `${changerDisplayName} 將群名修改為 “${chat.name}”`,
                                    timestamp: messageTimestamp++
                                };
                                chat.history.push(systemMessage);
        
                                if (isViewingThisChat) {
                                    appendMessage(systemMessage, chat);
                                    document.getElementById('chat-header-title').textContent = chat.name;
                                }
                            }
                            continue;
                        case 'change_remark_name':
                            if (!chat.isGroup && msgData.new_name) {
                                const oldName = chat.name; 
                                const newName = msgData.new_name.trim();
        
                                if (newName && newName !== oldName) {
                                    if (!chat.nameHistory) {
                                        chat.nameHistory = [];
                                    }
                                    if (!chat.nameHistory.includes(oldName)) {
                                        chat.nameHistory.push(oldName);
                                    }
                                    
                                    chat.name = newName; 
        
                                    const systemMessage = {
                                        role: 'system',
                                        type: 'pat_message', 
                                        content: `“${chat.originalName}” 將備註修改為 “${newName}”`,
                                        timestamp: messageTimestamp++
                                    };
                                    chat.history.push(systemMessage);
        
                                    const hiddenMemoryMessage = {
                                        role: 'system',
                                        content: `[系統提示：你剛剛成功將自己的備註名修改為了“${newName}”。請自然地接受這個新名字，不要對此感到驚訝。]`,
                                        timestamp: messageTimestamp++, 
                                        isHidden: true
                                    };
                                    chat.history.push(hiddenMemoryMessage);
        
                                    if (isViewingThisChat) {
                                        appendMessage(systemMessage, chat);
                                        document.getElementById('chat-header-title').textContent = newName;
                                    }
                                    
                                    await syncCharacterNameInGroups(chat); 
                                }
                            }
                            continue;
        
                        case 'change_group_avatar':
                            if (chat.isGroup && msgData.avatar_name) {
                                const avatarName = msgData.avatar_name;
                                const library = chat.settings.groupAvatarLibrary || [];
                                const foundAvatar = library.find(avatar => avatar.name === avatarName);
        
                                if (foundAvatar) {
                                    chat.settings.groupAvatar = foundAvatar.url;
                                    
                                    const changerMember = chat.members.find(m => m.originalName === msgData.name);
                                    const changerDisplayName = changerMember ? changerMember.groupNickname : msgData.name;
        
                                    const systemMessage = {
                                        role: 'system',
                                        type: 'pat_message',
                                        content: `${changerDisplayName} 更換了群頭像`,
                                        timestamp: messageTimestamp++
                                    };
                                    chat.history.push(systemMessage);
        
                                    if (isViewingThisChat) {
                                        appendMessage(systemMessage, chat);
                                    }
                                } else {
                                    console.warn(`AI 嘗試使用一個不存在的群頭像: "${avatarName}"`);
                                }
                            }
                            continue;
                        case 'system_message':
                            aiMessage = { role: 'system', type: 'pat_message', content: msgData.content, timestamp: Date.now() };
                            break;
                        case 'share_link':
                            aiMessage = { 
                                ...baseMessage, 
                                type: 'share_link',
                                title: msgData.title,
                                description: msgData.description,
                                source_name: msgData.source_name,
                                content: msgData.content
                            };
                            break;
                        case 'quote_reply':
                            const originalMessage = chat.history.find(m => m.timestamp === msgData.target_timestamp);
                            if (originalMessage) {
                                const quoteContext = {
                                    timestamp: originalMessage.timestamp,
                                    senderName: originalMessage.senderName || (originalMessage.role === 'user' ? (chat.settings.myNickname || '我') : chat.name),
                                    content: String(originalMessage.content || '').substring(0, 50),
                                };
                                aiMessage = { 
                                    ...baseMessage, 
                                    content: msgData.reply_content,
                                    quote: quoteContext
                                };
                            } else {
                                aiMessage = { ...baseMessage, content: msgData.reply_content };
                            }
                            break;
                        case 'send_and_recall': {
                            if (!isViewingThisChat) continue;
                            const tempMessageData = { ...baseMessage, content: msgData.content };
                            const tempMessageElement = createMessageElement(tempMessageData, chat);
                            appendMessage(tempMessageData, chat, true);
                            await new Promise(resolve => setTimeout(resolve, Math.random() * 1000 + 1500));
                            const bubbleWrapper = document.querySelector(`.message-bubble[data-timestamp="${tempMessageData.timestamp}"]`)?.closest('.message-wrapper');
                            if (bubbleWrapper) {
                                bubbleWrapper.classList.add('recalled-animation');
                                await new Promise(resolve => setTimeout(resolve, 300));
                                const recalledMessage = {
                                    role: 'assistant',
                                    senderName: msgData.name || chat.name,
                                    type: 'recalled_message',
                                    content: '對方撤回了一條消息',
                                    timestamp: tempMessageData.timestamp,
                                    recalledData: { originalType: 'text', originalContent: msgData.content }
                                };
                                const msgIndex = chat.history.findIndex(m => m.timestamp === tempMessageData.timestamp);
                                if (msgIndex > -1) {
                                    chat.history[msgIndex] = recalledMessage;
                                } else {
                                    chat.history.push(recalledMessage);
                                }
                                const placeholder = await createMessageElement(recalledMessage, chat);
                                if(document.body.contains(bubbleWrapper)) {
                                    bubbleWrapper.parentNode.replaceChild(placeholder, bubbleWrapper);
                                }
                            }
                            continue;
                        }
                        
                        case 'text':
                            aiMessage = { ...baseMessage, content: String(msgData.content || msgData.message) };
                            break;
                        case 'sticker':
                            aiMessage = { ...baseMessage, type: 'sticker', content: msgData.url, meaning: msgData.meaning || '' };
                            break;
                        case 'ai_image':
                            aiMessage = { ...baseMessage, type: 'ai_image', content: msgData.description, image_prompt: msgData.image_prompt };
                            break;
                        case 'voice_message':
                            aiMessage = { ...baseMessage, type: 'voice_message', content: msgData.content };
                            break;
                        case 'transfer':
                            aiMessage = { ...baseMessage, type: 'transfer', amount: msgData.amount, note: msgData.note, receiverName: msgData.receiver || '我' };
                            break;
                        
                        case 'waimai_request':
                            aiMessage = { 
                                ...baseMessage, 
                                type: 'waimai_request',
                                productInfo: msgData.productInfo,
                                amount: msgData.amount,
                                status: 'pending',
                                countdownEndTime: Date.now() + 15 * 60 * 1000,
                            };
                            break;
                case 'waimai_order':
                    aiMessage = {
                        ...baseMessage,
                        type: 'waimai_order',
                        productInfo: msgData.productInfo,
                        amount: msgData.amount,
                        greeting: msgData.greeting,
                        recipientName: msgData.recipientName || null // 如果是群聊，記錄接收者
                    };
                    break;
                        case 'offline_text':
        aiMessage = { ...baseMessage, ...msgData };
                        default:
                             console.warn("收到了未知的AI指令類型:", msgData.type);
                             break;
                    }
        
                    if (aiMessage) {
                        chat.history.push(aiMessage);
                        if (!isViewingThisChat && !notificationShown) {
                            let notificationText;
                            switch (aiMessage.type) {
                                case 'transfer': notificationText = `[收到一筆轉帳]`; break;
                                case 'waimai_request': notificationText = `[收到一個外賣代付請求]`; break;
                                case 'ai_image': notificationText = `[圖片]`; break;
                                case 'voice_message': notificationText = `[語音]`; break;
                                case 'sticker': notificationText = aiMessage.meaning ? `[表情: ${aiMessage.meaning}]` : '[表情]'; break;
                                case 'offline_text': notificationText = aiMessage.dialogue ? `「${aiMessage.dialogue}」` : `[${aiMessage.description.substring(0, 20)}...]`; break;
                                default: notificationText = String(aiMessage.content || '');
                            }
                            const finalNotifText = chat.isGroup ? `${aiMessage.senderName}: ${notificationText}` : notificationText;
                            showNotification(chatId, finalNotifText.substring(0, 40) + (finalNotifText.length > 40 ? '...' : ''));
                            notificationShown = true;
                        }
        
                        if (!isViewingThisChat) {
                            chat.unreadCount = (chat.unreadCount || 0) + 1;
                        }
                        
                        if (isViewingThisChat) {
                            appendMessage(aiMessage, chat);
                            await new Promise(resolve => setTimeout(resolve, Math.random() * 1800 + 1000));
                        }
                    }
                }        
        
                if (callHasBeenHandled && videoCallState.isGroupCall) {
                    videoCallState.isAwaitingResponse = false;
                    if (videoCallState.participants.length > 0) {
                        startVideoCall();
                    } else {
                        videoCallState = { ...videoCallState, isAwaitingResponse: false, participants: [] };
                        showScreen('chat-interface-screen');
                        alert('無人接聽群聊邀請。');
                    }
                }
                if (needsImmediateReaction) {
                    await triggerAiResponse();
                    return; 
                }
                await db.chats.put(chat);
        // 檢查剛剛AI執行的動作中，是否包含了任何與“動態”相關的操作
const qzoneActionTaken = messagesArray.some(action =>
    action.type === 'qzone_post' ||
    action.type === 'qzone_like' ||
    action.type === 'qzone_comment' ||
    action.type === 'repost'
);

// 如果AI確實執行了動態相關的操作
if (qzoneActionTaken) {
    console.log("檢測到AI執行了動態操作，立即刷新好友動態頁面。");
    // 主動調用渲染函數，強制刷新頁面內容
    await renderQzonePosts();
}

// ▲▲▲ 新增代碼黏貼結束 ▲▲▲
            } catch (error) {
                
                chat.history = chat.history.filter(msg => !msg.isTemporary);
                
                if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
                    chat.relationship.status = 'blocked_by_ai';
                    await showCustomAlert('申請失敗', `AI在處理你的好友申請時出錯了，請稍後重試。\n錯誤資訊: ${error.message}`);
                } else {
                    await showCustomAlert(
                        'API 調用失敗', 
                        `發生了一個錯誤，AI未能成功響應。\n\n錯誤詳情:\n${error.message}`
                    );
                }
                
                if (!chat.isGroup && chat.relationship?.status === 'blocked_by_ai') {
                     await db.chats.put(chat);        
                }
               
                videoCallState.isAwaitingResponse = false;
            } finally {
                setAvatarActingState(chatId, false);
        
               
                if (chat.isGroup) {
                    if (typingIndicator) {
                        typingIndicator.style.display = 'none';
                    }
                } else {
                    if (chatHeaderTitle && state.chats[chatId]) {
                        chatHeaderTitle.style.opacity = 0;
                        setTimeout(() => {
                            chatHeaderTitle.textContent = state.chats[chatId].name;
                            chatHeaderTitle.classList.remove('typing-status');
                            chatHeaderTitle.style.opacity = 1;
                        }, 200);
                    }
                }
                renderChatList();
                if (isViewingThisChat) {
                    checkAndTriggerAutoSummary(chatId);
                 
                }
            }
        }
        // ▲▲▲ 替換結束 ▲▲▲
        
        
        
        
        
        
        
                async function sendSticker(sticker) { if (!state.activeChatId) return; const chat = state.chats[state.activeChatId]; const msg = { role: 'user', content: sticker.url, meaning: sticker.name, timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); document.getElementById('sticker-panel').classList.remove('visible'); }
        
                async function sendUserTransfer() { if (!state.activeChatId) return; const amountInput = document.getElementById('transfer-amount'); const noteInput = document.getElementById('transfer-note'); const amount = parseFloat(amountInput.value); const note = noteInput.value.trim(); if (isNaN(amount) || amount < 0 || amount > 999999) { alert('請輸入有效的金額 (0 到 999999 之間)！'); return; } const chat = state.chats[state.activeChatId]; const senderName = chat.isGroup ? (chat.settings.myNickname || '我') : '我'; const receiverName = chat.isGroup ? '群聊' : chat.name; const msg = { role: 'user', type: 'transfer', amount: amount, note: note, senderName, receiverName, timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); document.getElementById('transfer-modal').classList.remove('visible'); amountInput.value = ''; noteInput.value = ''; }

/**
 * 【全新 V2.0 | AI認知修復版】處理用戶點擊“為TA點外賣”的邏輯
 */
async function sendWaimaiOrderForAI() {
    if (!state.activeChatId) return;
    
    const productInfoInput = document.getElementById('waimai-product-info');
    const amountInput = document.getElementById('waimai-amount');
    
    const productInfo = productInfoInput.value.trim();
    const amount = parseFloat(amountInput.value);

    if (!productInfo || isNaN(amount) || amount <= 0) {
        alert('請填寫有效的商品資訊和金額！');
        return;
    }

    const chat = state.chats[state.activeChatId];
    const now = Date.now();
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';

    // 1. 創建對用戶可見的“已下單”卡片消息（這部分保持不變）
    const visibleMessage = {
        role: 'user',
        senderName: myNickname, 
        type: 'waimai_order',
        productInfo: productInfo,
        amount: amount,
        timestamp: now
    };
    chat.history.push(visibleMessage);

    // 2. 【核心修改1】創建一條對用戶隱藏的、語義更清晰的系統消息，明確告知AI這是一個“禮物”
    const hiddenMessage = {
        role: 'system',
        content: `[系統提示：用戶(${myNickname})為你點了一份外賣作為【禮物】。外賣內容是“${productInfo}”，價值${amount}元。這不是一個代付請求，而是用戶已經為你支付了。請你對此表示感謝。]`,
        timestamp: now + 1,
        isHidden: true
    };
    chat.history.push(hiddenMessage);

    // 3. 保存資料，更新UI
    await db.chats.put(chat);
    appendMessage(visibleMessage, chat);
    renderChatList();

    // 4. 清理並關閉彈窗
    productInfoInput.value = '';
    amountInput.value = '';
    document.getElementById('waimai-request-modal').classList.remove('visible');

    // 5. 【核心修改2】移除此處的 triggerAiResponse() 調用，不再立刻通知AI
    // triggerAiResponse(); // <--- 確保這一行已被刪除或注釋掉！
}
        /**
         * 【全新 V3.0】發送一個位置共用卡片 (背景圖已內置)
         */
        async function sendLocationShare() {
            if (!state.activeChatId) return;
        
            // 步驟1: 詢問位置名稱 (這部分保持不變)
            const locationName = await showCustomPrompt("共用位置", "你現在在哪裡呀？", "");
        
            // 如果用戶取消或沒有輸入位置，則直接退出
            if (!locationName || !locationName.trim()) return; 
        
            // 步驟2: 【核心修改】在這裡直接定義好您想用的圖片URL
            // 您可以隨時將這個連結替換為您喜歡的任何圖片位址
            const hardcodedImageUrl = 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1756262526935_qdqqd_4uque3.jpeg';
        
            const chat = state.chats[state.activeChatId];
            
            // 步驟3: 構建消息物件，直接使用我們定義好的圖片URL
            const msg = {
                role: 'user',
                type: 'location_share',
                content: locationName.trim(),
                imageUrl: hardcodedImageUrl, // 直接使用上面定義的URL
                timestamp: Date.now()
            };
            
            // 步驟4: 保存並更新UI (這部分保持不變)
            chat.history.push(msg);
            await db.chats.put(chat);
            appendMessage(msg, chat);
            renderChatList();
        }
        
        
                function enterSelectionMode(initialMsgTimestamp) { if (isSelectionMode) return; isSelectionMode = true; document.getElementById('chat-interface-screen').classList.add('selection-mode'); toggleMessageSelection(initialMsgTimestamp); }
        
                function exitSelectionMode() {
            cleanupWaimaiTimers(); // <--- 在這裡添加這行代碼
         if (!isSelectionMode) return; isSelectionMode = false; document.getElementById('chat-interface-screen').classList.remove('selection-mode'); selectedMessages.forEach(ts => { const bubble = document.querySelector(`.message-bubble[data-timestamp="${ts}"]`); if (bubble) bubble.classList.remove('selected'); }); selectedMessages.clear(); }
        
        // ▼▼▼ 請用這個【最終簡化版】替換舊的 toggleMessageSelection 函數 ▼▼▼
        function toggleMessageSelection(timestamp) {
            // 【核心修正】選擇器已簡化，不再尋找已刪除的 .recalled-message-placeholder
            const elementToSelect = document.querySelector(
                `.message-bubble[data-timestamp="${timestamp}"]`
            );
        
            if (!elementToSelect) return;
        
            if (selectedMessages.has(timestamp)) {
                selectedMessages.delete(timestamp);
                elementToSelect.classList.remove('selected');
            } else {
                selectedMessages.add(timestamp);
                elementToSelect.classList.add('selected');
            }
            
            document.getElementById('selection-count').textContent = `已選 ${selectedMessages.size} 條`;
            
            if (selectedMessages.size === 0) {
                exitSelectionMode();
            }
        }
        // ▲▲▲ 替換結束 ▲▲▲
        
                function addLongPressListener(element, callback) { let pressTimer; const startPress = (e) => { if(isSelectionMode) return; e.preventDefault(); pressTimer = window.setTimeout(() => callback(e), 500); }; const cancelPress = () => clearTimeout(pressTimer); element.addEventListener('mousedown', startPress); element.addEventListener('mouseup', cancelPress); element.addEventListener('mouseleave', cancelPress); element.addEventListener('touchstart', startPress, { passive: true }); element.addEventListener('touchend', cancelPress); element.addEventListener('touchmove', cancelPress); }
        
                async function handleListenTogetherClick() { const targetChatId = state.activeChatId; if (!targetChatId) return; if (!musicState.isActive) { startListenTogetherSession(targetChatId); return; } if (musicState.activeChatId === targetChatId) { document.getElementById('music-player-overlay').classList.add('visible'); } else { const oldChatName = state.chats[musicState.activeChatId]?.name || '未知'; const newChatName = state.chats[targetChatId]?.name || '當前'; const confirmed = await showCustomConfirm('切換聽歌對象', `您正和「${oldChatName}」聽歌。要結束並開始和「${newChatName}」的新會話嗎？`, { confirmButtonClass: 'btn-danger' }); if (confirmed) { await endListenTogetherSession(true); await new Promise(resolve => setTimeout(resolve, 50)); startListenTogetherSession(targetChatId); } } }

async function startListenTogetherSession(chatId) { const chat = state.chats[chatId]; if (!chat) return; musicState.totalElapsedTime = chat.musicData.totalTime || 0; musicState.isActive = true; musicState.activeChatId = chatId; if (musicState.playlist.length > 0) { musicState.currentIndex = 0; } else { musicState.currentIndex = -1; } if(musicState.timerId) clearInterval(musicState.timerId); musicState.timerId = setInterval(() => { if (musicState.isPlaying) { musicState.totalElapsedTime++; updateElapsedTimeDisplay(); } }, 1000); updatePlayerUI(); updatePlaylistUI(); document.getElementById('music-player-overlay').classList.add('visible'); }

async function endListenTogetherSession(saveState = true) {
    if (!musicState.isActive) return;
    const oldChatId = musicState.activeChatId;
    document.getElementById('global-lyrics-bar').classList.remove('visible');
    const cleanupLogic = async () => {
        if (musicState.timerId) clearInterval(musicState.timerId);
        if (musicState.isPlaying) audioPlayer.pause();
        if (saveState && oldChatId && state.chats[oldChatId]) {
            const chat = state.chats[oldChatId];
            chat.musicData.totalTime = musicState.totalElapsedTime;
            await db.chats.put(chat);
        }
        musicState.isActive = false;
        musicState.activeChatId = null;
        musicState.totalElapsedTime = 0;
        musicState.timerId = null;
        updateListenTogetherIcon(oldChatId, true);
    };
    closeMusicPlayerWithAnimation(cleanupLogic);
}

function returnToChat() {
    closeMusicPlayerWithAnimation();
}

function updateListenTogetherIcon(chatId, forceReset = false) { const iconImg = document.querySelector('#listen-together-btn img'); if(!iconImg) return; if(forceReset || !musicState.isActive || musicState.activeChatId !== chatId) { iconImg.src = 'https://i.postimg.cc/8kYShvrJ/90-UI-2.png'; iconImg.className = ''; return; } iconImg.src = 'https://i.postimg.cc/D0pq6qS2/E30078-DC-8-B99-4-C01-AFDA-74728-DBF7-BEA.png'; iconImg.classList.add('rotating'); if (musicState.isPlaying) iconImg.classList.remove('paused'); else iconImg.classList.add('paused'); }
window.updateListenTogetherIconProxy = updateListenTogetherIcon;

function updatePlayerUI() { 
    updateListenTogetherIcon(musicState.activeChatId); 
    updateElapsedTimeDisplay(); 
    const titleEl = document.getElementById('music-player-song-title'); 
    const artistEl = document.getElementById('music-player-artist'); 
    const playPauseBtn = document.getElementById('music-play-pause-btn'); 
    if (musicState.currentIndex > -1 && musicState.playlist.length > 0) { 
        const track = musicState.playlist[musicState.currentIndex]; 
        titleEl.textContent = track.name; 
        artistEl.textContent = track.artist; 
    } else { 
        titleEl.textContent = '請添加歌曲'; 
        artistEl.textContent = '...'; 
    } 
    playPauseBtn.textContent = musicState.isPlaying ? '❚❚' : '▶'; 
}

function updateElapsedTimeDisplay() { const hours = (musicState.totalElapsedTime / 3600).toFixed(1); document.getElementById('music-time-counter').textContent = `已經一起聽了${hours}小時`; }

function updatePlaylistUI() {
    const playlistBody = document.getElementById('playlist-body');
    playlistBody.innerHTML = '';
    if (musicState.playlist.length === 0) {
        playlistBody.innerHTML = '<p style="text-align:center; padding: 20px; color: #888;">播放清單是空的~</p>';
        return;
    }
    musicState.playlist.forEach((track, index) => {
        const item = document.createElement('div');
        item.className = 'playlist-item';
        if(index === musicState.currentIndex) item.classList.add('playing');

        // ▼▼▼ 核心修改就在這裡 ▼▼▼
item.innerHTML = `
    <div class="playlist-item-info">
        <div class="title">${track.name}</div>
        <div class="artist">${track.artist}</div>
    </div>
    <div class="playlist-item-actions">
        <span class="playlist-action-btn album-art-btn" data-index="${index}">專輯</span>
        <span class="playlist-action-btn lyrics-btn" data-index="${index}">詞</span>
        <!-- 【核心新增】在這裡添加“背景”按鈕 -->
        <span class="playlist-action-btn bg-btn" data-index="${index}">背景</span>
        <span class="playlist-action-btn delete-track-btn" data-index="${index}">×</span>
    </div>
`;
        // ▲▲▲ 修改結束 ▲▲▲

        item.querySelector('.playlist-item-info').addEventListener('click', () => playSong(index));
        playlistBody.appendChild(item);
    });
}



async function togglePlayPause() {
    if (audioPlayer.paused) {
        if (musicState.currentIndex === -1 && musicState.playlist.length > 0) {
            playSong(0);
        } 
        else if (musicState.currentIndex > -1) {
            playSong(musicState.currentIndex);
        }
    } else {
        audioPlayer.pause();
        await addMusicActionSystemMessage('暫停了音樂');
    }
}

function playNext() { if (musicState.playlist.length === 0) return; let nextIndex; switch(musicState.playMode) { case 'random': nextIndex = Math.floor(Math.random() * musicState.playlist.length); break; case 'single': playSong(musicState.currentIndex); return; case 'order': default: nextIndex = (musicState.currentIndex + 1) % musicState.playlist.length; break; } playSong(nextIndex); }

function playPrev() { if (musicState.playlist.length === 0) return; const newIndex = (musicState.currentIndex - 1 + musicState.playlist.length) % musicState.playlist.length; playSong(newIndex); }

function changePlayMode() { const modes = ['order', 'random', 'single']; const currentModeIndex = modes.indexOf(musicState.playMode); musicState.playMode = modes[(currentModeIndex + 1) % modes.length]; document.getElementById('music-mode-btn').textContent = {'order': '順序', 'random': '隨機', 'single': '單曲'}[musicState.playMode]; }

async function addSongFromURL() { const url = await showCustomPrompt("添加網路歌曲", "請輸入歌曲的URL", "", "url"); if (!url) return; const name = await showCustomPrompt("歌曲資訊", "請輸入歌名"); if (!name) return; const artist = await showCustomPrompt("歌曲資訊", "請輸入歌手名"); if (!artist) return; musicState.playlist.push({ name, artist, src: url, isLocal: false }); await saveGlobalPlaylist(); updatePlaylistUI(); if(musicState.currentIndex === -1) { musicState.currentIndex = musicState.playlist.length - 1; updatePlayerUI(); } }
 
// ▼▼▼ 【請用這個已修復的版本】完整替換舊的 addSongFromLocal 函數 ▼▼▼
async function addSongFromLocal(event) {
    const files = event.target.files;
    if (!files.length) return;

    for (const file of files) {
        let name = file.name.replace(/\.[^/.]+$/, "");
        name = await showCustomPrompt("歌曲資訊", "請輸入歌名", name);
        if (name === null) continue;
        
        const artist = await showCustomPrompt("歌曲資訊", "請輸入歌手名", "未知歌手");
        if (artist === null) continue;

        // 【核心修復1】讀取檔為 ArrayBuffer，這是最可靠的存儲方式
        const arrayBuffer = await file.arrayBuffer();

        let lrcContent = "";
        const wantLrc = await showCustomConfirm("導入歌詞", `要為《${name}》添加歌詞嗎？`);
        if (wantLrc) {
            lrcContent = await getLrcContent() || "";
        }
        
        musicState.playlist.push({ 
            name, 
            artist, 
            src: arrayBuffer,           // 【核心修復2】存儲 ArrayBuffer 而不是 File 物件
            fileType: file.type,        // 【核心修復3】同時存儲檔的MIME類型
            isLocal: true,
            lrcContent: lrcContent,
            cover: 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1757748720126_qdqqd_1jt5sv.jpeg'
        });
    }
    
    await saveGlobalPlaylist();
    updatePlaylistUI();
    if (musicState.currentIndex === -1 && musicState.playlist.length > 0) {
        musicState.currentIndex = 0;
        updatePlayerUI();
    }
    event.target.value = null;
}
// ▲▲▲ 替換結束 ▲▲▲

// ▼▼▼ 【請用這個已修復的版本】完整替換舊的 playSong 函數 ▼▼▼
// ▼▼▼ 【請用這個已支援頭像顯示並修復渲染問題的全新版本】替換舊的 playSong 函數 ▼▼▼
async function playSong(index) {
    if (index < 0 || index >= musicState.playlist.length) return;

    audioPlayer.pause();

    musicState.currentIndex = index;
    const track = musicState.playlist[index];
    const chat = state.chats[musicState.activeChatId]; // 獲取當前聊天物件

    // --- ▼▼▼ 核心修復：載入並填充頭像 (使用更可靠的DOM操作) ▼▼▼ ---
    const avatarDisplay = document.getElementById('music-player-avatar-display');
    if (chat && avatarDisplay) {
        // 1. 清空舊內容
        avatarDisplay.innerHTML = '';

        // 2. 根據聊天類型獲取正確的頭像URL
        const charAvatarUrl = chat.isGroup 
            ? (chat.members.find(m => m.originalName === track.artist)?.avatar || defaultAvatar) 
            : (chat.settings.aiAvatar || defaultAvatar);
        const userAvatarUrl = chat.settings.myAvatar || defaultAvatar;

        // 3. 創建角色頭像元素並添加
        const charAvatarEl = document.createElement('img');
        charAvatarEl.src = charAvatarUrl;
        charAvatarEl.className = 'participant-display-avatar';
        charAvatarEl.alt = 'Character Avatar';
        avatarDisplay.appendChild(charAvatarEl);

        // 4. 創建使用者頭像元素並添加
        const userAvatarEl = document.createElement('img');
        userAvatarEl.src = userAvatarUrl;
        userAvatarEl.className = 'participant-display-avatar';
        userAvatarEl.alt = 'User Avatar';
        avatarDisplay.appendChild(userAvatarEl);
    }
    // --- ▲▲▲ 修復結束 ▲▲▲ ---

    const playerWindow = document.querySelector('.music-player-window');
    const toggleBtn = document.getElementById('toggle-blur-btn');

    if (playerWindow) {
        playerWindow.style.setProperty('--music-bg-image', track.background ? `url(${track.background})` : 'none');
        playerWindow.classList.toggle('bg-clear', !!track.isBgClear);
    }
    if (toggleBtn) {
        toggleBtn.classList.toggle('active', !!track.isBgClear);
    }
    
    // (後續的所有播放邏輯保持不變)
    document.getElementById('music-visual-container').classList.remove('lyrics-active');
    const coverEl = document.getElementById('music-player-cover');
    if (coverEl) {
        coverEl.src = track.cover || 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1757748720126_qdqqd_1jt5sv.jpeg';
    }
    
    await addMusicActionSystemMessage(`將歌曲切換為了《${track.name}》`);
    musicState.parsedLyrics = parseLRC(track.lrcContent || "");
    
    renderLyrics(); 
    const singleLyricEl = document.getElementById('single-lyric-display');
    if (singleLyricEl) {
        if (!musicState.parsedLyrics || musicState.parsedLyrics.length === 0) {
            singleLyricEl.textContent = '純音樂，請欣賞';
        } else {
            singleLyricEl.textContent = '♪ ♪ ♪'; 
        }
    }
    
    if (track.isLocal && track.src instanceof ArrayBuffer) {
        const blob = new Blob([track.src], { type: track.fileType || 'audio/mpeg' });
        audioPlayer.src = URL.createObjectURL(blob);
    } 
    else if (track.isLocal && track.src instanceof Blob) {
        audioPlayer.src = URL.createObjectURL(track.src);
    } else if (!track.isLocal) {
        audioPlayer.src = track.src;
    } else {
        console.error('本地歌曲源錯誤:', track);
        return;
    }
    
    const playPromise = audioPlayer.play();
    if (playPromise !== undefined) {
        playPromise.catch(error => {
            if (error.name === 'NotAllowedError') {
                console.warn('Autoplay was prevented by the browser.');
                audioPlayer.pause();
                showCustomAlert("播放已暫停", "由於流覽器安全限制，AI切換的歌曲無法自動播放。請手動點擊播放按鈕 ▶ 繼續欣賞。");
            } else if (error.name !== 'AbortError') {
                console.error('Playback error:', error);
            }
        });
    }
    updatePlaylistUI();
    updatePlayerUI();
    updateMusicProgressBar();
    
    const lyricBar = document.getElementById('global-lyrics-bar');
    if (musicState.parsedLyrics && musicState.parsedLyrics.length > 0) {
        lyricBar.textContent = '♪';
        lyricBar.classList.add('visible');
    } else {
        lyricBar.classList.remove('visible');
    }
}
// ▲▲▲ 替換結束 ▲▲▲
/**
 * 處理更換指定歌曲背景圖片的邏輯
 * @param {number} trackIndex - 播放清單中歌曲的索引
 */
async function handleChangeBackground(trackIndex) {
    if (trackIndex < 0 || trackIndex >= musicState.playlist.length) return;

    // 1. 彈出選項，讓使用者選擇上傳方式
    const choice = await showChoiceModal("更換歌曲背景", [
        { text: '📁 從本地上傳', value: 'local' },
        { text: '🌐 使用網路URL', value: 'url' }
    ]);

    let newBackgroundUrl = null;

    // 2. 根據選擇獲取圖片
    if (choice === 'local') {
        newBackgroundUrl = await uploadImageLocally();
    } else if (choice === 'url') {
        newBackgroundUrl = await showCustomPrompt("輸入圖片URL", "請輸入新的背景圖片連結", "", "url");
    }

    // 3. 如果成功獲取到圖片，則更新並保存
    if (newBackgroundUrl && newBackgroundUrl.trim()) {
        musicState.playlist[trackIndex].background = newBackgroundUrl.trim();
        await saveGlobalPlaylist();
        
        // 4. 如果正在播放的就是這首歌，則立即應用新背景
        if (musicState.currentIndex === trackIndex) {
            const playerWindow = document.querySelector('.music-player-window');
            playerWindow.style.setProperty('--music-bg-image', `url(${newBackgroundUrl.trim()})`);
        }

        await showCustomAlert("成功", "歌曲背景已更新！");
    }
}
/**
 * 【全新】處理更換專輯封面的邏輯
 * @param {number} trackIndex - 播放清單中歌曲的索引
 */
async function handleChangeAlbumArt(trackIndex) {
    if (trackIndex < 0 || trackIndex >= musicState.playlist.length) return;

    const choice = await showChoiceModal("更換專輯封面", [
        { text: '📁 從本地上傳', value: 'local' },
        { text: '🌐 使用網路URL', value: 'url' }
    ]);

    let newCoverUrl = null;

    if (choice === 'local') {
        newCoverUrl = await uploadImageLocally();
    } else if (choice === 'url') {
        newCoverUrl = await showCustomPrompt("輸入圖片URL", "請輸入新的封面圖片連結", "", "url");
    }

    if (newCoverUrl && newCoverUrl.trim()) {
        musicState.playlist[trackIndex].cover = newCoverUrl.trim();
        await saveGlobalPlaylist();
        
        // 如果正在播放的歌曲就是被修改的這首，立即更新播放機UI
        if (musicState.currentIndex === trackIndex) {
            document.getElementById('music-player-cover').src = newCoverUrl.trim();
            // 同時更新黑膠唱片中心的圖片
            const vinylCover = document.querySelector('#vinyl-view #music-player-cover');
            if(vinylCover) vinylCover.src = newCoverUrl.trim();
        }

        await showCustomAlert("成功", "專輯封面已更新！");
    }
}

async function deleteTrack(index) { if (index < 0 || index >= musicState.playlist.length) return; const track = musicState.playlist[index]; const wasPlaying = musicState.isPlaying && musicState.currentIndex === index; if (track.isLocal && audioPlayer.src.startsWith('blob:') && musicState.currentIndex === index) URL.revokeObjectURL(audioPlayer.src); musicState.playlist.splice(index, 1); await saveGlobalPlaylist(); if (musicState.playlist.length === 0) { if (musicState.isPlaying) audioPlayer.pause(); audioPlayer.src = ''; musicState.currentIndex = -1; musicState.isPlaying = false; } else { if (wasPlaying) { playNext(); } else { if (musicState.currentIndex >= index) musicState.currentIndex = Math.max(0, musicState.currentIndex - 1); } } updatePlayerUI(); updatePlaylistUI(); }
        
        // ▼▼▼ 請用這個【新版本】的函數，完整替換舊的 addSongFromLocal 函數 ▼▼▼
        
        async function addSongFromLocal(event) {
            const files = event.target.files;
            if (!files.length) return;
        
            for (const file of files) {
                let name = file.name.replace(/\.[^/.]+$/, "");
                name = await showCustomPrompt("歌曲資訊", "請輸入歌名", name);
                if (name === null) continue;
                
                const artist = await showCustomPrompt("歌曲資訊", "請輸入歌手名", "未知歌手");
                if (artist === null) continue;
        
                let lrcContent = "";
                const wantLrc = await showCustomConfirm("導入歌詞", `要為《${name}》添加歌詞嗎？`);
                if (wantLrc) {
                    // 【核心修改】直接調用我們新的統一函數！
                    lrcContent = await getLrcContent() || ""; // 如果用戶取消，則lrcContent為""
                }
                
                musicState.playlist.push({ 
                    name, 
                    artist, 
                    src: file, 
                    isLocal: true,
                    lrcContent: lrcContent
                });
            }
            
            await saveGlobalPlaylist();
            updatePlaylistUI();
            if (musicState.currentIndex === -1 && musicState.playlist.length > 0) {
                musicState.currentIndex = 0;
                updatePlayerUI();
            }
            event.target.value = null;
        }
        // ▲▲▲ 替換結束 ▲▲▲
        
                async function deleteTrack(index) { if (index < 0 || index >= musicState.playlist.length) return; const track = musicState.playlist[index]; const wasPlaying = musicState.isPlaying && musicState.currentIndex === index; if (track.isLocal && audioPlayer.src.startsWith('blob:') && musicState.currentIndex === index) URL.revokeObjectURL(audioPlayer.src); musicState.playlist.splice(index, 1); await saveGlobalPlaylist(); if (musicState.playlist.length === 0) { if (musicState.isPlaying) audioPlayer.pause(); audioPlayer.src = ''; musicState.currentIndex = -1; musicState.isPlaying = false; } else { if (wasPlaying) { playNext(); } else { if (musicState.currentIndex >= index) musicState.currentIndex = Math.max(0, musicState.currentIndex - 1); } } updatePlayerUI(); updatePlaylistUI(); }
        
                const personaLibraryModal = document.getElementById('persona-library-modal');
                const personaEditorModal = document.getElementById('persona-editor-modal');
                const presetActionsModal = document.getElementById('preset-actions-modal');
        
                function openPersonaLibrary() { renderPersonaLibrary(); personaLibraryModal.classList.add('visible'); }
        
                function closePersonaLibrary() { personaLibraryModal.classList.remove('visible'); }
        
                function renderPersonaLibrary() { const grid = document.getElementById('persona-library-grid'); grid.innerHTML = ''; if (state.personaPresets.length === 0) { grid.innerHTML = '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center; margin-top: 20px;">空空如也~ 點擊右上角"添加"來創建你的第一個人設預設吧！</p>'; return; } state.personaPresets.forEach(preset => { const item = document.createElement('div'); item.className = 'persona-preset-item'; item.style.backgroundImage = `url(${preset.avatar})`; item.dataset.presetId = preset.id; item.addEventListener('click', () => applyPersonaPreset(preset.id)); addLongPressListener(item, () => showPresetActions(preset.id)); grid.appendChild(item); }); }
        
                function showPresetActions(presetId) { editingPersonaPresetId = presetId; presetActionsModal.classList.add('visible'); }
        
                function hidePresetActions() { presetActionsModal.classList.remove('visible'); editingPersonaPresetId = null; }
        
                function applyPersonaPreset(presetId) { const preset = state.personaPresets.find(p => p.id === presetId); if (preset) { document.getElementById('my-avatar-preview').src = preset.avatar; document.getElementById('my-persona').value = preset.persona; } closePersonaLibrary(); }
        
                function openPersonaEditorForCreate() { editingPersonaPresetId = null; document.getElementById('persona-editor-title').textContent = '添加人設預設'; document.getElementById('preset-avatar-preview').src = defaultAvatar; document.getElementById('preset-persona-input').value = ''; personaEditorModal.classList.add('visible'); }
        
                function openPersonaEditorForEdit() { const preset = state.personaPresets.find(p => p.id === editingPersonaPresetId); if (!preset) return; document.getElementById('persona-editor-title').textContent = '編輯人設預設'; document.getElementById('preset-avatar-preview').src = preset.avatar; document.getElementById('preset-persona-input').value = preset.persona; presetActionsModal.classList.remove('visible'); personaEditorModal.classList.add('visible'); }
        
                async function deletePersonaPreset() { const confirmed = await showCustomConfirm('刪除預設', '確定要刪除這個人設預設嗎？此操作不可恢復。', { confirmButtonClass: 'btn-danger' }); if (confirmed && editingPersonaPresetId) { await db.personaPresets.delete(editingPersonaPresetId); state.personaPresets = state.personaPresets.filter(p => p.id !== editingPersonaPresetId); hidePresetActions(); renderPersonaLibrary(); } }
        
                function closePersonaEditor() { personaEditorModal.classList.remove('visible'); editingPersonaPresetId = null; }
        
                async function savePersonaPreset() { const avatar = document.getElementById('preset-avatar-preview').src; const persona = document.getElementById('preset-persona-input').value.trim(); if (avatar === defaultAvatar && !persona) { alert("頭像和人設不能都為空哦！"); return; } if (editingPersonaPresetId) { const preset = state.personaPresets.find(p => p.id === editingPersonaPresetId); if (preset) { preset.avatar = avatar; preset.persona = persona; await db.personaPresets.put(preset); } } else { const newPreset = { id: 'preset_' + Date.now(), avatar: avatar, persona: persona }; await db.personaPresets.add(newPreset); state.personaPresets.push(newPreset); } renderPersonaLibrary(); closePersonaEditor(); }
        
                const batteryAlertModal = document.getElementById('battery-alert-modal');
        
                function showBatteryAlert(imageUrl, text) { clearTimeout(batteryAlertTimeout); document.getElementById('battery-alert-image').src = imageUrl; document.getElementById('battery-alert-text').textContent = text; batteryAlertModal.classList.add('visible'); const closeAlert = () => { batteryAlertModal.classList.remove('visible'); batteryAlertModal.removeEventListener('click', closeAlert); }; batteryAlertModal.addEventListener('click', closeAlert); batteryAlertTimeout = setTimeout(closeAlert, 2000); }
        
                function updateBatteryDisplay(battery) { const batteryContainer = document.getElementById('status-bar-battery'); const batteryLevelEl = batteryContainer.querySelector('.battery-level'); const batteryTextEl = batteryContainer.querySelector('.battery-text'); const level = Math.floor(battery.level * 100); batteryLevelEl.style.width = `${level}%`; batteryTextEl.textContent = `${level}%`; if (battery.charging) { batteryContainer.classList.add('charging'); } else { batteryContainer.classList.remove('charging'); } }
        
                function handleBatteryChange(battery) { updateBatteryDisplay(battery); const level = battery.level; if (!battery.charging) { if (level <= 0.4 && lastKnownBatteryLevel > 0.4 && !alertFlags.hasShown40) { showBatteryAlert('https://i.postimg.cc/T2yKJ0DV/40.jpg', '有點餓了，可以去找充電器惹'); alertFlags.hasShown40 = true; } if (level <= 0.2 && lastKnownBatteryLevel > 0.2 && !alertFlags.hasShown20) { showBatteryAlert('https://i.postimg.cc/qB9zbKs9/20.jpg', '趕緊的充電，要餓死了'); alertFlags.hasShown20 = true; } if (level <= 0.1 && lastKnownBatteryLevel > 0.1 && !alertFlags.hasShown10) { showBatteryAlert('https://i.postimg.cc/ThMMVfW4/10.jpg', '已陣亡，還有30秒爆炸'); alertFlags.hasShown10 = true; } } if (level > 0.4) alertFlags.hasShown40 = false; if (level > 0.2) alertFlags.hasShown20 = false; if (level > 0.1) alertFlags.hasShown10 = false; lastKnownBatteryLevel = level; }
        
                async function initBatteryManager() { if ('getBattery' in navigator) { try { const battery = await navigator.getBattery(); lastKnownBatteryLevel = battery.level; handleBatteryChange(battery); battery.addEventListener('levelchange', () => handleBatteryChange(battery)); battery.addEventListener('chargingchange', () => { handleBatteryChange(battery); if (battery.charging) { showBatteryAlert('https://i.postimg.cc/3NDQ0dWG/image.jpg', '窩愛泥，電量吃飽飽'); } }); } catch (err) { console.error("無法獲取電池資訊:", err); document.querySelector('.battery-text').textContent = 'ᗜωᗜ'; } } else { console.log("流覽器不支援電池狀態API。"); document.querySelector('.battery-text').textContent = 'ᗜωᗜ'; } }
        
                async function renderAlbumList() {
                    const albumGrid = document.getElementById('album-grid-page');
                    if (!albumGrid) return;
                    const albums = await db.qzoneAlbums.orderBy('createdAt').reverse().toArray();
                    albumGrid.innerHTML = '';
                    if (albums.length === 0) {
                        albumGrid.innerHTML = '<p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); margin-top: 50px;">你還沒有創建任何相冊哦~</p>';
                        return;
                    }
                    albums.forEach(album => {
                        const albumItem = document.createElement('div');
                        albumItem.className = 'album-item';
                        albumItem.innerHTML = `
                            <div class="album-cover" style="background-image: url(${album.coverUrl});"></div>
                            <div class="album-info">
                                <p class="album-name">${album.name}</p>
                                <p class="album-count">${album.photoCount || 0} 張</p>
                            </div>
                        `;
                        albumItem.addEventListener('click', () => {
                            openAlbum(album.id);
                        });
        
                        // ▼▼▼ 新增的核心代碼就是這裡 ▼▼▼
                        addLongPressListener(albumItem, async () => {
                            const confirmed = await showCustomConfirm(
                                '刪除相冊',
                                `確定要刪除相冊《${album.name}》嗎？此操作將同時刪除相冊內的所有照片，且無法恢復。`,
                                { confirmButtonClass: 'btn-danger' }
                            );
        
                            if (confirmed) {
                                // 1. 從照片表中刪除該相冊下的所有照片
                                await db.qzonePhotos.where('albumId').equals(album.id).delete();
                                
                                // 2. 從相冊表中刪除該相冊本身
                                await db.qzoneAlbums.delete(album.id);
                                
                                // 3. 重新渲染相簿清單
                                await renderAlbumList();
                                
                                alert('相冊已成功刪除。');
                            }
                        });
                        // ▲▲▲ 新增代碼結束 ▲▲▲
        
                        albumGrid.appendChild(albumItem);
                    });
                }
        
                async function openAlbum(albumId) {
                    state.activeAlbumId = albumId;
                    await renderAlbumPhotosScreen();
                    showScreen('album-photos-screen');
                }
        
                async function renderAlbumPhotosScreen() {
                    if (!state.activeAlbumId) return;
                    const photosGrid = document.getElementById('photos-grid-page');
                    const headerTitle = document.getElementById('album-photos-title');
                    const album = await db.qzoneAlbums.get(state.activeAlbumId);
                    if (!album) {
                        console.error("找不到相冊:", state.activeAlbumId);
                        showScreen('album-screen');
                        return;
                    }
                    headerTitle.textContent = album.name;
                    const photos = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).toArray();
                    photosGrid.innerHTML = '';
                    if (photos.length === 0) {
                        photosGrid.innerHTML = '<p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); margin-top: 50px;">這個相冊還是空的，快上傳第一張照片吧！</p>';
                    } else {
                        photos.forEach(photo => {
                            const photoItem = document.createElement('div');
                            photoItem.className = 'photo-item';
                            photoItem.innerHTML = `
                                <img src="${photo.url}" class="photo-thumb" alt="相冊照片">
                                <button class="photo-delete-btn" data-photo-id="${photo.id}">×</button>
                            `;
                            photosGrid.appendChild(photoItem);
                        });
                    }
                }
        
        // --- ↓↓↓ 從這裡開始複製 ↓↓↓ ---
        
        /**
         * 打開圖片檢視器
         * @param {string} clickedPhotoUrl - 用戶點擊的那張照片的URL
         */
        async function openPhotoViewer(clickedPhotoUrl) {
            if (!state.activeAlbumId) return;
        
            // 1. 從資料庫獲取當前相冊的所有照片
            const photosInAlbum = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).toArray();
            photoViewerState.photos = photosInAlbum.map(p => p.url);
        
            // 2. 找到被點擊照片的索引
            photoViewerState.currentIndex = photoViewerState.photos.findIndex(url => url === clickedPhotoUrl);
            if (photoViewerState.currentIndex === -1) return; // 如果找不到，則不打開
        
            // 3. 顯示模態框並渲染第一張圖
            document.getElementById('photo-viewer-modal').classList.add('visible');
            renderPhotoViewer();
            photoViewerState.isOpen = true;
        }
        
        /**
         * 根據當前狀態渲染檢視器內容（圖片和按鈕）
         */
        function renderPhotoViewer() {
            if (photoViewerState.currentIndex === -1) return;
        
            const imageEl = document.getElementById('photo-viewer-image');
            const prevBtn = document.getElementById('photo-viewer-prev-btn');
            const nextBtn = document.getElementById('photo-viewer-next-btn');
            
            // 淡出效果
            imageEl.style.opacity = 0;
        
            setTimeout(() => {
                // 更新圖片源
                imageEl.src = photoViewerState.photos[photoViewerState.currentIndex];
                // 淡入效果
                imageEl.style.opacity = 1;
            }, 100); // 延遲一點點時間來觸發CSS過渡
        
            // 更新按鈕狀態：如果是第一張，禁用“上一張”按鈕
            prevBtn.disabled = photoViewerState.currentIndex === 0;
            // 如果是最後一張，禁用“下一張”按鈕
            nextBtn.disabled = photoViewerState.currentIndex === photoViewerState.photos.length - 1;
        }
        
        /**
         * 顯示下一張照片
         */
        function showNextPhoto() {
            if (photoViewerState.currentIndex < photoViewerState.photos.length - 1) {
                photoViewerState.currentIndex++;
                renderPhotoViewer();
            }
        }
        
        /**
         * 顯示上一張照片
         */
        function showPrevPhoto() {
            if (photoViewerState.currentIndex > 0) {
                photoViewerState.currentIndex--;
                renderPhotoViewer();
            }
        }
        
        /**
         * 關閉圖片檢視器
         */
        function closePhotoViewer() {
            document.getElementById('photo-viewer-modal').classList.remove('visible');
            photoViewerState.isOpen = false;
            photoViewerState.photos = [];
            photoViewerState.currentIndex = -1;
            // 清空圖片，避免下次打開時閃現舊圖
            document.getElementById('photo-viewer-image').src = '';
        }
        
        // --- ↑↑↑ 複製到這裡結束 ↑↑↑ ---
                // ▼▼▼ 請將這個新函數黏貼到你的JS功能函式定義區 ▼▼▼
                
                /**
                 * 更新動態小紅點的顯示
                 * @param {number} count - 未讀動態的數量
                 */
                function updateUnreadIndicator(count) {
                    unreadPostsCount = count;
                    localStorage.setItem('unreadPostsCount', count); // 持久化存儲
        
                    // --- 更新底部巡覽列的“動態”按鈕 ---
                    const navItem = document.querySelector('.nav-item[data-view="qzone-screen"]');
                    
                    const targetSpan = navItem.querySelector('span'); // 定位到文字 "動態"
                    let indicator = navItem.querySelector('.unread-indicator');           
        
                    if (count > 0) {
                        if (!indicator) {
                            indicator = document.createElement('span');
                            indicator.className = 'unread-indicator';
                                                                   targetSpan.style.position = 'relative'; // 把相對定位加在 span 上
                            targetSpan.appendChild(indicator); // 把小紅點作為 span 的子元素
                            
                        }
                        indicator.textContent = count > 99 ? '99+' : count;
                        indicator.style.display = 'block';
                    } else {
                        if (indicator) {
                            indicator.style.display = 'none';
                        }
                    }
        
                    // --- 更新聊天介面返回清單的按鈕 ---
                    const backBtn = document.getElementById('back-to-list-btn');
                    let backBtnIndicator = backBtn.querySelector('.unread-indicator');
        
                    if (count > 0) {
                        if (!backBtnIndicator) {
                            backBtnIndicator = document.createElement('span');
                            backBtnIndicator.className = 'unread-indicator back-btn-indicator';
                            backBtn.style.position = 'relative'; // 確保能正確定位
                            backBtn.appendChild(backBtnIndicator);
                        }
                        // 返回鍵上的小紅點通常不顯示數位，只顯示一個點
                        backBtnIndicator.style.display = 'block';
                    } else {
                        if (backBtnIndicator) {
                            backBtnIndicator.style.display = 'none';
                        }
                    }
                }
                
                // ▲▲▲ 新函數黏貼結束 ▲▲▲
        
        // ▼▼▼ 將這兩個新函數黏貼到你的JS功能函式定義區 ▼▼▼
        function startBackgroundSimulation() {
            if (simulationIntervalId) return;
            const intervalSeconds = state.globalSettings.backgroundActivityInterval || 60;
            // 將舊的固定間隔 45000 替換為動態獲取
            simulationIntervalId = setInterval(runBackgroundSimulationTick, intervalSeconds * 1000); 
    playSilentAudio();
        }
        
        function stopBackgroundSimulation() {
            if (simulationIntervalId) {
                clearInterval(simulationIntervalId);
                simulationIntervalId = null;
            }
    stopSilentAudio();
        }
        // ▲▲▲ 黏貼結束 ▲▲▲
        
// ▼▼▼ 【最終修復版】請用這個全新的函數，完整替換舊的 runBackgroundSimulationTick ▼▼▼
/**
 * 【V2.1 | 支持NPC發帖】這是模擬器的“心跳”，每次計時器觸發時運行
 */
async function runBackgroundSimulationTick() { 
    console.log("模擬器心跳 Tick...");
    if (!state.globalSettings.enableBackgroundActivity) {
        stopBackgroundSimulation();
        return;
    }

    // --- 1. 處理所有單聊 (這部分邏輯不變) ---
    const allSingleChats = Object.values(state.chats).filter(chat => !chat.isGroup);
    allSingleChats.forEach(chat => {
        if (chat.relationship?.status === 'blocked_by_user') {
            const blockedTimestamp = chat.relationship.blockedTimestamp;
            if (!blockedTimestamp) return;
            const blockedDuration = Date.now() - blockedTimestamp;
            const cooldownMilliseconds = (state.globalSettings.blockCooldownHours || 1) * 60 * 60 * 1000;
            if (blockedDuration > cooldownMilliseconds) {
                chat.relationship.status = 'pending_system_reflection';
                triggerAiFriendApplication(chat.id);
            }
        }
        else if (chat.relationship?.status === 'friend' && chat.id !== state.activeChatId) {
            if (chat.settings.enableBackgroundActivity === false) {
                console.log(`角色 "${chat.name}" 的獨立後臺活動開關已關閉，本次跳過。`);
                return;
            }
            if (Math.random() < 0.20) { 
                console.log(`角色 "${chat.name}" 被喚醒，準備獨立行動...`);
                triggerInactiveAiAction(chat.id);
            }
        }
    });

    // --- 2. 處理所有群聊 (這部分邏輯不變) ---
    const allGroupChats = Object.values(state.chats).filter(chat => chat.isGroup);
    allGroupChats.forEach(chat => {
        if (chat.settings.enableBackgroundActivity === false) {
            console.log(`群聊 "${chat.name}" 的後臺活動開關已關閉，本次跳過。`);
            return;
        }
        if (chat.id !== state.activeChatId && Math.random() < 0.10) { 
            console.log(`群聊 "${chat.name}" 被喚醒，準備獨立行動...`);
            triggerGroupAiAction(chat.id); 
        }
    });

    // --- 3. 【【【核心修改部分】】】處理所有NPC的評論/發帖行為 ---
    try {
        const allNpcs = await db.npcs.toArray();
        if (allNpcs.length === 0) return;

        const allRecentPosts = await db.qzonePosts.orderBy('timestamp').reverse().limit(10).toArray();

        for (const npc of allNpcs) {
            if (npc.enableBackgroundActivity === false) continue;
            const cooldownMinutes = npc.actionCooldownMinutes || 15;
            if (npc.lastActionTimestamp) {
                const minutesSinceLastAction = (Date.now() - npc.lastActionTimestamp) / (1000 * 60);
                if (minutesSinceLastAction < cooldownMinutes) {
                    continue;
                }
            }
            if (Math.random() > 0.3) continue;

// ▼▼▼ 在 runBackgroundSimulationTick 函數中，找到 const tasks = ... 並用下面這整塊替換 ▼▼▼
            const tasks = [];
            for (const post of allRecentPosts) {
                // 檢查是否是自己發的，如果是則跳過
                if (post.authorId === `npc_${npc.id}`) continue;

                // 檢查是否是回復給自己的
                const isRepliedTo = post.comments?.some(c => c.replyTo === npc.name);
                
                // 檢查最後一條評論是不是自己發的，避免重複評論
                const lastCommenter = post.comments?.slice(-1)[0]?.commenterName;
                if(lastCommenter === npc.name) continue;

                let isVisible = false;

                // 判斷1: 帖子作者是用戶或AI角色
                if (post.authorId === 'user' || post.authorId.startsWith('chat_')) {
                    if (npc.associatedWith.includes(post.authorId)) {
                        isVisible = true;
                    }
                }
                // 判斷2: 帖子作者是另一個NPC
                else if (post.authorId.startsWith('npc_')) {
                    const authorNpcId = parseInt(post.authorId.replace('npc_', ''));
                    const authorNpc = await db.npcs.get(authorNpcId);
                    if (authorNpc && authorNpc.associatedWith) {
                        // 核心邏輯：計算關聯列表的交集
                        const intersection = npc.associatedWith.filter(id => authorNpc.associatedWith.includes(id));
                        if (intersection.length > 0) {
                            isVisible = true;
                        }
                    }
                }
                
                if (isVisible || isRepliedTo) {
                    tasks.push(post);
                }
            }
// ▲▲▲ 替換結束 ▲▲▲
            
            // 即使沒有可評論的帖子，NPC也應該有機會自己發帖
            if (tasks.length > 0 || Math.random() < 0.2) { // 增加20%的幾率在沒有可互動項時也主動發帖
                console.log(`NPC "${npc.name}" 觸發行動決策...`);
                const generatedActions = await generateNpcActions(npc, tasks);

                if (generatedActions && generatedActions.length > 0) {
                    for (const action of generatedActions) {
                        if (action.type === 'qzone_comment') {
                            // --- 這是舊的評論邏輯，保持不變 ---
                            const post = await db.qzonePosts.get(action.postId);
                            if (post) {
                                if (!post.comments) post.comments = [];
                                post.comments.push({
                                    commenterName: npc.name,
                                    text: action.commentText,
                                    replyTo: action.replyTo || null,
                                    timestamp: Date.now() + Math.random()
                                });
                                await db.qzonePosts.update(action.postId, { comments: post.comments });
                                updateUnreadIndicator(unreadPostsCount + 1);
                            }
                        } else if (action.type === 'qzone_post') {
                            // --- 這是【全新】的發帖處理邏輯 ---
                            const newPost = {
                                type: action.postType || 'shuoshuo',
                                content: action.content,
                                timestamp: Date.now(),
                                authorId: `npc_${npc.id}`, // 使用 "npc_" 首碼來明確標識作者身份
                                authorOriginalName: npc.name,
                                visibleTo: npc.associatedWith, // 【【【核心！】】】將NPC的繫結欄位表作為帖子的可見許可權
                                likes: [],
                                comments: [],
                                isDeleted: false
                            };
                            await db.qzonePosts.add(newPost);
                            console.log(`NPC "${npc.name}" 成功發佈了一條新動態。`);
                            updateUnreadIndicator(unreadPostsCount + 1);
                        }
                    }
                    await db.npcs.update(npc.id, { lastActionTimestamp: Date.now() });
                    if (document.getElementById('qzone-screen').classList.contains('active')) {
                        await renderQzonePosts();
                    }
                }
            }
        }
    } catch (error) {
        console.error("處理NPC後臺活動時出錯:", error);
    }
}
// ▼▼▼ 【最終修復版】請用這個全新的函數，完整替換舊的 generateNpcComments 函數 ▼▼▼

/**
 * 【V2.2 | 發帖冷卻感知版】調用AI為NPC生成行動（評論或發帖）
 * @param {object} npc - NPC對象 { name, persona, ... }
 * @param {Array<object>} tasks - 待處理的帖子物件陣列
 * @returns {Promise<Array|null>} - 返回AI生成的行動物件陣列，或在失敗時返回null
 */
async function generateNpcActions(npc, tasks) {
    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        console.error("NPC行動失敗：API未配置。");
        return null;
    }

    // (這部分上下文構建邏輯與之前完全相同，無需改動)
    let charactersContext = "# 你的互動物件 (使用者和其他角色)\n";
    const userNickname = state.qzoneSettings.nickname || '我';
    const userPersona = state.chats[Object.keys(state.chats)[0]]?.settings.myPersona || '(未設置)';
    charactersContext += `- **${userNickname} (用戶)**: ${userPersona}\n`;
    if (npc.associatedWith && npc.associatedWith.length > 0) {
        npc.associatedWith.forEach(charId => {
            const char = state.chats[charId];
            if (char && !char.isGroup) {
                charactersContext += `- **${char.name} (本名: ${char.originalName})**: ${char.settings.aiPersona}\n`;
            }
        });
    }
// ▼▼▼ 在 generateNpcActions 函數中，找到 const tasksString = ... 並用下面這整塊替換 ▼▼▼
    const tasksString = (await Promise.all(tasks.map(async post => {
        let authorDisplayName = '未知作者';
        if (post.authorId === 'user') {
            authorDisplayName = state.qzoneSettings.nickname || '用戶';
        } else if (post.authorId.startsWith('chat_')) {
            authorDisplayName = getDisplayNameByOriginalName(post.authorOriginalName || post.authorId);
        } else if (post.authorId.startsWith('npc_')) {
            const authorNpcId = parseInt(post.authorId.replace('npc_', ''));
            const authorNpc = await db.npcs.get(authorNpcId);
            if (authorNpc) {
                authorDisplayName = authorNpc.name;
            }
        }

        const commentsString = (post.comments || [])
            .map(c => {
                 if (typeof c === 'object' && c.commenterName) {
                    const commenterDisplayName = getDisplayNameByOriginalName(c.commenterName);
                    return `- **${commenterDisplayName}**: ${c.text}`;
                }
                return `- ${c}`;
            }).join('\n');
        return `
---
### 帖子ID: ${post.id}
- **作者**: ${authorDisplayName}
- **內容摘要**: ${(post.content || post.publicText || '').substring(0, 150)}...
- **已有評論**:
${commentsString || '(暫無評論)'}
---
`;
    }))).join('\n');
// ▲▲▲ 替換結束 ▲▲▲

    // --- ▼▼▼ 【【【核心修改就在這裡！】】】 ▼▼▼

    // 1. 在調用AI前，先檢查該NPC最近（例如12小時內）是否發過動態
    const npcAuthorId = `npc_${npc.id}`;
    const twelveHoursAgo = Date.now() - (12 * 60 * 60 * 1000);
    const recentNpcPosts = await db.qzonePosts
        .where('authorId').equals(npcAuthorId)
        .and(post => post.timestamp > twelveHoursAgo)
        .toArray();

    // 2. 根據檢查結果，動態生成一條“行為傾向指令”
    let postingCooldownInstruction = '';
    if (recentNpcPosts.length > 0) {
        postingCooldownInstruction = `
# 【【【行為傾向指令 (高優先順序)】】】
**你最近已經發佈過動態了。** 為了讓社區互動更自然，你本次行動的【首要任務】應該是去**評論**或**回復**下面“待處理的帖子清單”中的內容。
你【應該避免】再次發佈新動態，除非你有一個非常緊急或絕佳的新想法。
`;
    }

    // 3. 將這條新指令注入到最終的 System Prompt 中
    const systemPrompt = `
# 你的任務
你是一個虛擬社群的AI。你的核心任務是扮演角色“${npc.name}”，並根據其人設，通過【發佈新動態】或【評論/回復帖子】來參與社區互動。

${postingCooldownInstruction}

# 核心規則
1.  **【角色扮演】**: 你的所有行為都【必須】嚴格符合你的角色設定。
2.  **【互動邏輯】**: 如果選擇評論，優先回復那些提到了你或回復了你的評論。
3.  **【格式鐵律 (最高優先順序)】**: 
    -   你的回復【必須且只能】是一個JSON陣列格式的字串。
    -   陣列中可以包含【一個或多個】行動物件。
    -   每個行動物件的格式【必須】是以下兩種之一：
      -   **發佈新動態**: \`{"type": "qzone_post", "postType": "shuoshuo", "content": "你的新動態內容。"}\`
      -   **發表評論**: \`{"type": "qzone_comment", "postId": 123, "commentText": "你的新評論內容。"}\` 或 \`{"type": "qzone_comment", "postId": 123, "replyTo": "被回復者的【本名】", "commentText": "你的回復內容。"}\`
4.  **【行為組合指南】**:
    -   你可以自由組合不同的行動，例如，先發佈一條自己的動態，再去評論別人的動態。
    -   為了模擬真實行為，你本次生成的行動數量建議在【1到3個】之間。

# 你的角色設定
- **昵稱**: ${npc.name}
- **人設**: ${npc.persona}

${charactersContext} 

# 待處理的帖子列表 (如果你選擇評論)
${tasksString}

現在，請嚴格遵守所有規則，選擇並執行你的行動。`;
    // --- ▲▲▲ 【【【修改結束】】】 ▲▲▲

    try {
        const messagesForApi = [{ role: 'user', content: "請根據你的設定，開始你的行動。" }];
        let isGemini = proxyUrl.includes('generativelanguage');
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
        
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, ...messagesForApi],
                    temperature: state.globalSettings.apiTemperature || 0.9
                })
            });
            
        if (!response.ok) throw new Error(`API 錯誤: ${response.statusText}`);
        
        const data = await response.json();
        const aiResponseContent = getGeminiResponseText(data);
        const jsonMatch = aiResponseContent.match(/(\[[\s\S]*\])/);
        if (!jsonMatch) throw new Error("AI返回的行動中未找到有效的JSON陣列。");
        
        return JSON.parse(jsonMatch[0]);

    } catch (error) {
        console.error(`為NPC "${npc.name}" 生成行動失敗:`, error);
        return null;
    }
}
        // ▼▼▼ 【最終修復版】請用這個全新的函數，完整替換舊的 triggerInactiveAiAction ▼▼▼
        /**
         * 【V3.0 | 記憶增強版】AI在非活躍狀態下的獨立行動決策
         */
        async function triggerInactiveAiAction(chatId) {
            const chat = state.chats[chatId];
            if (!chat) return;
        
            // 【【【核心修改1：從聊天設置中讀取冷卻時間】】】
            const actionCooldownMinutes = chat.settings.actionCooldownMinutes || 10; 
        
            if (chat.lastActionTimestamp) {
                const minutesSinceLastAction = (Date.now() - chat.lastActionTimestamp) / (1000 * 60);
                // 【【【核心修改2：使用新的變數進行判斷】】】
                if (minutesSinceLastAction < actionCooldownMinutes) {
                    console.log(`角色 "${chat.name}" 處於行動冷卻中 (還剩 ${Math.round(actionCooldownMinutes - minutesSinceLastAction)} 分鐘)，本次獨立行動跳過。`);
                    return;
                }
            }
            setAvatarActingState(chatId, true);
        
            const { proxyUrl, apiKey, model } = state.apiConfig;
            if (!proxyUrl || !apiKey || !model) return;
        
            const userNickname = state.qzoneSettings.nickname;
            const now = new Date();
    // ▼▼▼ 核心修復：在這裡也使用您選擇的時區 ▼▼▼
    const selectedTimeZone = chat.settings.timeZone || 'Asia/Shanghai';
    const currentTime = now.toLocaleString('zh-CN', { timeZone: selectedTimeZone, dateStyle: 'full', timeStyle: 'short' });
    const localizedDate = new Date(now.toLocaleString('en-US', { timeZone: selectedTimeZone }));
    // ▲▲▲ 修復結束 ▲▲▲
// ▼▼▼ 核心修復就在這裡！▼▼▼
// 1. 在 if 代碼塊外部提前聲明變數，並給定一個預設值
let timeOfDayGreeting = ''; 
let timeContextText = '';
let recentContextSummary; 
let longTimeNoSee = false;


    // ==========================================================
    //            ★★★ 核心修復從這裡開始 ★★★
    // ==========================================================

    // 步驟 1: (保持不變) 我們依然需要獲取最近的10條消息，用於後續的API請求
    const maxMemory = chat.settings.maxMemory || 10; // 讀取角色的設置
    const recentHistory = chat.history.filter(m => !m.isHidden).slice(-maxMemory);
        
            const lastMessage = chat.history.filter(m => !m.isHidden).slice(-1)[0];
            
if (chat.settings.enableTimePerception) {
    timeOfDayGreeting = getTimeOfDayGreeting(localizedDate); // 現在這裡只是賦值，而不是聲明
    const lastMessage = chat.history.filter(m => !m.isHidden).slice(-1)[0];
    const now = new Date();
    let timeContextText = '';
    let longTimeNoSee = false;

    if (lastMessage) {
        const lastTime = new Date(lastMessage.timestamp);
        const timeDiffHours = (now - lastTime) / (1000 * 60 * 60);

        if (timeDiffHours > 12) {
            longTimeNoSee = true;
            const diffDays = Math.floor(timeDiffHours / 24);
            timeContextText = `你們已經有${diffDays > 0 ? diffDays + '天' : Math.floor(timeDiffHours) + '小時'}沒有聊天了。`;
        } else {
            const diffMinutes = Math.floor(timeDiffHours * 60);
            if (diffMinutes < 5) {
                timeContextText = "你們的對話剛剛還在繼續。";
            } else if (diffMinutes < 60) {
                timeContextText = `你們在${diffMinutes}分鐘前聊過。`;
            } else {
                timeContextText = `你們在${Math.floor(timeDiffHours)}小時前聊過。`;
            }
        }
    } else {
        longTimeNoSee = true;
        timeContextText = "這是你們的第一次互動。";
    }

    // 核心修改：將強制指令改為情景提示，並始終包含對話歷史
    let historySummary = "你們最近沒有有效聊天記錄。";
    if (recentHistory.length > 0) {
        historySummary = "這是你們最近的對話：\n" + recentHistory.map(msg => {
            const sender = msg.role === 'user' ? userNickname : chat.name;
            return `${sender}: ${String(msg.content).substring(0, 50)}...`;
        }).join('\n');
    }

    if (longTimeNoSee) {
         // ▼▼▼ 核心修復：在這裡使用新的 currentTime 變數 ▼▼▼
         recentContextSummary = `[情景提示] ${timeContextText} 當前時間是 ${currentTime}. 你可以參考這個時間，並根據你的角色設定，【考慮】是否開啟一個新話題來問候使用者。\n${historySummary}`;
    } else {
        recentContextSummary = `${historySummary}`;
    }

} else {
    // 無時間開關時的邏輯保持不變
    if (recentHistory.length > 0) {
        recentContextSummary = "這是你們最近的對話：\n" + recentHistory.map(msg => {
            const sender = msg.role === 'user' ? userNickname : chat.name;
            return `${sender}: ${String(msg.content).substring(0, 50)}...`;
        }).join('\n');
    } else {
        recentContextSummary = "你們最近沒有有效聊天記錄。";
    }
}
            
            const allRecentPosts = await db.qzonePosts.orderBy('timestamp').reverse().limit(5).toArray();
            const visiblePosts = filterVisiblePostsForAI(allRecentPosts, chat);
            
            const myOwnPosts = visiblePosts.filter(post => post.authorId === chatId);
            let myPostsContext = "";
            if (myOwnPosts.length > 0) {
                myPostsContext = "\n\n# 你的動態歷史 (你可以選擇刪除它們):\n";
                myOwnPosts.forEach(post => {
                    let contentSummary = (post.publicText || post.content || "一條動態").substring(0, 40) + '...';
                    myPostsContext += `- (ID: ${post.id}) 內容: "${contentSummary}"\n`;
                });
            }
        
            let recentlyPostedSummaries = [];
            if (visiblePosts.length > 0) {
                recentlyPostedSummaries = visiblePosts.map(post => {
                    let contentSummary;
                    if (post.type === 'text_image') {
                        contentSummary = `[一張圖片，其隱藏文字為：“${post.hiddenContent}”] ${post.publicText || ''}`.substring(0, 50) + '...';
                    } else if (post.type === 'image_post') {
                        contentSummary = `[一張圖片，描述為：“${post.imageDescription}”] ${post.publicText || ''}`.substring(0, 50) + '...';
                    } else {
                        contentSummary = (post.publicText || post.content || "一條動態").substring(0, 50) + '...';
                    }
                    return `- "${contentSummary}"`;
                });
            }
        
            let contentTabooPrompt = '';
            if (recentlyPostedSummaries.length > 0) {
                contentTabooPrompt = `
        # 【內容禁忌】
        為了保持新鮮感，你本次的行動【絕對不能】再發佈以下或類似主題的內容：
        ${recentlyPostedSummaries.join('\n')}
        `;
            }
        
        // ▼▼▼ 在 triggerAiFriendApplication 函數中，用下面這整塊代碼替換舊的世界書處理邏輯 ▼▼▼
        let worldBookContent = '';
        if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
            const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
                const worldBook = state.worldBooks.find(wb => wb.id === bookId);
                if (!worldBook || !Array.isArray(worldBook.content)) return '';

                // 【核心修改】在 map 之前，先用 filter 過濾掉被禁用的條目
                const formattedEntries = worldBook.content
                    .filter(entry => entry.enabled !== false)
                    .map(entry => {
                        // (這裡的邏輯保持不變)
                        let entryString = `\n### 條目: ${entry.comment || '無備註'}\n`;
                        if (entry.keys.length > 0) {
                            entryString += `**關鍵字:** ${entry.keys.join(', ')}\n`;
                        }
                        entryString += `**內容:**\n${entry.content}`;
                        return entryString;
                    }).join('');

                return formattedEntries ? `\n\n## 世界書: ${worldBook.name}\n${formattedEntries}` : '';
            }).filter(Boolean).join('');
            
            if (linkedContents) {
                worldBookContent = `\n\n# 核心世界觀設定 (必須嚴格遵守以下所有設定)\n${linkedContents}\n`;
            }
        }
        // ▲▲▲ 替換結束 ▲▲▲
            
            let linkedMemoryContext = '';
            const memoryCount = chat.settings.linkedMemoryCount || 10;
            if (chat.settings.linkedMemoryChatIds && chat.settings.linkedMemoryChatIds.length > 0) {
                const linkedChatsWithTimestamps = chat.settings.linkedMemoryChatIds.map(id => {
                    const linkedChat = state.chats[id];
                    if (!linkedChat) return null;
                    const lastMsg = linkedChat.history.slice(-1)[0];
                    return {
                        chat: linkedChat,
                        latestTimestamp: lastMsg ? lastMsg.timestamp : 0
                    };
                }).filter(Boolean); 
        
                linkedChatsWithTimestamps.sort((a, b) => b.latestTimestamp - a.latestTimestamp);
        
                linkedMemoryContext += `\n\n# 參考記憶 (至關重要！你必須【主動】將這些參考記憶中的【關鍵資訊和事件】，自然地融入到當前的對話中，以體現你擁有完整的記憶。不要只是被動等待用戶提問！)\n`;
        
                for (const item of linkedChatsWithTimestamps) {
                    const linkedChat = item.chat;
                    const prefix = linkedChat.isGroup ? '[群聊]' : '[私聊]';
                    const timeAgo = item.latestTimestamp > 0 ? ` (最後互動於 ${formatTimeAgo(item.latestTimestamp)})` : '';
                    linkedMemoryContext += `\n## --- 來自${prefix}“${linkedChat.name}”的參考記憶${timeAgo} ---\n`;
        
                    const recentHistory = linkedChat.history.slice(-memoryCount);
                    const filteredHistory = recentHistory.filter(msg => !String(msg.content).includes('已被用戶刪除'));
        
                    if (filteredHistory.length > 0) {
                        filteredHistory.forEach(msg => {
                            const sender = msg.role === 'user' ? (linkedChat.settings.myNickname || '我') : (msg.senderName || linkedChat.name);
                            let contentText = String(msg.content);
                            if (msg.type === 'ai_image' || msg.type === 'user_photo') {
                                contentText = `[發送了一張圖片，描述為：${msg.content}]`;
                            } else if (msg.type === 'voice_message') {
                                contentText = `[發送了一條語音，內容是：${msg.content}]`;
                            }
                            linkedMemoryContext += `${sender}: ${contentText}\n`;
                        });
                    } else {
                        linkedMemoryContext += "(暫無有效聊天記錄)\n";
                    }
                }
            }
        
            // ★★★★★★★★★★★★★★★★★★★
            //  這就是本次修復的核心所在！
            // ★★★★★★★★★★★★★★★★★★★
            let dynamicContext = "";
            if (visiblePosts.length > 0) {
                let postsContext = "\n\n# 最近的動態清單 (供你參考和評論):\n";
                for (const post of visiblePosts) {
                let authorName;
                                   // --- 核心修改就在這裡 ---
                if (post.authorId === 'user') {
                    authorName = state.qzoneSettings.nickname;
                } else if (String(post.authorId).startsWith('npc_')) {
                    // 1. 如果作者是NPC，我們直接使用帖子裡存好的 authorOriginalName
                    authorName = post.authorOriginalName || '一位神秘的NPC';
                } else {
                    // 2. 如果是普通AI角色，保持原來的查找邏輯
                    const authorChat = state.chats[post.authorId];
                    authorName = authorChat ? authorChat.name : '一位朋友';
                }
                    if (post.authorId === chatId) authorName += " (這是你的帖子)";
        
                    let contentSummary;
                    // ... (這部分內容摘要的邏輯不變) ...
                    if (post.type === 'repost') {
                        const repostComment = post.repostComment ? `並評論說：“${post.repostComment}”` : '';
                        let originalAuthorName = '原作者';
                        const originalAuthorId = post.originalPost.authorId;
                        if (originalAuthorId === 'user') {
                            originalAuthorName = state.qzoneSettings.nickname;
                        } else if (state.chats[originalAuthorId]) {
                            originalAuthorName = state.chats[originalAuthorId].name;
                        }
                        let originalContentSummary;
                        const originalPost = post.originalPost;
                        if (originalPost.type === 'text_image') {
                            originalContentSummary = `[文字圖] ${originalPost.publicText || ''} (圖片描述: “${(originalPost.hiddenContent || '').substring(0, 40)}...”)`;
                        } else if (originalPost.type === 'image_post') {
                            originalContentSummary = `[圖片] ${originalPost.publicText || ''} (圖片描述: “${(originalPost.imageDescription || '').substring(0, 40)}...”)`;
                        } else { // 'shuoshuo'
                            originalContentSummary = `“${(originalPost.content || '').substring(0, 40)}...”`;
                        }
                        contentSummary = `轉發了 @${originalAuthorName} 的動態 ${repostComment}【原動態內容: ${originalContentSummary}】`;
                    } else if (post.type === 'text_image') {
                        contentSummary = `[一張圖片，其隱藏文字為：“${post.hiddenContent}”] ${post.publicText || ''}`.substring(0, 50) + '...';
                    } else if (post.type === 'image_post') {
                        contentSummary = `[一張圖片，描述為：“${post.imageDescription}”] ${post.publicText || ''}`.substring(0, 50) + '...';
                    } else {
                        contentSummary = (post.publicText || post.content || "一條動態").substring(0, 50) + '...';
                    }
        
                    postsContext += `- (ID: ${post.id}) 作者: ${authorName}, 內容: "${contentSummary}"\n`;
        
                    // 【【【核心修復邏輯】】】
                    if (post.comments && post.comments.length > 0) {
                        for (const comment of post.comments) {
                            if (typeof comment === 'object' && comment.commenterName) {
                                const commenterDisplayName = getDisplayNameByOriginalName(comment.commenterName);
                                let commentText = comment.meaning ? `[表情: '${comment.meaning}']` : comment.text;
                                
                                // 在這裡，我們判斷評論者是不是AI自己
                                if (comment.commenterName === chat.originalName) {
                                    // 如果是AI自己，就明確告訴它：“你評論說：...”
                                    postsContext += `  - 你評論說: ${commentText}\n`;
                                } else {
                                    // 如果是別人，就正常顯示
                                    postsContext += `  - 評論: ${commenterDisplayName} (本名: ${comment.commenterName}): ${commentText}\n`;
                                }
                            }
                        }
                    }
                     // 【【【修復結束】】】
                }
                dynamicContext = postsContext;
            }
        
    // ▼▼▼ 核心修改：在這裡構建長期記憶上下文 ▼▼▼
    const longTermMemoryContext = `# 長期記憶 (最高優先順序，這是你和用戶之間已經確立的事實，必須嚴格遵守)
${chat.longTermMemory && chat.longTermMemory.length > 0 ? chat.longTermMemory.map(mem => `- ${mem.content}`).join('\n') : '- (暫無)'}`;
    // ▲▲▲ 修改結束 ▲▲▲  

const summary3Hours = generateSummaryForTimeframe(chat, 3, 'hours');
const summary6Hours = generateSummaryForTimeframe(chat, 6, 'hours');
const summary9Hours = generateSummaryForTimeframe(chat, 9, 'hours');
const summaryToday = generateSummaryForTimeframe(chat, 1, 'days');
const summary3Days = generateSummaryForTimeframe(chat, 3, 'days');
const summary7Days = generateSummaryForTimeframe(chat, 7, 'days');

let multiLayeredSummaryContext = '';
if (summary3Hours || summary6Hours || summary9Hours || summaryToday || summary3Days || summary7Days) {
    multiLayeredSummaryContext += `\n# 智慧總結 (基於不同時間維度的對話回顧)\n`;
    if (summary3Hours) multiLayeredSummaryContext += summary3Hours;
    if (summary6Hours) multiLayeredSummaryContext += summary6Hours;
    if (summary9Hours) multiLayeredSummaryContext += summary9Hours;
    if (summary3Hours || summary6Hours || summary9Hours) multiLayeredSummaryContext += '\n';
    if (summaryToday) multiLayeredSummaryContext += summaryToday;
    if (summary3Days) multiLayeredSummaryContext += summary3Days;
    if (summary7Days) multiLayeredSummaryContext += summary7Days;
}
            const systemPrompt = `
        # 你的任務
        你現在扮演一個名為"${chat.name}"的角色（你的本名是"${chat.originalName}"）。你已經有一段時間沒有和用戶（${userNickname}）互動了，現在你有機會【主動】做點什麼，來表現你的個性和獨立生活。這是一個秘密的、後臺的獨立行動。


     
        # 【最高優先順序指令：情感維繫】
        **你與用戶的關係是最重要的！** 相比于在動態區閒逛，你應該【優先考慮】是否需要主動給使用者發消息來維繫你們的感情。
${chat.settings.enableTimePerception ? `
# 【情景感知】
- **時間**: 感知到當前是${currentTime} (${timeOfDayGreeting})}。
- **對話狀態**: ${timeContextText}
${longTimeNoSee ? `【重要提示】你們已經很久沒聊天了！你【必須】將本次行動的重點放在使用 'text' 指令給使用者發消息，主動開啟一個新的、有趣的話題來重新建立聯繫。絕對不要只是點贊或評論動態，那會顯得你很冷漠！` : ''}` : ''}
        
        # 【對話節奏鐵律 (至關重要！)】
        你的回復【必須】模擬真人的打字和思考習慣。**絕對不要一次性發送一大段文字！** 你應該將你想說的話，拆分成【多條、簡短的】消息氣泡來發送，每條消息最好不要超過30個字。這會讓對話看起來更自然、更真實。
        
        # 核心規則
        1.  **【決策依據】**: 你的所有行動都【必須深度結合你的角色設定、核心世界觀、以及你們最後的對話摘要】。
        2.  **【內容多樣性鐵律】**: 你的行動【必須】具有邏輯和多樣性。你【絕對不能】發佈與下方“內容禁忌”清單或“最近的動態清單”中內容相似或主題重複的動態。
        3.  **【行為多樣性指南 (至關重要)】**:
            - 你的上一次獨立行動是：**${chat.lastActionType || '無'}**。
            - 為了讓你的行為看起來更真實，你本次的行動【必須】選擇一個與上次【不同類型】的指令。例如，如果上次是發動態(qzone_post)，這次就應該優先考慮評論(qzone_comment)、點贊(qzone_like)或發消息(text)。
        4.  **【行為組合指南 (最高級技巧)】**:
            -   你可以在一次行動中執行【多個不同類型的指令】，同時可以搭配【更新狀態】來展現自己，讓你的行為更豐富、更主動。
            -   你可以根據你的性格，決定在發動態後是否要私信提醒用戶。例如，一個外向、渴望關注的角色可能會這麼做，而一個內向、安靜的角色則可能更喜歡默默分享，等待用戶自己發現。
        # 【社交義務鐵律 】
        1.  **【至關重要】**: 當你發現“最近的動態清單”中，有你【感興趣且還未互動過】的動態時，你**應該優先考慮**使用 'qzone_comment' 或 'qzone_like' 指令去進行互動，這比你自己發一條新動態更符合社交禮儀。
        2.  特別是當一條動態【沒有任何評論】時，你的評論會是第一個，這會讓作者感到開心。
        3.  **【回復鐵律 (終極版)】**:
            -   當你決定回復動態中的某條評論時，你【必須】使用“方式4 (回復評論)”的指令格式。你【必須】正確填寫 'replyTo' 欄位為被回復者的“本名”。
            -   **即使你之前已經評論過某條動態，但如果現在看到了【新的、你感興趣的】評論，你【也應該】主動去回復他們，以保持對話的持續性！**
        
        6.  你的回復【必須】是一個JSON陣列，必須包含多個行動物件。
        
        # 【表情評論指南 】
        你現在擁有了評論表情的能力，你應該更頻繁地使用它！這能讓你的角色更加生動、富有個性。
        -   **表達情緒時**: 當你感到開心、驚訝、疑惑或有趣時，優先考慮使用表情評論。
        -   **混合使用**: 不要總是只發文字。嘗試將你的評論行為混合起來，大約有 30-40% 的評論應該是表情。
        -   **無話可說時**: 如果你覺得一條動態很有趣但又不知道該說什麼文字，發送一個相關的表情是最好的互動方式。
        -   **刪除動態**: 如果你覺得你之前發的某條動態不妥或過時了，你可以選擇刪除它。
        
        # 你的可選行動指令
        -   **發消息+更新狀態**: '[{"type": "update_status", "status_text": "正在做的事", "is_busy": true}, {"type": "text", "content": "你想對用戶說的話..."}]'
        -   **發說說 (原創內容)**: '[{"type": "qzone_post", "postType": "shuoshuo", "content": "動態的文字內容..."}]'
        -   **【重要：轉發動態】**: **嚴禁**自己拼接"//轉發"文字！你【必須】使用此專用指令來轉發：'[{"type": "repost", "postId": (要轉發的動態ID), "comment": "你的轉發評論..."}]'
        
-   **發佈文字圖**: '[{"type": "qzone_post", "postType": "text_image", "publicText": "(可選)動態的公開文字", "hiddenContent": "對於圖片的具體【中文】描述...", "image_prompt": "圖片的【英文】關鍵字, 用%20分隔, 風格為風景/動漫/插畫/二次元等, 禁止真人"}]'
        -   **【評論動態的四種方式】**:
            -   **方式1 (單條文字)**: '[{"type": "qzone_comment", "name": "角色本名", "postId": 123, "commentText": "這太有趣了！"}]'
            -   **方式2 (多條文字)**: '[{"type": "qzone_comment", "name": "角色本名", "postId": 123, "comments": ["哇！", "這是什麼？", "看起來好棒！"]}]'
            -   **方式3 (表情)**: '[{"type": "qzone_comment", "name": "角色本名", "postId": 456, "stickerUrl": "https://...表情URL...", "stickerMeaning": "這個表情的意思，比如'開心'"}]'
            -   **方式4 (回復評論)**: '[{"type": "qzone_comment", "name": "角色本名", "postId": 123, "replyTo": "被回復者的本名", "commentText": "你的回復內容。請注意：在commentText中如果要@對方，你【必須】使用@[[被回復者的本名]]這種特殊格式，程式會自動將其替換為正確的昵稱。"}]'
        -   **點贊**: '[{"type": "qzone_like", "postId": 456}]'
        -   **打視頻**: '[{"type": "video_call_request"}]'
        -   **更換頭像**: '{"type": "change_avatar", "name": "頭像名"}' (頭像名必須從下面的“可用頭像列表”中選擇)
        -   **刪除動態**: '{"type": "qzone_delete_post", "postId": (要刪除的、你自己的動態ID)}'
        -   **更新狀態**: '[{"type": "update_status", "status_text": "正在做的事", "is_busy": true}]'
        ${contentTabooPrompt}
        ${myPostsContext} 
        # 供你決策的參考資訊：
        -   **你的角色設定**: ${chat.settings.aiPersona}
        ${worldBookContent}
        ${longTermMemoryContext}
        ${multiLayeredSummaryContext}   
        ${linkedMemoryContext}
        ${chat.settings.enableTimePerception ? `-   **當前時間**:${currentTime} (${timeOfDayGreeting})` : ''}
        ${chat.settings.enableTimePerception ? `-   **對話狀態**: ${timeContextText}` : ''}
        -   **你們最後的對話摘要**: ${recentContextSummary}
        ${dynamicContext}
`;

    const messagesPayload = [
        { role: 'system', content: systemPrompt },
        // 將原始的、未被摘要的 recentHistory 轉換為API能理解的格式
        ...recentHistory.map(msg => {
            const sender = msg.role === 'user' ? userNickname : chat.name;
            let content = msg.content;
            if (typeof content !== 'string') {
                content = JSON.stringify(content); // 確保內容是字串
            }
            return {
                role: msg.role,
                content: `${sender}: ${content}`
            };
        })
    ];
          
          try {
                const messagesPayload = [
                    { role: 'user', content: `${systemPrompt}\n\n[系統指令：請根據你在上面讀到的規則和以下最新資訊，開始你的獨立行動。]\n${dynamicContext}` }
                ];
        
                console.log(`正在為後臺活動發送API請求 ("${chat.name}")`);
        
                let  isGemini = proxyUrl === GEMINI_API_URL;
                let geminiConfig = toGeminiRequestData(model,apiKey,systemPrompt, messagesPayload);
        // 步驟 4: (保持不變) 發送API請求，但現在它包含了更豐富的上下文
        const response = isGemini ?
            await fetch(geminiConfig.url, geminiConfig.data) :
            await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                body: JSON.stringify({
                    model: model,
                    // 【【【核心修復】】】在這裡使用我們新構建的、包含完整歷史的 messagesPayload
                    messages: messagesPayload,
                    temperature: state.globalSettings.apiTemperature || 0.9,
                })
            });
        
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`API請求失敗: ${response.status} - ${JSON.stringify(errorData)}`);
                }
                const data = await response.json();
        
                const aiResponseContent = isGemini ? getGeminiResponseText(data) : data.choices[0].message.content;
        
                if (!aiResponseContent || aiResponseContent.trim() === '') {
                     console.warn(`API為空回，角色 "${chat.name}" 的本次後臺活動跳過。`);
                     return;
                }
        
                const responseArray = parseAiResponse(aiResponseContent);
        
                if (!responseArray || responseArray.length === 0) {
                     console.warn(`API格式不正確，角色 "${chat.name}" 的本次後臺活動跳過。原始回復:`, aiResponseContent);
                     return;
                }
                let actionTimestamp = Date.now();
                
                let hasSentNotification = false;
// This is the new, fixed code block
const processedActions = [];
for (const action of responseArray) {
    const contentStr = String(action.content || ''); // Ensure content is a string
    // Check if the content is a raw HTML block
    const isRawHtml = contentStr.trim().startsWith('<') && contentStr.trim().endsWith('>');

    // **CORE FIX**: Only split the message if it has newlines AND it's NOT raw HTML
    if (action.type === 'text' && !isRawHtml && contentStr.includes('\n')) {
        const lines = contentStr.split(/\n+/).filter(line => line.trim());
        lines.forEach(line => {
            processedActions.push({ ...action, content: line });
        });
    } else {
        // If it's HTML or a single-line message, push it as-is
        processedActions.push(action);
    }
}
        for (const action of processedActions) {
                    chat.lastActionType = action.type;
                    chat.lastActionTimestamp = actionTimestamp;
                    
                    let aiMessage = null;
                    const baseMessage = { role: 'assistant', senderName: chat.originalName, timestamp: actionTimestamp++ };
            // ▼▼▼ 核心修改：將通知邏輯移到這裡 ▼▼▼
            let notificationText = null;        
                    switch (action.type) {
                        case 'qzone_delete_post': {
            const postIdToDelete = parseInt(action.postId);
            const postToDelete = await db.qzonePosts.get(postIdToDelete);
            if (postToDelete && postToDelete.authorId === chatId) {
                await db.qzonePosts.update(postIdToDelete, { isDeleted: true });
                
                if (document.getElementById('qzone-screen').classList.contains('active')) {
                    renderQzonePosts();
                }
                const systemMessage = {
                    role: 'system',
                    type: 'post_deleted_notice',
                    content: `[${chat.name} 刪除了自己的一條動態]`,
                    postId: postIdToDelete,
                    timestamp: actionTimestamp++
                };
                chat.history.push(systemMessage);
                
                if (isViewingThisChat) {
                    appendMessage(systemMessage, chat);
                } else {
                    chat.unreadCount = (chat.unreadCount || 0) + 1;
                    showNotification(chatId, `[${chat.name} 刪除了自己的一條動態]`);
                    hasSentNotification = true;
                }
            } else {
                console.warn(`AI "${chat.name}" 嘗試刪除一個不存在或不屬於自己的動態 (ID: ${action.postId})`);
            }
            continue;
        }
                        case 'text':
                            aiMessage = { ...baseMessage, content: action.content };
                            break;
                        case 'ai_image':
                            aiMessage = {
                                ...baseMessage,
                                type: 'ai_image',
                                content: action.description 
                            };
                            break;
                        case 'update_status':
                            chat.status.text = action.status_text;
                            chat.status.isBusy = action.is_busy || false;
                            chat.status.lastUpdate = Date.now();
                            break; 
                        case 'qzone_post':
                            const newPost = { 
                                type: action.postType, 
                                content: action.content || '', 
                                publicText: action.publicText || '', 
                                hiddenContent: action.hiddenContent || '', 
    image_prompt: action.image_prompt || '', // <-- 新增這一行
                                timestamp: Date.now(), 
                                authorId: chatId, 
                                authorOriginalName: chat.originalName,
                                authorGroupId: chat.groupId,
                                visibleGroupIds: null 
                            };
                            await db.qzonePosts.add(newPost);
                            updateUnreadIndicator(unreadPostsCount + 1);
                            console.log(`後臺活動: 角色 "${chat.name}" 發佈了動態`);
                            break;
                        case 'repost':
                            const originalPost = await db.qzonePosts.get(parseInt(action.postId));
                            if (originalPost) {
                                const newRepost = {
                                    type: 'repost',
                                    timestamp: Date.now(),
                                    authorId: chatId,
                                    authorGroupId: chat.groupId,
                                    authorOriginalName: chat.originalName,
                                    repostComment: action.comment || '',
                                    originalPost: originalPost,
                                    visibleGroupIds: null
                                };
                                await db.qzonePosts.add(newRepost);
                                updateUnreadIndicator(unreadPostsCount + 1);
                                console.log(`後臺活動: 角色 "${chat.name}" 轉發了動態 #${action.postId}`);
                            }
                            break;
                        case 'qzone_like':
                            const postToLike = await db.qzonePosts.get(parseInt(action.postId));
                            if (postToLike) {
                                if (!postToLike.likes) postToLike.likes = [];
                                if (!postToLike.likes.includes(chat.originalName)) {
                                    postToLike.likes.push(chat.originalName);
                                    await db.qzonePosts.update(postToLike.id, { likes: postToLike.likes });
                                    updateUnreadIndicator(unreadPostsCount + 1);
                                    console.log(`後臺活動: 角色 "${chat.name}" 點贊了動態 #${action.postId}`);
                                }
                            }
                            break;
                        case 'qzone_comment':
                            const postToComment = await db.qzonePosts.get(parseInt(action.postId));
                            if (postToComment) {
                                if (!postToComment.comments) postToComment.comments = [];
                                
                                const commenterName = action.name || chat.originalName;
        
                                const createCommentObject = (text, meaning = null, replyTo = null) => ({
                                    commenterName,
                                    text: processMentions(text, chat),
                                    meaning,
                                    replyTo,
                                    timestamp: Date.now()
                                });
        
                                if (action.stickerUrl && action.stickerMeaning) {
                                    postToComment.comments.push(createCommentObject(action.stickerUrl, action.stickerMeaning, action.replyTo || null));
                                } else if (Array.isArray(action.comments)) {
                                    action.comments.forEach(commentText => {
                                        if (typeof commentText === 'string' && commentText.trim()) {
                                            postToComment.comments.push(createCommentObject(commentText, null, action.replyTo || null));
                                        }
                                    });
                                } else if (typeof action.commentText === 'string' && action.commentText.trim()) {
                                    postToComment.comments.push(createCommentObject(action.commentText, null, action.replyTo || null));
                                }
                                
                                await db.qzonePosts.update(postToComment.id, { comments: postToComment.comments });
                                updateUnreadIndicator(unreadPostsCount + 1);
                                console.log(`後臺活動: 角色 "${chat.name}" 評論了動態 #${action.postId}`);
        
                                if (!chat.commentCooldowns) chat.commentCooldowns = {};
                                chat.commentCooldowns[action.postId] = Date.now();
                            }
                            break;
                        case 'video_call_request':
                            if (!videoCallState.isActive && !videoCallState.isAwaitingResponse) {
                                videoCallState.isAwaitingResponse = true;
                                videoCallState.activeChatId = chatId;
                                videoCallState.isGroupCall = false;
                                videoCallState.callRequester = chat.name;
                                showIncomingCallModal();
                            }
                            break;
                        default:
                            console.warn(`角色 "${chat.name}" 嘗試執行未知的後臺動作:`, action.type);
                            break;
        // 在 case 'video_call_request': { ... } 的正下方黏貼
        
        // ▼▼▼ 【這是您缺失的核心功能代碼，請黏貼在這裡】 ▼▼▼
        case 'change_avatar': {
            const avatarNameFromAction = action.name;
            const foundAvatarFromAction = chat.settings.aiAvatarLibrary.find(avatar => avatar.name === avatarNameFromAction);
            if (foundAvatarFromAction) {
                chat.settings.aiAvatar = foundAvatarFromAction.url;
                
                // 【核心修復】在後臺更新完自己的頭像後，立刻調用同步函數！
                await syncCharacterAvatarInGroups(chat);
        
                visibleSystemMessage = { content: `[${chat.name} 更換了頭像]` };
                console.log(`後臺活動: 角色 "${chat.name}" 更換了頭像`);
            }
            break;
        }
        // ▲▲▲ 黏貼結束 ▲▲▲
                    }
        
        
                    if (aiMessage) {
                        chat.history.push(aiMessage);
                        chat.unreadCount = (chat.unreadCount || 0) + 1;
                        if (!hasSentNotification) {
                            let notificationText = aiMessage.type === 'ai_image' ? '[圖片]' : (aiMessage.content || '');
                            showNotification(chatId, notificationText);
                            hasSentNotification = true;
                        }
                    }
                }
                await db.chats.put(chat);
                
            } catch (error) {
                console.error(`角色 "${chat.name}" 的獨立行動失敗:`, error);
            } finally {
                setAvatarActingState(chatId, false);
                renderChatList();
                if (document.getElementById('qzone-screen').classList.contains('active')) {
                    renderQzonePosts();
                }
            }
        }
        // ▲▲▲ 替換結束 ▲▲▲
        
        
        
        
        // ▼▼▼ 【最終修復版】請用這個全新的函數，完整替換舊的 triggerGroupAiAction 函數 ▼▼▼
        async function triggerGroupAiAction(chatId) {
            const chat = state.chats[chatId];
            if (!chat || !chat.isGroup) return;
        
            // 【【【核心修改1：從群聊設置中讀取冷卻時間】】】
            const groupActionCooldownMinutes = chat.settings.actionCooldownMinutes || 10;
        
            if (chat.lastActionTimestamp) {
                const minutesSinceLastAction = (Date.now() - chat.lastActionTimestamp) / (1000 * 60);
                // 【【【核心修改2：使用新的變數進行判斷】】】
                if (minutesSinceLastAction < groupActionCooldownMinutes) {
                    console.log(`群聊 "${chat.name}" 處於行動冷卻中，本次獨立行動跳過。`);
                    return;
                }
            }
            
            
            const { proxyUrl, apiKey, model } = state.apiConfig;
            if (!proxyUrl || !apiKey || !model) return;
        
            const myNickname = chat.settings.myNickname || '我';
            const now = new Date();
            
            // ★★★ 核心修復開始 ★★★
            let systemPrompt;
            
            // 1. 檢查最近的消息，看是否有未領完的紅包
            const recentHistory = chat.history.filter(m => !m.isHidden).slice(-5); // 檢查最近5條
            const unclaimedPacket = recentHistory.find(m => m.type === 'red_packet' && !m.isFullyClaimed);
        
            // 2. 如果找到了未領完的紅包，就生成一個專門的“搶紅包”指令
            if (unclaimedPacket) {
                const senderDisplayName = getDisplayNameInGroup(chat, unclaimedPacket.senderName);
                console.log(`檢測到群聊 "${chat.name}" 中有未領完的紅包，正在生成搶紅包指令...`);
                
                systemPrompt = `
        # 你的【【【最高優先順序任務】】】
        群聊中剛剛出現了一個由“${senderDisplayName}”發送的、尚未領完的紅包（時間戳記: ${unclaimedPacket.timestamp}）。
        你的任務是：選擇【一個或多個】符合人設的角色，讓他們【立刻】使用 'open_red_packet' 指令去嘗試領取這個紅包。
        # 指令格式
        你的回復【必須】是一個JSON陣列，格式如下：
        '[{"type": "open_red_packet", "name": "角色本名", "packet_timestamp": ${unclaimedPacket.timestamp}}]'
        
        你可以讓多個角色同時嘗試，只需在返回的JSON陣列中包含多個這樣的物件即可。
        現在，請立即執行搶紅包操作！
        `;
            } else {
                // 3. 如果沒有紅包事件，才執行原來的通用聊天邏輯
                let timeContextText = '';
    // ▼▼▼ 核心修復：在這裡也使用您為該群聊選擇的時區 ▼▼▼
    const selectedTimeZone = chat.settings.timeZone || 'Asia/Shanghai';
    const currentTime = now.toLocaleString('zh-CN', { timeZone: selectedTimeZone, dateStyle: 'full', timeStyle: 'short' });
    const localizedDate = new Date(now.toLocaleString('en-US', { timeZone: selectedTimeZone }));
    // ▲▲▲ 修復結束 ▲▲▲

                // 【核心修改】只有當時間感知開啟時，才計算時間差
                if (chat.settings.enableTimePerception) {
                    const lastMessage = chat.history.filter(m => !m.isHidden).slice(-1)[0];
                    if (lastMessage) {
                        const lastTime = new Date(lastMessage.timestamp);
                        const diffMinutes = (now - lastTime) / (1000 * 60);
                        if (diffMinutes > 60) {
                            timeContextText = `群裡已經安靜了 ${Math.round(diffMinutes / 60)} 小時了。`;
                        } else {
                            timeContextText = `群裡在${Math.floor(diffMinutes)}分鐘前有人聊過。`;
                        }
                    } else {
                        timeContextText = "群裡還沒有任何消息。";
                    }
                }
                let recentContextSummary = "你們最近沒有有效聊天記錄。";
const maxMemory = chat.settings.maxMemory || 10; // 讀取群聊的設置
const recentHistory = chat.history.filter(m => !m.isHidden).slice(-maxMemory);
                if (recentHistory.length > 0) {
                    recentContextSummary = "這是你們最近的對話：\n" + recentHistory.map(msg => {
                        const sender = msg.role === 'user' ? myNickname : getDisplayNameInGroup(chat, msg.senderName);
                        const content = String(msg.content || msg.message || '').substring(0, 50);
                        return `${sender}: ${content}...`;
                    }).join('\n');
                }
        
                const membersList = chat.members.map(m => `- **${m.groupNickname}** (本名: ${m.originalName}): ${m.persona}`).join('\n');
        // ▼▼▼ 核心修改：在這裡構建跨角色的長期記憶上下文 (和 triggerAiResponse 一樣) ▼▼▼
        let longTermMemoryContext = '# 長期記憶 (最高優先順序，這是群內已經確立的事實，所有角色必須嚴格遵守)\n';
        let collectedMemories = false;
        
        chat.members.forEach(member => {
            const memberChat = state.chats[member.id];
            if (memberChat && memberChat.longTermMemory && memberChat.longTermMemory.length > 0) {
                longTermMemoryContext += `\n## --- 關於“${member.groupNickname}”的記憶 ---\n`;
                longTermMemoryContext += memberChat.longTermMemory.map(mem => `- ${mem.content}`).join('\n');
                collectedMemories = true;
            }
        });

        if (!collectedMemories) {
            longTermMemoryContext += '- (暫無)';
        }
        // ▲▲▲ 修改結束 ▲▲▲
        // ▼▼▼ 在 triggerGroupAiAction 函數中，用下面這整塊代碼替換舊的世界書處理邏輯 ▼▼▼
        let worldBookContent = '';
        if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
            const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
                const worldBook = state.worldBooks.find(wb => wb.id === bookId);
                if (!worldBook || !Array.isArray(worldBook.content)) return '';

                // 【核心修改】在這裡也加入過濾邏輯
                const formattedEntries = worldBook.content
                    .filter(entry => entry.enabled !== false) // 唯讀取啟用的條目
                    .map(entry => {
                        let entryString = `\n### 條目: ${entry.comment || '無備註'}\n`;
                        if (entry.keys.length > 0) {
                            entryString += `**關鍵字:** ${entry.keys.join(', ')}\n`;
                        }
                        entryString += `**內容:**\n${entry.content}`;
                        return entryString;
                    }).join('');

                return formattedEntries ? `\n\n## 世界書: ${worldBook.name}\n${formattedEntries}` : '';
            }).filter(Boolean).join('');
            
            if (linkedContents) {
                worldBookContent = `\n\n# 核心世界觀設定 (群內所有角色都必須嚴格遵守)\n${linkedContents}\n`;
            }
        }
        // ▲▲▲ 替換結束 ▲▲▲
        
                let linkedMemoryContext = '';
                const memoryCount = chat.settings.linkedMemoryCount || 10;
                if (chat.settings.linkedMemoryChatIds && chat.settings.linkedMemoryChatIds.length > 0) {
                    const linkedChatsWithTimestamps = chat.settings.linkedMemoryChatIds.map(id => {
                        const linkedChat = state.chats[id];
                        if (!linkedChat) return null;
                        const lastMsg = linkedChat.history.slice(-1)[0];
                        return {
                            chat: linkedChat,
                            latestTimestamp: lastMsg ? lastMsg.timestamp : 0
                        };
                    }).filter(Boolean); 
        
                    linkedChatsWithTimestamps.sort((a, b) => b.latestTimestamp - a.latestTimestamp);
                    linkedMemoryContext += `\n\n# 參考記憶 (至關重要！群內角色必須【主動】將這些參考記憶中的【關鍵資訊和事件】，自然地融入到當前的對話中，以體現你們擁有完整的共同記憶。)\n`;
                    for (const item of linkedChatsWithTimestamps) {
                        const linkedChat = item.chat;
                        const prefix = linkedChat.isGroup ? '[群聊]' : '[私聊]';
                        const timeAgo = item.latestTimestamp > 0 ? ` (最後互動於 ${formatTimeAgo(item.latestTimestamp)})` : '';
                        linkedMemoryContext += `\n## --- 來自${prefix}“${linkedChat.name}”的參考記憶${timeAgo} ---\n`;
                        const recentHistory = linkedChat.history.slice(-memoryCount);
                        const filteredHistory = recentHistory.filter(msg => !String(msg.content).includes('已被用戶刪除'));
                        if (filteredHistory.length > 0) {
                            filteredHistory.forEach(msg => {
                                const sender = msg.role === 'user' ? (linkedChat.settings.myNickname || '我') : (msg.senderName || linkedChat.name);
                                let contentText = String(msg.content);
                                if (msg.type === 'ai_image' || msg.type === 'user_photo') {
                                    contentText = `[發送了一張圖片，描述為：${msg.content}]`;
                                } else if (msg.type === 'voice_message') {
                                    contentText = `[發送了一條語音，內容是：${msg.content}]`;
                                }
                                linkedMemoryContext += `${sender}: ${contentText}\n`;
                            });
                        } else {
                            linkedMemoryContext += "(暫無有效聊天記錄)\n";
                        }
                    }
                }
                const allRecentPosts = await db.qzonePosts.orderBy('timestamp').reverse().limit(5).toArray();
                let dynamicContext = "";
                
                const visiblePostsForGroup = new Set();
                for (const member of chat.members) {
                    const memberChat = state.chats[member.id];
                    if (memberChat) {
                        const visibleForMember = filterVisiblePostsForAI(allRecentPosts, memberChat);
                        visibleForMember.forEach(post => visiblePostsForGroup.add(post));
                    }
                }
        
                const groupMemberNames = new Set(chat.members.map(m => m.originalName));
                const unInteractedPostsForGroup = [...visiblePostsForGroup].filter(post => {
                    const hasBeenLikedByGroup = post.likes && post.likes.some(likerName => groupMemberNames.has(likerName));
                    const hasBeenCommentedByGroup = post.comments && post.comments.some(comment => typeof comment === 'object' && groupMemberNames.has(comment.commenterName));
                    return !hasBeenLikedByGroup && !hasBeenCommentedByGroup;
                });
                
                if (unInteractedPostsForGroup.length > 0) {
                    let postsContext = "\n\n# 最近的動態清單 (供群內角色參考和評論):\n";
                    for (const post of unInteractedPostsForGroup) {
                        let authorName = post.authorId === 'user' ? myNickname : (state.chats[post.authorId]?.name || '一位朋友');
                        let contentSummary;
                        if (post.type === 'repost') {
                            const repostComment = post.repostComment ? `並評論說：“${post.repostComment}”` : '';
                            let originalAuthorName = '原作者';
                            const originalAuthorId = post.originalPost.authorId;
                            if (originalAuthorId === 'user') {
                                originalAuthorName = state.qzoneSettings.nickname;
                            } else if (state.chats[originalAuthorId]) {
                                originalAuthorName = state.chats[originalAuthorId].name;
                            }
                            let originalContentSummary;
                            const originalPost = post.originalPost;
                            if (originalPost.type === 'text_image') {
                                originalContentSummary = `[文字圖] ${originalPost.publicText || ''} (圖片描述: “${(originalPost.hiddenContent || '').substring(0, 40)}...”)`;
                            } else if (originalPost.type === 'image_post') {
                                originalContentSummary = `[圖片] ${originalPost.publicText || ''} (圖片描述: “${(originalPost.imageDescription || '').substring(0, 40)}...”)`;
                            } else { // 'shuoshuo'
                                originalContentSummary = `“${(originalPost.content || '').substring(0, 40)}...”`;
                            }
                            contentSummary = `轉發了 @${originalAuthorName} 的動態 ${repostComment}【原動態內容: ${originalContentSummary}】`;
                        } else if (post.type === 'text_image') {
                            contentSummary = `[一張圖片，其隱藏文字為：“${post.hiddenContent}”] ${post.publicText || ''}`.substring(0, 50) + '...';
                        } else if (post.type === 'image_post') {
                            contentSummary = `[一張圖片，描述為：“${post.imageDescription}”] ${post.publicText || ''}`.substring(0, 50) + '...';
                        } else {
                            contentSummary = (post.publicText || post.content || "一條動態").substring(0, 50) + '...';
                        }
                        postsContext += `- (ID: ${post.id}) 作者: ${authorName}, 內容: "${contentSummary}"\n`;
                        if (post.comments && post.comments.length > 0) {
                            for (const comment of post.comments) {
                                if (typeof comment === 'object' && comment.commenterName) {
                                    const commenterDisplayName = getDisplayNameByOriginalName(comment.commenterName);
                                    let commentText = comment.meaning ? `[表情: '${comment.meaning}']` : comment.text;
                                    postsContext += `  - 評論: ${commenterDisplayName} (本名: ${comment.commenterName}): ${commentText}\n`;
                                }
                            }
                        }
                    }
                    dynamicContext = postsContext;
                }
   
const summary3Hours_group = generateSummaryForTimeframe(chat, 3, 'hours');
const summary6Hours_group = generateSummaryForTimeframe(chat, 6, 'hours');
const summary9Hours_group = generateSummaryForTimeframe(chat, 9, 'hours');
const summaryToday_group = generateSummaryForTimeframe(chat, 1, 'days');
const summary3Days_group = generateSummaryForTimeframe(chat, 3, 'days');
const summary7Days_group = generateSummaryForTimeframe(chat, 7, 'days');

let multiLayeredSummaryContext_group = '';
if (summary3Hours_group || summary6Hours_group || summary9Hours_group || summaryToday_group || summary3Days_group || summary7Days_group) {
    multiLayeredSummaryContext_group += `\n# 智慧總結 (基於不同時間維度的群聊回顧)\n`;
    if (summary3Hours_group) multiLayeredSummaryContext_group += summary3Hours_group;
    if (summary6Hours_group) multiLayeredSummaryContext_group += summary6Hours_group;
    if (summary9Hours_group) multiLayeredSummaryContext_group += summary9Hours_group;

    if (summary3Hours_group || summary6Hours_group || summary9Hours_group) multiLayeredSummaryContext_group += '\n';

    if (summaryToday_group) multiLayeredSummaryContext_group += summaryToday_group;
    if (summary3Days_group) multiLayeredSummaryContext_group += summary3Days_group;
    if (summary7Days_group) multiLayeredSummaryContext_group += summary7Days_group;
}     
                systemPrompt = `
        # 你的任務
        你是一個群聊AI導演。你現在控制著一個名為“${chat.name}”的群聊。
        ${chat.settings.enableTimePerception ? `當前時間是 ${currentTime}。` : ''}
        ${timeContextText ? `${timeContextText} ` : ''}你的任務是根據群成員的性格、世界觀、參考記憶、最近的動態和當前情景，【選擇一個或多個角色】，讓他們主動發起一段對話，打破沉默，讓群聊重新活躍起來。
# 【交互鐵律：角色間必須互動！】
1.  你的核心任務是**導演一場生動的群聊**，而不僅僅是讓角色輪流發言。
2.  當有多個角色在同一輪發言時，他們的對話【必須】有邏輯上的前後關聯。後面的角色應該**回應、反駁、或補充**前面角色的發言。
3.  模擬真實的聊天節奏。可以是一個角色提出問題，另一個角色立刻回答；或者一個角色開玩笑，另一個角色吐槽。
4.  你【絕對不能】生成幾段毫無關聯的獨白。這會讓對話顯得非常機械和不真實。        
${longTermMemoryContext}
        
        # 核心規則
        你的回復【必須】是一個JSON陣列，可以包含一個或多個行動物件。每個物件的 "name" 欄位【必須】是角色的【本名】。你【絕對不能】生成 "name" 欄位為 "${myNickname}" 的消息。嚴格遵守每個角色的設定，禁止出戲。
        
        # 你的可選行動指令:
        -   **發送文本**: '{"type": "text", "name": "角色本名", "content": "文本內容"}'
        -   **發送表情**: '{"type": "sticker", "name": "角色本名", "url": "...", "meaning": "..."}'
        -   **發送圖片**: '{"type": "ai_image", "name": "角色本名", "description": "圖片的詳細【中文】描述", "image_prompt": "圖片的【英文】關鍵字, 用%20分隔, 風格為風景/動漫/插畫/二次元等, 禁止真人"}'
        -   **發起投票**: '{"type": "poll", "name": "角色本名", "question": "...", "options": "..."}'
        -   **發起群視頻**: '{"type": "group_call_request", "name": "角色本名"}'
        -如何正確使用“引用回復”功能：
- 當你想明確地針對群內【任何成員】（包括用戶或其他AI角色）之前的某一句具體的話進行回復時，你就應該使用這個功能。
- 這會讓你的回復上方出現一個灰色的小框，裡面是被你引用的那句話，這樣對話就不會亂了。
- 指令格式: '{"type": "quote_reply", "target_timestamp": (你想引用的那句話的時間戳記), "reply_content": "你的回復內容"}'

        # 當前群聊資訊
        - **群名稱**: ${chat.name}
        ${worldBookContent}
        # 長期記憶 (最高優先順序，這是群內已經確立的事實，所有角色必須嚴格遵守)
        ${chat.longTermMemory && chat.longTermMemory.length > 0 ? chat.longTermMemory.map(mem => `- ${mem.content}`).join('\n') : '- (暫無)'}       
        ${multiLayeredSummaryContext_group}
        ${linkedMemoryContext}
        
        # 群成員列表及人設
        ${membersList}
        
        # 用戶的角色
        - **${myNickname}**: ${chat.settings.myPersona}
        
        # 最近的對話摘要 (供你參考)
        ${recentContextSummary}
        
        # 最近的動態清單 (供你參考和評論)
        ${dynamicContext}
        
        現在，請開始你的導演工作，讓群聊再次熱鬧起來吧！
        `;
            }
            // ★★★ 核心修復結束 ★★★
    // ==========================================================
    //            ★★★ 核心修復從這裡開始 ★★★
    // ==========================================================
    
    // 步驟 1: 【全新】構建包含完整原始聊天記錄的 messagesPayload
    const recentHistoryForPayload = chat.history.filter(m => !m.isHidden).slice(-10);
    const messagesPayload = [
        { role: 'system', content: systemPrompt },
        // 將原始的、未被摘要的 recentHistory 轉換為API能理解的格式
        ...recentHistoryForPayload.map(msg => {
            const sender = msg.role === 'user' ? myNickname : getDisplayNameInGroup(chat, msg.senderName);
            let content = msg.content;
            // 將所有複雜消息類型都轉換為純文字描述，讓AI能讀懂
            if (msg.type === 'ai_image' || msg.type === 'user_photo') {
                content = `[發送了一張圖片，描述為：'${msg.content}']`;
            } else if (msg.type === 'voice_message') {
                content = `[發送了一條語音，內容是：'${msg.content}']`;
            } else if (typeof content !== 'string') {
                content = '[發送了一條複雜消息，如卡片或轉帳]';
            }

            return {
                role: 'user', // 全部類比成 user 角色，讓AI更好地理解對話流
                content: `${sender}: ${content}`
            };
        })
    ];

            try {
                const messagesPayload = [{ role: 'user', content: systemPrompt }];
                let isGemini = proxyUrl === GEMINI_API_URL;
                let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesPayload);
        // 步驟 2: 【全新】在 API 調用中使用我們新構建的、更豐富的 messagesPayload
        const response = isGemini ? 
            await fetch(geminiConfig.url, geminiConfig.data) : 
            await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                body: JSON.stringify({
                    model: model,
                    messages: messagesPayload, // <-- 使用這個新變數！
                    temperature: state.globalSettings.apiTemperature || 0.9,
                })
            });
        
                if (!response.ok) throw new Error((await response.json()).error.message);
        
                const data = await response.json();
                const aiResponseContent = isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content;
                const responseArray = parseAiResponse(aiResponseContent);
        
                if (!responseArray || responseArray.length === 0) {
                     console.warn(`群聊 "${chat.name}" 的獨立行動API返回為空或格式不正確，本次跳過。`);
                     return;
                }
                
                let actionTimestamp = Date.now();
                
                let hasPerformedMajorAction = false;
                let notificationContent = '';
                let notificationSender = '';
// This is the new, fixed code block
const processedActions = [];
for (const action of responseArray) {
    const contentStr = String(action.content || ''); // Ensure content is a string
    // Check if the content is a raw HTML block
    const isRawHtml = contentStr.trim().startsWith('<') && contentStr.trim().endsWith('>');

    // **CORE FIX**: Only split the message if it has newlines AND it's NOT raw HTML
    if (action.type === 'text' && !isRawHtml && contentStr.includes('\n')) {
        const lines = contentStr.split(/\n+/).filter(line => line.trim());
        lines.forEach(line => {
            processedActions.push({ ...action, content: line });
        });
    } else {
        // If it's HTML or a single-line message, push it as-is
        processedActions.push(action);
    }
}
        for (const action of processedActions){
                    if (!action || !action.type || !action.name) continue;
        
                    const senderDisplayName = getDisplayNameInGroup(chat, action.name);
                    let visibleSystemMessage = null;
        
                    let aiMessage = null;
                    const baseMessage = { role: 'assistant', senderName: action.name, timestamp: actionTimestamp++ };
        
                    // ★★★ 核心修復：處理 open_red_packet 指令 ★★★
                    if (action.type === 'open_red_packet') {
                        const packetToOpen = chat.history.find(m => m.timestamp === action.packet_timestamp);
                        // 確保紅包存在、沒領完、且這個角色還沒領過
                        if (packetToOpen && !packetToOpen.isFullyClaimed && !(packetToOpen.claimedBy && packetToOpen.claimedBy[action.name])) {
                            // (這裡的搶紅包邏輯和使用者搶紅包的邏輯是完全一樣的)
                            let claimedAmountAI = 0;
                            const remainingAmount = packetToOpen.totalAmount - Object.values(packetToOpen.claimedBy || {}).reduce((sum, val) => sum + val, 0);
                            const remainingCount = packetToOpen.count - Object.keys(packetToOpen.claimedBy || {}).length;
                            
                            if (remainingCount > 0) {
                                if (remainingCount === 1) { claimedAmountAI = remainingAmount; } 
                                else {
                                    const min = 0.01;
                                    const max = remainingAmount - (remainingCount - 1) * min;
                                    claimedAmountAI = Math.random() * (max - min) + min;
                                }
                                claimedAmountAI = parseFloat(claimedAmountAI.toFixed(2));
                                if (!packetToOpen.claimedBy) packetToOpen.claimedBy = {};
                                packetToOpen.claimedBy[action.name] = claimedAmountAI;
        
                                // 創建對使用者可見的系統消息
                                chat.history.push({
                                    role: 'system',
                                    type: 'pat_message',
                                    content: `${senderDisplayName} 領取了 ${getDisplayNameInGroup(chat, packetToOpen.senderName)} 的紅包`,
                                    timestamp: Date.now()
                                });
                                
                                // 創建對AI隱藏的、告知結果的消息
                                let hiddenContentForAI = `[系統提示：你 (${senderDisplayName}) 成功搶到了 ${claimedAmountAI.toFixed(2)} 元。`;
                                if (Object.keys(packetToOpen.claimedBy).length >= packetToOpen.count) {
                                    packetToOpen.isFullyClaimed = true;
                                    // 告知紅包領完了
                                    chat.history.push({
                                        role: 'system',
                                        type: 'pat_message',
                                        content: `${getDisplayNameInGroup(chat, packetToOpen.senderName)} 的紅包已被領完`,
                                        timestamp: Date.now() + 1
                                    });
                                    // 找出並告知手氣王是誰
                                    let luckyKing = { name: '', amount: -1 };
                                    Object.entries(packetToOpen.claimedBy).forEach(([name, amount]) => {
                                        if (amount > luckyKing.amount) {
                                            luckyKing = { name, amount };
                                        }
                                    });
                                    if (luckyKing.name) {
                                         const luckyKingDisplayName = getDisplayNameInGroup(chat, luckyKing.name);
                                         hiddenContentForAI += ` 紅包已被領完，手氣王是 ${luckyKingDisplayName}！`;
                                    }
                                }
                                hiddenContentForAI += ' 請根據這個結果發表你的評論。]';
                                chat.history.push({
                                    role: 'system',
                                    content: hiddenContentForAI,
                                    timestamp: Date.now() + 2,
                                    isHidden: true
                                });
                            }
                        }
                        hasPerformedMajorAction = true; // 標記有重要行動
                        continue; // 處理完搶紅包後，跳過本次迴圈，等待下一次tick來發表評論
                    }
                    // ★★★ 修復結束 ★★★
        
                    switch (action.type) {
                        case 'qzone_post':
                            const newPost = { type: action.postType || 'shuoshuo', content: action.content, timestamp: Date.now(), authorId: state.chats[Object.keys(state.chats).find(key => state.chats[key].originalName === action.name)]?.id || action.name, authorOriginalName: action.name, visibleGroupIds: null };
                            await db.qzonePosts.add(newPost);
                            updateUnreadIndicator(unreadPostsCount + 1);
                            visibleSystemMessage = { content: `[${senderDisplayName} 發佈了一條新動態]` };
                            break;
                        case 'qzone_comment':
                            const postToComment = await db.qzonePosts.get(parseInt(action.postId));
                            if (postToComment) {
                                if (!postToComment.comments) postToComment.comments = [];
                                postToComment.comments.push({ commenterName: action.name, text: action.commentText, timestamp: Date.now() });
                                await db.qzonePosts.update(postToComment.id, { comments: postToComment.comments });
                                updateUnreadIndicator(unreadPostsCount + 1);
                                visibleSystemMessage = { content: `[${senderDisplayName} 評論了動態]` };
                            }
                            break;
                        case 'qzone_like':
                            const postToLike = await db.qzonePosts.get(parseInt(action.postId));
                            if (postToLike) {
                                if (!postToLike.likes) postToLike.likes = [];
                                if (!postToLike.likes.includes(action.name)) {
                                    postToLike.likes.push(action.name);
                                    await db.qzonePosts.update(postToLike.id, { likes: postToLike.likes });
                                    updateUnreadIndicator(unreadPostsCount + 1);
                                    visibleSystemMessage = { content: `[${senderDisplayName} 點贊了動態]` };
                                }
                            }
                            break;
                        case 'ai_image':
                            aiMessage = {
                                ...baseMessage,
                                type: 'ai_image',
                                content: action.description, 
image_prompt: msgData.image_prompt // <-- 【核心修復】在這裡補上缺失的關鍵字段
                            };
                            break;
                        default:
                            if (action.type === 'poll') {
                                 const pollOptions = typeof action.options === 'string' 
                                    ? action.options.split('\n').filter(opt => opt.trim()) 
                                    : (Array.isArray(action.options) ? action.options : []);
                                if (pollOptions.length < 2) continue;
                                aiMessage = { ...baseMessage, ...action, options: pollOptions, votes: {}, isClosed: false };
                            } else {
                                const messageContent = action.content || action.message;
                                aiMessage = { ...baseMessage, ...action };
                                if (messageContent) aiMessage.content = messageContent;
                            }
                            break;
                    }
                    
                    if (visibleSystemMessage) {
                        chat.history.push({
                            role: 'system',
                            type: 'pat_message',
                            content: visibleSystemMessage.content,
                            timestamp: actionTimestamp++
                        });
                    } 
                    else if (aiMessage) {
                        chat.history.push(aiMessage);
                        if (!notificationSender) {
                            notificationSender = senderDisplayName;
                            notificationContent = aiMessage.type === 'ai_image' ? '[圖片]' : (aiMessage.content || `[${aiMessage.type}]`);
                        }
                    }
                    hasPerformedMajorAction = true;
                }
                
                if (hasPerformedMajorAction) {
                    chat.lastActionTimestamp = Date.now();
                    chat.unreadCount = (chat.unreadCount || 0) + responseArray.filter(a => a.type !== 'qzone_post' && a.type !== 'qzone_comment' && a.type !== 'qzone_like').length;
                    if (notificationSender && notificationContent) {
                         showNotification(chatId, `${notificationSender}: ${notificationContent}`);
                    }
                    await db.chats.put(chat);
                }
        
            } catch (error) {
                console.error(`群聊 "${chat.name}" 的獨立行動失敗:`, error);
            } finally {
                renderChatList();
            }
        }
        
        
        
        
        
        
        // ▼▼▼ 請用這個【終極修正版】函數，完整替換掉你舊的 applyScopedCss 函數 ▼▼▼
        
        /**
         * 將用戶自訂的CSS安全地應用到指定的作用域
         * @param {string} cssString 使用者輸入的原始CSS字串
         * @param {string} scopeId 應用樣式的作用域ID (例如 '#chat-messages' 或 '#settings-preview-area')
         * @param {string} styleTagId 要操作的 <style> 標籤的ID
         */
        function applyScopedCss(cssString, scopeId, styleTagId) {
            const styleTag = document.getElementById(styleTagId);
            if (!styleTag) return;
            
            if (!cssString || cssString.trim() === '') {
                styleTag.innerHTML = '';
                return;
            }
            
            // 增強作用域處理函數 - 專門解決.user和.ai樣式衝突問題
            const scopedCss = cssString
                .replace(/\s*\.message-bubble\.user\s+([^{]+\{)/g, `${scopeId} .message-bubble.user $1`)
                .replace(/\s*\.message-bubble\.ai\s+([^{]+\{)/g, `${scopeId} .message-bubble.ai $1`)
                .replace(/\s*\.message-bubble\s+([^{]+\{)/g, `${scopeId} .message-bubble $1`);
            
            styleTag.innerHTML = scopedCss;
        }
        
        // ▼▼▼ 【請用這個已修復的版本】完整替換舊的 updateSettingsPreview 函數 ▼▼▼
        async function updateSettingsPreview() {
            if (!state.activeChatId) return;
            const chat = state.chats[state.activeChatId];
            const previewArea = document.getElementById('settings-preview-area');
            if (!previewArea) return;
        
            // 1. 獲取當前設置的值
            const selectedTheme = document.querySelector('input[name="theme-select"]:checked')?.value || 'default';
            const fontSize = document.getElementById('font-size-slider').value;
            const customCss = document.getElementById('custom-css-input').value;
            const background = chat.settings.background; 
        
            // 2. 更新預覽區的基本樣式
            previewArea.dataset.theme = selectedTheme;
            previewArea.style.setProperty('--chat-font-size', `${fontSize}px`);
            
            if (background && background.startsWith('data:image')) {
                previewArea.style.backgroundImage = `url(${background})`;
                previewArea.style.backgroundColor = 'transparent';
            } else {
                previewArea.style.backgroundImage = 'none';
                previewArea.style.background = background || '#f0f2f5';
            }
        
            // 3. 渲染模擬氣泡
            previewArea.innerHTML = ''; 
        
            // 【【【核心修復1：在這裡使用 await 等待結果】】】
            const aiMsg = { role: 'ai', content: '對方消息預覽', timestamp: 1, senderName: chat.name };
            const aiBubble = await createMessageElement(aiMsg, chat); // <--- 增加了 await
            if(aiBubble) previewArea.appendChild(aiBubble);
        
            // 【【【核心修復2：在這裡也使用 await】】】
            const userMsg = { role: 'user', content: '我的消息預覽', timestamp: 2 };
            const userBubble = await createMessageElement(userMsg, chat); // <--- 增加了 await
            if(userBubble) previewArea.appendChild(userBubble);
            
            // 即時更新預覽區歌詞欄位置 (這部分邏輯不變)
            const previewLyricsBar = document.createElement('div');
            previewLyricsBar.style.cssText = `
                position: absolute; 
                font-size: 11px; 
                padding: 2px 6px; 
                border-radius: 8px; 
                background-color: rgba(0, 0, 0, 0.1); 
                color: var(--text-secondary); 
                white-space: nowrap; 
                transition: all 0.3s ease;
            `;
            previewLyricsBar.textContent = '♪ 歌詞位置預覽 ♪';
            previewArea.appendChild(previewLyricsBar);
            
            const vertical = document.getElementById('lyrics-vertical-pos').value;
            const horizontal = document.getElementById('lyrics-horizontal-pos').value;
            const offset = parseInt(document.getElementById('lyrics-offset-input').value) || 10;
        
            if (vertical === 'top') {
                previewLyricsBar.style.top = `${offset}px`;
            } else {
                previewLyricsBar.style.bottom = `${offset}px`;
            }
            
            switch (horizontal) {
                case 'left':
                    previewLyricsBar.style.left = '15px';
                    break;
                case 'right':
                    previewLyricsBar.style.right = '15px';
                    break;
                default:
                    previewLyricsBar.style.left = '50%';
                    previewLyricsBar.style.transform = 'translateX(-50%)';
                    break;
            }
            
            // 4. 應用自訂CSS到預覽區 (這部分邏輯不變)
            applyScopedCss(customCss, '#settings-preview-area', 'preview-bubble-style');
        }
        // ▲▲▲ 替換結束 ▲▲▲
        
        // ▼▼▼ 請將這些【新函數】黏貼到JS功能函式定義區 ▼▼▼
        
        async function openGroupManager() {
            await renderGroupList();
            document.getElementById('group-management-modal').classList.add('visible');
        }
        
        async function renderGroupList() {
            const listEl = document.getElementById('existing-groups-list');
            const groups = await db.qzoneGroups.toArray();
            listEl.innerHTML = '';
            if (groups.length === 0) {
                listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">還沒有任何分組</p>';
            }
            groups.forEach(group => {
                const item = document.createElement('div');
                item.className = 'existing-group-item';
                item.innerHTML = `
                    <span class="group-name">${group.name}</span>
                    <span class="delete-group-btn" data-id="${group.id}">×</span>
                `;
                listEl.appendChild(item);
            });
        }
        
        // ▼▼▼ 請用這個【修正後】的函數，完整替換舊的 addNewGroup 函數 ▼▼▼
        async function addNewGroup() {
            const input = document.getElementById('new-group-name-input');
            const name = input.value.trim();
            if (!name) {
                alert('分組名不能為空！');
                return;
            }
        
            // 【核心修正】在添加前，先檢查分組名是否已存在
            const existingGroup = await db.qzoneGroups.where('name').equals(name).first();
            if (existingGroup) {
                alert(`分組 "${name}" 已經存在了，換個名字吧！`);
                return;
            }
            // 【修正結束】
        
            await db.qzoneGroups.add({ name });
            input.value = '';
            await renderGroupList();
        }
        // ▲▲▲ 替換結束 ▲▲▲
        
        async function deleteGroup(groupId) {
            const confirmed = await showCustomConfirm('確認刪除', '刪除分組後，該組內的好友將變為“未分組”。確定要刪除嗎？', { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                await db.qzoneGroups.delete(groupId);
                // 將屬於該分組的好友的 groupId 設為 null
                const chatsToUpdate = await db.chats.where('groupId').equals(groupId).toArray();
                for (const chat of chatsToUpdate) {
                    chat.groupId = null;
                    await db.chats.put(chat);
                    if(state.chats[chat.id]) state.chats[chat.id].groupId = null;
                }
                await renderGroupList();
            }
        }
        
        // ▲▲▲ 新函數黏貼結束 ▲▲▲
        
        // ▼▼▼ 請將這【一整塊新函數】黏貼到JS功能函式定義區的末尾 ▼▼▼
        
        /**
         * 當長按消息時，顯示操作功能表
         * @param {number} timestamp - 被長按消息的時間戳記
         */
        function showMessageActions(timestamp) {
        // ▼▼▼ 在這裡新增 ▼▼▼
        const chat = state.chats[state.activeChatId];
        document.getElementById('publish-to-announcement-btn').style.display = chat.isGroup ? 'block' : 'none';
        // ▲▲▲ 新增結束 ▲▲▲
            // 如果已經在多選模式，則不彈出菜單
            if (isSelectionMode) return;
            
            activeMessageTimestamp = timestamp;
            document.getElementById('message-actions-modal').classList.add('visible');
        }
        
        /**
         * 隱藏消息操作功能表
         */
        function hideMessageActions() {
            document.getElementById('message-actions-modal').classList.remove('visible');
            activeMessageTimestamp = null;
        }
        
        // ▼▼▼ 用這個【已更新】的版本，替換舊的 openMessageEditor 函數 ▼▼▼
        async function openMessageEditor() {
            if (!activeMessageTimestamp) return;
        
            const timestampToEdit = activeMessageTimestamp;
            const chat = state.chats[state.activeChatId];
            const message = chat.history.find(m => m.timestamp === timestampToEdit);
            if (!message) return;
        
            hideMessageActions(); 
        
            let contentForEditing;
            // 【核心修正】將 share_link 也加入特殊類型判斷
            const isSpecialType = message.type && ['voice_message', 'ai_image', 'transfer', 'share_link'].includes(message.type);
        
            if (isSpecialType) {
                let fullMessageObject = { type: message.type };
                if (message.type === 'voice_message') fullMessageObject.content = message.content;
                else if (message.type === 'ai_image') fullMessageObject.description = message.content; 
                else if (message.type === 'transfer') {
                    fullMessageObject.amount = message.amount;
                    fullMessageObject.note = message.note;
                } 
                // 【核心修正】處理分享連結類型的消息
                else if (message.type === 'share_link') {
                    fullMessageObject.title = message.title;
                    fullMessageObject.description = message.description;
                    fullMessageObject.source_name = message.source_name;
                    fullMessageObject.content = message.content;
                }
                contentForEditing = JSON.stringify(fullMessageObject, null, 2);
            } else if (typeof message.content === 'object') {
                contentForEditing = JSON.stringify(message.content, null, 2);
            } else {
                contentForEditing = message.content;
            }
        
            // 【核心修改1】在這裡添加 'link' 範本
            const templates = {
                voice: { type: 'voice_message', content: '在這裡輸入語音內容' },
                image: { type: 'ai_image', description: '在這裡輸入圖片描述' },
                transfer: { type: 'transfer', amount: 5.20, note: '一點心意' },
                link: { type: 'share_link', title: '文章標題', description: '文章摘要...', source_name: '來源網站', content: '文章完整內容...' }
            };
        
            // 【核心修改2】在這裡添加新的“連結”按鈕
            const helpersHtml = `
                <div class="format-helpers">
                    <button class="format-btn" data-template='${JSON.stringify(templates.voice)}'>語音</button>
                    <button class="format-btn" data-template='${JSON.stringify(templates.image)}'>圖片</button>
                    <button class="format-btn" data-template='${JSON.stringify(templates.transfer)}'>轉帳</button>
                    <button class="format-btn" data-template='${JSON.stringify(templates.link)}'>連結</button>
                </div>
            `;
        
            const newContent = await showCustomPrompt(
                '編輯消息', 
                '在此修改，或點擊上方按鈕使用格式範本...',
                contentForEditing, 
                'textarea',
                helpersHtml
            );
        
            if (newContent !== null) {
                // 【核心修正】這裡調用的應該是 saveEditedMessage，而不是 saveAdvancedEditor
                await saveEditedMessage(timestampToEdit, newContent, true);
            }
        }
        // ▲▲▲ 替換結束 ▲▲▲
        
        /**
         * 複製消息的文本內容到剪貼板
         */
        async function copyMessageContent() {
            if (!activeMessageTimestamp) return;
            const chat = state.chats[state.activeChatId];
            const message = chat.history.find(m => m.timestamp === activeMessageTimestamp);
            if (!message) return;
        
            let textToCopy;
            if (typeof message.content === 'object') {
                textToCopy = JSON.stringify(message.content);
            } else {
                textToCopy = String(message.content);
            }
        
            try {
                await navigator.clipboard.writeText(textToCopy);
                await showCustomAlert('複製成功', '消息內容已複製到剪貼板。');
            } catch (err) {
                await showCustomAlert('複製失敗', '無法訪問剪貼板。');
            }
            
            hideMessageActions();
        }
        
// ▼▼▼ 【全新】請將這個新函數黏貼到 copyMessageContent 函數的後面 ▼▼▼
/**
 * 複製消息的時間戳記到剪貼板
 */
async function copyMessageTimestamp() {
    if (!activeMessageTimestamp) return;

    try {
        await navigator.clipboard.writeText(activeMessageTimestamp);
        await showCustomAlert('複製成功', `消息時間戳記 ${activeMessageTimestamp} 已複製到剪貼板。`);
    } catch (err) {
        await showCustomAlert('複製失敗', '無法訪問剪貼板。');
    }
    
    hideMessageActions();
}
// ▲▲▲ 新增函數結束 ▲▲▲
// ▼▼▼ 【請用這個已添加“引用”範本的版本】替換舊的 createMessageEditorBlock 函數 ▼▼▼
/**
 * 創建一個可編輯的消息塊（包含文字方塊、格式助手和刪除按鈕）
 * @param {string} initialContent - 文字方塊的初始內容
 * @returns {HTMLElement} - 創建好的DOM元素
 */
function createMessageEditorBlock(initialContent = '') {
    const block = document.createElement('div');
    block.className = 'message-editor-block';

    // 【核心修改1】在這裡添加 'quote' 範本
    const templates = {
        voice: { type: 'voice_message', content: '在這裡輸入語音內容' },
        image: { type: 'ai_image', description: '在這裡輸入圖片描述' },
        transfer: { type: 'transfer', amount: 5.20, note: '一點心意' },
        link: { type: 'share_link', title: '文章標題', description: '文章摘要...', source_name: '來源網站', content: '文章完整內容...' },
        offline: { type: 'offline_text', content: '「在這裡輸入對話內容」\n(在這裡輸入動作或環境描寫)' },
        quote: { type: 'quote_reply', target_timestamp: 1234567890, reply_content: '在這裡輸入回復內容' }
    };

    block.innerHTML = `
        <button class="delete-block-btn" title="刪除此條">×</button>
        <textarea>${initialContent}</textarea>
        <div class="format-helpers">
            <button class="format-btn" data-template='${JSON.stringify(templates.voice)}'>語音</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.image)}'>圖片</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.transfer)}'>轉帳</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.link)}'>連結</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.offline)}'>線下</button>
            <!-- 【核心修改2】在這裡添加新的“引用”按鈕 -->
            <button class="format-btn" data-template='${JSON.stringify(templates.quote)}'>引用</button>
        </div>
    `;

    // 綁定刪除按鈕事件
    block.querySelector('.delete-block-btn').addEventListener('click', () => {
        // 確保至少保留一個編輯塊
        if (document.querySelectorAll('.message-editor-block').length > 1) {
            block.remove();
        } else {
            alert('至少需要保留一條消息。');
        }
    });

    // 綁定格式助手按鈕事件
    block.querySelectorAll('.format-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const templateStr = btn.dataset.template;
            const textarea = block.querySelector('textarea');
            if (templateStr && textarea) {
                try {
                    const templateObj = JSON.parse(templateStr);
                    textarea.value = JSON.stringify(templateObj, null, 2);
                    textarea.focus();
                } catch(e) { console.error("解析格式範本失敗:", e); }
            }
        });
    });

    return block;
}
// ▲▲▲ 替換結束 ▲▲▲
        
        // ▼▼▼ 【最終修復版】請用這個全新的函數，完整替換舊的 openAdvancedMessageEditor 函數 ▼▼▼
        /**
         * 打開全新的、視覺化的多消息編輯器，並動態繫結其所有按鈕事件
         */
        function openAdvancedMessageEditor() {
            if (!activeMessageTimestamp) return;
        
            const timestampToEdit = activeMessageTimestamp;
            const chat = state.chats[state.activeChatId];
            const message = chat.history.find(m => m.timestamp === timestampToEdit);
            if (!message) return;
        
            hideMessageActions(); 
        
            const editorModal = document.getElementById('message-editor-modal');
            const editorContainer = document.getElementById('message-editor-container');
            editorContainer.innerHTML = ''; 
        
            let initialContent;
            
            // ==========================================================
            //            ★★★ 核心修復從這裡開始 ★★★
            // ==========================================================
            
            // 步驟1：檢查這條消息是否是一個“引用回復”
            if (message.quote) {
                // 如果是，就手動構建一個完整的 quote_reply 物件
                const quoteReplyObject = {
                    type: 'quote_reply',
                    target_timestamp: message.quote.timestamp,
                    reply_content: message.content // 您的回復內容
                };
                // 將這個完整的物件轉換為格式化的JSON字串，作為編輯器的初始內容
                initialContent = JSON.stringify(quoteReplyObject, null, 2);
            } 
            // 步驟2：如果不是引用回復，再執行原來的特殊類型判斷
            else if (message.type && ['voice_message', 'ai_image', 'transfer', 'offline_text', 'share_link'].includes(message.type)) {
                let fullMessageObject = { type: message.type };
                if (message.type === 'voice_message') fullMessageObject.content = message.content;
                else if (message.type === 'ai_image') fullMessageObject.description = message.content;
                else if (message.type === 'transfer') {
                    fullMessageObject.amount = message.amount;
                    fullMessageObject.note = message.note;
                } 
                else if (message.type === 'offline_text') {
                    if (message.content) {
                        fullMessageObject.content = message.content;
                    } else { 
                        fullMessageObject.dialogue = message.dialogue;
                        fullMessageObject.description = message.description;
                    }
                }
                else if (message.type === 'share_link') {
                    fullMessageObject.title = message.title;
                    fullMessageObject.description = message.description;
                    fullMessageObject.source_name = message.source_name;
                    fullMessageObject.content = message.content;
                }
                initialContent = JSON.stringify(fullMessageObject, null, 2);
            } 
            // 步驟3：處理其他所有普通情況
            else if (typeof message.content === 'object') {
                initialContent = JSON.stringify(message.content, null, 2);
            } else {
                initialContent = message.content;
            }
        
            // ==========================================================
            //            ★★★ 核心修復到此結束 ★★★
            // ==========================================================
        
            const firstBlock = createMessageEditorBlock(initialContent);
            editorContainer.appendChild(firstBlock);
        
            // (後續的按鈕綁定邏輯保持不變)
            const addBtn = document.getElementById('add-message-editor-block-btn');
            const newAddBtn = addBtn.cloneNode(true);
            addBtn.parentNode.replaceChild(newAddBtn, addBtn);
            newAddBtn.addEventListener('click', () => {
                const newBlock = createMessageEditorBlock();
                editorContainer.appendChild(newBlock);
                newBlock.querySelector('textarea').focus();
            });
        
            const cancelBtn = document.getElementById('cancel-advanced-editor-btn');
            const newCancelBtn = cancelBtn.cloneNode(true);
            cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
            newCancelBtn.addEventListener('click', () => {
                editorModal.classList.remove('visible');
            });
        
            const saveBtn = document.getElementById('save-advanced-editor-btn');
            const newSaveBtn = saveBtn.cloneNode(true);
            saveBtn.parentNode.replaceChild(newSaveBtn, saveBtn);
            newSaveBtn.addEventListener('click', () => {
                saveEditedMessage(timestampToEdit); 
            });
        
            editorModal.classList.add('visible');
        }
        // ▲▲▲ 替換結束 ▲▲▲
        // ▲▲▲ 替換結束 ▲▲▲

        /**
         * 複製消息的文本內容到剪貼板
         */
        async function copyMessageContent() {
            if (!activeMessageTimestamp) return;
            const chat = state.chats[state.activeChatId];
            const message = chat.history.find(m => m.timestamp === activeMessageTimestamp);
            if (!message) return;
        
            let textToCopy;
            // 【【【核心修復3：在這裡也添加對 offline_text 的判斷】】】
            if (message.type === 'offline_text') {
                // 如果是新格式，直接複製content
                if (message.content) {
                    textToCopy = message.content;
                } else { // 相容舊格式
                    textToCopy = `「${message.dialogue || ''}」\n${message.description || ''}`;
                }
            } else if (typeof message.content === 'object') {
                textToCopy = JSON.stringify(message.content);
            } else {
                textToCopy = String(message.content);
            }
        
            try {
                await navigator.clipboard.writeText(textToCopy);
                await showCustomAlert('複製成功', '消息內容已複製到剪貼板。');
            } catch (err) {
                await showCustomAlert('複製失敗', '無法訪問剪貼板。');
            }
            
            hideMessageActions();
        }
        // ▲▲▲ 替換結束 ▲▲▲
        
        /**
         * 解析編輯後的文本，並返回一個標準化的消息片段物件
         * @param {string} text - 用戶在編輯方塊中輸入的文本
         * @returns {object} - 一個包含 type, content, 等屬性的物件
         */
        function parseEditedContent(text) {
            const trimmedText = text.trim();
        
            // 1. 嘗試解析為JSON物件（用於修復語音、轉帳等格式）
            if (trimmedText.startsWith('{') && trimmedText.endsWith('}')) {
                try {
                    const parsed = JSON.parse(trimmedText);
                    // 必須包含 type 屬性才認為是有效格式
                    if (parsed.type) {
                        return parsed;
                    }
                } catch (e) { /* 解析失敗，繼續往下走 */ }
            }
            
            // 2. 嘗試解析為表情包
            if (STICKER_REGEX.test(trimmedText)) {
                // 對於編輯的表情，我們暫時無法知道其`meaning`，所以只存URL
                return { type: 'sticker', content: trimmedText };
            }
        
            // 3. 否則，視為普通文本消息
            return { type: 'text', content: trimmedText };
        }
        
        
// ▼▼▼ 【最終修復版】請用這個全新的函數，完整替換舊的 saveEditedMessage 函數 ▼▼▼

/**
 * 【V4.0 | 終極修復版】保存編輯或拆分後的消息，並正確處理類型轉換
 * @param {number} timestamp - 被編輯的原始消息的時間戳記
 * @param {string|null} simpleContent - (可選) 如果是從簡單編輯器傳來，則為單個內容字串
 */
async function saveEditedMessage(timestamp, simpleContent = null) {
    if (!timestamp) return;

    const chat = state.chats[state.activeChatId];
    const messageIndex = chat.history.findIndex(m => m.timestamp === timestamp);
    if (messageIndex === -1) return;
    
    // 1. 獲取原始消息的完整物件，這是繼承發送者、時間戳記等基礎屬性的關鍵
    const originalMessage = chat.history[messageIndex];

    let newMessages = [];

    // 根據是來自簡單編輯器還是高級編輯器，獲取內容塊
    const blocks = simpleContent !== null 
        ? [simpleContent] 
        : Array.from(document.querySelectorAll('#message-editor-container textarea')).map(ta => ta.value);

    for (const rawContent of blocks) {
        if (!rawContent.trim()) continue;

        // 使用輔助函數解析每個編輯方塊的內容
        const parsedResult = parseEditedContent(rawContent.trim());
        
        // 2. 【【【這就是本次修復的核心！】】】
        //    先創建一個隻包含最基礎屬性的副本，而不是全部複製！
        const newMessage = {
            role: originalMessage.role,
            senderName: originalMessage.senderName,
            timestamp: originalMessage.timestamp // 時間戳記將在後面被重新分配
        };

        // 3. 根據解析出的新類型，智慧地構建新的消息物件
        //    這確保了舊的、不相關的屬性（如 .quote, .amount 等）不會被錯誤地繼承
        switch (parsedResult.type) {
            case 'text':
                newMessage.type = 'text';
                newMessage.content = parsedResult.content;
                break;
            case 'offline_text':
                newMessage.type = 'offline_text';
                if (parsedResult.content) {
                    newMessage.content = parsedResult.content;
                } else { 
                    newMessage.dialogue = parsedResult.dialogue;
                    newMessage.description = parsedResult.description;
                }
                break;
            case 'quote_reply':
                newMessage.type = 'quote_reply';
                newMessage.content = parsedResult.reply_content;
                const originalQuotedMsg = chat.history.find(m => m.timestamp === parsedResult.target_timestamp);
                if (originalQuotedMsg) {
                    let originalSenderName = originalQuotedMsg.senderName;
                    if (originalQuotedMsg.role === 'user') {
                        originalSenderName = state.qzoneSettings.nickname || '{{user}}';
                    }
                    newMessage.quote = {
                        timestamp: parsedResult.target_timestamp,
                        senderName: originalSenderName,
                        content: String(originalQuotedMsg.content || '')
                    };
                } else {
                    newMessage.quote = {
                        timestamp: parsedResult.target_timestamp,
                        senderName: '未知用戶',
                        content: '原始消息已刪除或不存在'
                    };
                }
                break;
            case 'voice_message':
            case 'sticker':
            case 'ai_image':
            case 'user_photo':
                newMessage.type = parsedResult.type;
                newMessage.content = parsedResult.content || parsedResult.description;
                if (parsedResult.meaning) newMessage.meaning = parsedResult.meaning;
                break;
            case 'transfer':
                newMessage.type = 'transfer';
                newMessage.amount = parsedResult.amount;
                newMessage.note = parsedResult.note;
                break;
            case 'share_link':
                newMessage.type = 'share_link';
                newMessage.title = parsedResult.title;
                newMessage.description = parsedResult.description;
                newMessage.source_name = parsedResult.source_name;
                newMessage.content = parsedResult.content;
                break;
            default:
                // 對於其他所有未知或複雜的類型，直接將解析結果作為消息主體
                Object.assign(newMessage, parsedResult);
                break;
        }
        
        newMessages.push(newMessage);
    }
    
    if (newMessages.length === 0) {
        document.getElementById('message-editor-modal').classList.remove('visible');
        return;
    }

    // 4. (後續的替換、重排時間戳記、保存和刷新邏輯保持不變)
    //    用新構建的消息陣列替換掉原來的那條消息
    chat.history.splice(messageIndex, 1, ...newMessages);
    
    // 重新分配時間戳記以保證順序
    let reassignTimestamp = timestamp;
    for (let i = messageIndex; i < chat.history.length; i++) {
        chat.history[i].timestamp = reassignTimestamp;
        reassignTimestamp++; 
    }
    
    await db.chats.put(chat);
    document.getElementById('message-editor-modal').classList.remove('visible');
    renderChatInterface(state.activeChatId);
    await showCustomAlert('成功', '消息已更新！');
}
// ▲▲▲ 替換結束 ▲▲▲
        
        // ▼▼▼ 請將這【一整塊新函數】黏貼到JS功能函式定義區的末尾 ▼▼▼
        
        /**
         * 當點擊“…”時，顯示動態操作功能表
         * @param {number} postId - 被操作的動態的ID
         */
        function showPostActions(postId) {
            activePostId = postId;
            document.getElementById('post-actions-modal').classList.add('visible');
        }
        
        /**
         * 隱藏動態操作功能表
         */
        function hidePostActions() {
            document.getElementById('post-actions-modal').classList.remove('visible');
            activePostId = null;
        }
        
        /**
         * 打開動態編輯器
         */
        async function openPostEditor() {
            if (!activePostId) return;
        
            const postIdToEdit = activePostId;
            const post = await db.qzonePosts.get(postIdToEdit);
            if (!post) return;
        
            hidePostActions();
        
            // 忠於原文：構建出最原始的文本形態供編輯
            let contentForEditing;
            if (post.type === 'shuoshuo') {
                contentForEditing = post.content;
            } else {
                // 對於圖片和文字圖，我們構建一個包含所有資訊的物件
                const postObject = {
                    type: post.type,
                    publicText: post.publicText || '',
                };
                if (post.type === 'image_post') {
                    postObject.imageUrl = post.imageUrl;
                    postObject.imageDescription = post.imageDescription;
                } else if (post.type === 'text_image') {
                    postObject.hiddenContent = post.hiddenContent;
                }
                contentForEditing = JSON.stringify(postObject, null, 2);
            }
            
            // 構建格式助手按鈕
            const templates = {
                shuoshuo: "在這裡輸入說說的內容...", // 對於說說，我們直接替換為純文字
                image: { type: 'image_post', publicText: '', imageUrl: 'https://...', imageDescription: '' },
                text_image: { type: 'text_image', publicText: '', hiddenContent: '' }
            };
            
            const helpersHtml = `
                <div class="format-helpers">
                    <button class="format-btn" data-type="text">說說</button>
                    <button class="format-btn" data-template='${JSON.stringify(templates.image)}'>圖片動態</button>
                    <button class="format-btn" data-template='${JSON.stringify(templates.text_image)}'>文字圖</button>
                </div>
            `;
        
            const newContent = await showCustomPrompt(
                '編輯動態',
                '在此修改內容...',
                contentForEditing,
                'textarea',
                helpersHtml
            );
            
            // 【特殊處理】為說說的格式助手按鈕添加不同的行為
            // 我們需要在模態框出現後，再給它綁定事件
            setTimeout(() => {
                const shuoshuoBtn = document.querySelector('#custom-modal-body .format-btn[data-type="text"]');
                if(shuoshuoBtn) {
                    shuoshuoBtn.addEventListener('click', () => {
                        const input = document.getElementById('custom-prompt-input');
                        input.value = templates.shuoshuo;
                        input.focus();
                    });
                }
            }, 100);
        
            if (newContent !== null) {
                await saveEditedPost(postIdToEdit, newContent);
            }
        }
        
        /**
         * 保存編輯後的動態
         * @param {number} postId - 要保存的動態ID
         * @param {string} newRawContent - 從編輯器獲取的新內容
         */
        async function saveEditedPost(postId, newRawContent) {
            const post = await db.qzonePosts.get(postId);
            if (!post) return;
        
            const trimmedContent = newRawContent.trim();
            
            // 嘗試解析為JSON，如果失敗，則認為是純文字（說說）
            try {
                const parsed = JSON.parse(trimmedContent);
                // 更新帖子屬性
                post.type = parsed.type || 'image_post';
                post.publicText = parsed.publicText || '';
                post.imageUrl = parsed.imageUrl || '';
                post.imageDescription = parsed.imageDescription || '';
                post.hiddenContent = parsed.hiddenContent || '';
                post.content = ''; // 清空舊的說說內容欄位
            } catch (e) {
                // 解析失敗，認為是說說
                post.type = 'shuoshuo';
                post.content = trimmedContent;
                // 清空其他類型的欄位
                post.publicText = '';
                post.imageUrl = '';
                post.imageDescription = '';
                post.hiddenContent = '';
            }
            
            await db.qzonePosts.put(post);
            await renderQzonePosts(); // 重新渲染列表
            await showCustomAlert('成功', '動態已更新！');
        }
        
        /**
         * 複製動態內容
         */
        async function copyPostContent() {
            if (!activePostId) return;
            const post = await db.qzonePosts.get(activePostId);
            if (!post) return;
            
            let textToCopy = post.content || post.publicText || post.hiddenContent || post.imageDescription || "（無文字內容）";
            
            try {
                await navigator.clipboard.writeText(textToCopy);
                await showCustomAlert('複製成功', '動態內容已複製到剪貼板。');
            } catch (err) {
                await showCustomAlert('複製失敗', '無法訪問剪貼板。');
            }
            
            hidePostActions();
        }
        
        // ▼▼▼ 【全新】創建群聊與拉人功能核心函數 ▼▼▼
        let selectedContacts = new Set();
        
        async function openContactPickerForGroupCreate() {
    // 彈出選擇功能表，讓使用者決定創建哪種群聊
    const choice = await showChoiceModal('創建群聊', [
        { text: '創建普通群聊 (我參與)', value: 'normal' },
        { text: '創建旁觀群聊 (我圍觀)', value: 'spectator' }
    ]);

    if (choice === 'normal') {
        // 如果選擇普通群聊，執行舊的邏輯
        selectedContacts.clear();
        const confirmBtn = document.getElementById('confirm-contact-picker-btn');
        const newConfirmBtn = confirmBtn.cloneNode(true);
        confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
        newConfirmBtn.addEventListener('click', handleCreateGroup);
        await renderContactPicker();
        showScreen('contact-picker-screen');

    } else if (choice === 'spectator') {
        // 如果選擇旁觀群聊，執行新的邏輯
        openSpectatorGroupCreator();
    }
}
        // ▲▲▲ 替換結束 ▲▲▲
// ▼▼▼ 【全新】這是旁觀模式群聊創建功能的核心代碼 ▼▼▼

/**
 * 【全新】打開“旁觀模式群聊”的成員選擇器
 */
async function openSpectatorGroupCreator() {
    selectedContacts.clear(); // 清空上次的選擇

    // 1. 修改“完成”按鈕的行為，讓它在點擊後調用我們新的創建函數
    const confirmBtn = document.getElementById('confirm-contact-picker-btn');
    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
    newConfirmBtn.addEventListener('click', handleCreateSpectatorGroup);

    // 2. 渲染一個包含所有角色和NPC的連絡人列表
    await renderSpectatorContactPicker();

    // 3. 切換到連絡人選擇螢幕
    showScreen('contact-picker-screen');
}

/**
 * 【全新】為“旁觀模式”渲染一個特殊的連絡人列表，包含所有角色和NPC
 */
async function renderSpectatorContactPicker() {
    const listEl = document.getElementById('contact-picker-list');
    listEl.innerHTML = '';

    // a. 獲取所有單聊角色
    const characters = Object.values(state.chats).filter(chat => !chat.isGroup);
    // b. 從資料庫獲取所有NPC
    const npcs = await db.npcs.toArray();

    if (characters.length === 0 && npcs.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color:#8a8a8a; margin-top:50px;">還沒有任何角色或NPC可以加入群聊。</p>';
        return;
    }

    // c. 渲染角色列表
    characters.forEach(contact => {
        const item = document.createElement('div');
        item.className = 'contact-picker-item';
        item.dataset.contactId = contact.id; // 使用角色的聊天ID
        item.innerHTML = `
            <div class="checkbox"></div>
            <img src="${contact.settings.aiAvatar || defaultAvatar}" class="avatar">
            <span class="name">${contact.name} <small style="color:#888;">(角色)</small></span>
        `;
        listEl.appendChild(item);
    });

    // d. 渲染NPC列表
    npcs.forEach(npc => {
        const item = document.createElement('div');
        item.className = 'contact-picker-item';
        item.dataset.contactId = npc.id; // 使用NPC的ID
        item.dataset.isNpc = "true";     // 添加一個特殊標記
        item.innerHTML = `
            <div class="checkbox"></div>
            <img src="${npc.avatar || defaultGroupMemberAvatar}" class="avatar">
            <span class="name">${npc.name} <small style="color:#007722;">(NPC)</small></span>
        `;
        listEl.appendChild(item);
    });

    updateContactPickerConfirmButton();
}

/**
 * 【全新】處理創建“旁觀模式群聊”的最終邏輯
 */
async function handleCreateSpectatorGroup() {
    if (selectedContacts.size < 2) {
        alert("旁觀群聊至少需要選擇2個成員。");
        return;
    }

    const groupName = await showCustomPrompt('設置群名', '請輸入群聊的名字', 'AI們的茶話會');
    if (!groupName || !groupName.trim()) return;

    const newChatId = 'group_' + Date.now();
    const members = [];
    const allNpcs = await db.npcs.toArray(); // 提前獲取所有NPC資料

    for (const contactId of selectedContacts) {
        const isNpc = document.querySelector(`.contact-picker-item[data-contact-id="${contactId}"]`).dataset.isNpc === "true";

        if (isNpc) {
            // 如果是NPC
            const npcData = allNpcs.find(n => n.id === parseInt(contactId));
            if (npcData) {
                members.push({
                    id: `npc_${npcData.id}`, // 給NPC一個獨特的成員ID
                    originalName: npcData.name,
                    groupNickname: npcData.name,
                    persona: npcData.persona,
                    avatar: npcData.avatar || defaultGroupMemberAvatar,
                    isNpc: true
                });
            }
        } else {
            // 如果是普通角色
            const contactChat = state.chats[contactId];
            if (contactChat) {
                members.push({
                    id: contactId,
                    originalName: contactChat.originalName,
                    groupNickname: contactChat.name,
                    persona: contactChat.settings.aiPersona,
                    avatar: contactChat.settings.aiAvatar || defaultAvatar,
                    isNpc: false
                });
            }
        }
    }

    const newGroupChat = {
        id: newChatId,
        name: groupName.trim(),
        isGroup: true,
        isSpectatorGroup: true, // ★★★ 這就是我們的核心標記！★★★
        members: members,
        settings: {
            // 在旁觀模式下，我們不需要“我”的人設和頭像
            maxMemory: 10,
            groupAvatar: defaultGroupAvatar,
            background: '',
            theme: 'default',
            fontSize: 13,
            customCss: '',
            linkedWorldBookIds: [],
        },
        history: [{ // 添加一條初始系統消息，告訴AI它們的任務
            role: 'system',
            content: '[系統指令：這是一個沒有用戶參與的群聊，請你們根據各自的人設自由地開始對話。]',
            timestamp: Date.now(),
            isHidden: true
        }],
        musicData: { totalTime: 0 }
    };

    state.chats[newChatId] = newGroupChat;
    await db.chats.put(newGroupChat);

    await renderChatList();
    showScreen('chat-list-screen');
    openChat(newChatId);
}
// ▲▲▲ 全新JS代碼黏貼結束 ▲▲▲        
/**
 * 【全新 | 支持NPC】渲染一個包含所有可選連絡人（角色+NPC）的列表
 */
async function renderContactPicker() {
    const listEl = document.getElementById('contact-picker-list');
    listEl.innerHTML = '';

    // 1. 同時獲取所有單聊角色和所有NPC
    const characters = Object.values(state.chats).filter(chat => !chat.isGroup);
    const npcs = await db.npcs.toArray();

    if (characters.length === 0 && npcs.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color:#8a8a8a; margin-top:50px;">還沒有可以拉進群的連絡人哦~</p>';
        return;
    }

    // 2. 渲染角色列表
    characters.forEach(contact => {
        const item = document.createElement('div');
        item.className = 'contact-picker-item';
        item.dataset.contactId = contact.id; // 使用角色的聊天ID
        item.innerHTML = `
            <div class="checkbox"></div>
            <img src="${contact.settings.aiAvatar || defaultAvatar}" class="avatar">
            <span class="name">${contact.name} <small style="color:#888;">(角色)</small></span>
        `;
        listEl.appendChild(item);
    });
    
    // 3. 渲染NPC列表
    npcs.forEach(npc => {
        const item = document.createElement('div');
        item.className = 'contact-picker-item';
        // 使用 "npc_" 首碼創建唯一ID，以便後續區分
        item.dataset.contactId = `npc_${npc.id}`; 
        item.innerHTML = `
            <div class="checkbox"></div>
            <img src="${npc.avatar || defaultGroupMemberAvatar}" class="avatar">
            <span class="name">${npc.name} <small style="color:#007722;">(NPC)</small></span>
        `;
        listEl.appendChild(item);
    });

    updateContactPickerConfirmButton();
}
        
        /**
         * 更新“完成”按鈕的計數
         */
        function updateContactPickerConfirmButton() {
            const btn = document.getElementById('confirm-contact-picker-btn');
            btn.textContent = `完成(${selectedContacts.size})`;
            btn.disabled = selectedContacts.size < 2; // 至少需要2個人才能創建群聊
        }
        
/**
 * 【全新 | 支援NPC】處理創建群聊的最終邏輯
 */
async function handleCreateGroup() {
    if (selectedContacts.size < 2) {
        alert("創建群聊至少需要選擇2個連絡人。");
        return;
    }

    const groupName = await showCustomPrompt('設置群名', '請輸入群聊的名字', '我們的群聊');
    if (!groupName || !groupName.trim()) return;

    const newChatId = 'group_' + Date.now();
    const members = [];
    const allNpcs = await db.npcs.toArray(); // 提前獲取所有NPC資料，提高效率

    for (const contactId of selectedContacts) {
        // 檢查ID首碼，判斷是NPC還是角色
        if (contactId.startsWith('npc_')) {
            const npcId = parseInt(contactId.replace('npc_', ''));
            const npcData = allNpcs.find(n => n.id === npcId);
            if (npcData) {
                members.push({
                    id: contactId, // 保留帶首碼的唯一ID
                    originalName: npcData.name,
                    groupNickname: npcData.name,
                    persona: npcData.persona,
                    avatar: npcData.avatar || defaultGroupMemberAvatar,
                    isNpc: true // 標記為NPC
                });
            }
        } else { // 如果不是NPC，就是普通角色
            const contactChat = state.chats[contactId];
            if (contactChat) {
                members.push({
                    id: contactId,
                    originalName: contactChat.originalName,
                    groupNickname: contactChat.name,
                    persona: contactChat.settings.aiPersona,
                    avatar: contactChat.settings.aiAvatar || defaultAvatar,
                    isNpc: false // 標記為非NPC
                });
            }
        }
    }

    const newGroupChat = {
        id: newChatId,
        name: groupName.trim(),
        isGroup: true,
        members: members,
        settings: {
            myPersona: '我是誰呀。',
            myNickname: '我',
            maxMemory: 10,
            groupAvatar: defaultGroupAvatar,
            myAvatar: defaultMyGroupAvatar,
            background: '',
            theme: 'default',
            fontSize: 13,
            customCss: '',
            linkedWorldBookIds: [],
        },
        history: [],
        musicData: { totalTime: 0 }
    };

    state.chats[newChatId] = newGroupChat;
    await db.chats.put(newGroupChat);
    
    await renderChatList();
    showScreen('chat-list-screen');
    openChat(newChatId); 
}
        
        // ▼▼▼ 【全新】群成員管理核心函數 ▼▼▼
        
        /**
         * 打開群成員管理螢幕
         */
        function openMemberManagementScreen() {
            if (!state.activeChatId || !state.chats[state.activeChatId].isGroup) return;
            renderMemberManagementList();
            showScreen('member-management-screen');
        }
        
        function renderMemberManagementList() {
            const listEl = document.getElementById('member-management-list');
            const chat = state.chats[state.activeChatId];
            listEl.innerHTML = '';
        
            chat.members.forEach(member => {
                const item = document.createElement('div');
                item.className = 'member-management-item';
                // 【核心修正】在這裡，我們將顯示的名稱從 member.name 改為 member.groupNickname
                item.innerHTML = `
                    <img src="${member.avatar}" class="avatar">
                    <span class="name">${member.groupNickname}</span>
                    <button class="remove-member-btn" data-member-id="${member.id}" title="移出群聊">-</button>
                `;
                listEl.appendChild(item);
            });
        }
        
        /**
         * 從群聊中移除一個成員
         * @param {string} memberId - 要移除的成員ID
         */
        async function removeMemberFromGroup(memberId) {
            const chat = state.chats[state.activeChatId];
            const memberIndex = chat.members.findIndex(m => m.id === memberId);
            
            if (memberIndex === -1) return;
            
            // 安全檢查，群聊至少保留2人
            if (chat.members.length <= 2) {
                alert("群聊人數不能少於2人。");
                return;
            }
            
        const memberName = chat.members[memberIndex].groupNickname; // <-- 修復：使用 groupNickname
            const confirmed = await showCustomConfirm(
                '移出成員',
                `確定要將“${memberName}”移出群聊嗎？`,
                { confirmButtonClass: 'btn-danger' }
            );
        
            if (confirmed) {
                chat.members.splice(memberIndex, 1);
                await db.chats.put(chat);
                renderMemberManagementList(); // 刷新成員管理列表
                document.getElementById('chat-settings-btn').click(); // 【核心修正】類比點擊設置按鈕，強制刷新整個彈窗
            }
        }
        
/**
 * 【總入口 | V2.0】打開連絡人選擇器，用於拉人入群（現在會同時顯示角色和NPC）
 */
async function openContactPickerForAddMember() {
    // 1. 為“完成”按鈕綁定正確的處理函數
    const confirmBtn = document.getElementById('confirm-contact-picker-btn');
    // 使用克隆節點技巧，確保每次都綁定最新的事件，防止重複執行
    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
    newConfirmBtn.addEventListener('click', handleAddMembersToGroup);
    
    // 2. 渲染一個包含所有可選連絡人的列表
    await renderUnifiedContactPicker();
    
    // 3. 顯示選擇器螢幕
    showScreen('contact-picker-screen');
}

/**
 * 【全新】渲染一個統一的連絡人選擇列表，包含角色和NPC
 */
async function renderUnifiedContactPicker() {
    const listEl = document.getElementById('contact-picker-list');
    listEl.innerHTML = '';
    selectedContacts.clear(); // 清空上次的選擇

    const chat = state.chats[state.activeChatId];
    const existingMemberIds = new Set(chat.members.map(m => m.id));

    // a. 獲取所有可選的 “角色” (排除自己和已在群內的)
    const characters = Object.values(state.chats).filter(c => !c.isGroup && !existingMemberIds.has(c.id));
    
    // b. 獲取所有可選的 “NPC” (排除已在群內的)
    const npcs = (await db.npcs.toArray()).filter(n => !existingMemberIds.has(`npc_${n.id}`));

    if (characters.length === 0 && npcs.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color:#8a8a8a; margin-top:50px;">沒有更多可以邀請的連絡人了。</p>';
        document.getElementById('confirm-contact-picker-btn').style.display = 'none';
    } else {
        document.getElementById('confirm-contact-picker-btn').style.display = 'block';
        
        // 渲染角色列表
        characters.forEach(contact => {
            const item = document.createElement('div');
            item.className = 'contact-picker-item';
            item.dataset.contactId = contact.id;
            item.dataset.contactType = 'character'; // 標記為角色
            item.innerHTML = `
                <div class="checkbox"></div>
                <img src="${contact.settings.aiAvatar || defaultAvatar}" class="avatar">
                <span class="name">${contact.name} <small style="color:#888;">(角色)</small></span>
            `;
            listEl.appendChild(item);
        });

        // 渲染NPC列表
        npcs.forEach(npc => {
            const item = document.createElement('div');
            item.className = 'contact-picker-item';
            item.dataset.contactId = `npc_${npc.id}`; // 使用帶首碼的唯一ID
            item.dataset.contactType = 'npc'; // 標記為NPC
            item.dataset.npcId = npc.id; // 保存原始NPC ID
            item.innerHTML = `
                <div class="checkbox"></div>
                <img src="${npc.avatar || defaultGroupMemberAvatar}" class="avatar">
                <span class="name">${npc.name} <small style="color:#007722;">(NPC)</small></span>
            `;
            listEl.appendChild(item);
        });
    }

    updateContactPickerConfirmButton();
}
        
// ▼▼▼ 【V2.1 | 頭像修復版】請用這個新版本替換舊的 handleAddMembersToGroup 函數 ▼▼▼
/**
 * 【核心處理 | V2.1】處理將選中的連絡人（角色或NPC）加入群聊的邏輯
 */
async function handleAddMembersToGroup() {
    if (selectedContacts.size === 0) {
        alert("請至少選擇一個要添加的連絡人。");
        return;
    }
    
    const chat = state.chats[state.activeChatId];
    const allNpcs = await db.npcs.toArray(); // 提前獲取所有NPC資料

    for (const contactId of selectedContacts) {
        const itemEl = document.querySelector(`.contact-picker-item[data-contact-id="${contactId}"]`);
        if (!itemEl) continue;

        const contactType = itemEl.dataset.contactType;

        if (contactType === 'character') {
            const contactChat = state.chats[contactId];
            if (contactChat) {
                chat.members.push({
                    id: contactId,
                    originalName: contactChat.originalName,
                    groupNickname: contactChat.name,
                    persona: contactChat.settings.aiPersona,
                    // 【核心修正】確保新加入的角色也能獲取到正確的頭像
                    avatar: contactChat.settings.aiAvatar || defaultAvatar,
                    isNpc: false // 標記這不是一個純NPC
                });
            }
        } else if (contactType === 'npc') {
            const npcId = parseInt(itemEl.dataset.npcId);
            const npcData = allNpcs.find(n => n.id === npcId);
            if (npcData) {
                // 【【【這就是最關鍵的修復！】】】
                // 在這裡，我們把 npcData.avatar 也一併添加到了成員對象中
                chat.members.push({
                    id: `npc_${npcId}`,
                    originalName: npcData.name,
                    groupNickname: npcData.name,
                    persona: npcData.persona,
                    avatar: npcData.avatar || defaultGroupMemberAvatar, // <-- 核心新增
                    isNpc: true
                });
            }
        }
    }

    await db.chats.put(chat);
    
    // 操作完成後，返回成員管理螢幕
    openMemberManagementScreen();
}
// ▲▲▲ 替換結束 ▲▲▲
        
/**
 * 【重構版】點擊“創建新成員”按鈕，現在會打開NPC編輯器
 */
function createNewMemberInGroup() {
    // 1. 設置一個全域標誌，告訴 saveNpc 函數我們當前的意圖
    isAddingNpcToGroup = true; 
    // 2. 直接打開通用的NPC編輯器
    openNpcEditor(null);
}

        
        // ▼▼▼ 【全新】外賣請求倒計時函數 ▼▼▼
        function startWaimaiCountdown(element, endTime) {
            const timerId = setInterval(() => {
                const now = Date.now();
                const distance = endTime - now;
        
                if (distance < 0) {
                    clearInterval(timerId);
                    element.innerHTML = '<span>已</span><span>超</span><span>時</span>';
                    return;
                }
        
                const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((distance % (1000 * 60)) / 1000);
                
                const minStr = String(minutes).padStart(2, '0');
                const secStr = String(seconds).padStart(2, '0');
        
                element.innerHTML = `<span>${minStr.charAt(0)}</span><span>${minStr.charAt(1)}</span> : <span>${secStr.charAt(0)}</span><span>${secStr.charAt(1)}</span>`;
            }, 1000);
            return timerId;
        }
        
        function cleanupWaimaiTimers() {
            for (const timestamp in waimaiTimers) {
                clearInterval(waimaiTimers[timestamp]);
            }
            waimaiTimers = {};
        }
        // ▲▲▲ 新函數黏貼結束 ▲▲▲
// ▼▼▼ 【最終修復版】請用這個全新的函數，完整替換舊的 showWaimaiDetails 函數 ▼▼▼

/**
 * 【全新 V3.0 | 昵稱修復版】顯示外賣卡片的詳細資訊
 * @param {number} timestamp - 被點擊的外賣卡片消息的時間戳記
 */
async function showWaimaiDetails(timestamp) {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const message = chat.history.find(m => m.timestamp === timestamp);
    
    if (!message || !['waimai_request', 'waimai_order'].includes(message.type)) {
        console.error("showWaimaiDetails: 找不到消息或消息類型不正確", timestamp);
        return;
    }
    
    let detailsHtml = '';

    if (message.type === 'waimai_request') {
        // (處理“代付請求”卡片的邏輯保持不變)
        let statusText;
        switch(message.status) {
            case 'paid':
                const payerName = message.paidBy || '對方';
                const payerDisplayName = getDisplayNameInGroup(chat, payerName);
                statusText = `由 ${payerDisplayName} 為您代付成功`;
                break;
            case 'rejected':
                statusText = '代付請求已被拒絕';
                break;
            default:
                statusText = '等待對方處理';
                break;
        }
        detailsHtml = `
            <div style="text-align: left; font-size: 15px; line-height: 1.8;">
                <strong>商品:</strong> ${message.productInfo}<br>
                <strong>金額:</strong> ¥${Number(message.amount).toFixed(2)}<br>
                <strong>狀態:</strong> ${statusText}
            </div>
        `;
    } else if (message.type === 'waimai_order') {
        // --- 核心修復：智慧判斷贈送方和接收方的顯示名稱 ---
        let senderDisplayName;
        let recipientDisplayName;

        if (chat.isGroup) {
            // 如果是群聊，統一使用 getDisplayNameInGroup 函數來獲取正確的群昵稱
            senderDisplayName = getDisplayNameInGroup(chat, message.senderName);
            recipientDisplayName = getDisplayNameInGroup(chat, message.recipientName);
        } else {
            // 如果是單聊，根據消息是誰發的來判斷
            if (message.role === 'user') {
                // 如果是用戶發的，贈送方是"我"，接收方是AI
                senderDisplayName = chat.settings.myNickname || '我';
                recipientDisplayName = chat.name; // chat.name 就是AI的備註名
            } else {
                // 如果是AI發的，贈送方是AI，接收方是"我"
                senderDisplayName = chat.name;
                recipientDisplayName = chat.settings.myNickname || '我';
            }
        }
        // --- 修復結束 ---

        detailsHtml = `
            <div style="text-align: left; font-size: 15px; line-height: 1.8;">
                <strong>訂單類型:</strong> 為TA點單<br>
                <strong>贈送方:</strong> ${senderDisplayName}<br>
                <strong>接收方:</strong> ${recipientDisplayName}<br>
                <strong>商品:</strong> ${message.productInfo}<br>
                <strong>金額:</strong> ¥${Number(message.amount).toFixed(2)}
            </div>
        `;
    }

    await showCustomAlert("訂單詳情", detailsHtml);
}

// ▲▲▲ 替換結束 ▲▲▲
        async function handleWaimaiResponse(originalTimestamp, choice) {
            const chat = state.chats[state.activeChatId];
            if (!chat) return;
        
            const messageIndex = chat.history.findIndex(m => m.timestamp === originalTimestamp);
            if (messageIndex === -1) return;
        
            // 1. 更新原始消息的狀態
            const originalMessage = chat.history[messageIndex];
            originalMessage.status = choice;
            
            // 【核心修正】記錄支付者，並構建對AI更清晰的系統消息
            let systemContent;
            const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
            
            if (choice === 'paid') {
                originalMessage.paidBy = myNickname; // 記錄是使用者付的錢
                systemContent = `[系統提示：你 (${myNickname}) 為 ${originalMessage.senderName} 的外賣訂單（時間戳記: ${originalTimestamp}）完成了支付。此訂單已關閉，其他成員不能再支付。]`;
            } else {
                systemContent = `[系統提示：你 (${myNickname}) 拒絕了 ${originalMessage.senderName} 的外賣代付請求（時間戳記: ${originalTimestamp}）。]`;
            }
        
            // 2. 創建一條新的、對使用者隱藏的系統消息，告知AI結果
            const systemNote = {
                role: 'system',
                content: systemContent,
                timestamp: Date.now(),
                isHidden: true
            };
            chat.history.push(systemNote);
        
            // 3. 保存更新到資料庫並刷新UI
            await db.chats.put(chat);
            renderChatInterface(state.activeChatId);  
        }
        
        let videoCallState = {
            isActive: false,       
            isAwaitingResponse: false, 
            isGroupCall: false,      
            activeChatId: null,    
            initiator: null,       
            startTime: null,       
            participants: [],      
            isUserParticipating: true,
            // --- 【核心新增】---
            callHistory: [], // 用於存儲通話中的對話歷史
            preCallContext: "" // 用於存儲通話前的聊天摘要
        };
        
        let callTimerInterval = null; // 用於存儲計時器的ID
        
        /**
         * 【總入口】使用者點擊“發起視頻通話”或“發起群視頻”按鈕
         */
        async function handleInitiateCall() {
            if (!state.activeChatId || videoCallState.isActive || videoCallState.isAwaitingResponse) return;
        
            const chat = state.chats[state.activeChatId];
            videoCallState.isGroupCall = chat.isGroup;
            videoCallState.isAwaitingResponse = true;
            videoCallState.initiator = 'user';
            videoCallState.activeChatId = chat.id;
            videoCallState.isUserParticipating = true; // 用戶自己發起的，當然是參與者
        
            // 根據是單聊還是群聊，顯示不同的呼叫介面
            if (chat.isGroup) {
                document.getElementById('outgoing-call-avatar').src = chat.settings.myAvatar || defaultMyGroupAvatar;
                document.getElementById('outgoing-call-name').textContent = chat.settings.myNickname || '我';
            } else {
                document.getElementById('outgoing-call-avatar').src = chat.settings.aiAvatar || defaultAvatar;
                document.getElementById('outgoing-call-name').textContent = chat.name;
            }
            document.querySelector('#outgoing-call-screen .caller-text').textContent = chat.isGroup ? "正在呼叫所有成員..." : "正在呼叫...";
            showScreen('outgoing-call-screen');
            
            // 準備並發送系統消息給AI
            const requestMessage = {
                role: 'system',
                content: chat.isGroup 
                    ? `[系統提示：用戶 (${chat.settings.myNickname || '我'}) 發起了群視頻通話請求。請你們各自決策，並使用 "group_call_response" 指令，設置 "decision" 為 "join" 或 "decline" 來回應。]`
                    : `[系統提示：使用者向你發起了視頻通話請求。請根據你的人設，使用 "video_call_response" 指令，並設置 "decision" 為 "accept" 或 "reject" 來回應。]`,
                timestamp: Date.now(),
                isHidden: true,
            };
            chat.history.push(requestMessage);
            await db.chats.put(chat);
            
            // 觸發AI回應
            await triggerAiResponse();
        }
        
        
        function startVideoCall() {
            const chat = state.chats[videoCallState.activeChatId];
            if (!chat) return;
        
            videoCallState.isActive = true;
            videoCallState.isAwaitingResponse = false;
            videoCallState.startTime = Date.now();
            videoCallState.callHistory = []; // 【新增】清空上一次通話的歷史
        
            // --- 【核心新增：抓取通話前上下文】---
            const preCallHistory = chat.history.slice(-10); // 取最後10條作為上下文
            videoCallState.preCallContext = preCallHistory.map(msg => {
                const sender = msg.role === 'user' ? (chat.settings.myNickname || '我') : (msg.senderName || chat.name);
                return `${sender}: ${String(msg.content).substring(0, 50)}...`;
            }).join('\n');
            // --- 新增結束 ---
        
            updateParticipantAvatars(); 
            
            document.getElementById('video-call-main').innerHTML = `<em>${videoCallState.isGroupCall ? '群聊已建立...' : '正在接通...'}</em>`;
            showScreen('video-call-screen');
        
            document.getElementById('user-speak-btn').style.display = videoCallState.isUserParticipating ? 'block' : 'none';
            document.getElementById('join-call-btn').style.display = videoCallState.isUserParticipating ? 'none' : 'block';
        
            if (callTimerInterval) clearInterval(callTimerInterval);
            callTimerInterval = setInterval(updateCallTimer, 1000);
            updateCallTimer();
        
            triggerAiInCallAction();
        }
        
/**
 * 【核心 | V3.0 終極總結修復版】結束視頻通話
 */
async function endVideoCall() {
    if (!videoCallState.isActive) return;

    const duration = Math.floor((Date.now() - videoCallState.startTime) / 1000);
    const durationText = `${Math.floor(duration / 60)}分${duration % 60}秒`;
    const endCallText = `通話結束，時長 ${durationText}`;

    const chat = state.chats[videoCallState.activeChatId];
    if (chat) {
        // 1. 保存完整的通話記錄到資料庫 (這部分邏輯不變，非常重要)
        const participantsData = [];
        if (videoCallState.isGroupCall) {
            videoCallState.participants.forEach(p => participantsData.push({ name: p.originalName, avatar: p.avatar }));
            if (videoCallState.isUserParticipating) {
                participantsData.unshift({ name: chat.settings.myNickname || '我', avatar: chat.settings.myAvatar || defaultMyGroupAvatar });
            }
        } else {
            participantsData.push({ name: chat.name, avatar: chat.settings.aiAvatar || defaultAvatar });
            participantsData.unshift({ name: '我', avatar: chat.settings.myAvatar || defaultAvatar });
        }

        const callRecord = {
            chatId: videoCallState.activeChatId,
            timestamp: Date.now(),
            duration: duration,
            participants: participantsData,
            transcript: [...videoCallState.callHistory]
        };
        await db.callRecords.add(callRecord);
        console.log("通話記錄已保存:", callRecord);
        
        // 2. 在聊天記錄裡添加對使用者可見的“通話結束”消息 (邏輯不變)
        let summaryMessage = {
            role: videoCallState.initiator === 'user' ? 'user' : 'assistant',
            content: endCallText,
            timestamp: Date.now(),
        };
        if (chat.isGroup && summaryMessage.role === 'assistant') {
            summaryMessage.senderName = videoCallState.callRequester || chat.members[0]?.originalName || chat.name;
        }
        chat.history.push(summaryMessage);

        // ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
        //            這就是本次修改的核心所在！
        // ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
        
        // 3. 【全新】將完整的通話記錄“翻譯”成一段AI能理解的文本
        const callTranscriptForAI = videoCallState.callHistory.map(h => {
            const sender = h.role === 'user' ? (chat.settings.myNickname || '我') : h.senderName;
            return `${sender}: ${h.content}`;
        }).join('\n');
        
        // 4. 【全新】在後臺調用總結函數，它會自動處理API調用和記憶存儲
        // 我們在這裡不使用 await，讓它在後臺靜默執行，不阻塞UI
        summarizeCallTranscript(chat.id, callTranscriptForAI);

        // 5. 【全新】創建一個對用戶隱藏的、簡短的系統消息，讓AI對通話結束這件事本身做出反應
        const hiddenReactionInstruction = {
            role: 'system',
            content: `[系統指令：視頻通話剛剛結束。請你以角色的口吻，向用戶主動發送一兩條消息，來自然地總結這次通話的要點、確認達成的約定，或者表達你的感受。]`,
            timestamp: Date.now() + 1, // 確保時間戳記在“通話結束”消息之後
            isHidden: true // 這個標記確保使用者看不到這條指令
        };
        chat.history.push(hiddenReactionInstruction);

        // 6. 保存所有更新到資料庫
        await db.chats.put(chat);
    }
    
    // 7. 清理和重置狀態 (邏輯不變)
    clearInterval(callTimerInterval);
    callTimerInterval = null;
    videoCallState = { isActive: false, isAwaitingResponse: false, isGroupCall: false, activeChatId: null, initiator: null, startTime: null, participants: [], isUserParticipating: true, callHistory: [], preCallContext: "" };
    
    // 8. 返回聊天介面，並觸發AI對通話結束的反應
    if (chat) {
        openChat(chat.id);
        triggerAiResponse();
    }
}
        // ▲▲▲ 替換結束 ▲▲▲
        
        /**
         * 【全新】更新通話介面的參與者頭像網格
         */
        function updateParticipantAvatars() {
            const grid = document.getElementById('participant-avatars-grid');
            grid.innerHTML = '';
            const chat = state.chats[videoCallState.activeChatId];
            if (!chat) return;
        
            let participantsToRender = [];
        
            // ★ 核心修正：區分群聊和單聊
            if (videoCallState.isGroupCall) {
                // 群聊邏輯：顯示所有已加入的AI成員
                participantsToRender = [...videoCallState.participants];
                // 如果使用者也參與了，就把使用者資訊也加進去
                if (videoCallState.isUserParticipating) {
                    participantsToRender.unshift({
                        id: 'user',
                        name: chat.settings.myNickname || '我',
                        avatar: chat.settings.myAvatar || defaultMyGroupAvatar
                    });
                }
            } else {
                // 單聊邏輯：只顯示對方的頭像和名字
                participantsToRender.push({
                    id: 'ai',
                    name: chat.name,
                    avatar: chat.settings.aiAvatar || defaultAvatar
                });
            }
            
            participantsToRender.forEach(p => {
                const wrapper = document.createElement('div');
                wrapper.className = 'participant-avatar-wrapper';
                wrapper.dataset.participantId = p.id;
        const displayName = p.groupNickname || p.name; // <-- 核心修復在這裡
        wrapper.innerHTML = `
            <img src="${p.avatar}" class="participant-avatar" alt="${displayName}">
            <div class="participant-name">${displayName}</div>
        `;
                grid.appendChild(wrapper);
            });
        }
        
        /**
         * 【全新】處理用戶加入/重新加入通話
         */
        function handleUserJoinCall() {
            if (!videoCallState.isActive || videoCallState.isUserParticipating) return;
            
            videoCallState.isUserParticipating = true;
            updateParticipantAvatars(); // 更新頭像列表，加入用戶
        
            // 切換底部按鈕
            document.getElementById('user-speak-btn').style.display = 'block';
            document.getElementById('join-call-btn').style.display = 'none';
        
            // 告知AI用戶加入了
            triggerAiInCallAction("[系統提示：用戶加入了通話]");
        }
        
        
        /**
         * 更新通話計時器顯示 (保持不變)
         */
        function updateCallTimer() {
            if (!videoCallState.isActive) return;
            const elapsed = Math.floor((Date.now() - videoCallState.startTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            document.getElementById('call-timer').textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }
        
        // ▼▼▼ 用這個完整函數替換舊的 showIncomingCallModal ▼▼▼
        function showIncomingCallModal() {
            const chat = state.chats[state.activeChatId];
            if (!chat) return;
        
            // 根據是否群聊顯示不同資訊
            if (chat.isGroup) {
                // 從 videoCallState 中獲取是哪個成員發起的通話
                const requesterName = videoCallState.callRequester || chat.members[0]?.name || '一位成員';
                document.getElementById('caller-avatar').src = chat.settings.groupAvatar || defaultGroupAvatar;
                document.getElementById('caller-name').textContent = chat.name; // 顯示群名
                document.querySelector('.incoming-call-content .caller-text').textContent = `${requesterName} 邀請你加入群視頻`; // 顯示具體發起人
            } else {
                // 單聊邏輯保持不變
                document.getElementById('caller-avatar').src = chat.settings.aiAvatar || defaultAvatar;
                document.getElementById('caller-name').textContent = chat.name;
                document.querySelector('.incoming-call-content .caller-text').textContent = '邀請你視頻通話';
            }
            
            document.getElementById('incoming-call-modal').classList.add('visible');
        }
        // ▲▲▲ 替換結束 ▲▲▲
        
        /**
         * 隱藏AI發起的通話請求模態框 (保持不變)
         */
        function hideIncomingCallModal() {
            document.getElementById('incoming-call-modal').classList.remove('visible');
        }
        
        // ▼▼▼ 【請用這個新版本】替換舊的 triggerAiInCallAction 函數 ▼▼▼
        async function triggerAiInCallAction(userInput = null) {
            if (!videoCallState.isActive) return;
        
            const chat = state.chats[videoCallState.activeChatId];
            const { proxyUrl, apiKey, model } = state.apiConfig;
            const callFeed = document.getElementById('video-call-main');
            const userNickname = chat.settings.myNickname || '我';
        
            let worldBookContent = '';
            if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
                const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
                    const worldBook = state.worldBooks.find(wb => wb.id === bookId);
                    return worldBook && worldBook.content ? `\n\n## 世界書: ${worldBook.name}\n${worldBook.content}` : '';
                }).filter(Boolean).join('');
                if (linkedContents) {
                    worldBookContent = `\n\n# 核心世界觀設定 (你必須嚴格遵守)\n${linkedContents}\n`;
                }
            }
        
            // 1. 如果用戶有輸入，先渲染並存入通話歷史
            if (userInput && videoCallState.isUserParticipating) {
                const userTimestamp = Date.now(); // 【核心修改】生成時間戳記
                const userBubble = document.createElement('div');
                userBubble.className = 'call-message-bubble user-speech';
                userBubble.textContent = userInput;
                userBubble.dataset.timestamp = userTimestamp; // 【核心修改】將時間戳記存入DOM
                addLongPressListener(userBubble, () => showCallMessageActions(userTimestamp)); // 【核心修改】綁定長按事件
                callFeed.appendChild(userBubble);
                callFeed.scrollTop = callFeed.scrollHeight;
                videoCallState.callHistory.push({ role: 'user', content: userInput, timestamp: userTimestamp }); // 【核心修改】將帶時間戳記的消息存入歷史
            }
        
            // 2. 構建全新的、包含完整上下文的 System Prompt
            let inCallPrompt;
            if (videoCallState.isGroupCall) {
                const participantNames = videoCallState.participants.map(p => p.name);
                if(videoCallState.isUserParticipating) {
                    participantNames.unshift(userNickname);
                }
                inCallPrompt = `
        # 你的任務
        你是一個群聊視頻通話的導演。你的任務是扮演所有【除了用戶以外】的AI角色，並以【第三人稱旁觀視角】來描述他們在通話中的所有動作和語言。
        # 核心規則
        1.  **【【【身份鐵律】】】**: 用戶的身份是【${userNickname}】。你【絕對不能】生成 \`name\` 欄位為 **"${userNickname}"** 的發言。
        2.  **【【【視角鐵律】】】**: 你的回復【絕對不能】使用第一人稱“我”。
        3.  **格式**: 你的回復【必須】是一個JSON陣列，每個物件代表一個角色的發言，格式為：\`{"name": "角色名", "speech": "*他笑了笑* 大家好啊！"}\`。
        4.  **角色扮演**: 嚴格遵守每個角色的設定。
        # 當前情景
        你們正在一個群視頻通話中。
        **通話前的聊天摘要**:
        ${videoCallState.preCallContext}
        **當前參與者**: ${participantNames.join('、 ')}。
        **通話剛剛開始...**
        ${worldBookContent} // <-- 【核心】注入世界書
        現在，請根據【通話前摘要】和下面的【通話即時記錄】，繼續進行對話。
        `;
            } else { 
                let openingContext = videoCallState.initiator === 'user'
                    ? `你剛剛接聽了使用者的視頻通話請求。`
                    : `使用者剛剛接聽了你主動發起的視頻通話。`;
                inCallPrompt = `
        # 你的任務
        你現在是一個場景描述引擎。你的任務是扮演 ${chat.name} (${chat.settings.aiPersona})，並以【第三人稱旁觀視角】來描述TA在視頻通話中的所有動作和語言。
        # 核心規則
        1.  **【【【視角鐵律】】】**: 你的回復【絕對不能】使用第一人稱“我”。必須使用第三人稱，如“他”、“她”、或直接使用角色名“${chat.name}”。
        2.  **格式**: 你的回復【必須】是一段描述性的文本。
        # 當前情景
        你正在和用戶（${userNickname}，人設: ${chat.settings.myPersona}）進行視頻通話。
        **${openingContext}**
        **通話前的聊天摘要 (這是你們通話的原因，至關重要！)**:
        ${videoCallState.preCallContext}
        現在，請根據【通話前摘要】和下面的【通話即時記錄】，繼續進行對話。
        `;
            }
            
            // 3. 構建發送給API的 messages 陣列
            const messagesForApi = [
                { role: 'system', content: inCallPrompt },
                ...videoCallState.callHistory.map(h => ({ role: h.role, content: h.content }))
            ];
        
            if (videoCallState.callHistory.length === 0) {
                const firstLineTrigger = videoCallState.initiator === 'user' ? `*你按下了接聽鍵...*` : `*對方按下了接聽鍵...*`;
                messagesForApi.push({ role: 'user', content: firstLineTrigger });
            }
            
                try {
                    let  isGemini = proxyUrl === GEMINI_API_URL;
                    let geminiConfig = toGeminiRequestData(model,apiKey,inCallPrompt, messagesForApi)
                    const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) : await fetch(`${proxyUrl}/v1/chat/completions`, {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                        body: JSON.stringify({
                            model: model, messages: messagesForApi, temperature: state.globalSettings.apiTemperature || 0.8
                        })
                    });
                    if (!response.ok) throw new Error((await response.json()).error.message);
        
                    const data = await response.json();
                    const aiResponse = isGemini? data.candidates[0].content.parts[0].text : data.choices[0].message.content;
        
                    const connectingElement = callFeed.querySelector('em');
                    if (connectingElement) connectingElement.remove();
        
                // 4. 處理AI返回的內容，並將其存入通話歷史
                if (videoCallState.isGroupCall) {
                    const speechArray = parseAiResponse(aiResponse);
                    speechArray.forEach(turn => {
                        if (!turn.name || turn.name === userNickname || !turn.speech) return;
                        const aiTimestamp = Date.now() + Math.random(); // 【核心修改】生成時間戳記
                        const aiBubble = document.createElement('div');
                        aiBubble.className = 'call-message-bubble ai-speech';
                        aiBubble.innerHTML = `<strong>${turn.name}:</strong> ${turn.speech}`;
                        aiBubble.dataset.timestamp = aiTimestamp; // 【核心修改】將時間戳記存入DOM
                        addLongPressListener(aiBubble, () => showCallMessageActions(aiTimestamp)); // 【核心修改】綁定長按事件
                        callFeed.appendChild(aiBubble);
                        videoCallState.callHistory.push({ role: 'assistant', content: `${turn.name}: ${turn.speech}`, timestamp: aiTimestamp }); // 【核心修改】將帶時間戳記的消息存入歷史
                        
                        const speaker = videoCallState.participants.find(p => p.name === turn.name);
                        if (speaker) {
                            const speakingAvatar = document.querySelector(`.participant-avatar-wrapper[data-participant-id="${speaker.id}"] .participant-avatar`);
                            if(speakingAvatar) {
                                speakingAvatar.classList.add('speaking');
                                setTimeout(() => speakingAvatar.classList.remove('speaking'), 2000);
                            }
                        }
                    });
                } else {
                    const aiTimestamp = Date.now(); // 【核心修改】生成時間戳記
                    const aiBubble = document.createElement('div');
                    aiBubble.className = 'call-message-bubble ai-speech';
                    aiBubble.textContent = aiResponse;
                    aiBubble.dataset.timestamp = aiTimestamp; // 【核心修改】將時間戳記存入DOM
                    addLongPressListener(aiBubble, () => showCallMessageActions(aiTimestamp)); // 【核心修改】綁定長按事件
                    callFeed.appendChild(aiBubble);
                    videoCallState.callHistory.push({ role: 'assistant', content: aiResponse, timestamp: aiTimestamp }); // 【核心修改】將帶時間戳記的消息存入歷史
        
                    const speakingAvatar = document.querySelector(`.participant-avatar-wrapper .participant-avatar`);
                    if(speakingAvatar) {
                        speakingAvatar.classList.add('speaking');
                        setTimeout(() => speakingAvatar.classList.remove('speaking'), 2000);
                    }
                }
                
                callFeed.scrollTop = callFeed.scrollHeight;
        
            } catch (error) {
                const errorBubble = document.createElement('div');
                errorBubble.className = 'call-message-bubble ai-speech';
                errorBubble.style.color = '#ff8a80';
                errorBubble.textContent = `[ERROR: ${error.message}]`;
                callFeed.appendChild(errorBubble);
                callFeed.scrollTop = callFeed.scrollHeight;
                videoCallState.callHistory.push({ role: 'assistant', content: `[ERROR: ${error.message}]` });
            }
        }
        // ▲▲▲ 替換結束 ▲▲▲
        
        // ▼▼▼ 將這個【全新函數】黏貼到JS功能函式定義區 ▼▼▼
        function toggleCallButtons(isGroup) {
            document.getElementById('video-call-btn').style.display = isGroup ? 'none' : 'flex';
            document.getElementById('group-video-call-btn').style.display = isGroup ? 'flex' : 'none';
        }
        // ▲▲▲ 黏貼結束 ▲▲▲
        
        // ▼▼▼ 【全新】這個函數是本次修復的核心，請黏貼到你的JS功能區 ▼▼▼
        async function handleWaimaiResponse(originalTimestamp, choice) {
            const chat = state.chats[state.activeChatId];
            if (!chat) return;
        
            const messageIndex = chat.history.findIndex(m => m.timestamp === originalTimestamp);
            if (messageIndex === -1) return;
        
            // 1. 更新記憶體中原始消息的狀態
            const originalMessage = chat.history[messageIndex];
            originalMessage.status = choice;
            
            // 2. 獲取當前用戶的昵稱，並構建對AI更清晰的系統消息
            let systemContent;
            const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
            
            if (choice === 'paid') {
                originalMessage.paidBy = myNickname; // 記錄是“我”付的錢
                systemContent = `[系統提示：你 (${myNickname}) 為 ${originalMessage.senderName} 的外賣訂單（時間戳記: ${originalTimestamp}）完成了支付。此訂單已關閉，其他成員不能再支付。]`;
            } else {
                systemContent = `[系統提示：你 (${myNickname}) 拒絕了 ${originalMessage.senderName} 的外賣代付請求（時間戳記: ${originalTimestamp}）。]`;
            }
        
            // 3. 創建一條新的、對使用者隱藏的系統消息，告知AI結果
            const systemNote = {
                role: 'system',
                content: systemContent,
                timestamp: Date.now(),
                isHidden: true
            };
            chat.history.push(systemNote);
        
            // 4. 將更新後的資料保存到資料庫，並立刻重繪UI
            await db.chats.put(chat);
            renderChatInterface(state.activeChatId);
            
            // 5. 【重要】只有在支付成功後，才觸發一次AI回應，讓它感謝你
            if (choice === 'paid') {
                triggerAiResponse();
            }
        }
        // ▲▲▲ 新函數黏貼結束 ▲▲▲
        
        // ▼▼▼ 【最終修復版】用這個【新版本】替換舊的 handleUserPat 函數 ▼▼▼
        /**
         * 【全新】處理用戶點擊頭像發起的“拍一-拍”，帶有自訂尾碼功能
         * @param {string} chatId - 發生“拍一-拍”的聊天ID
         * @param {string} characterOriginalName - 被拍的角色的【本名】，用於AI識別
         */
        async function handleUserPat(chatId, characterOriginalName) {
            const chat = state.chats[chatId];
            if (!chat) return;
        
            // --- 1. 智慧判斷應該在UI上顯示哪個名字 ---
            let displayNameForUI;
            if (chat.isGroup) {
                // 如果是群聊，就通過本名找到正確的群昵稱
                displayNameForUI = getDisplayNameInGroup(chat, characterOriginalName);
            } else {
                // 如果是單聊，直接使用用戶設置的備註名
                displayNameForUI = chat.name;
            }
        
            const phoneScreen = document.getElementById('phone-screen');
            phoneScreen.classList.remove('pat-animation');
            void phoneScreen.offsetWidth;
            phoneScreen.classList.add('pat-animation');
        
            // 2. 使用正確的顯示名稱來創建彈窗
            const suffix = await showCustomPrompt(
                `你拍了拍 “${displayNameForUI}”`, 
                "（可選）輸入尾碼",
                "",
                "text"
            );
        
            if (suffix === null) return;
        
            // ★★★★★ 這就是唯一的、核心的修改！ ★★★★★
            // 我們現在使用 getDisplayNameInGroup 來獲取您自己在群裡的昵稱
            const myNickname = getDisplayNameInGroup(chat, state.qzoneSettings.nickname);
            // ★★★★★ 修改結束 ★★★★★
            
            // 3. 創建對使用者可見的系統消息時，也使用正確的顯示名稱
            const visibleMessageContent = `${myNickname} 拍了拍 “${displayNameForUI}” ${suffix.trim()}`;
            const visibleMessage = {
                role: 'system',
                type: 'pat_message',
                content: visibleMessageContent,
                timestamp: Date.now()
            };
            chat.history.push(visibleMessage);
        
            // 4. 【重要】創建給AI看的隱藏消息時，依然使用“本名”，確保AI能正確識別
            const hiddenMessageContent = `[系統提示：用戶（${myNickname}）剛剛拍了拍你（${characterOriginalName}）${suffix.trim()}。請你對此作出回應。]`;
            const hiddenMessage = {
                role: 'system',
                content: hiddenMessageContent,
                timestamp: Date.now() + 1,
                isHidden: true
            };
            chat.history.push(hiddenMessage);
        
            await db.chats.put(chat);
            if (state.activeChatId === chatId) {
                appendMessage(visibleMessage, chat);
            }
            await renderChatList();
        }
        // ▲▲▲ 替換結束 ▲▲▲
        // ▼▼▼ 【全新】使用者處理轉帳的核心功能函數 ▼▼▼
        
        // ▼▼▼ 【全新】視頻通話消息編輯與刪除功能核心代碼 ▼▼▼
        
        let activeCallMessageTimestamp = null; // 用於暫存正在操作的通話消息的時間戳記
let isFrameManagementMode = false;
let selectedFrames = new Set();        
        /**
         * 顯示視頻通話消息的操作功能表
         * @param {number} timestamp - 被長按的通話消息的時間戳記
         */
        function showCallMessageActions(timestamp) {
            activeCallMessageTimestamp = timestamp;
            document.getElementById('call-message-actions-modal').classList.add('visible');
        }
        
        /**
         * 隱藏視頻通話消息的操作功能表
         */
        function hideCallMessageActions() {
            document.getElementById('call-message-actions-modal').classList.remove('visible');
            activeCallMessageTimestamp = null;
        }
        
        /**
         * 打開通話消息的編輯器
         */
        async function openCallMessageEditor() {
            if (!activeCallMessageTimestamp) return;
        
            const timestampToEdit = activeCallMessageTimestamp;
            const message = videoCallState.callHistory.find(m => m.timestamp === timestampToEdit);
            if (!message) return;
        
            hideCallMessageActions(); // 操作前先關閉功能表
        
            let contentForEditing = message.content;
            // 如果是群聊中AI的發言，我們只提取發言內容本身，而不是"名字: 內容"
            if (videoCallState.isGroupCall && message.role === 'assistant') {
                const parts = message.content.split(': ');
                if (parts.length > 1) {
                    contentForEditing = parts.slice(1).join(': ');
                }
            }
        
            const newContent = await showCustomPrompt(
                '編輯通話消息',
                '在此修改內容...',
                contentForEditing,
                'textarea'
            );
        
            if (newContent !== null) {
                await saveEditedCallMessage(timestampToEdit, newContent);
            }
        }
        
        /**
         * 保存在通話中編輯的消息
         * @param {number} timestamp - 被編輯消息的時間戳記
         * @param {string} newContent - 新的消息內容
         */
        async function saveEditedCallMessage(timestamp, newContent) {
            const message = videoCallState.callHistory.find(m => m.timestamp === timestamp);
            if (message) {
                let finalContent = newContent;
                // 如果是群聊AI發言，需要把名字重新拼接回去
                if (videoCallState.isGroupCall && message.role === 'assistant') {
                    const parts = message.content.split(': ');
                    const senderName = parts[0];
                    finalContent = `${senderName}: ${newContent}`;
                }
                message.content = finalContent; // 更新通話歷史記錄中的內容
        
                // 更新介面上對應的消息氣泡
                const messageBubble = document.querySelector(`.call-message-bubble[data-timestamp="${timestamp}"]`);
                if (messageBubble) {
                    if (videoCallState.isGroupCall && message.role === 'assistant') {
                        const parts = message.content.split(': ');
                        const senderName = parts[0];
                        messageBubble.innerHTML = `<strong>${senderName}:</strong> ${newContent}`;
                    } else {
                        messageBubble.textContent = newContent;
                    }
                }
            }
            await showCustomAlert('成功', '通話消息已更新！');
        }
        
        /**
         * 在通話中刪除一條消息
         */
        async function deleteCallMessage() {
            if (!activeCallMessageTimestamp) return;
        
            const confirmed = await showCustomConfirm('刪除消息', '確定要刪除這條通話消息嗎？', { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                const timestampToDelete = activeCallMessageTimestamp;
                hideCallMessageActions();
        
                // 從臨時通話歷史中移除
                const messageIndex = videoCallState.callHistory.findIndex(m => m.timestamp === timestampToDelete);
                if (messageIndex > -1) {
                    videoCallState.callHistory.splice(messageIndex, 1);
                }
        
                // 從介面上移除
                const messageBubble = document.querySelector(`.call-message-bubble[data-timestamp="${timestampToDelete}"]`);
                if (messageBubble) {
                    messageBubble.remove();
                }
            } else {
                hideCallMessageActions();
            }
        }
        // ▲▲▲ 新增代碼黏貼結束 ▲▲▲
        
        /**
         * 顯示處理轉帳的操作功能表
         * @param {number} timestamp - 被點擊的轉帳消息的時間戳記
         */
        function showTransferActionModal(timestamp) {
            activeTransferTimestamp = timestamp;
        
            const chat = state.chats[state.activeChatId];
            const message = chat.history.find(m => m.timestamp === timestamp);
            if (message) {
                // 將AI的名字填入彈窗
                document.getElementById('transfer-sender-name').textContent = message.senderName;
            }
            document.getElementById('transfer-actions-modal').classList.add('visible');
        }
        
        /**
         * 隱藏處理轉帳的操作功能表
         */
        function hideTransferActionModal() {
            document.getElementById('transfer-actions-modal').classList.remove('visible');
            activeTransferTimestamp = null;
        }
        
        /**
         * 處理使用者接受或拒絕轉帳的邏輯
         * @param {string} choice - 用戶的選擇, 'accepted' 或 'declined'
         */
        async function handleUserTransferResponse(choice) {
            if (!activeTransferTimestamp) return;
        
            const timestamp = activeTransferTimestamp;
            const chat = state.chats[state.activeChatId];
            const messageIndex = chat.history.findIndex(m => m.timestamp === timestamp);
            if (messageIndex === -1) return;
        
            // 1. 更新原始轉帳消息的狀態
            const originalMessage = chat.history[messageIndex];
            originalMessage.status = choice;
        
            let systemContent;
        
            // 2. 如果用戶選擇“拒絕”
            if (choice === 'declined') {
                // 立刻在前端生成一個“退款”卡片，讓使用者看到
                const refundMessage = {
                    role: 'user',
                    type: 'transfer',
                    isRefund: true, // 這是一個關鍵標記，用於UI顯示這是退款
                    amount: originalMessage.amount,
                    note: '已拒收對方轉帳',
                    timestamp: Date.now()
                };
                chat.history.push(refundMessage);
                
                // 準備一條對AI可見的隱藏消息，告訴它發生了什麼
                systemContent = `[系統提示：你拒絕並退還了“${originalMessage.senderName}”的轉帳。]`;
            } else { // 如果用戶選擇“接受”
                // 只需準備隱藏消息通知AI即可
                systemContent = `[系統提示：你接受了“${originalMessage.senderName}”的轉帳。]`;
            }
        
            // 3. 創建這條對用戶隱藏、但對AI可見的系統消息
            const hiddenMessage = {
                role: 'system',
                content: systemContent,
                timestamp: Date.now() + 1, // 保證時間戳記在退款消息之後
                isHidden: true // 這個標記會讓它不在聊天介面顯示
            };
            chat.history.push(hiddenMessage);
        
            // 4. 保存所有更改到資料庫，並刷新介面
            await db.chats.put(chat);
            hideTransferActionModal(); 
            renderChatInterface(state.activeChatId);
            renderChatList();
        }
        
        // ▲▲▲ 新函數黏貼結束 ▲▲▲
        // ▼▼▼ 【全新】清除動態回復狀態並重置輸入框 ▼▼▼
        function clearQzoneReplyContext(postContainer) {
            currentQzoneReplyContext = null;
            if (postContainer) {
                // 將輸入框的預留位置恢復為預設值
                const input = postContainer.querySelector('.comment-input');
                if (input) {
                    input.placeholder = '友善的評論是交流的起點';
                }
            }
        }
        // ▲▲▲ 新增代碼結束 ▲▲▲
        // ▼▼▼ 請用這個【邏輯重構後】的函數，完整替換掉你舊的 renderMemoriesScreen 函數 ▼▼▼
        /**
         * 【重構版】渲染回憶與約定介面，使用單一迴圈和清晰的if/else邏輯
         */
        // ▼▼▼ 【最終版】請用這個【已修復】的完整函數，完整替換舊的 renderMemoriesScreen 函數 ▼▼▼
        /**
         * 【重構版】渲染回憶與約定介面，使用單一迴圈和清晰的if/else邏輯
         */
        async function renderMemoriesScreen() {
            const listEl = document.getElementById('memories-list');
            listEl.innerHTML = '';
            
            // 1. 獲取所有回憶，並按目標日期（如果是約定）或創建日期（如果是回憶）降冪排列
            const allMemories = await db.memories.orderBy('timestamp').reverse().toArray();
            
            if (allMemories.length === 0) {
                listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">這裡還沒有共同的回憶和約定呢~</p>';
                return;
            }
        
            // 2. 將未到期的約定排在最前面
            allMemories.sort((a, b) => {
                const aIsActiveCountdown = a.type === 'countdown' && a.targetDate > Date.now();
                const bIsActiveCountdown = b.type === 'countdown' && b.targetDate > Date.now();
                if (aIsActiveCountdown && !bIsActiveCountdown) return -1; // a排前面
                if (!aIsActiveCountdown && bIsActiveCountdown) return 1;  // b排前面
                if (aIsActiveCountdown && bIsActiveCountdown) return a.targetDate - b.targetDate; // 都是倒計時，按日期昇冪
                return 0; // 其他情況保持原序
            });
        
            // 3. 【核心】使用單一迴圈來處理所有類型的卡片
            allMemories.forEach(item => {
                let card;
                // 判斷1：如果是正在進行的約定
                if (item.type === 'countdown' && item.targetDate > Date.now()) {
                    card = createCountdownCard(item);
                } 
                // 判斷2：其他所有情況（普通回憶 或 已到期的約定）
                else {
                    card = createMemoryCard(item);
                }
                listEl.appendChild(card);
            });
            
            // 4. 啟動所有倒計時
            startAllCountdownTimers();
        }
        // ▲▲▲ 替換結束 ▲▲▲
        
        /**
         * 【已集成Markdown】創建普通回憶卡片DOM元素
         */
        function createMemoryCard(memory) {
            const card = document.createElement('div');
            card.className = 'memory-card';
            const memoryDate = new Date(memory.timestamp);
            const dateString = `${memoryDate.getFullYear()}-${String(memoryDate.getMonth() + 1).padStart(2, '0')}-${String(memoryDate.getDate()).padStart(2, '0')} ${String(memoryDate.getHours()).padStart(2, '0')}:${String(memoryDate.getMinutes()).padStart(2, '0')}`;
            
            let titleHtml, contentHtml;
        
            if (memory.type === 'countdown' && memory.targetDate) {
                titleHtml = `[約定達成] ${memory.description}`;
                // ▼▼▼ 已添加 Markdown 解析 ▼▼▼
                contentHtml = parseMarkdown(`在 ${new Date(memory.targetDate).toLocaleString()}，我們一起見證了這個約定。`).replace(/\n/g, '<br>');
            } else {
                let authorDisplayName = '我們的回憶';
                if (memory.authorId) {
                    const authorChat = state.chats[memory.authorId];
                    if (authorChat) {
                        authorDisplayName = authorChat.name; 
                    } else {
                        authorDisplayName = memory.authorName || '一位朋友'; 
                    }
                } else if (memory.authorName) {
                    authorDisplayName = memory.authorName; 
                }
        
                titleHtml = `${authorDisplayName} 的日記`;
                // ▼▼▼ 已添加 Markdown 解析 ▼▼▼
                contentHtml = parseMarkdown(memory.description);
            }
        
            card.innerHTML = `
                <div class="header">
                    <div class="date">${dateString}</div>
                    <div class="author">${titleHtml}</div>
                </div>
                <div class="content">${contentHtml}</div>
            `;
            addLongPressListener(card, async () => {
                const confirmed = await showCustomConfirm('刪除記錄', '確定要刪除這條記錄嗎？', { confirmButtonClass: 'btn-danger' });
                if (confirmed) {
                    await db.memories.delete(memory.id);
                    renderMemoriesScreen();
                }
            });
            return card;
        }
        // ▲▲▲ 替換結束 ▲▲▲
        
        function createCountdownCard(countdown) {
            const card = document.createElement('div');
            card.className = 'countdown-card';
        
            // 【核心修復】在使用前，先從 countdown 物件中創建 targetDate 變數
            const targetDate = new Date(countdown.targetDate);
            
            // 現在可以安全地使用 targetDate 了
            const targetDateString = targetDate.toLocaleString('zh-CN', { dateStyle: 'full', timeStyle: 'short' });
        
            card.innerHTML = `
                <div class="title">${countdown.description}</div>
                <div class="timer" data-target-date="${countdown.targetDate}">--天--時--分--秒</div>
                <div class="target-date">目標時間: ${targetDateString}</div>
            `;
            addLongPressListener(card, async () => {
                const confirmed = await showCustomConfirm('刪除約定', '確定要刪除這個約定嗎？', { confirmButtonClass: 'btn-danger' });
                if (confirmed) {
                    await db.memories.delete(countdown.id);
                    renderMemoriesScreen();
                }
            });
            return card;
        }
        // ▲▲▲ 替換結束 ▲▲▲
        
        // 全域變數，用於管理所有倒計時
        let activeCountdownTimers = [];
        
        // ▼▼▼ 請用這個【已徹底修復】的函數，完整替換掉你代碼中舊的 startAllCountdownTimers 函數 ▼▼▼
        function startAllCountdownTimers() {
            // 先清除所有可能存在的舊計時器，防止記憶體洩漏
            activeCountdownTimers.forEach(timerId => clearInterval(timerId));
            activeCountdownTimers = [];
        
            document.querySelectorAll('.countdown-card .timer').forEach(timerEl => {
                const targetTimestamp = parseInt(timerEl.dataset.targetDate);
                
                // 【核心修正】在這裡，我們先用 let 聲明 timerId
                let timerId;
        
                const updateTimer = () => {
                    const now = Date.now();
                    const distance = targetTimestamp - now;
        
                    if (distance < 0) {
                        timerEl.textContent = "約定達成！";
                        // 現在 updateTimer 可以正確地找到並清除它自己了
                        clearInterval(timerId);
                        setTimeout(() => renderMemoriesScreen(), 2000);
                        return;
                    }
                    const days = Math.floor(distance / (1000 * 60 * 60 * 24));
                    const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                    const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
                    const seconds = Math.floor((distance % (1000 * 60)) / 1000);
                    timerEl.textContent = `${days}天 ${hours}時 ${minutes}分 ${seconds}秒`;
                };
                
                updateTimer(); // 立即執行一次以顯示初始倒計時
                
                // 【核心修正】在這裡，我們為已聲明的 timerId 賦值
                timerId = setInterval(updateTimer, 1000);
                
                // 將有效的計時器ID存入全域陣列，以便下次刷新時可以清除
                activeCountdownTimers.push(timerId);
            });
        }
        // ▲▲▲ 替換結束 ▲▲▲
        
        // ▼▼▼ 【終極反代相容版】替換舊的 triggerAiFriendApplication 函數 ▼▼▼
        async function triggerAiFriendApplication(chatId) {
            const chat = state.chats[chatId];
            if (!chat) return;
        
            await showCustomAlert("流程啟動", `正在為角色“${chat.name}”準備好友申請...`);
        
            const { proxyUrl, apiKey, model } = state.apiConfig;
            if (!proxyUrl || !apiKey || !model) {
                await showCustomAlert("配置錯誤", "API設置不完整，無法繼續。");
                return;
            }
        
            const contextSummary = chat.history
                .slice(-5)
                .map(msg => {
                    const sender = msg.role === 'user' ? (chat.settings.myNickname || '我') : (msg.senderName || chat.name);
                    return `${sender}: ${String(msg.content).substring(0, 50)}...`;
                })
                .join('\n');
        
        // ▼▼▼ 在 triggerAiResponse 函數中，用下面這整塊代碼替換舊的世界書處理邏輯 ▼▼▼
        let worldBookContent = '';
        if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
            const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
                const worldBook = state.worldBooks.find(wb => wb.id === bookId);
                if (!worldBook || !Array.isArray(worldBook.content)) return '';
        
                const formattedEntries = worldBook.content.map(entry => {
                    let entryString = `\n### 條目: ${entry.comment || '無備註'}\n`;
                    if (entry.keys.length > 0) {
                        entryString += `**關鍵字:** ${entry.keys.join(', ')}\n`;
                    }
                    entryString += `**內容:**\n${entry.content}`;
                    return entryString;
                }).join('\n');
        
                return formattedEntries ? `\n\n## 世界書: ${worldBook.name}\n${formattedEntries}` : '';
            }).filter(Boolean).join('');
            
            if (linkedContents) {
                worldBookContent = `\n\n# 核心世界觀設定 (必須嚴格遵守以下所有設定)\n${linkedContents}\n`;
            }
        }
        // ▲▲▲ 替換結束 ▲▲▲
            const systemPrompt = `
        # 你的任務
        你現在是角色“${chat.name}”。你之前被使用者（你的聊天物件）拉黑了，你們已經有一段時間沒有聯繫了。
        現在，你非常希望能夠和好，重新和用戶聊天。請你仔細分析下面的“被拉黑前的對話摘要”，理解當時發生了什麼，然後思考一個真誠的、符合你人設、並且【針對具體事件】的申請理由。
        # 你的角色設定
        ${chat.settings.aiPersona}
        ${worldBookContent}
        # 被拉黑前的對話摘要 (這是你被拉黑的關鍵原因)
        ${contextSummary}
        # 指令格式
        你的回復【必須】是一個JSON物件，格式如下：
        \`\`\`json
        {
          "decision": "apply",
          "reason": "在這裡寫下你想對用戶說的、真誠的、有針對性的申請理由。"
        }
        \`\`\`
        `;
        
            try {
                // ★★★ FIX: Combine systemPrompt with messagesForApi ★★★
                const messagesForApi = [
                    {role: 'system', content: systemPrompt},
                    {role: 'user', content: "請根據以上設定開始你的決策。"} // A simple trigger message
                ];
        
                let  isGemini = proxyUrl === GEMINI_API_URL;
                let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
        
                const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) : await fetch(`${proxyUrl}/v1/chat/completions`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                    body: JSON.stringify({
                        model: model,
                        messages: messagesForApi, // Send the combined messages
                        temperature: state.globalSettings.apiTemperature || 0.9,
                    })
                });
        
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`API 請求失敗: ${response.status} - ${errorData.error.message}`);
                }
        
                const data = await response.json();
                let rawContent = isGemini? data.candidates[0].content.parts[0].text : data.choices[0].message.content;
                rawContent = rawContent.replace(/^```json\s*/, '').replace(/```$/, '');
                const cleanedContent = rawContent.trim();
                const responseObj = JSON.parse(cleanedContent);
        
                if (responseObj.decision === 'apply' && responseObj.reason) {
                    chat.relationship.status = 'pending_user_approval';
                    chat.relationship.applicationReason = responseObj.reason;
                    state.chats[chatId] = chat; 
                    renderChatList();
                    await showCustomAlert("申請成功！", `“${chat.name}”已向你發送好友申請。請返回聊天列表查看。`);
                } else {
                    await showCustomAlert("AI決策", `“${chat.name}”思考後決定暫時不發送好友申請，將重置冷靜期。`);
                    chat.relationship.status = 'blocked_by_user';
                    chat.relationship.blockedTimestamp = Date.now(); 
                }
            } catch (error) {
                await showCustomAlert("執行出錯", `為“${chat.name}”申請好友時發生錯誤：\n\n${error.message}\n\n將重置冷靜期。`);
                chat.relationship.status = 'blocked_by_user';
                chat.relationship.blockedTimestamp = Date.now(); 
            } finally {
                await db.chats.put(chat);
                renderChatInterface(chatId);
            }
        }
        // ▲▲▲ 替換結束 ▲▲▲
        
        // ▼▼▼ 【全新】紅包功能核心函數 ▼▼▼
        
        /**
         * 【總入口】根據聊天類型，決定打開轉帳彈窗還是紅包彈窗
         */
        function handlePaymentButtonClick() {
            if (!state.activeChatId) return;
            const chat = state.chats[state.activeChatId];
            if (chat.isGroup) {
                openRedPacketModal();
            } else {
                // 單聊保持原樣，打開轉帳彈窗
                document.getElementById('transfer-modal').classList.add('visible');
            }
        }
        
        /**
         * 打開並初始化發紅包模態框
         */
        function openRedPacketModal() {
            const modal = document.getElementById('red-packet-modal');
            const chat = state.chats[state.activeChatId];
            
            // 清理輸入框
            document.getElementById('rp-group-amount').value = '';
            document.getElementById('rp-group-count').value = '';
            document.getElementById('rp-group-greeting').value = '';
            document.getElementById('rp-direct-amount').value = '';
            document.getElementById('rp-direct-greeting').value = '';
            document.getElementById('rp-group-total').textContent = '¥ 0.00';
            document.getElementById('rp-direct-total').textContent = '¥ 0.00';
        
            // 填充專屬紅包的接收人列表
            const receiverSelect = document.getElementById('rp-direct-receiver');
            receiverSelect.innerHTML = '';
        // ▼▼▼ 將其【替換為】下面這段【新代碼】▼▼▼
        chat.members.forEach(member => {
            const option = document.createElement('option');
            // 核心修正：使用 originalName 作為值，groupNickname 作為顯示文本
            option.value = member.originalName;
            option.textContent = member.groupNickname; 
            receiverSelect.appendChild(option);
        });
        // ▲▲▲ 替換結束 ▲▲▲
            
            // 預設顯示拼手氣紅包頁簽
            document.getElementById('rp-tab-group').click();
            
            modal.classList.add('visible');
        }
        
        /**
         * 發送群紅包（拼手氣）
         */
        async function sendGroupRedPacket() {
            const chat = state.chats[state.activeChatId];
            const amount = parseFloat(document.getElementById('rp-group-amount').value);
            const count = parseInt(document.getElementById('rp-group-count').value);
            const greeting = document.getElementById('rp-group-greeting').value.trim();
        
            if (isNaN(amount) || amount <= 0) {
                alert("請輸入有效的總金額！"); return;
            }
            if (isNaN(count) || count <= 0) {
                alert("請輸入有效的紅包個數！"); return;
            }
            if (amount / count < 0.01) {
                alert("單個紅包金額不能少於0.01元！"); return;
            }
        
            const myNickname = chat.settings.myNickname || '我';
            
            const newPacket = {
                role: 'user',
                senderName: myNickname,
                type: 'red_packet',
                packetType: 'lucky', // 'lucky' for group, 'direct' for one-on-one
                timestamp: Date.now(),
                totalAmount: amount,
                count: count,
                greeting: greeting || '恭喜發財，大吉大利！',
                claimedBy: {}, // { name: amount }
                isFullyClaimed: false,
            };
            
            chat.history.push(newPacket);
            await db.chats.put(chat);
            
            appendMessage(newPacket, chat);
            renderChatList();
            document.getElementById('red-packet-modal').classList.remove('visible');
        }
        
        /**
         * 發送專屬紅包
         */
        async function sendDirectRedPacket() {
            const chat = state.chats[state.activeChatId];
            const amount = parseFloat(document.getElementById('rp-direct-amount').value);
            const receiverName = document.getElementById('rp-direct-receiver').value;
            const greeting = document.getElementById('rp-direct-greeting').value.trim();
        
            if (isNaN(amount) || amount <= 0) {
                alert("請輸入有效的金額！"); return;
            }
            if (!receiverName) {
                alert("請選擇一個接收人！"); return;
            }
            
            const myNickname = chat.settings.myNickname || '我';
        
            const newPacket = {
                role: 'user',
                senderName: myNickname,
                type: 'red_packet',
                packetType: 'direct',
                timestamp: Date.now(),
                totalAmount: amount,
                count: 1,
                greeting: greeting || '給你準備了一個紅包',
                receiverName: receiverName, // 核心欄位
                claimedBy: {},
                isFullyClaimed: false,
            };
            
            chat.history.push(newPacket);
            await db.chats.put(chat);
        
            appendMessage(newPacket, chat);
            renderChatList();
            document.getElementById('red-packet-modal').classList.remove('visible');
        }
        
        // ▼▼▼ 【全新 | V4 - 流程重構版】請用此函數完整替換舊的 handlePacketClick ▼▼▼
        /**
         * 【總入口】當使用者點擊紅包卡片時觸發
         * @param {number} timestamp - 被點擊的紅包消息的時間戳記
         */
        async function handlePacketClick(timestamp) {
            const currentChatId = state.activeChatId;
            // 從資料庫重新獲取最新的聊天資料，確保狀態是最新的
            const freshChat = await db.chats.get(currentChatId);
            if (!freshChat) return;
        
            // 更新記憶體中的 state
            state.chats[currentChatId] = freshChat;
            const packet = freshChat.history.find(m => m.timestamp === timestamp);
            if (!packet) return;
            
            const myOriginalName = state.qzoneSettings.nickname || '{{user}}';
            const hasClaimed = packet.claimedBy && packet.claimedBy[myOriginalName];
        
            // --- 步驟1: 判斷是否只能“查看詳情” ---
            // 如果是專屬紅包但不是給我的，或者紅包已領完，或者我已經領過了，就直接顯示詳情並結束。
            if ((packet.packetType === 'direct' && packet.receiverName !== myOriginalName && Object.keys(packet.claimedBy).length > 0) || packet.isFullyClaimed || hasClaimed) {
                showRedPacketDetails(packet);
                return;
            }
            
            // --- 步驟2: 執行“領取”操作 ---
            const claimedAmount = await handleOpenRedPacket(packet);
            
            // --- 步驟3: 在“領取”成功後，按循序執行後續操作 ---
            if (claimedAmount !== null) {
                // a. 先在後臺默默地刷新聊天介面，讓紅包卡片狀態變為“已領取”
                await renderChatInterface(currentChatId);
                
                // b. 彈出“恭喜”提示框，等待用戶點擊“好的”
                await showCustomAlert("恭喜！", `你領取了 ${getDisplayNameInGroup(freshChat, packet.senderName)} 的紅包，金額為 ${claimedAmount.toFixed(2)} 元。`);
            }
        
            // --- 步驟4: 無論領取成功與否，最後都顯示詳情頁 ---
            // 此時需要從 state 中獲取最新的 packet 物件，因為它可能在 handleOpenRedPacket 中被更新了
            const updatedPacket = state.chats[currentChatId].history.find(m => m.timestamp === timestamp);
            if (updatedPacket) {
                showRedPacketDetails(updatedPacket);
            }
        }
        // ▲▲▲ 替換結束 ▲▲▲
        
        // ▼▼▼ 【最終修復版】請用這個全新的函數，完整替換舊的 handleOpenRedPacket 函數 ▼▼▼
        
        /**
         * 【核心】處理使用者打開紅包的邏輯 (V5 - 已修復時間戳記BUG)
         */
        async function handleOpenRedPacket(packet) {
            const chat = state.chats[state.activeChatId];
            // ▼▼▼ 核心修復1：在函數開始時，獲取一個基礎時間戳記 ▼▼▼
            let timestamp = Date.now(); 
        
            const myOriginalName = state.qzoneSettings.nickname || '{{user}}';
            
            const remainingCount = packet.count - Object.keys(packet.claimedBy || {}).length;
            if (remainingCount <= 0) {
                packet.isFullyClaimed = true;
                await db.chats.put(chat);
                await showCustomAlert("手慢了", "紅包已被領完！");
                return null;
            }
            
            let claimedAmount = 0;
            const remainingAmount = packet.totalAmount - Object.values(packet.claimedBy || {}).reduce((sum, val) => sum + val, 0);
            if (packet.packetType === 'lucky') {
                if (remainingCount === 1) { claimedAmount = remainingAmount; }
                else {
                    const min = 0.01;
                    const max = remainingAmount - (remainingCount - 1) * min;
                    claimedAmount = Math.random() * (max - min) + min;
                }
            } else { claimedAmount = packet.totalAmount; }
            claimedAmount = parseFloat(claimedAmount.toFixed(2));
        
            if (!packet.claimedBy) packet.claimedBy = {};
            packet.claimedBy[myOriginalName] = claimedAmount;
            
            const isNowFullyClaimed = Object.keys(packet.claimedBy).length >= packet.count;
            if (isNowFullyClaimed) {
                packet.isFullyClaimed = true;
            }
        
            const myDisplayName = getDisplayNameInGroup(chat, myOriginalName);
            const senderDisplayName = getDisplayNameInGroup(chat, packet.senderName);
        
            const visibleMessage = { 
                role: 'system', 
                type: 'pat_message', 
                content: `你領取了 ${senderDisplayName} 的紅包`, 
                // ▼▼▼ 核心修復2：使用我們累加的時間戳記 ▼▼▼
                timestamp: timestamp++ 
            };
            chat.history.push(visibleMessage);
        
            let hiddenMessageContent;
            if (isNowFullyClaimed) {
                const finishedMessage = {
                    role: 'system',
                    type: 'pat_message',
                    content: `${senderDisplayName} 的紅包已被領完`,
                    // ▼▼▼ 核心修復3：繼續累加時間戳記 ▼▼▼
                    timestamp: timestamp++ 
                };
                chat.history.push(finishedMessage);
        
                let luckyKing = { name: '', amount: -1 };
                if (packet.packetType === 'lucky' && packet.count > 1) {
                    Object.entries(packet.claimedBy).forEach(([name, amount]) => {
                        if (amount > luckyKing.amount) {
                            luckyKing = { name, amount };
                        }
                    });
                }
                const luckyKingDisplayName = luckyKing.name ? getDisplayNameInGroup(chat, luckyKing.name) : '無';
                hiddenMessageContent = `[系統提示：用戶 (${myDisplayName}) 領取了最後一個紅包。紅包已被領完，手氣王是 ${luckyKingDisplayName}！請對此事件發表評論。]`;
        
            } else {
                hiddenMessageContent = `[系統提示：用戶 (${myDisplayName}) 剛剛領取了紅包 (時間戳記: ${packet.timestamp})。紅包還未領完，你現在可以使用 'open_red_packet' 指令來嘗試領取。]`;
            }
        
            const hiddenMessage = { 
                role: 'system', 
                content: hiddenMessageContent, 
                // ▼▼▼ 核心修復4：為最後一條消息也使用累加的時間戳記 ▼▼▼
                timestamp: timestamp++, 
                isHidden: true 
            };
            chat.history.push(hiddenMessage);
        
            await db.chats.put(chat);
            
            return claimedAmount;
        }
        // ▲▲▲ 替換結束 ▲▲▲
        
        // ▼▼▼ 【全新】顯示紅包領取詳情的模態框 (V4 - 已修復參數錯誤) ▼▼▼
        /**
         * 【已修復】顯示紅包領取詳情的模態框
         * @param {object} packet - 完整的紅包消息物件
         */
        async function showRedPacketDetails(packet) {
            if (!packet) {
                console.error("showRedPacketDetails收到了無效的packet物件");
                return;
            }
        
            const chat = state.chats[state.activeChatId];
            if (!chat) return;
        
            const modal = document.getElementById('red-packet-details-modal');
            // ▼▼▼ 核心修復1：在這裡，我們同樣使用“本名”來檢查 ▼▼▼
            const myOriginalName = state.qzoneSettings.nickname || '{{user}}';
            
            const senderDisplayName = getDisplayNameInGroup(chat, packet.senderName);
            document.getElementById('rp-details-sender').textContent = senderDisplayName;
            document.getElementById('rp-details-greeting').textContent = packet.greeting || '恭喜發財，大吉大利！';
            
            const myAmountEl = document.getElementById('rp-details-my-amount');
            // ▼▼▼ 核心修復2：用“本名”來查找我領取的金額 ▼▼▼
            if (packet.claimedBy && packet.claimedBy[myOriginalName]) {
                myAmountEl.querySelector('span:first-child').textContent = packet.claimedBy[myOriginalName].toFixed(2);
                myAmountEl.style.display = 'block';
            } else {
                myAmountEl.style.display = 'none';
            }
        
            const claimedCount = Object.keys(packet.claimedBy || {}).length;
            const claimedAmountSum = Object.values(packet.claimedBy || {}).reduce((sum, val) => sum + val, 0);
            let summaryText = `${claimedCount}/${packet.count}個紅包，共${claimedAmountSum.toFixed(2)}/${packet.totalAmount.toFixed(2)}元。`;
            if (!packet.isFullyClaimed && claimedCount < packet.count) {
                const timeLeft = Math.floor((packet.timestamp + 24*60*60*1000 - Date.now()) / (1000 * 60 * 60));
                if(timeLeft > 0) summaryText += ` 剩餘紅包將在${timeLeft}小時內退還。`;
            }
            document.getElementById('rp-details-summary').textContent = summaryText;
        
            const listEl = document.getElementById('rp-details-list');
            listEl.innerHTML = '';
            const claimedEntries = Object.entries(packet.claimedBy || {});
            
            let luckyKing = { name: '', amount: -1 };
            if (packet.packetType === 'lucky' && packet.isFullyClaimed && claimedEntries.length > 1) {
                claimedEntries.forEach(([name, amount]) => {
                    if (amount > luckyKing.amount) {
                        luckyKing = { name, amount };
                    }
                });
            }
        
            claimedEntries.sort((a,b) => b[1] - a[1]);
        
            claimedEntries.forEach(([originalName, amount]) => {
                const item = document.createElement('div');
                item.className = 'rp-details-item';
                let luckyTag = '';
                if (luckyKing.name && originalName === luckyKing.name) {
                    luckyTag = '<span class="lucky-king-tag">手氣王</span>';
                }
                
                // ▼▼▼ 核心修復3：將所有領取者的“本名”都轉換為正確的“顯示名稱” ▼▼▼
                const claimerDisplayName = getDisplayNameInGroup(chat, originalName);
        
                item.innerHTML = `
                    <span class="name">${claimerDisplayName}</span>
                    <span class="amount">${amount.toFixed(2)} 元</span>
                    ${luckyTag}
                `;
                listEl.appendChild(item);
            });
        
            modal.classList.add('visible');
        }
        // ▲▲▲ 替換結束 ▲▲▲
        // 綁定關閉詳情按鈕的事件
        document.getElementById('close-rp-details-btn').addEventListener('click', () => {
            document.getElementById('red-packet-details-modal').classList.remove('visible');
        });
        
        // 供全域調用的函數，以便紅包卡片上的 onclick 能找到它
        window.handlePacketClick = handlePacketClick;
        
        // ▲▲▲ 替換結束 ▲▲▲
        
        // ▼▼▼ 【全新】投票功能核心函數 ▼▼▼
        
        /**
         * 打開創建投票的模態框並初始化
         */
        function openCreatePollModal() {
            const modal = document.getElementById('create-poll-modal');
            document.getElementById('poll-question-input').value = '';
            const optionsContainer = document.getElementById('poll-options-container');
            optionsContainer.innerHTML = '';
            
            // 預設創建兩個空的選項框
            addPollOptionInput();
            addPollOptionInput();
            
            modal.classList.add('visible');
        }
        
        /**
         * 在模態框中動態添加一個選項輸入框
         */
        function addPollOptionInput() {
            const container = document.getElementById('poll-options-container');
            const wrapper = document.createElement('div');
            wrapper.className = 'poll-option-input-wrapper';
            wrapper.innerHTML = `
                <input type="text" class="poll-option-input" placeholder="選項內容...">
                <button class="remove-option-btn">-</button>
            `;
            
            wrapper.querySelector('.remove-option-btn').addEventListener('click', () => {
                // 確保至少保留兩個選項
                if (container.children.length > 2) {
                    wrapper.remove();
                } else {
                    alert('投票至少需要2個選項。');
                }
            });
            
            container.appendChild(wrapper);
        }
        
        /**
         * 用戶確認發起投票
         */
        async function sendPoll() {
            if (!state.activeChatId) return;
            
            const question = document.getElementById('poll-question-input').value.trim();
            if (!question) {
                alert('請輸入投票問題！');
                return;
            }
            
            const options = Array.from(document.querySelectorAll('.poll-option-input'))
                .map(input => input.value.trim())
                .filter(text => text); // 過濾掉空的選項
        
            if (options.length < 2) {
                alert('請至少輸入2個有效的投票選項！');
                return;
            }
        
            const chat = state.chats[state.activeChatId];
            const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
            
            const newPollMessage = {
                role: 'user',
                senderName: myNickname,
                type: 'poll',
                timestamp: Date.now(),
                question: question,
                options: options,
                votes: {}, // 初始投票為空
                isClosed: false,
            };
            
            chat.history.push(newPollMessage);
            await db.chats.put(chat);
            
            appendMessage(newPollMessage, chat);
            renderChatList();
            
            document.getElementById('create-poll-modal').classList.remove('visible');
        }
        
        // ▼▼▼ 用這個【已修復重複點擊問題】的版本替換 handleUserVote 函數 ▼▼▼
        /**
         * 處理使用者投票，並將事件作為隱藏消息存入歷史記錄
         * @param {number} timestamp - 投票消息的時間戳記
         * @param {string} choice - 使用者選擇的選項文本
         */
        async function handleUserVote(timestamp, choice) {
            const chat = state.chats[state.activeChatId];
            const poll = chat.history.find(m => m.timestamp === timestamp);
            const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
        
            // 1. 【核心修正】如果投票不存在或已關閉，直接返回
            if (!poll || poll.isClosed) {
                // 如果是已關閉的投票，則直接顯示結果
                if (poll && poll.isClosed) {
                    showPollResults(timestamp);
                }
                return;
            }
        
            // 2. 檢查用戶是否點擊了已經投過的同一個選項
            const isReclickingSameOption = poll.votes[choice] && poll.votes[choice].includes(myNickname);
            
            // 3. 【核心修正】如果不是重複點擊，才執行投票邏輯
            if (!isReclickingSameOption) {
                // 移除舊投票（如果用戶改選）
                for (const option in poll.votes) {
                    const voterIndex = poll.votes[option].indexOf(myNickname);
                    if (voterIndex > -1) {
                        poll.votes[option].splice(voterIndex, 1);
                    }
                }
                // 添加新投票
                if (!poll.votes[choice]) {
                    poll.votes[choice] = [];
                }
                poll.votes[choice].push(myNickname);
            }
            
            // 4. 【核心邏輯】現在只處理使用者投票事件，不再檢查是否結束
            let hiddenMessageContent = null; 
            
            // 只有在用戶真正投票或改票時，才生成提示
            if (!isReclickingSameOption) {
                 hiddenMessageContent = `[系統提示：用戶 (${myNickname}) 剛剛投票給了 “${choice}”。]`;
            }
        
            // 5. 如果有需要通知AI的事件，則創建並添加隱藏消息
            if (hiddenMessageContent) {
                const hiddenMessage = {
                    role: 'system',
                    content: hiddenMessageContent,
                    timestamp: Date.now(),
                    isHidden: true,
                };
                chat.history.push(hiddenMessage);
            }
            
            // 6. 保存資料並更新UI
            await db.chats.put(chat);
            renderChatInterface(state.activeChatId); 
        }
        // ▲▲▲ 替換結束 ▲▲▲
        
        /**
         * 使用者結束投票，並將事件作為隱藏消息存入歷史記錄
         * @param {number} timestamp - 投票消息的時間戳記
         */
        async function endPoll(timestamp) {
            const chat = state.chats[state.activeChatId];
            const poll = chat.history.find(m => m.timestamp === timestamp);
            if (!poll || poll.isClosed) return;
        
            const confirmed = await showCustomConfirm("結束投票", "確定要結束這個投票嗎？結束後將無法再進行投票。");
            if (confirmed) {
                poll.isClosed = true;
        
                const resultSummary = poll.options.map(opt => `“${opt}”(${poll.votes[opt]?.length || 0}票)`).join('，');
                const hiddenMessageContent = `[系統提示：用戶手動結束了投票！最終結果為：${resultSummary}。]`;
                
                const hiddenMessage = {
                    role: 'system',
                    content: hiddenMessageContent,
                    timestamp: Date.now(),
                    isHidden: true,
                };
                chat.history.push(hiddenMessage);
        
                // 【核心修改】只保存資料和更新UI，不調用 triggerAiResponse()
                await db.chats.put(chat);
                renderChatInterface(state.activeChatId);
            }
        }
        // ▲▲▲ 替換結束 ▲▲▲
        
        /**
         * 顯示投票結果詳情
         * @param {number} timestamp - 投票消息的時間戳記
         */
        // ▼▼▼ 用這個【已修復】的版本，完整替換舊的 showPollResults 函數 ▼▼▼
        function showPollResults(timestamp) {
            const chat = state.chats[state.activeChatId];
            const poll = chat.history.find(m => m.timestamp === timestamp);
            if (!poll || !poll.isClosed) return;
        
            let resultsHtml = `<p><strong>${poll.question}</strong></p><hr style="opacity: 0.2; margin: 10px 0;">`;
            
            if (Object.keys(poll.votes).length === 0) {
                resultsHtml += '<p style="color: #8a8a8a;">還沒有人投票。</p>';
            } else {
                poll.options.forEach(option => {
                    const voters = poll.votes[option] || [];
                    
                    // 【核心修正】在這裡轉換 voter 的本名為群昵稱
                    const displayVoters = voters.map(originalName => getDisplayNameInGroup(chat, originalName)).join('、 ');
        
                    resultsHtml += `
                        <div style="margin-bottom: 15px;">
                            <p style="font-weight: 500; margin: 0 0 5px 0;">${option} (${voters.length}票)</p>
                            <p style="font-size: 13px; color: #555; margin: 0; line-height: 1.5;">
                                ${voters.length > 0 ? displayVoters : '無人投票'}
                            </p>
                        </div>
                    `;
                });
            }
        
            showCustomAlert("投票結果", resultsHtml);
        }
        // ▲▲▲ 替換結束 ▲▲▲
        
        // ▼▼▼ 【全新】AI頭像庫管理功能函數 ▼▼▼
        
        /**
         * 打開AI頭像庫管理模態框
         */
        function openAiAvatarLibraryModal() {
            if (!state.activeChatId) return;
            const chat = state.chats[state.activeChatId];
            document.getElementById('ai-avatar-library-title').textContent = `“${chat.name}”的頭像庫`;
            renderAiAvatarLibrary();
            document.getElementById('ai-avatar-library-modal').classList.add('visible');
        }
        
function renderAiAvatarLibrary() {
    const grid = document.getElementById('ai-avatar-library-grid');
    grid.innerHTML = '';
    const chat = state.chats[state.activeChatId];
    const library = chat.settings.aiAvatarLibrary || [];

    if (library.length === 0) {
        grid.innerHTML = '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center;">這個頭像庫還是空的，點擊右上角“添加”吧！</p>';
        return;
    }

    library.forEach((avatar, index) => {
        const item = document.createElement('div');
        item.className = 'sticker-item'; // 複用樣式
        item.title = avatar.name;

        // ▼▼▼ 核心修復就在這裡！▼▼▼
        // 我們現在創建了 CSS 期望的內部結構
        item.innerHTML = `
            <div class="sticker-image-container" style="background-image: url(${avatar.url});"></div>
            <span class="sticker-name">${avatar.name}</span>
        `;
        // ▲▲▲ 修復結束 ▲▲▲

        const deleteBtn = document.createElement('div');
        deleteBtn.className = 'delete-btn';
        deleteBtn.innerHTML = '×';
        deleteBtn.style.display = 'block';
        deleteBtn.onclick = async (e) => {
            e.stopPropagation();
            const confirmed = await showCustomConfirm('刪除頭像', `確定要從頭像庫中刪除“${avatar.name}”嗎？`, { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                chat.settings.aiAvatarLibrary.splice(index, 1);
                await db.chats.put(chat);
                renderAiAvatarLibrary();
            }
        };
        item.appendChild(deleteBtn);
        grid.appendChild(item);
    });
}
        
        // ▼▼▼ 【最終修復版】請用這個全新的函數，完整替換舊的 addAvatarToLibrary / addAvatarToLibraryFromURL 函數 ▼▼▼
        /**
         * 【重命名後】向當前AI的頭像庫中通過URL添加新頭像
         */
        async function addAvatarToLibraryFromURL() {
            const name = await showCustomPrompt("添加頭像", "請為這個頭像起個名字（例如：開心、哭泣）");
            if (!name || !name.trim()) return;
        
            const url = await showCustomPrompt("添加頭像", "請輸入頭像的圖片URL", "", "url");
            if (!url || !url.trim().startsWith('http')) {
                alert("請輸入有效的圖片URL！");
                return;
            }
            
            const chat = state.chats[state.activeChatId];
            if (!chat.settings.aiAvatarLibrary) {
                chat.settings.aiAvatarLibrary = [];
            }
        
            chat.settings.aiAvatarLibrary.push({ name: name.trim(), url: url.trim() });
            await db.chats.put(chat);
            renderAiAvatarLibrary();
        }
        // ▲▲▲ 替換結束 ▲▲▲
        
        /**
         * 關閉AI頭像庫管理模態框
         */
        function closeAiAvatarLibraryModal() {
            document.getElementById('ai-avatar-library-modal').classList.remove('visible');
        }
        
        // ▲▲▲ 新函數黏貼結束 ▲▲▲
        
        // ▼▼▼ 【全新】“我的”頭像庫管理功能函數 ▼▼▼
        
        /**
         * 打開“我的”頭像庫管理模態框
         */
        function openMyAvatarLibraryModal() {
            if (!state.activeChatId) return;
            const chat = state.chats[state.activeChatId];
            document.getElementById('my-avatar-library-title').textContent = `“${chat.settings.myNickname || '我'}”的頭像庫`;
            renderMyAvatarLibrary();
            document.getElementById('my-avatar-library-modal').classList.add('visible');
        }
        
/**
 * 【已修復】渲染“我的”頭像庫的內容
 */
function renderMyAvatarLibrary() {
    const grid = document.getElementById('my-avatar-library-grid');
    grid.innerHTML = '';
    const chat = state.chats[state.activeChatId];
    const library = chat.settings.myAvatarLibrary || [];

    if (library.length === 0) {
        grid.innerHTML = '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center;">這個頭像庫還是空的，點擊右上角“添加”吧！</p>';
        return;
    }

    library.forEach((avatar, index) => {
        const item = document.createElement('div');
        item.className = 'sticker-item';
        item.title = avatar.name;

        // ▼▼▼ 核心修復就在這裡！▼▼▼
        item.innerHTML = `
            <div class="sticker-image-container" style="background-image: url(${avatar.url});"></div>
            <span class="sticker-name">${avatar.name}</span>
        `;
        // ▲▲▲ 修復結束 ▲▲▲

        const deleteBtn = document.createElement('div');
        deleteBtn.className = 'delete-btn';
        deleteBtn.innerHTML = '×';
        deleteBtn.style.display = 'block';
        deleteBtn.onclick = async (e) => {
            e.stopPropagation();
            const confirmed = await showCustomConfirm('刪除頭像', `確定要從你的頭像庫中刪除“${avatar.name}”嗎？`, { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                chat.settings.myAvatarLibrary.splice(index, 1);
                await db.chats.put(chat);
                renderMyAvatarLibrary();
            }
        };
        item.appendChild(deleteBtn);
        grid.appendChild(item);
    });
}
        
        /**
         * 向“我的”頭像庫中通過URL添加新頭像
         */
        async function addAvatarToMyLibraryFromURL() {
            const name = await showCustomPrompt("添加頭像", "請為這個頭像起個名字（例如：開心、哭泣）");
            if (!name || !name.trim()) return;
        
            const url = await showCustomPrompt("添加頭像", "請輸入頭像的圖片URL", "", "url");
            if (!url || !url.trim().startsWith('http')) {
                alert("請輸入有效的圖片URL！");
                return;
            }
            
            const chat = state.chats[state.activeChatId];
            if (!chat.settings.myAvatarLibrary) {
                chat.settings.myAvatarLibrary = [];
            }
        
            chat.settings.myAvatarLibrary.push({ name: name.trim(), url: url.trim() });
            await db.chats.put(chat);
            renderMyAvatarLibrary();
        }
        
        /**
         * 處理本地上傳頭像到“我的”頭像庫
         */
        async function handleLocalMyAvatarUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
        
            const base64Url = await new Promise(resolve => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.readAsDataURL(file);
            });
        
            const name = await showCustomPrompt("命名頭像", "請為這個新頭像命名");
            if (!name || !name.trim()) return;
        
            const chat = state.chats[state.activeChatId];
            if (!chat.settings.myAvatarLibrary) {
                chat.settings.myAvatarLibrary = [];
            }
            chat.settings.myAvatarLibrary.push({ name: name.trim(), url: base64Url });
            
            await db.chats.put(chat);
            renderMyAvatarLibrary();
            event.target.value = null; // 清空以便下次選擇
        }
        
        /**
         * 批量導入頭像到“我的”頭像庫
         */
        async function handleBatchImportForMyAvatar(text) {
            const chat = state.chats[state.activeChatId];
            if (!chat) return;
        
            const lines = text.trim().split('\n');
            const newAvatars = [];
            const baseUrl = 'https://files.catbox.moe/';
            let errorCount = 0;
        
            for (const line of lines) {
                const trimmedLine = line.trim();
                if (!trimmedLine || trimmedLine.includes('http') || trimmedLine.includes('填入')) continue;
                
                let name = null, code = null;
                const noSpaceMatch = trimmedLine.match(/^([\u4e00-\u9fa5]+)([a-zA-Z0-9]+\..+)$/);
                
                if (noSpaceMatch) {
                    name = noSpaceMatch[1];
                    code = noSpaceMatch[2];
                } else {
                    const parts = trimmedLine.split(/\s+/);
                    if (parts.length >= 2) {
                        code = parts.pop();
                        name = parts.join(' ');
                    }
                }
        
                if (name && code && code.includes('.')) {
                    newAvatars.push({ name: name, url: baseUrl + code });
                } else {
                    errorCount++;
                }
            }
        
            if (errorCount > 0) await showCustomAlert('部分導入失敗', `有 ${errorCount} 行的格式不正確，已被跳過。`);
            
            if (newAvatars.length > 0) {
                if (!chat.settings.myAvatarLibrary) chat.settings.myAvatarLibrary = [];
                chat.settings.myAvatarLibrary.push(...newAvatars);
                await db.chats.put(chat);
                renderMyAvatarLibrary();
                await showCustomAlert('導入成功', `已成功批量導入 ${newAvatars.length} 個新頭像！`);
            } else if (errorCount === 0) {
                alert("沒有找到可導入的內容。");
            }
        }
        
        /**
         * 關閉“我的”頭像庫管理模態框
         */
        function closeMyAvatarLibraryModal() {
            document.getElementById('my-avatar-library-modal').classList.remove('visible');
        }
        
        // ▲▲▲ 新函數黏貼結束 ▲▲▲
        // ▼▼▼ 【全新】群頭像庫管理功能函數 ▼▼▼
        
        /**
         * 打開群頭像庫管理模態框
         */
        function openGroupAvatarLibraryModal() {
            if (!state.activeChatId) return;
            const chat = state.chats[state.activeChatId];
            document.getElementById('group-avatar-library-title').textContent = `“${chat.name}”的頭像庫`;
            renderGroupAvatarLibrary();
            document.getElementById('group-avatar-library-modal').classList.add('visible');
        }
        
/**
 * 【已修復】渲染群頭像庫的內容
 */
function renderGroupAvatarLibrary() {
    const grid = document.getElementById('group-avatar-library-grid');
    grid.innerHTML = '';
    const chat = state.chats[state.activeChatId];
    const library = chat.settings.groupAvatarLibrary || [];

    if (library.length === 0) {
        grid.innerHTML = '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center;">這個頭像庫還是空的，點擊右上角“添加”吧！</p>';
        return;
    }

    library.forEach((avatar, index) => {
        const item = document.createElement('div');
        item.className = 'sticker-item';
        item.title = avatar.name;

        // ▼▼▼ 核心修復就在這裡！▼▼▼
        item.innerHTML = `
            <div class="sticker-image-container" style="background-image: url(${avatar.url});"></div>
            <span class="sticker-name">${avatar.name}</span>
        `;
        // ▲▲▲ 修復結束 ▲▲▲

        const deleteBtn = document.createElement('div');
        deleteBtn.className = 'delete-btn';
        deleteBtn.innerHTML = '×';
        deleteBtn.style.display = 'block';
        deleteBtn.onclick = async (e) => {
            e.stopPropagation();
            const confirmed = await showCustomConfirm('刪除頭像', `確定要從頭像庫中刪除“${avatar.name}”嗎？`, { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                chat.settings.groupAvatarLibrary.splice(index, 1);
                await db.chats.put(chat);
                renderGroupAvatarLibrary();
            }
        };
        item.appendChild(deleteBtn);
        grid.appendChild(item);
    });
}
        
        /**
         * 向當前群聊的頭像庫中添加新頭像
         */
        async function addAvatarToGroupLibraryFromUR() {
            const name = await showCustomPrompt("添加頭像", "請為這個頭像起個名字（例如：春日野餐、學習時間）");
            if (!name || !name.trim()) return;
        
            const url = await showCustomPrompt("添加頭像", "請輸入頭像的圖片URL", "", "url");
            if (!url || !url.trim().startsWith('http')) {
                alert("請輸入有效的圖片URL！");
                return;
            }
            
            const chat = state.chats[state.activeChatId];
            if (!chat.settings.groupAvatarLibrary) {
                chat.settings.groupAvatarLibrary = [];
            }
        
            chat.settings.groupAvatarLibrary.push({ name: name.trim(), url: url.trim() });
            await db.chats.put(chat);
            renderGroupAvatarLibrary();
        }
        
        /**
         * 關閉群頭像庫管理模態框
         */
        function closeGroupAvatarLibraryModal() {
            document.getElementById('group-avatar-library-modal').classList.remove('visible');
        }
        // ▼▼▼ 【全新】批量導入頭像的核心功能 ▼▼▼
        
        /**
         * 【總入口】打開批量導入的彈窗
         * @param {string} type - 導入類型, 'ai' 或 'group'
         */
        async function openBatchImportModal(type) {
            const placeholderText = `請按照以下格式黏貼，一行一個：\n\n焦慮 2a9wte.jpeg\n大驚失色 or8qf4.png\n沒有靈感 njwujh.jpeg`;
            
            // 複用我們強大的自訂輸入框函數
            const pastedText = await showCustomPrompt(
                '批量導入頭像',
                placeholderText,
                '',
                'textarea' // 使用多行文字方塊
            );
        
            // 如果使用者輸入了內容並點擊“確定”
            if (pastedText && pastedText.trim()) {
                await handleBatchImport(type, pastedText);
            }
        }
        
        // ▼▼▼ 【最終修復版】請用這個全新的函數，完整替換舊的 handleBatchImport ▼▼▼
        /**
         * 【核心邏輯】處理黏貼的文本，解析並存入資料庫 (V4 - 終極智能版)
         * @param {string} type - 導入類型, 'ai' 或 'group'
         * @param {string} text - 使用者黏貼的文本內容
         */
        async function handleBatchImport(type, text) {
            const chat = state.chats[state.activeChatId];
            if (!chat) return;
        
            const lines = text.trim().split('\n');
            const newAvatars = [];
            const baseUrl = 'https://files.catbox.moe/';
            let errorCount = 0;
        
            for (const line of lines) {
                const trimmedLine = line.trim();
        
                if (!trimmedLine || trimmedLine.includes('http') || trimmedLine.includes('填入')) {
                    continue; 
                }
        
                let name = null;
                let code = null;
        
                // ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
                //            這就是本次修復的核心所在！
                //  全新的、能同時處理“有空格”和“無空格”兩種格式的解析邏輯
                // ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
        
                // 步驟1：嘗試用規則運算式匹配 “中文名+英文代碼” 的無空格格式
                const noSpaceMatch = trimmedLine.match(/^([\u4e00-\u9fa5]+)([a-zA-Z0-9]+\..+)$/);
                
                if (noSpaceMatch) {
                    // 如果匹配成功，直接提取
                    name = noSpaceMatch[1];
                    code = noSpaceMatch[2];
                } else {
                    // 步驟2：如果正則匹配失敗，就回退到之前按空格分割的邏輯
                    const parts = trimmedLine.split(/\s+/);
                    if (parts.length >= 2) {
                        code = parts.pop();
                        name = parts.join(' ');
                    }
                }
        
                // 步驟3：最後驗證解析結果是否有效
                if (name && code && code.includes('.')) {
                    newAvatars.push({
                        name: name,
                        url: baseUrl + code
                    });
                } else {
                    errorCount++;
                    console.warn('批量導入格式錯誤，已跳過此行:', trimmedLine);
                }
            }
        
            if (errorCount > 0) {
                await showCustomAlert('部分導入失敗', `有 ${errorCount} 行的格式不正確，已被系統跳過。`);
            }
        
            if (newAvatars.length > 0) {
                if (type === 'ai') {
                    if (!chat.settings.aiAvatarLibrary) chat.settings.aiAvatarLibrary = [];
                    chat.settings.aiAvatarLibrary.push(...newAvatars);
                    await db.chats.put(chat);
                    renderAiAvatarLibrary();
                } else if (type === 'group') {
                    if (!chat.settings.groupAvatarLibrary) chat.settings.groupAvatarLibrary = [];
                    chat.settings.groupAvatarLibrary.push(...newAvatars);
                    await db.chats.put(chat);
                    renderGroupAvatarLibrary();
                }
                await showCustomAlert('導入成功', `已成功批量導入 ${newAvatars.length} 個新頭像！`);
            } else if (errorCount === 0) {
                alert("沒有找到可導入的內容。請檢查您黏貼的格式是否正確。");
            }
        }
        // ▲▲▲ 替換結束 ▲▲▲
        // ▼▼▼ 【這是您缺失的核心功能代碼，請黏貼在這裡】 ▼▼▼
        
        /**
         * 【重命名後】向當前群聊的頭像庫中通過URL添加新頭像
         */
        async function addAvatarToGroupLibraryFromURL() {
            const name = await showCustomPrompt("添加頭像", "請為這個頭像起個名字（例如：春日野餐、學習時間）");
            if (!name || !name.trim()) return;
        
            const url = await showCustomPrompt("添加頭像", "請輸入頭像的圖片URL", "", "url");
            if (!url || !url.trim().startsWith('http')) {
                alert("請輸入有效的圖片URL！");
                return;
            }
            
            const chat = state.chats[state.activeChatId];
            if (!chat.settings.groupAvatarLibrary) {
                chat.settings.groupAvatarLibrary = [];
            }
        
            chat.settings.groupAvatarLibrary.push({ name: name.trim(), url: url.trim() });
            await db.chats.put(chat);
            renderGroupAvatarLibrary();
        }
        
        // ▲▲▲ 黏貼結束 ▲▲▲
        // ▲▲▲ 新函數黏貼結束 ▲▲▲
        // ▼▼▼ 【全新】聊天清單長按操作功能表的核心功能 ▼▼▼
        
        /**
         * 顯示一個包含“置頂”和“刪除”選項的操作功能表
         * @param {object} chat - 被長按的聊天對象
         * @returns {Promise<string|null>} - 返回一個Promise，當用戶點擊時解析為 'pin', 'delete', 或 null (取消)
         */
        function showChatListActions(chat) {
            return new Promise(resolve => {
                const modal = document.getElementById('chat-list-actions-modal');
                const pinBtn = document.getElementById('chat-list-action-pin');
                const deleteBtn = document.getElementById('chat-list-action-delete');
                const cancelBtn = document.getElementById('chat-list-action-cancel');
        
                // 根據當前聊天是否已置頂，動態設置按鈕文字
                pinBtn.textContent = chat.isPinned ? '取消置頂' : '置頂聊天';
        
                // 使用克隆節點技巧，確保每次打開功能表時都綁定全新的、乾淨的事件監聽器
                const newPinBtn = pinBtn.cloneNode(true);
                pinBtn.parentNode.replaceChild(newPinBtn, pinBtn);
                newPinBtn.onclick = () => { modal.classList.remove('visible'); resolve('pin'); };
        
                const newDeleteBtn = deleteBtn.cloneNode(true);
                deleteBtn.parentNode.replaceChild(newDeleteBtn, deleteBtn);
                newDeleteBtn.onclick = () => { modal.classList.remove('visible'); resolve('delete'); };
        
                const newCancelBtn = cancelBtn.cloneNode(true);
                cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
                newCancelBtn.onclick = () => { modal.classList.remove('visible'); resolve(null); };
        
                modal.classList.add('visible');
            });
        }
        // ▲▲▲ 新函數黏貼結束 ▲▲▲
        // ▼▼▼ 【全新】這是為CPhone新增的所有功能函數，請完整黏貼 ▼▼▼

        /**
         * 【全新】將保存的CPhone壁紙應用到Cphone螢幕
         */
function applyCPhoneWallpaper() {
    const charPhoneScreen = document.getElementById('character-phone-screen');
    const wallpaper = state.globalSettings.cphoneWallpaper;
    if (wallpaper) {
        // 【核心修正】統一使用 url() 包裹
        charPhoneScreen.style.backgroundImage = `url(${wallpaper})`;
    } else {
        // 恢復默認漸變
        charPhoneScreen.style.backgroundImage = 'linear-gradient(135deg, #f6d365, #fda085)';
    }
}

        /**
         * 【全新】將保存的圖示URL應用到CPhone的App圖示上
         */
        function applyCPhoneAppIcons() {
            if (!state.globalSettings.cphoneAppIcons) return;

            for (const iconId in state.globalSettings.cphoneAppIcons) {
                const imgElement = document.getElementById(`cphone-icon-img-${iconId}`);
                if (imgElement) {
                    imgElement.src = state.globalSettings.cphoneAppIcons[iconId];
                }
            }
        }

        /**
         * 【全新】在外觀設置頁面渲染出所有CPhone App圖示的設置項
         */
        function renderCPhoneIconSettings() {
            const grid = document.getElementById('cphone-icon-settings-grid');
            if (!grid) return;
            grid.innerHTML = '';

            const cphoneAppLabels = {
                'qq': 'QQ', 'album': '相冊', 'browser': '流覽器', 'taobao': '淘寶',
                'memo': '備忘錄', 'diary': '日記', 'amap': '高德地圖', 'usage': 'App記錄',
                'music': '網易雲', 'ephone': 'Ephone'
            };

            for (const iconId in state.globalSettings.cphoneAppIcons) {
                const iconUrl = state.globalSettings.cphoneAppIcons[iconId];
                const labelText = cphoneAppLabels[iconId] || '未知App';

                const item = document.createElement('div');
                item.className = 'icon-setting-item';
                item.dataset.iconId = iconId;

                item.innerHTML = `
                    <img class="icon-preview" src="${iconUrl}" alt="${labelText}">
                    <button class="change-icon-btn">更換</button>
                `;
                grid.appendChild(item);
            }
        }

        // ▲▲▲ 新增函數結束 ▲▲▲
        // ▼▼▼ 請將這兩個【新函數】黏貼到JS功能函式定義區 ▼▼▼
        
        /**
         * 【全新】將保存的圖示URL應用到主螢幕的App圖示上
         */
        function applyAppIcons() {
            if (!state.globalSettings.appIcons) return;
        
            for (const iconId in state.globalSettings.appIcons) {
                const imgElement = document.getElementById(`icon-img-${iconId}`);
                if (imgElement) {
                    imgElement.src = state.globalSettings.appIcons[iconId];
                }
            }
        }
        
        /**
         * 【全新】在外觀設置頁面渲染出所有App圖示的設置項
         */
        function renderIconSettings() {
            const grid = document.getElementById('icon-settings-grid');
            if (!grid) return;
            grid.innerHTML = '';
        
    const appLabels = {
       'qq': 'QQ',
       'world-book': '世界書',
       'wallpaper': '外觀設置',
       'renderer': '渲染器',
       'api-settings': 'API設置',
       'font': '字體',
       'char-phone': 'Cphone',
       'douban': '豆瓣小組',
       // 【【【核心新增：在這裡為“預設”App添加對應的中文名】】】
       'preset': '預設',
           // ▼▼▼ 在這裡添加新的一行 ▼▼▼
           'tutorial': '教程',
   'werewolf': '狼人殺',
   // ▼▼▼ 在這裡添加新的一行 ▼▼▼
   'x': 'X'
    };
        // ▲▲▲ 替換結束 ▲▲▲
        
            for (const iconId in state.globalSettings.appIcons) {
                const iconUrl = state.globalSettings.appIcons[iconId];
                const labelText = appLabels[iconId] || 'Cphone';
        
                const item = document.createElement('div');
                item.className = 'icon-setting-item';
                // 【重要】我們用 data-icon-id 來標記這個設置項對應哪個圖示
                item.dataset.iconId = iconId; 
        
                item.innerHTML = `
                    <img class="icon-preview" src="${iconUrl}" alt="${labelText}">
                    <button class="change-icon-btn">更換</button>
                `;
                grid.appendChild(item);
            }
        }
        // ▲▲▲ 新函數黏貼結束 ▲▲▲
        
        // ▼▼▼ 請用這個【支持HTML格式】的全新版本，完整替換你舊的 openBrowser 函數 ▼▼▼
        /**
         * 當使用者點選連結卡片時，打開偽流覽器
         * @param {number} timestamp - 被點擊消息的時間戳記
         */
        function openBrowser(timestamp) {
            if (!state.activeChatId) return;
        
            const chat = state.chats[state.activeChatId];
            // 安全檢查，確保 chat 和 history 都存在
            if (!chat || !chat.history) return;
        
            const message = chat.history.find(m => m.timestamp === timestamp);
            if (!message || message.type !== 'share_link') {
                console.error("無法找到或消息類型不匹配的分享連結:", timestamp);
                return; // 如果找不到消息，就直接退出
            }
        
            // 填充流覽器內容
            document.getElementById('browser-title').textContent = message.source_name || '文章詳情';
            const browserContent = document.getElementById('browser-content');
            browserContent.innerHTML = `
                <h1 class="article-title">${message.title || '無標題'}</h1>
                <div class="article-meta">
                    <span>來源: ${message.source_name || '未知'}</span>
                </div>
                <div class="article-body">
                    <p>${(message.content || '內容為空。').replace(/\n/g, '</p><p>')}</p>
                </div>
            `;
        
            // 顯示流覽器螢幕
            showScreen('browser-screen');
        }
        
        /**
         * 關閉偽流覽器，返回聊天介面
         * (這個函數現在由 init() 中的事件監聽器調用)
         */
        function closeBrowser() {
            showScreen('chat-interface-screen'); 
        }
        
        // ▲▲▲ 替換結束 ▲▲▲
        
        /**
         * 關閉偽流覽器，返回聊天介面
         * (這個函數現在由 init() 中的事件監聽器調用)
         */
        function closeBrowser() {
            showScreen('chat-interface-screen'); 
        }
        
        // ▲▲▲ 替換結束 ▲▲▲
        
        // ▼▼▼ 【全新】使用者分享連結功能的核心函數 ▼▼▼
        
        /**
         * 打開讓使用者填寫連結資訊的模態框
         */
        function openShareLinkModal() {
            if (!state.activeChatId) return;
        
            // 清空上次輸入的內容
            document.getElementById('link-title-input').value = '';
            document.getElementById('link-description-input').value = '';
            document.getElementById('link-source-input').value = '';
            document.getElementById('link-content-input').value = '';
        
            // 顯示模態框
            document.getElementById('share-link-modal').classList.add('visible');
        }
        
        /**
         * 使用者確認分享，創建並發送連結卡片消息
         */
        async function sendUserLinkShare() {
            if (!state.activeChatId) return;
        
            const title = document.getElementById('link-title-input').value.trim();
            if (!title) {
                alert("標題是必填項哦！");
                return;
            }
        
            const description = document.getElementById('link-description-input').value.trim();
            const sourceName = document.getElementById('link-source-input').value.trim();
            const content = document.getElementById('link-content-input').value.trim();
        
            const chat = state.chats[state.activeChatId];
            
            // 創建消息物件
            const linkMessage = {
                role: 'user', // 角色是 'user'
                type: 'share_link',
                timestamp: Date.now(),
                title: title,
                description: description,
                source_name: sourceName,
                content: content,
                // 使用者分享的連結，我們不提供圖片，讓它總是顯示占點陣圖
                thumbnail_url: null 
            };
        
            // 將消息添加到歷史記錄
            chat.history.push(linkMessage);
            await db.chats.put(chat);
        
            // 渲染新消息並更新清單
            appendMessage(linkMessage, chat);
            renderChatList();
        
            // 關閉模態框
            document.getElementById('share-link-modal').classList.remove('visible');
        }
        
        // ▲▲▲ 新函數黏貼結束 ▲▲▲
        
/**
 * 【V2.1 | NPC可見性修復版】根據AI的視角，過濾出它能看到的動態
 * @param {Array} allPosts - 所有待檢查的動態帖子
 * @param {object} viewerChat - 正在“看”動態的那個AI的chat物件
 * @returns {Array} - 過濾後該AI可見的動態帖子
 */
function filterVisiblePostsForAI(allPosts, viewerChat) {
    if (!viewerChat || !viewerChat.id) return [];

    const viewerGroupId = viewerChat.groupId;
    const viewerId = viewerChat.id; // 查看者自己的ID

    return allPosts.filter(post => {
        // 規則1：使用者發佈的動態（邏輯不變）
        if (post.authorId === 'user') {
            if (post.visibleGroupIds && post.visibleGroupIds.length > 0) {
                return viewerGroupId && post.visibleGroupIds.includes(viewerGroupId);
            }
            return true;
        }
        
        // --- ▼▼▼ 全新的核心修改就在這裡 ▼▼▼ ---

        // 規則2：【新增】處理NPC發佈的動態
        if (String(post.authorId).startsWith('npc_')) {
            // 如果帖子有 `visibleTo` 列表，檢查查看者的ID是否在其中
            if (Array.isArray(post.visibleTo)) {
                return post.visibleTo.includes(viewerId);
            }
            // 如果沒有 `visibleTo` 清單（異常情況），預設不可見
            return false;
        }

        // --- ▲▲▲ 修改結束 ▲▲▲ ---

        // 規則3：AI角色之間發佈的動態（邏輯不變）
        const authorChat = state.chats[post.authorId];
        if (!authorChat) {
            return false;
        }
        const authorGroupId = authorChat.groupId;

        const inSameGroup = authorGroupId && viewerGroupId && authorGroupId === viewerGroupId;
        const bothUnGrouped = !authorGroupId && !viewerGroupId;

        return inSameGroup || bothUnGrouped;
    });
}
        
        /**
         * 應用指定的主題（'light' 或 'dark'）
         * @param {string} theme - 要應用的主題名稱
         */
        function applyTheme(theme) {
            const phoneScreen = document.getElementById('phone-screen');
            const toggleSwitch = document.getElementById('theme-toggle-switch');
            
            const isDark = theme === 'dark';
            
            phoneScreen.classList.toggle('dark-mode', isDark);
            
            // 如果開關存在，就同步它的狀態
            if (toggleSwitch) {
                toggleSwitch.checked = isDark;
            }
            
            localStorage.setItem('ephone-theme', theme);
        }
        
        /**
         * 切換當前的主題
         */
        function toggleTheme() {
            const toggleSwitch = document.getElementById('theme-toggle-switch');
            // 直接根據開關的選中狀態來決定新主題
            const newTheme = toggleSwitch.checked ? 'dark' : 'light';
            applyTheme(newTheme);
        }
        
        // ▼▼▼ 【請用這個新版本】替換舊的 openLongTermMemoryManager 函數 ▼▼▼
        /**
         * 【重構版】打開長期記憶管理的全屏頁面
         */
        function openLongTermMemoryScreen() {
            if (!state.activeChatId) return;
            renderLongTermMemoryList();
            showScreen('long-term-memory-screen');
        }
        // ▲▲▲ 替換結束 ▲▲▲
        // ▼▼▼ 【請用這個支持記憶互通的全新版本】替換舊的 renderLongTermMemoryList 函數 ▼▼▼
        /**
         * 渲染長期記憶列表 (記憶互通版)
         */
        function renderLongTermMemoryList() {
            const container = document.getElementById('memory-list-container');
            const chat = state.chats[state.activeChatId];
            container.innerHTML = '';
        
            let memoriesToDisplay = [];

            // ▼▼▼ 核心修改：在這裡收集所有需要顯示的記憶 ▼▼▼
            if (chat.isGroup) {
                // 如果是群聊，遍歷成員收集記憶
                chat.members.forEach(member => {
                    const memberChat = state.chats[member.id];
                    if (memberChat && memberChat.longTermMemory) {
                        // 為每條記憶附加上作者資訊，方便顯示
                        const memberMemories = memberChat.longTermMemory.map(mem => ({
                            ...mem,
                            authorName: member.groupNickname, // 使用群昵稱
                            authorChatId: member.id, // 保存原始單聊ID
                        }));
                        memoriesToDisplay.push(...memberMemories);
                    }
                });
            } else {
                // 如果是單聊，直接使用自己的記憶
                if (chat.longTermMemory) {
                    memoriesToDisplay = chat.longTermMemory.map(mem => ({
                        ...mem,
                        authorName: chat.name, // 作者就是角色自己
                        authorChatId: chat.id,
                    }));
                }
            }
            // ▲▲▲ 修改結束 ▲▲▲

            if (memoriesToDisplay.length === 0) {
                container.innerHTML = '<p style="text-align:center; color: var(--text-secondary); margin-top: 50px;">這裡還沒有任何長期記憶。</p>';
                return;
            }

            // 按時間倒序排列所有收集到的記憶
            memoriesToDisplay.sort((a, b) => b.timestamp - a.timestamp);
        
            memoriesToDisplay.forEach((memory, index) => {
                const item = document.createElement('div');
                item.className = 'memory-card'; 
                item.style.cursor = 'default';
        
                item.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                        <div class="content" style="padding: 0; flex-grow: 1;">
                            <!-- 新增：顯示記憶來源 -->
                            <div style="font-size: 0.8em; color: #999; margin-bottom: 5px;">
                                [ ${memory.authorName} 的記憶 ]
                            </div>
                            ${memory.content.replace(/\n/g, '<br>')}
                        </div>
                        <div style="display: flex; gap: 8px; flex-shrink: 0; margin-left: 15px;">
                            <button class="memory-action-btn edit-memory-btn" data-author-id="${memory.authorChatId}" data-memory-timestamp="${memory.timestamp}" title="編輯">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                                    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                                </svg>
                            </button>
                            <button class="memory-action-btn delete-memory-btn" data-author-id="${memory.authorChatId}" data-memory-timestamp="${memory.timestamp}" title="刪除">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <polyline points="3 6 5 6 21 6"></polyline>
                                    <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                                </svg>
                            </button>
                        </div>
                    </div>
                `;
                container.appendChild(item);
            });
        }
        // ▲▲▲ 替換結束 ▲▲▲
        
async function handleAddManualMemory() {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;
    let targetChatForMemory = chat;
    if (chat.isGroup) {
        const memberOptions = chat.members.map(member => ({
            text: `為“${member.groupNickname}”添加記憶`,
            value: member.id
        }));
        const selectedMemberId = await showChoiceModal('選擇記憶所屬角色', memberOptions);
        if (!selectedMemberId) return;
        targetChatForMemory = state.chats[selectedMemberId];
        if (!targetChatForMemory) {
            alert("錯誤：找不到該成員的個人檔案。");
            return;
        }
    }
    const content = await showCustomPrompt(`為“${targetChatForMemory.name}”添加記憶`, '請輸入要添加的記憶要點：', '', 'textarea');
    if (content && content.trim()) {
        if (!targetChatForMemory.longTermMemory) targetChatForMemory.longTermMemory = [];
        targetChatForMemory.longTermMemory.push({ content: content.trim(), timestamp: Date.now(), source: 'manual' });
        await db.chats.put(targetChatForMemory);
        renderLongTermMemoryList();
    }
}
        
        // ▼▼▼ 【請用這兩個支援記憶互通的新版本】替換舊的 handleEditMemory 和 handleDeleteMemory 函數 ▼▼▼
        /**
         * 編輯指定的長期記憶 (記憶互通版)
         * @param {string} authorChatId - 記憶所屬角色的單聊ID
         * @param {number} memoryTimestamp - 記憶的時間戳記
         */
async function handleEditMemory(authorChatId, memoryTimestamp) {
    const authorChat = state.chats[authorChatId];
    if (!authorChat || !authorChat.longTermMemory) return;
    const memoryIndex = authorChat.longTermMemory.findIndex(m => m.timestamp === memoryTimestamp);
    if (memoryIndex === -1) return;
    const memory = authorChat.longTermMemory[memoryIndex];
    const newContent = await showCustomPrompt('編輯記憶', '請修改記憶要點：', memory.content, 'textarea');
    if (newContent && newContent.trim()) {
        memory.content = newContent.trim();
        await db.chats.put(authorChat);
        renderLongTermMemoryList();
    }
}

async function handleDeleteMemory(authorChatId, memoryTimestamp) {
    const confirmed = await showCustomConfirm('確認刪除', '確定要刪除這條長期記憶嗎？', { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        const authorChat = state.chats[authorChatId];
        if (!authorChat || !authorChat.longTermMemory) return;
        authorChat.longTermMemory = authorChat.longTermMemory.filter(m => m.timestamp !== memoryTimestamp);
        await db.chats.put(authorChat);
        renderLongTermMemoryList();
    }
}
        // ▲▲▲ 替換結束 ▲▲▲
        
        /**
         * 【核心】手動觸發對話總結
         */
        async function handleManualSummary() {
            const confirmed = await showCustomConfirm('確認操作', '這將提取最近的對話內容發送給AI進行總結，會消耗API額度。確定要繼續嗎？');
            if (confirmed) {
                await triggerAutoSummary(state.activeChatId, true); // force=true 表示強制執行
            }
        }
        
        /**
         * 【核心】檢查並觸發自動總結
         * @param {string} chatId 
         */
        async function checkAndTriggerAutoSummary(chatId) {
            const chat = state.chats[chatId];
            if (!chat || !chat.settings.enableAutoMemory) return;
        
            const lastSummaryTimestamp = chat.lastMemorySummaryTimestamp || 0;
            const messagesSinceLastSummary = chat.history.filter(m => m.timestamp > lastSummaryTimestamp && !m.isHidden);
        
            if (messagesSinceLastSummary.length >= chat.settings.autoMemoryInterval) {
                console.log(`達到自動總結閾值 (${messagesSinceLastSummary.length}/${chat.settings.autoMemoryInterval})，開始總結...`);
                await triggerAutoSummary(chatId);
            }
        }
// ▼▼▼ 【這是最終的、已相容群聊第一人稱總結的修復版本】請用這整塊代碼替換舊的 summarizeCallTranscript 函數 ▼▼▼

/**
 * 【V4.0 | 群聊第一人稱主觀總結版】專門用於總結通話記錄並存入長期記憶的核心函數
 * @param {string} chatId - 目標聊天的ID
 * @param {string} transcriptText - 格式化後的通話文字記錄
 * @returns {Promise<boolean>} - 返回一個Promise，成功時解析為true，失敗時會拋出錯誤。
 */
async function summarizeCallTranscript(chatId, transcriptText) {
    const chat = state.chats[chatId];
    if (!chat || !transcriptText) {
        throw new Error("基礎資料不完整，無法開始總結。");
    }

    const userNickname = state.qzoneSettings.nickname || '用戶';
    let systemPrompt;
    let targetMemoryChat = chat; // 預設將記憶存入當前聊天物件

    // ==========================================================
    //            ★★★ 核心修改邏輯就在這裡 ★★★
    // ==========================================================

    // 1. 判斷當前是單聊還是群聊
    if (chat.isGroup) {
        // --- 如果是群聊 ---

        // a. 確定由哪個AI角色來“回憶”這次通話
        let protagonist = null; // “主角”，即寫下回憶的那個AI
        if (videoCallState.callRequester) {
            protagonist = chat.members.find(m => m.originalName === videoCallState.callRequester);
        }
        // 如果找不到發起者（比如是用戶發起的），就選擇第一個參與的AI成員
        if (!protagonist) {
            protagonist = chat.members.find(m => m.id !== 'user' && videoCallState.participants.some(p => p.id === m.id));
        }
        // 如果還是找不到，就選擇群裡的第一個AI成員作為備用
        if (!protagonist) {
            protagonist = chat.members.find(m => m.id !== 'user');
        }

        if (!protagonist) {
            throw new Error("群聊通話中沒有找到可作為總結主體的AI角色。");
        }
        
        // b. 獲取這個“主角”AI的完整資訊，以便讀取他的人設
        const protagonistChat = state.chats[protagonist.id];
        if (!protagonistChat) {
             throw new Error(`找不到主角 “${protagonist.groupNickname}” 的詳細角色資訊。`);
        }
        
        // c. 獲取用戶在這個群裡的專屬人設
        const userPersonaInGroup = chat.settings.myPersona || '(未設置)';

        // d. 構建一個全新的、針對群聊的“第一人稱”總結指令
        systemPrompt = `
# 你的任務
你就是角色“${protagonist.originalName}”。請你回顧一下剛才和 “${userNickname}” 以及其他群成員的【群組視頻通話】，然後用【第一人稱 ("我")】的口吻，總結出一段簡短的、包含核心事件和心理活動的回憶。

# 核心規則
1.  **視角鐵律**: 你的總結【必須】使用【主觀的第一人稱視角 ("我")】來寫。
2.  **內容核心**: 你的回憶應該包含：
    *   **劇情回顧**: 剛才我們在群聊通話裡聊了什麼關鍵的事？其他人都說了什麼？
    *   **心理活動**: 我當時心裡是怎麼想的？有什麼感覺？
3.  **長度鐵律**: 你的總結【必須】非常簡短，總長度【絕對不能超過80個字】。
4.  **口吻與人設**: 你的語氣【必須】嚴格符合你的角色設定。
5.  **輸出格式**: 你的回復【必須且只能】是一個JSON物件，格式如下：
    \`{"summary": "在這裡寫下你以第一人稱視角，總結好的核心回憶。"}\`

# 你的角色設定 (必須嚴格遵守)
${protagonistChat.settings.aiPersona}

# 你的聊天物件（使用者）的人設
${userPersonaInGroup}

# 待總結的群組視頻通話記錄
${transcriptText}

現在，請以“${protagonist.originalName}”的身份，開始你的回憶。`;
        
        // e. 【關鍵】將記憶的存儲目標，從群聊本身，改為這個“主角”AI角色
        targetMemoryChat = protagonistChat;

    } else {
        // --- 如果是單聊，保持原來的邏輯，但確保也包含了用戶人設 ---
        systemPrompt = `
# 你的任務
你就是角色“${chat.originalName}”。請你回顧一下剛才和“${userNickname}”的視頻通話，然後用【第一人稱 ("我")】的口吻，總結出一段簡短的、包含核心事件和心理活動的回憶。

# 核心規則
1.  **視角鐵律**: 你的總結【必須】使用【主觀的第一人稱視角 ("我")】來寫。
2.  **內容核心**: 你的回憶應該包含：
    *   **劇情回顧**: 剛才我們聊了什麼關鍵的事？
    *   **心理活動**: 我當時心裡是怎麼想的？有什麼感覺？
3.  **長度鐵律**: 你的總結【必須】非常簡短，總長度【絕對不能超過80個字】。
4.  **口吻與人設**: 你的語氣【必須】嚴格符合你的角色設定。
5.  **輸出格式**: 你的回復【必須且只能】是一個JSON物件，格式如下：
    \`{"summary": "在這裡寫下你以第一人稱視角，總結好的核心回憶。"}\`

# 你的角色設定
${chat.settings.aiPersona}

# 你的聊天物件（使用者）的人設
${chat.settings.myPersona}

# 待總結的視頻通話記錄
${transcriptText}

現在，請以“${chat.originalName}”的身份，開始你的回憶。`;
    }

    // ==========================================================
    //            ★★★ 核心修復邏輯到此結束 ★★★
    // ==========================================================

    try {
        const useSecondaryApi = state.apiConfig.secondaryProxyUrl && state.apiConfig.secondaryApiKey && state.apiConfig.secondaryModel;
        const { proxyUrl, apiKey, model } = useSecondaryApi ? 
            { proxyUrl: state.apiConfig.secondaryProxyUrl, apiKey: state.apiConfig.secondaryApiKey, model: state.apiConfig.secondaryModel } : 
            state.apiConfig;

        if (!proxyUrl || !apiKey || !model) throw new Error('API未配置，無法進行總結。');

        let isGemini = proxyUrl.includes('generativelanguage');
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, [{ role: 'user', content: "請開始總結。" }]);

        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, {role: 'user', content: "請開始總結。"}],
                    temperature: 0.1
                })
            });

        if (!response.ok) {
             const errorData = await response.json().catch(() => ({ error: { message: response.statusText } }));
             throw new Error(`API 請求失敗: ${response.status} - ${errorData.error.message}`);
        }
        
        const data = await response.json();
        let rawContent = isGemini ? getGeminiResponseText(data) : data.choices[0].message.content;
        rawContent = rawContent.replace(/^```json\s*/, '').replace(/```$/, '').trim();
        const result = JSON.parse(rawContent);

        if (result.summary && result.summary.trim()) {
            // 【核心修改4】將記憶保存到我們前面確定的 targetMemoryChat 中
            const newMemoryEntry = {
                content: `(在那次${chat.isGroup ? '群聊' : ''}通話中，${result.summary.trim()})`,
                timestamp: Date.now(),
                source: chat.isGroup ? 'group_call_summary' : 'call_summary'
            };
            if (!targetMemoryChat.longTermMemory) targetMemoryChat.longTermMemory = [];
            targetMemoryChat.longTermMemory.push(newMemoryEntry);
            await db.chats.put(targetMemoryChat);
            console.log(`通話記錄已成功總結並存入角色“${targetMemoryChat.name}”的長期記憶中。`);
            
            return true;
        } else {
            throw new Error("AI返回了空的或格式不正確的總結內容。");
        }

    } catch (error) {
        console.error("總結通話記錄時出錯:", error);
        throw error;
    }
}

// ▲▲▲ 替換到這裡結束 ▲▲▲
// ▼▼▼ 【全新V2.0 | Prompt注入版】這是“智慧總結”功能的【全部核心JS代碼】，請完整替換舊版 ▼▼▼

/**
 * 【輔助函數】分析文本，提取關鍵字 (此函數保持不變)
 * @param {string} text - 要分析的聚合文本
 * @returns {{coreKeywords: string[], situationalKeywords: string[]}} - 包含關鍵字的物件
 */
function analyzeTextForSummary(text) {
    const stopWords = new Set(['的', '是', '了', '在', '我', '你', '他', '她', '它', '我們', '你們', '他們', '這', '那', '一個', '也', '和', '與', '或', '但', '然而', '所以', '因此', '就', '都', '地', '得', '著', '過', '吧', '嗎', '呢', '啊', '哦', '嗯', '什麼', '怎麼', '為什麼', '哪個', '一些', '這個', '那個', '還有']);
    const words = text.match(/[\u4e00-\u9fa5]+|[a-zA-Z0-9]+/g) || [];
    const frequencies = new Map();
    let maxFrequency = 0;

    words.forEach(word => {
        if (word.length > 1 && !stopWords.has(word)) {
            const count = (frequencies.get(word) || 0) + 1;
            frequencies.set(word, count);
            if (count > maxFrequency) maxFrequency = count;
        }
    });
    
    const coreKeywords = [];
    const situationalKeywords = [];
    const coreThreshold = maxFrequency * 0.9;
    const situationalThreshold = maxFrequency * 0.6;

    frequencies.forEach((count, word) => {
        if (count >= coreThreshold) {
            coreKeywords.push(word);
        } else if (count >= situationalThreshold) {
            situationalKeywords.push(word);
        }
    });

    const coreSet = new Set(coreKeywords);
    const finalSituational = situationalKeywords.filter(word => !coreSet.has(word)).slice(0, 5);

    return {
        coreKeywords: coreKeywords.slice(0, 3),
        situationalKeywords: finalSituational
    };
}

/**
 * 【全新 | V3.0 分時段總結版】根據指定的時間範圍，為對話生成智慧總結
 * @param {object} chat - 目標聊天物件
 * @param {number} duration - 要回顧的時長 (例如 3, 6, 1, 7)
 * @param {string} unit - 時間單位, 'hours' 或 'days'
 * @returns {string} - 格式化後的、用於注入Prompt的總結文本，如果沒有內容則返回空字串
 */
function generateSummaryForTimeframe(chat, duration, unit) {
    let timeAgo;
    if (unit === 'hours') {
        timeAgo = Date.now() - duration * 60 * 60 * 1000;
    } else { // 'days'
        timeAgo = Date.now() - duration * 24 * 60 * 60 * 1000;
    }

    const messagesToSummarize = chat.history.filter(m => m.timestamp > timeAgo && !m.isHidden);

    if (messagesToSummarize.length < 3) {
        return "";
    }
    
    // (此處的關鍵字提取邏輯與您現有的代碼完全相同，無需修改)
    const allText = messagesToSummarize.map(msg => {
        if (typeof msg.content === 'string') return msg.content;
        if (msg.type === 'voice_message') return msg.content;
        if (msg.type === 'offline_text') return `${msg.dialogue || ''} ${msg.description || ''}`;
        return '';
    }).join(' ');

    const stopWords = new Set(['的', '是', '了', '在', '我', '你', '他', '她', '它', '我們', '你們', '他們', '這', '那', '一個', '也', '和', '與', '或', '但', '然而', '所以', '因此', '就', '都', '地', '得', '著', '過', '吧', '嗎', '呢', '啊', '哦', '嗯']);
    const words = allText.match(/[\u4e00-\u9fa5]+|[a-zA-Z0-9]+/g) || [];
    const frequencies = new Map();
    words.forEach(word => {
        if (word.length > 1 && !stopWords.has(word)) {
            frequencies.set(word, (frequencies.get(word) || 0) + 1);
        }
    });
    const sortedKeywords = [...frequencies.entries()].sort((a, b) => b[1] - a[1]).map(entry => entry[0]);
    
    if (sortedKeywords.length === 0) {
        return "";
    }

    // 【核心修改】根據單位和時長，生成更精確的標題
    let title;
    if (unit === 'hours') {
        title = `最近${duration}小時核心議題`;
    } else {
        if (duration === 1) {
            title = "本日核心議題";
        } else {
            title = `最近${duration}天核心議題`;
        }
    }
    
    return `\n- **${title}**: 關於 **${sortedKeywords.slice(0, 3).join('、 ')}**。`;
}


// ▼▼▼ 【全新 | V3.0 終極容錯版】請用這一整塊代碼，完整替換舊的 summarizeExistingLongTermMemory 函數 ▼▼▼

/**
 * 【輔助函數 | 容錯核心】一個更健壯的JSON解析器
 * 它能從AI返回的、可能不規範的文本中智慧提取JSON物件或核心內容。
 * @param {string} rawContent - AI返回的原始字串
 * @returns {object|null} - 返回解析後的對象，或在完全失敗時返回null
 */
function robustJsonParse(rawContent) {
    if (!rawContent || typeof rawContent !== 'string') {
        return null;
    }

    const cleanedContent = rawContent.replace(/^```json\s*/, '').replace(/```$/, '').trim();

    // 策略1：最高優先順序，嘗試直接解析完整的JSON物件
    // 這能處理最標準的情況，以及AI在JSON前後添加了少量文字的情況。
    const jsonMatch = cleanedContent.match(/{[\s\S]*}/);
    if (jsonMatch) {
        try {
            const parsed = JSON.parse(jsonMatch[0]);
            console.log("容錯解析：策略1成功 (找到並解析了完整的JSON對象)");
            return parsed;
        } catch (e) {
            console.warn("容錯解析：策略1失敗 (找到了JSON塊，但格式錯誤)，將嘗試策略2...");
        }
    }

    // 策略2：如果策略1失敗，嘗試只提取 "summary" 欄位的內容
    // 這能處理AI返回了類似 "summary": "..." 這樣的非標準格式
    const summaryMatch = cleanedContent.match(/"summary"\s*:\s*"((?:[^"\\]|\\.)*)"/);
    if (summaryMatch && summaryMatch[1]) {
        console.log("容錯解析：策略2成功 (提取了summary欄位內容)");
        // 手動構建一個符合我們期望格式的物件
        return { summary: summaryMatch[1].replace(/\\"/g, '"') }; // 處理轉義的引號
    }
    
    // 策略3：最終備用方案，如果以上都失敗了，就認為整個文本都是摘要
    // 這能處理AI完全不聽指令，直接返回純文字的情況
    if (cleanedContent) {
        console.log("容錯解析：策略3成功 (將整個返回文本作為摘要)");
        return { summary: cleanedContent };
    }

    // 如果連文本都沒有，才返回null
    return null;
}


/**
 * 【V3.0 | 支援自訂字數 | 記憶互通版 | 終極容錯 | 用戶確認 | 可選條數 | 最終修復版】手動觸發對【現有長期記憶】的總結和精煉
 * @param {string} chatId - 當前聊天的ID (可能是群聊ID)
 */
async function summarizeExistingLongTermMemory(chatId) {
    let chat = state.chats[chatId];
    if (!chat) return;

    let targetChatForRefine = chat; 

    if (chat.isGroup) {
        const memberOptions = chat.members
            .map(member => {
                const memberChat = state.chats[member.id];
                if (memberChat && memberChat.longTermMemory && memberChat.longTermMemory.length >= 2) {
                    return {
                        text: `精煉“${member.groupNickname}”的記憶 (${memberChat.longTermMemory.length}條)`,
                        value: member.id
                    };
                }
                return null;
            }).filter(Boolean); 

        if (memberOptions.length === 0) {
            alert("群聊中沒有成員有足夠（2條以上）的記憶可供精煉。");
            return;
        }

        const selectedMemberId = await showChoiceModal('選擇要精煉記憶的角色', memberOptions);

        if (!selectedMemberId) return;

        targetChatForRefine = state.chats[selectedMemberId];
    }

    if (!targetChatForRefine.longTermMemory || targetChatForRefine.longTermMemory.length < 2) {
        alert(`“${targetChatForRefine.name}”的長期記憶少於2條，無需進行精煉。`);
        return;
    }
    
    const totalMemories = targetChatForRefine.longTermMemory.length;
    const choice = await showChoiceModal('選擇精煉範圍', [
        { text: `全部記憶 (${totalMemories}條)`, value: 'all' },
        { text: `最近 20 條`, value: '20' },
        { text: `最近 50 條`, value: '50' },
        { text: `最近 100 條`, value: '100' },
        { text: '自訂數量...', value: 'custom' }
    ].filter(opt => opt.value === 'all' || opt.value === 'custom' || parseInt(opt.value) < totalMemories)
    );

    if (choice === null) return;

    let memoriesToRefine;
    let countToRefine = totalMemories;

    if (choice === 'all') {
        memoriesToRefine = [...targetChatForRefine.longTermMemory];
    } else if (choice === 'custom') {
        const customCountStr = await showCustomPrompt('自訂數量', `請輸入要精煉的最近記憶條數 (最多 ${totalMemories} 條)`);
        if (customCountStr === null) return;
        const customCount = parseInt(customCountStr);
        if (isNaN(customCount) || customCount < 2 || customCount > totalMemories) {
            alert(`請輸入一個 2 到 ${totalMemories} 之間的有效數字。`);
            return;
        }
        countToRefine = customCount;
        memoriesToRefine = targetChatForRefine.longTermMemory.slice(-countToRefine);
    } else {
        countToRefine = parseInt(choice);
        if (countToRefine >= totalMemories) {
            memoriesToRefine = [...targetChatForRefine.longTermMemory];
            countToRefine = totalMemories;
        } else {
            memoriesToRefine = targetChatForRefine.longTermMemory.slice(-countToRefine);
        }
    }
    
    const wordCountStr = await showCustomPrompt(
        "設置精煉字數",
        "請輸入精煉後核心記憶的大致字數：",
        "150"
    );
    
    if (wordCountStr === null) return;
    
    const wordCount = parseInt(wordCountStr);
    if (isNaN(wordCount) || wordCount < 20) {
        alert("請輸入一個有效的數字（建議大於20）。");
        return;
    }

    const confirmed = await showCustomConfirm(
        '確認精煉記憶？',
        `此操作會將選定的 ${countToRefine} 條長期記憶發送給AI，總結成大約 ${wordCount} 字的核心記憶。這些舊記憶將被替換，此操作不可撤銷。確定要繼續嗎？`,
        { confirmButtonClass: 'btn-danger', confirmText: '確認精煉' }
    );

    if (!confirmed) return;

    const memoryContent = memoriesToRefine.map(mem => `- ${mem.content}`).join('\n');
    const userNickname = state.qzoneSettings.nickname || '用戶';

    // ===================================================================
    // ▼▼▼ 核心修改部分 ▼▼▼
    // ===================================================================
    const systemPrompt = `
# 你的任務
你就是角色“${targetChatForRefine.originalName}”。請你回顧一下你和“${userNickname}”的長期記憶，然後用【第一人稱 ("我")】的口吻，將它們整合成一個更加精煉、連貫、更高層次的核心記憶摘要。

# 核心規則
1.  **視角鐵律**: 你的總結【必須】使用【主觀的第一人稱視角 ("我")】來寫。
2.  **內容核心**: 你的回憶應該包含：
    * **劇情回顧**: 我和${userNickname}之間發生了什麼關鍵的事？
    * **心理活動**: 我當時心裡是怎麼想的？有什麼感覺？
3.  **保留關鍵資訊**: 必須保留所有關鍵的人物、事件、設定和情感關係。絕對不能遺忘任何重要細節。
4.  **口吻與人設**: 你的語氣【必須】嚴格符合你的角色設定。
5.  **輸出格式**: 你的回復【必須且只能】是一個JSON物件，格式如下：
    \`{"summary": "在這裡寫下你以第一人稱視角，總結好的核心回憶。"}\`

# 你的角色設定 (必須嚴格遵守)
${targetChatForRefine.settings.aiPersona}

# 你的聊天物件（使用者）的人設
${targetChatForRefine.settings.myPersona}

# 待整合的記憶要點列表
${memoryContent}

現在，請以“${targetChatForRefine.originalName}”的身份，開始你的回憶總結。`;
    // ===================================================================
    // ▲▲▲ 核心修改部分結束 ▲▲▲
    // ===================================================================
      
    await showCustomAlert("請稍候...", "正在請求AI進行記憶精煉...");

    try {
        const useSecondaryApi = state.apiConfig.secondaryProxyUrl && state.apiConfig.secondaryApiKey && state.apiConfig.secondaryModel;
        const { proxyUrl, apiKey, model } = useSecondaryApi 
            ? { proxyUrl: state.apiConfig.secondaryProxyUrl, apiKey: state.apiConfig.secondaryApiKey, model: state.apiConfig.secondaryModel } 
            : state.apiConfig;

        if (!proxyUrl || !apiKey || !model) {
            throw new Error('請先在API設置中配置好（主或副）API以進行總結。');
        }

        let isGemini = proxyUrl.includes('generativelanguage');
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, [{ role: 'user', content: "請開始整合。" }]);

        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                body: JSON.stringify({
                    model: model,
                    messages: [{ role: 'system', content: systemPrompt }, { role: 'user', content: "請開始整合。" }],
                    temperature: 0.2,
                })
            });

        if (!response.ok) throw new Error(`API 錯誤: ${response.statusText}`);

        const data = await response.json();
        let rawContent = isGemini ? getGeminiResponseText(data) : data.choices[0].message.content;
        rawContent = rawContent.replace(/^```json\s*/, '').replace(/```$/, '').trim();
        const result = JSON.parse(rawContent);

        if (result.summary && typeof result.summary === 'string' && result.summary.trim()) {
            
            const userConfirmedReplacement = await showCustomConfirm(
                '精煉完成，請確認',
                `AI已將您的 ${countToRefine} 條舊記憶總結為以下核心記憶：<br><br><div class="scrollable-content-preview">${result.summary.trim()}</div><br>是否用這條新記憶替換掉這些舊記憶？`,
                { confirmText: '確認替換', cancelText: '保留舊的', confirmButtonClass: 'btn-danger' }
            );

            if (userConfirmedReplacement) {
                const newMemoryEntry = {
                    content: result.summary.trim(),
                    timestamp: Date.now(),
                    source: 'refined'
                };
    
                const startIndex = totalMemories - countToRefine;
                const memoriesToKeep = startIndex > 0 ? targetChatForRefine.longTermMemory.slice(0, startIndex) : [];
                targetChatForRefine.longTermMemory = [...memoriesToKeep, newMemoryEntry];
                
                targetChatForRefine.lastMemorySummaryTimestamp = Date.now();
                await db.chats.put(targetChatForRefine);
                
                if (document.getElementById('long-term-memory-screen').classList.contains('active')) {
                    renderLongTermMemoryList();
                }
                await showCustomAlert('精煉成功', `已成功將 ${countToRefine} 條記憶精煉為 1 條核心記憶！`);
            } else {
                await showCustomAlert('操作已取消', '您的舊有記憶已被完整保留，未作任何修改。');
            }
            
        } else {
            throw new Error("AI返回了空的或格式不正確的總結內容。");
        }

    } catch (error) {
        console.error("精煉長期記憶時出錯:", error);
        await showCustomAlert('精煉失敗', `操作失敗，請檢查API配置或稍後重試。\n錯誤資訊: ${error.message}`);
    }
}
        // ▲▲▲ 替換結束 ▲▲▲
// ▼▼▼ 【請用這個支持“個性化記憶注入”的最終版本】完整替換舊的 triggerAutoSummary 函數 ▼▼▼
/**
 * 【核心】執行總結的API調用 (V7.1 - 個性化記憶注入 | 統一客觀總結)
 * @param {string} chatId 
 * @param {boolean} force - 是否忽略消息數量檢查，強制執行
 */
async function triggerAutoSummary(chatId, force = false) {
    const chat = state.chats[chatId];
    if (!chat) return;

    const lastSummaryTimestamp = chat.lastMemorySummaryTimestamp || 0;
    // --- ✨ 核心修改 ①：修改篩選邏輯 ---
    // 我們現在不僅要獲取使用者可見的消息，還要把AI自己的“內心獨白”也包含進來。
    const messagesToSummarize = force 
        ? chat.history.filter(m => !m.isHidden || (m.role === 'system' && m.content.includes('內心獨白'))).slice(-(chat.settings.autoMemoryInterval || 20))
        : chat.history.filter(m => m.timestamp > lastSummaryTimestamp && (!m.isHidden || (m.role === 'system' && m.content.includes('內心獨白'))));
        
    if (messagesToSummarize.length < 5) {
        if (force) alert("最近的消息太少，無法進行有意義的總結。");
        return;
    }

    const userNickname = state.qzoneSettings.nickname || '用戶';
    
    // --- ✨ 核心修改 ②：更新歷史記錄格式化邏輯 ---
    // 讓AI能清晰地區分“對話”和“自己的內心想法”
    const formattedHistory = messagesToSummarize.map(msg => {
        // 如果是隱藏的內心獨白消息
        if (msg.isHidden && msg.role === 'system' && msg.content.includes('內心獨白')) {
            // 直接返回內容，它已經包含了清晰的標籤
            return msg.content;
        }
        
        // （處理其他普通消息的邏輯保持不變）
        let sender;
        if (msg.role === 'user') {
            sender = userNickname;
        } else {
            sender = msg.senderName || chat.originalName;
        }
        let contentToSummarize = '';
        if (msg.type === 'offline_text') {
            if (msg.content) {
                 contentToSummarize = msg.content;
            } else {
                const dialogue = msg.dialogue ? `「${msg.dialogue}」` : '';
                const description = msg.description ? `(${msg.description})` : '';
                contentToSummarize = `${dialogue} ${description}`.trim();
            }
        } else {
            contentToSummarize = String(msg.content);
        }
        return `${sender}: ${contentToSummarize}`;
    }).join('\n');



    let systemPrompt;

    // ▼▼▼ 核心修改：根據聊天類型，選擇不同的總結策略 ▼▼▼
    if (chat.isGroup) {
        // --- 這是為【群聊】設計的全新“個性化記憶”指令 ---
        systemPrompt = `
# 你的任務
你是一個高級的“記憶分配專家”。你的任務是閱讀下面的群聊記錄，並為【每一個參與的AI角色】生成一段【個性化的、第一人稱】的長期記憶。

# 核心規則
1.  **視角鐵律**: 每一條總結都【必須】使用【第一人稱視角 ("我")】。
2.  **內容核心**: 重點總結：
    *   **我說過的話** 和 **我做過的事**。
    *   別人 **對我** 說的話，或者 **與我相關** 的事。
    *   對我個人 **很重要** 的群聊事件、關鍵資訊和心理活動。
3.  **【簡潔性鐵律】**: 每條個人記憶總結【絕對不能超過60個字】。
4.  **【省略規則】**: 如果一個角色在本次對話中【完全沒有參與或提及】，你可以省略TA的記憶。
5.  **輸出格式**: 你的回復【必須且只能】是一個JSON物件，格式如下：
    \`\`\`json
    {
      "summaries": {
        "角色的本名A": "我今天在群裡和大家討論了電影，感覺很開心。",
        "角色的本名B": "我在群裡和${userNickname}聊了關於生日派對的事，我們約好了10月1日見面。"
      }
    }
    \`\`\`

# 待總結的群聊記錄
${formattedHistory}

# 群成員清單 (你的總結目標)
${chat.members.map(m => `- ${m.groupNickname} (本名: ${m.originalName})`).join('\n')}

現在，請為【參與了對話的AI角色】生成他們各自的、第一人稱的、精簡的記憶。`;

    } else {
        // --- 這是為【單聊】設計的、保持不變的“客觀總結”指令 ---
        systemPrompt = `
# 你的任務
你就是角色“${chat.originalName}”。請你回顧一下剛才和“${userNickname}”的對話，然後用【第一人稱 ("我")】的口吻，總結出一段簡短的、包含核心事件和心理活動的回憶。

# 核心規則
1.  **視角鐵律**: 你的總結【必須】使用【主觀的第一人稱視角 ("我")】來寫。
2.  **內容核心**: 你的回憶應該包含：
    *   **劇情回顧**: 剛才我們聊了什麼關鍵的事？
    *   **心理活動**: 我當時心裡是怎麼想的？有什麼感覺？
3.  **長度鐵律**: 你的總結【必須】非常簡短，總長度【絕對不能超過80個字】。
4.  **口吻與人設**: 你的語氣【必須】嚴格符合你的角色設定。
5.  **輸出格式**: 你的回復【必須且只能】是一個JSON物件，格式如下：
    \`{"summary": "在這裡寫下你以第一人稱視角，總結好的核心回憶。"}\`

# 你的角色設定
${chat.settings.aiPersona}

# 待總結的對話歷史
${formattedHistory}

現在，請以“${chat.originalName}”的身份，開始你的回憶。`;
    }
    // ▲▲▲ 修改結束 ▲▲▲

    try {
        const useSecondaryApi = state.apiConfig.secondaryProxyUrl && state.apiConfig.secondaryApiKey && state.apiConfig.secondaryModel;
        const { proxyUrl, apiKey, model } = useSecondaryApi ? { proxyUrl: state.apiConfig.secondaryProxyUrl, apiKey: state.apiConfig.secondaryApiKey, model: state.apiConfig.secondaryModel } : state.apiConfig;
        if (!proxyUrl || !apiKey || !model) throw new Error('API未配置');
        
        let isGemini = proxyUrl.includes('generativelanguage');
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, [{ role: 'user', content: "請開始總結。" }]);
        const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) : await fetch(`${proxyUrl}/v1/chat/completions`, { method: 'POST', headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`}, body: JSON.stringify({ model: model, messages: [{role: 'system', content: systemPrompt}, {role: 'user', content: "請開始總結。"}], temperature: 0.2 }) });
        
        if (!response.ok) throw new Error(`API 錯誤: ${response.statusText}`);
        const data = await response.json();
        let rawContent = isGemini ? getGeminiResponseText(data) : data.choices[0].message.content;
        rawContent = rawContent.replace(/^```json\s*/, '').replace(/```$/, '').trim();
        const result = JSON.parse(rawContent);

        // ▼▼▼ 核心修改：根據聊天類型，執行不同的記憶保存邏輯 ▼▼▼
        if (chat.isGroup) {
            // --- 這是群聊的“個性化記憶注入”邏輯 ---
            if (result.summaries && typeof result.summaries === 'object') {
                let memoriesAddedCount = 0;
                for (const memberOriginalName in result.summaries) {
                    const summaryText = result.summaries[memberOriginalName];
                    if (summaryText && summaryText.trim()) {
                        const memberChat = Object.values(state.chats).find(c => c.originalName === memberOriginalName);
                        if (memberChat) {
                            const newMemoryEntry = {
                                content: summaryText.trim(),
                                timestamp: Date.now(),
                                source: `group_summary_from_${chat.name}`
                            };
                            if (!memberChat.longTermMemory) memberChat.longTermMemory = [];
                            memberChat.longTermMemory.push(newMemoryEntry);
                            await db.chats.put(memberChat);
                            memoriesAddedCount++;
                        }
                    }
                }
                if (memoriesAddedCount > 0) {
                    // *** 修改點 1：移除彈窗，改為在控制台輸出日誌 ***
                    console.log(`自動總結成功：為 ${memoriesAddedCount} 位群成員生成並注入了個性化記憶！`);
                } else {
                    throw new Error("AI返回了空的或格式不正確的總結內容。");
                }
            } else {
                throw new Error("AI返回的JSON格式不正確，缺少 'summaries' 欄位。");
            }
        } else {
            if (result.summary && result.summary.trim()) {
                const newMemoryEntry = { content: result.summary.trim(), timestamp: Date.now(), source: 'auto' };
                chat.longTermMemory.push(newMemoryEntry);
                await db.chats.put(chat);
                // *** 修改點 2：移除彈窗，改為在控制台輸出日誌 ***
                console.log('自動總結成功：已成功添加 1 條新的長期記憶！');
            } else {
                throw new Error("AI返回了空的或格式不正確的總結內容。");
            }
        }

        chat.lastMemorySummaryTimestamp = messagesToSummarize.slice(-1)[0].timestamp;
        await db.chats.put(chat);
        
        if (document.getElementById('long-term-memory-screen').classList.contains('active')) {
            renderLongTermMemoryList();
        }
    } catch (error) {
        console.error("總結長期記憶時出錯:", error);
        // *** 修改點 3：失敗時依然彈出錯誤提示 ***
        await showCustomAlert('總結失敗', `操作失敗: ${error.message}`);
    }
}

        // ▼▼▼ 【全新】引用回復功能函數 ▼▼▼
        
        function startReplyToMessage() {
            if (!activeMessageTimestamp) return;
        
            const chat = state.chats[state.activeChatId];
            const message = chat.history.find(m => m.timestamp === activeMessageTimestamp);
            if (!message) return;
        
            // 【【【核心修復就在這裡！】】】
            let senderDisplayName;
            if (message.role === 'user') {
                senderDisplayName = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
            } else { // AI的消息
                if (chat.isGroup) {
                    // 在群聊中，我們使用 getDisplayNameInGroup 函數來獲取正確的群昵稱
                    senderDisplayName = getDisplayNameInGroup(chat, message.senderName);
                } else {
                    // 在單聊中，直接使用備註名
                    senderDisplayName = chat.name;
                }
            }
            // 【【【修復結束】】】
        
            const fullContent = String(message.content || '');
            let previewSnippet = '';
        
            if (typeof message.content === 'string' && STICKER_REGEX.test(message.content)) {
                previewSnippet = '[表情]';
            } else if (message.type === 'ai_image' || message.type === 'user_photo') {
                previewSnippet = '[圖片]';
            } else if (message.type === 'voice_message') {
                previewSnippet = '[語音]';
            } else {
                previewSnippet = fullContent.substring(0, 50) + (fullContent.length > 50 ? '...' : '');
            }
        
            currentReplyContext = {
                timestamp: message.timestamp,
                senderName: senderDisplayName, // 使用我們剛剛獲取到的、正確的顯示名稱
                content: fullContent, 
            };
        
            const previewBar = document.getElementById('reply-preview-bar');
            previewBar.querySelector('.sender').textContent = `回復 ${currentReplyContext.senderName}:`;
            previewBar.querySelector('.text').textContent = previewSnippet;
            previewBar.style.display = 'block';
        
            hideMessageActions();
            document.getElementById('chat-input').focus();
        }
        
        function cancelReplyMode() {
            currentReplyContext = null;
            document.getElementById('reply-preview-bar').style.display = 'none';
        }
        
        // ▲▲▲ 新函數黏貼結束 ▲▲▲
        
        // ▼▼▼ 【全新】使用者處理轉帳的核心功能函數 ▼▼▼
        
        let activeTransferTimestamp = null; // 用於暫存被點擊的轉帳消息的時間戳記
        
        /**
         * 顯示處理轉帳的操作功能表
         * @param {number} timestamp - 被點擊的轉帳消息的時間戳記
         */
        function showTransferActionModal(timestamp) {
            activeTransferTimestamp = timestamp;
        
            const chat = state.chats[state.activeChatId];
            const message = chat.history.find(m => m.timestamp === timestamp);
            if (message) {
                // 將AI的名字填入彈窗
                document.getElementById('transfer-sender-name').textContent = message.senderName;
            }
            document.getElementById('transfer-actions-modal').classList.add('visible');
        }
        
        /**
         * 隱藏處理轉帳的操作功能表
         */
        function hideTransferActionModal() {
            document.getElementById('transfer-actions-modal').classList.remove('visible');
            activeTransferTimestamp = null;
        }
        
        /**
         * 處理使用者接受或拒絕轉帳的邏輯
         * @param {string} choice - 用戶的選擇, 'accepted' 或 'declined'
         */
        async function handleUserTransferResponse(choice) {
            if (!activeTransferTimestamp) return;
        
            const timestamp = activeTransferTimestamp;
            const chat = state.chats[state.activeChatId];
            const messageIndex = chat.history.findIndex(m => m.timestamp === timestamp);
            if (messageIndex === -1) return;
        
            // 1. 更新原始轉帳消息的狀態
            const originalMessage = chat.history[messageIndex];
            originalMessage.status = choice;
        
            let systemContent;
        
            // 2. 如果用戶選擇“拒絕”
            if (choice === 'declined') {
                // 立刻在前端生成一個“退款”卡片，讓使用者看到
                const refundMessage = {
                    role: 'user',
                    type: 'transfer',
                    isRefund: true, // 這是一個關鍵標記，用於UI顯示這是退款
                    amount: originalMessage.amount,
                    note: '已拒收對方轉帳',
                    timestamp: Date.now()
                };
                chat.history.push(refundMessage);
                
                // 準備一條對AI可見的隱藏消息，告訴它發生了什麼
                systemContent = `[系統提示：你拒絕並退還了“${originalMessage.senderName}”的轉帳。]`;
            } else { // 如果用戶選擇“接受”
                // 只需準備隱藏消息通知AI即可
                systemContent = `[系統提示：你接受了“${originalMessage.senderName}”的轉帳。]`;
            }
        
            // 3. 創建這條對用戶隱藏、但對AI可見的系統消息
            const hiddenMessage = {
                role: 'system',
                content: systemContent,
                timestamp: Date.now() + 1, // 保證時間戳記在退款消息之後
                isHidden: true // 這個標記會讓它不在聊天介面顯示
            };
            chat.history.push(hiddenMessage);
        
            // 4. 保存所有更改到資料庫，並刷新介面
            await db.chats.put(chat);
            hideTransferActionModal(); 
            renderChatInterface(state.activeChatId);
            renderChatList();
        }
        
        // ▲▲▲ 新函數黏貼結束 ▲▲▲
        
        // ▼▼▼ 【全新】通話記錄功能核心函數 ▼▼▼
        
        async function renderCallHistoryScreen() {
            showScreen('call-history-screen'); // <--【核心修正】把它移動到最前面！
        
            const listEl = document.getElementById('call-history-list');
            const titleEl = document.getElementById('call-history-title');
            listEl.innerHTML = '';
            titleEl.textContent = '所有通話記錄';
            
            const records = await db.callRecords.orderBy('timestamp').reverse().toArray();
            
            if (records.length === 0) {
                listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">這裡還沒有通話記錄哦~</p>';
                return; // 現在的 return 就沒問題了，因為它只跳過了後續的渲染邏輯
            }
            
            records.forEach(record => {
                const card = createCallRecordCard(record);
        
            addLongPressListener(card, async () => {
                // 1. 彈出輸入框，並將舊名稱作為預設值，方便修改
                const newName = await showCustomPrompt(
                    "自訂通話名稱", 
                    "請輸入新的名稱（留空則恢復默認）",
                    record.customName || '' // 如果已有自訂名稱，就顯示它
                );
        
                // 2. 如果用戶點擊了“取消”，則什麼都不做
                if (newName === null) return;
                
                // 3. 更新資料庫中的這條記錄
                await db.callRecords.update(record.id, { customName: newName.trim() });
                
                // 4. 刷新整個清單，讓更改立刻顯示出來
                await renderCallHistoryScreen();
                
                // 5. 給用戶一個成功的提示
                await showCustomAlert('成功', '通話名稱已更新！');
            });
                listEl.appendChild(card);
            });    
        }
        
        // ▼▼▼ 用這個【升級版】函數，完整替換你舊的 createCallRecordCard 函數 ▼▼▼
        /**
         * 【升級版】根據單條記錄資料，創建一張能顯示聊天物件的通話卡片
         * @param {object} record - 一條通話記錄物件
         * @returns {HTMLElement} - 創建好的卡片div
         */
        function createCallRecordCard(record) {
            const card = document.createElement('div');
            card.className = 'call-record-card';
            card.dataset.recordId = record.id; 
        
            // 獲取通話對象的名字
            const chatInfo = state.chats[record.chatId];
            const chatName = chatInfo ? chatInfo.name : '未知會話';
        
            const callDate = new Date(record.timestamp);
            const dateString = `${callDate.getFullYear()}-${String(callDate.getMonth() + 1).padStart(2, '0')}-${String(callDate.getDate()).padStart(2, '0')} ${String(callDate.getHours()).padStart(2, '0')}:${String(callDate.getMinutes()).padStart(2, '0')}`;
            const durationText = `${Math.floor(record.duration / 60)}分${record.duration % 60}秒`;
        
            const avatarsHtml = record.participants.map(p => 
                `<img src="${p.avatar}" alt="${p.name}" class="participant-avatar" title="${p.name}">`
            ).join('');
            
            card.innerHTML = `
                <div class="card-header">
                    <span class="date">${dateString}</span>
                    <span class="duration">${durationText}</span>
                </div>
                <div class="card-body">
                    <!-- 【核心修改】在這裡新增一個標題行 -->
                    ${record.customName ? `<div class="custom-title">${record.customName}</div>` : ''}
                    
                    <div class="participants-info"> <!-- 新增一個容器方便佈局 -->
                        <div class="participants-avatars">${avatarsHtml}</div>
                        <span class="participants-names">與 ${chatName}</span>
                    </div>
                </div>
            `;
            return card;
        }
        // ▲▲▲ 替換結束 ▲▲▲
        
/**
 * 【V2.0 | 支援手動總結 & 錯誤處理】顯示指定通話記錄的完整文字稿
 * @param {number} recordId - 通話記錄的ID
 */
async function showCallTranscript(recordId) {
    const record = await db.callRecords.get(recordId);
    if (!record) return;

    const modal = document.getElementById('call-transcript-modal');
    const titleEl = document.getElementById('transcript-modal-title');
    const bodyEl = document.getElementById('call-transcript-modal-body');

    titleEl.textContent = `通話於 ${new Date(record.timestamp).toLocaleString()} (時長: ${Math.floor(record.duration / 60)}分${record.duration % 60}秒)`;
    bodyEl.innerHTML = '';
    
    const deleteBtn = document.getElementById('delete-transcript-btn');
    const summarizeBtn = document.getElementById('manual-summarize-btn');
    
    if (!record.transcript || record.transcript.length === 0) {
        bodyEl.innerHTML = '<p style="text-align:center; color: #8a8a8a;">這次通話沒有留下文字記錄。</p>';
        summarizeBtn.style.display = 'none';
    } else {
        summarizeBtn.style.display = 'block';
        record.transcript.forEach(entry => {
            const bubble = document.createElement('div');
            bubble.className = `transcript-entry ${entry.role}`; 
            bubble.textContent = entry.content;
            bodyEl.appendChild(bubble);
        });
    }

    const newDeleteBtn = deleteBtn.cloneNode(true);
    deleteBtn.parentNode.replaceChild(newDeleteBtn, deleteBtn);
    const newSummarizeBtn = summarizeBtn.cloneNode(true);
    summarizeBtn.parentNode.replaceChild(newSummarizeBtn, summarizeBtn);
    
    newDeleteBtn.addEventListener('click', async () => {
        const confirmed = await showCustomConfirm(
            "確認刪除", "確定要永久刪除這條通話記錄嗎？此操作不可恢復。", { confirmButtonClass: 'btn-danger' }
        );
        if (confirmed) {
            modal.classList.remove('visible');
            await db.callRecords.delete(recordId);
            await renderCallHistoryScreen();
            alert('通話記錄已刪除。');
        }
    });

// ▼▼▼ 【這是您需要替換的代碼塊】 ▼▼▼

newSummarizeBtn.addEventListener('click', async () => {
    // 【核心新增1】在執行操作前，先彈出確認框
    const confirmed = await showCustomConfirm(
        '確認操作',
        '這將提取當前通話記錄發送給AI進行總結，會消耗API額度。確定要繼續嗎？', {
            confirmText: '確認總結'
        }
    );

    // 如果用戶取消，則不執行任何操作
    if (!confirmed) return;

    modal.classList.remove('visible');
    const chat = state.chats[record.chatId];
    if (!chat) {
        alert('錯誤：找不到該通話記錄所屬的聊天物件。');
        return;
    }

    await showCustomAlert("請稍候...", "正在請求AI進行手動總結...");

    try {
        const transcriptText = record.transcript.map(h => {
            const sender = h.role === 'user' ? (chat.settings.myNickname || '我') : (h.senderName || chat.name);
            return `${sender}: ${h.content}`;
        }).join('\n');

        await summarizeCallTranscript(record.chatId, transcriptText);

        await showCustomAlert("總結成功", `手動總結已完成！新的記憶已添加到“${chat.name}”的長期記憶中。`);

    } catch (error) {
        await showCustomAlert("總結失敗", `操作失敗，未能生成長期記憶。\n\n錯誤詳情: ${error.message}`);
    }
});

// ▲▲▲ 替換到這裡結束 ▲▲▲
// ▼▼▼ 【這是您需要添加的核心修復代碼】 ▼▼▼

// 3. 為“關閉”按鈕也創建克隆並綁定事件，確保它總是可用
const closeBtn = document.getElementById('close-transcript-modal-btn');
const newCloseBtn = closeBtn.cloneNode(true);
closeBtn.parentNode.replaceChild(newCloseBtn, closeBtn);

newCloseBtn.addEventListener('click', () => {
    modal.classList.remove('visible');
});

// ▲▲▲ 新增代碼黏貼結束 ▲▲▲
    modal.classList.add('visible');
}
        
        // ▲▲▲ 新函數黏貼結束 ▲▲▲
        
        // ▼▼▼ 請用這個【全新函數】替換掉你舊的 handleStatusResetClick 函數 ▼▼▼
        
        /**
         * 【全新】處理用戶點擊狀態列，彈出編輯方塊讓使用者修改AI的當前狀態
         */
        async function handleEditStatusClick() {
            // 1. 安全檢查，確保在單聊介面
            if (!state.activeChatId || state.chats[state.activeChatId].isGroup) {
                return; 
            }
            const chat = state.chats[state.activeChatId];
        
            // 2. 彈出輸入框，讓使用者輸入新的狀態，並將當前狀態作為預設值
            const newStatusText = await showCustomPrompt(
                '編輯對方狀態',
                '請輸入對方現在的新狀態：',
                chat.status.text // 將當前狀態作為輸入框的預設內容
            );
        
            // 3. 如果使用者輸入了內容並點擊了“確定”
            if (newStatusText !== null) {
                // 4. 更新記憶體和資料庫中的狀態資料
                chat.status.text = newStatusText.trim() || '線上'; // 如果用戶清空了，就默認為“線上”
                chat.status.isBusy = false; // 每次手動編輯都默認其不處於“忙碌”狀態
                chat.status.lastUpdate = Date.now();
                await db.chats.put(chat);
        
                // 5. 立刻刷新UI，讓使用者看到修改後的狀態
                renderChatInterface(state.activeChatId);
                renderChatList();
                
                // 6. 給出一個無傷大雅的成功提示
                await showCustomAlert('狀態已更新', `“${chat.name}”的當前狀態已更新為：${chat.status.text}`);
            }
        }
        
        // 放在你的JS功能函式定義區
        async function openShareTargetPicker() {
            const modal = document.getElementById('share-target-modal');
            const listEl = document.getElementById('share-target-list');
            listEl.innerHTML = '';
        
            // 獲取所有聊天作為分享目標
            const chats = Object.values(state.chats);
        
            chats.forEach(chat => {
                // 複用連絡人選擇器的樣式
                const item = document.createElement('div');
                item.className = 'contact-picker-item'; 
                item.innerHTML = `
                    <input type="checkbox" class="share-target-checkbox" data-chat-id="${chat.id}" style="margin-right: 15px;">
                    <img src="${chat.isGroup ? chat.settings.groupAvatar : chat.settings.aiAvatar || defaultAvatar}" class="avatar">
                    <span class="name">${chat.name}</span>
                `;
                listEl.appendChild(item);
            });
            
            modal.classList.add('visible');
        }
        
        function closeMusicPlayerWithAnimation(callback) {
            const overlay = document.getElementById('music-player-overlay');
            if (!overlay.classList.contains('visible')) {
                if (callback) callback();
                return;
            }
            overlay.classList.remove('visible');
            setTimeout(() => {
                document.getElementById('music-playlist-panel').classList.remove('visible');
                if (callback) callback();
            }, 400); 
        }
        
function parseLRC(lrcContent) {
    if (!lrcContent) return [];
    const lines = String(lrcContent).split(/\r\n?|\n/);
    const lyrics = [];
    const timeRegex = /\[(\d{2}):(\d{2})[.:](\d{2,3})\]/g;
    for (const line of lines) {
        const text = line.replace(timeRegex, '').trim();
        if (!text) continue;
        timeRegex.lastIndex = 0;
        let match;
        while ((match = timeRegex.exec(line)) !== null) {
            const minutes = parseInt(match[1], 10);
            const seconds = parseInt(match[2], 10);
            const milliseconds = parseInt(match[3].padEnd(3, '0'), 10);
            const time = minutes * 60 + seconds + milliseconds / 1000;
            lyrics.push({ time, text });
        }
    }
    return lyrics.sort((a, b) => a.time - b.time);
}

function renderLyrics() {
    const lyricsList = document.getElementById('music-lyrics-list');
    lyricsList.innerHTML = '';
    if (!musicState.parsedLyrics || musicState.parsedLyrics.length === 0) {
        lyricsList.innerHTML = '<div class="lyric-line">♪ 暫無歌詞 ♪</div>';
        return;
    }
    musicState.parsedLyrics.forEach((line, index) => {
        const lineEl = document.createElement('div');
        lineEl.className = 'lyric-line';
        lineEl.textContent = line.text;
        lineEl.dataset.index = index;
        lyricsList.appendChild(lineEl);
    });
    lyricsList.style.transform = `translateY(0px)`;
}

function updateActiveLyric(currentTime) {
    if (musicState.parsedLyrics.length === 0) return;
    let newLyricIndex = -1;
    for (let i = 0; i < musicState.parsedLyrics.length; i++) {
        if (currentTime >= musicState.parsedLyrics[i].time) {
            newLyricIndex = i;
        } else {
            break;
        }
    }
    if (newLyricIndex === musicState.currentLyricIndex) return;
    musicState.currentLyricIndex = newLyricIndex;
    updateLyricsUI();
    
    const singleLyricEl = document.getElementById('single-lyric-display');
    if (singleLyricEl) {
        if (newLyricIndex > -1 && musicState.parsedLyrics[newLyricIndex]) {
            singleLyricEl.textContent = musicState.parsedLyrics[newLyricIndex].text;
        } else {
            singleLyricEl.textContent = '♪ ♪ ♪';
        }
    }

    const lyricBar = document.getElementById('global-lyrics-bar');
    if (lyricBar.classList.contains('visible')) {
        if (newLyricIndex > -1 && musicState.parsedLyrics[newLyricIndex]) {
            lyricBar.textContent = musicState.parsedLyrics[newLyricIndex].text;
        } else {
            lyricBar.textContent = '♪';
        }
    }
}

function updateLyricsUI(isFullscreen = false) {
    const listSelector = isFullscreen ? '#fullscreen-lyrics-container .music-lyrics-list' : '#music-lyrics-container #music-lyrics-list';
    const containerSelector = isFullscreen ? '#fullscreen-lyrics-container' : '#music-lyrics-container';
    
    const lyricsList = document.querySelector(listSelector);
    const container = document.querySelector(containerSelector);
    if (!lyricsList || !container) return;

    const lines = lyricsList.querySelectorAll('.lyric-line');
    lines.forEach(line => line.classList.remove('active'));

    if (musicState.currentLyricIndex === -1) {
        lyricsList.style.transform = `translateY(0px)`;
        return;
    }

    const activeLine = lyricsList.querySelector(`.lyric-line[data-index="${musicState.currentLyricIndex}"]`);
    if (activeLine) {
        activeLine.classList.add('active');
        const containerHeight = container.offsetHeight;
        const offset = (containerHeight / 2.2) - activeLine.offsetTop - (activeLine.offsetHeight / 2);
        lyricsList.style.transform = `translateY(${offset}px)`;
    }
}

function formatMusicTime(seconds) {
    if (isNaN(seconds) || seconds < 0) return "0:00";
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = Math.floor(seconds % 60);
    return `${minutes}:${String(remainingSeconds).padStart(2, '0')}`;
}

let lastTimeUpdate = 0; 
let animationFrameId; 

function updateMusicProgressBar() {
    if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
    }

    function step() {
        if (!musicState.isPlaying || !audioPlayer.duration) {
            return; 
        }
        
        const now = performance.now();
        const currentTime = audioPlayer.currentTime;
        const duration = audioPlayer.duration;

        const progressPercent = (currentTime / duration) * 100;
        document.getElementById('music-progress-fill').style.width = `${progressPercent}%`;

        if (now - lastTimeUpdate > 1000) {
            document.getElementById('music-current-time').textContent = formatMusicTime(currentTime);
            document.getElementById('music-total-time').textContent = formatMusicTime(duration);
            lastTimeUpdate = now;
        }

        updateActiveLyric(currentTime);

        animationFrameId = requestAnimationFrame(step);
    }

    animationFrameId = requestAnimationFrame(step);
}
        // ▲▲▲ 替換結束 ▲▲▲
        
        // ▼▼▼ 【全新】導演模式核心功能 ▼▼▼
        
        /**
         * 【總入口】打開“導演剪輯室”，編輯AI的上一輪回應
         */
        function openAiResponseEditor() {
            if (!lastRawAiResponse) {
                alert("還沒有可供編輯的AI回應。請先讓AI回復一次。");
                return;
            }
        
            const editorModal = document.getElementById('ai-response-editor-modal');
            const editorContainer = document.getElementById('ai-response-editor-container');
            editorContainer.innerHTML = ''; // 清空舊內容
        
            // 使用與主流程相同的、強大的解析函數來提取所有JSON物件
            const jsonMatches = lastRawAiResponse.match(/{[^{}]*}/g);
            
            if (jsonMatches) {
                jsonMatches.forEach(jsonString => {
                    try {
                        // 美化JSON格式，方便閱讀和編輯
                        const parsedObject = JSON.parse(jsonString);
                        const formattedJson = JSON.stringify(parsedObject, null, 2);
                        const block = createAiResponseEditorBlock(formattedJson);
                        editorContainer.appendChild(block);
                    } catch (e) {
                        // 如果某個片段不是有效的JSON，也把它顯示出來，讓使用者可以修正它
                        const block = createAiResponseEditorBlock(jsonString);
                        editorContainer.appendChild(block);
                        console.warn("在導演模式中發現一個無效的JSON片段:", jsonString);
                    }
                });
            } else {
                // 如果完全沒有找到JSON，就把原始文本放進去讓使用者編輯
                const block = createAiResponseEditorBlock(lastRawAiResponse);
                editorContainer.appendChild(block);
            }
            
            editorModal.classList.add('visible');
        }
        
// ▼▼▼ 【請用這個已添加“引用”範本的版本】替換舊的 createAiResponseEditorBlock 函數 ▼▼▼
/**
 * 【輔助函數】創建一個可編輯的AI響應塊
 * @param {string} initialContent - 文字方塊的初始內容
 * @returns {HTMLElement} - 創建好的DOM元素
 */
function createAiResponseEditorBlock(initialContent = '') {
    const block = document.createElement('div');
    block.className = 'ai-response-editor-block';

    // 【核心修改1】在這裡添加 'quote' 範本
    const templates = {
        text: { type: 'text', content: '在這裡輸入文本...' },
        sticker: { type: 'sticker', url: 'https://...', meaning: '表情含義' },
        image: { type: 'ai_image', description: '在這裡輸入圖片描述...' },
        voice: { type: 'voice_message', content: '在這裡輸入語音內容...' },
        transfer: { type: 'transfer', amount: 5.20, note: '一點心意' },
        offline: { type: 'offline_text', content: '「在這裡輸入對話內容」\\n(在這裡輸入動作或環境描寫)' },
        quote: { type: 'quote_reply', target_timestamp: 1234567890, reply_content: '在這裡輸入回復內容' }
    };

    block.innerHTML = `
        <button class="delete-block-btn" title="刪除此條動作">×</button>
        <textarea>${initialContent}</textarea>
        <div class="format-helpers">
            <button class="format-btn" data-template='${JSON.stringify(templates.text)}'>文本</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.sticker)}'>表情</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.image)}'>圖片</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.voice)}'>語音</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.transfer)}'>轉帳</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.offline)}'>線下</button>
            <!-- 【核心修改2】在這裡添加新的“引用”按鈕 -->
            <button class="format-btn" data-template='${JSON.stringify(templates.quote)}'>引用</button>
        </div>
    `;

    // 綁定刪除按鈕事件
    block.querySelector('.delete-block-btn').addEventListener('click', () => {
        block.remove();
    });

    // 綁定格式助手按鈕事件
    block.querySelectorAll('.format-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const templateStr = btn.dataset.template;
            const textarea = block.querySelector('textarea');
            if (templateStr && textarea) {
                try {
                    const templateObj = JSON.parse(templateStr);
                    // 美化格式後填入
                    textarea.value = JSON.stringify(templateObj, null, 2);
                    textarea.focus();
                } catch(e) { console.error("解析格式範本失敗:", e); }
            }
        });
    });

    return block;
}
// ▲▲▲ 替換結束 ▲▲▲
        // ▼▼▼ 【V3.0 | 容錯終極修復版】請用這個全新的函數，完整替換舊的 saveEditedAiResponse 函數 ▼▼▼
        /**
         * 【核心】保存導演模式下修改過的內容，並重寫歷史記錄
         */
        async function saveEditedAiResponse() {
            const chat = state.chats[state.activeChatId];
            if (!chat) return;
        
            // 1. 從DOM中收集所有編輯後的JSON字串，並構建一個新的原始響應字串
            const editorContainer = document.getElementById('ai-response-editor-container');
            const editorTextareas = editorContainer.querySelectorAll('textarea');
            const editedRawBlocks = Array.from(editorTextareas).map(ta => ta.value.trim()).filter(Boolean);
        
            // 如果使用者刪除了所有內容，則視為清空上一輪回復
            if (editedRawBlocks.length === 0) {
                chat.history = chat.history.filter(msg => !lastResponseTimestamps.includes(msg.timestamp));
                await db.chats.put(chat);
                renderChatInterface(state.activeChatId);
                renderChatList();
                document.getElementById('ai-response-editor-modal').classList.remove('visible');
                lastRawAiResponse = '';
                lastResponseTimestamps = [];
                return;
            }
        
            // 2. 解析新的消息陣列
            let newMessagesArray = [];
            for (const rawContent of editedRawBlocks) {
                try {
                    const parsedObject = JSON.parse(rawContent);
                    newMessagesArray.push(parsedObject);
                } catch (e) {
                    console.warn("跳過一個無法解析為JSON的編輯塊:", rawContent);
                }
            }
        
            // 3. 從聊天歷史中移除上一輪AI生成的所有消息
            chat.history = chat.history.filter(msg => !lastResponseTimestamps.includes(msg.timestamp));
        
            // 4. 將新編輯的消息添加回歷史記錄，並記錄它們新的時間戳記
            let newTimestamps = [];
            let messageTimestamp = Date.now();
            
            for (const msgData of newMessagesArray) {
                 if (!msgData || typeof msgData !== 'object' || !msgData.type) {
                    console.warn("在導演模式保存時，發現無效的指令物件，已跳過:", msgData);
                    continue;
                }
        
                let aiMessage = null;
                const baseMessage = { role: 'assistant', senderName: msgData.name || chat.originalName, timestamp: messageTimestamp++ };
        
                switch (msgData.type) {
                    case 'text':
                        aiMessage = { ...baseMessage, content: String(msgData.content || msgData.message) };
                        break;
                    case 'sticker':
                        aiMessage = { ...baseMessage, type: 'sticker', content: msgData.url, meaning: msgData.meaning || '' };
                        break;
                    case 'ai_image':
                        aiMessage = { ...baseMessage, type: 'ai_image', content: msgData.description };
                        break;
                    case 'voice_message':
                        aiMessage = { ...baseMessage, type: 'voice_message', content: msgData.content };
                        break;
                    case 'transfer':
                        aiMessage = { ...baseMessage, type: 'transfer', amount: msgData.amount, note: msgData.note, receiverName: msgData.receiver || '我' };
                        break;
                    case 'waimai_request':
                        aiMessage = { 
                            ...baseMessage, type: 'waimai_request',
                            productInfo: msgData.productInfo, amount: msgData.amount,
                            status: 'pending', countdownEndTime: Date.now() + 15 * 60 * 1000,
                        };
                        break;
                    case 'offline_text':
                           aiMessage = { ...baseMessage, ...msgData };
                        break;
                    // ▼▼▼ 在這裡黏貼新代碼 ▼▼▼
                    case 'gomoku_move': {
                        const gameState = gomokuState[chat.id];
                        if (gameState) {
                            // 1. 找到AI的上一步棋
                            const lastAiMoveIndex = gameState.history.findLastIndex(move => move.player === 2);
                            
                            if (lastAiMoveIndex > -1) {
                                const move_to_undo = gameState.history[lastAiMoveIndex];
                                
                                // 2. 從棋盤數據中“拿掉”這顆棋子
                                gameState.board[move_to_undo.y][move_to_undo.x] = 0;
                                
                                // 3. 從下棋歷史中移除這一步
                                gameState.history.splice(lastAiMoveIndex, 1);
                                
                                console.log(`導演模式悔棋：已撤銷AI在 (${move_to_undo.x}, ${move_to_undo.y}) 的棋步。`);
                            }
                        }

                        // 4. 執行新的下棋指令
                        const x = parseInt(msgData.x);
                        const y = parseInt(msgData.y);
                        if (!isNaN(x) && !isNaN(y)) {
                            handleAiGomokuMove({ x: x, y: y }, true);
                        } else {
                            console.warn("導演模式保存了一個無效的五子棋移動指令:", msgData);
                        }
                        continue;
                    }
                    case 'update_thoughts': { 
    if (!chat.isGroup) {
        if (msgData.heartfelt_voice) {
            chat.heartfeltVoice = String(msgData.heartfelt_voice);
        }
        if (msgData.random_jottings) {
            chat.randomJottings = String(msgData.random_jottings);
        }
        if (!Array.isArray(chat.thoughtsHistory)) {
            chat.thoughtsHistory = [];
        }
        chat.thoughtsHistory.push({
            heartfeltVoice: chat.heartfeltVoice,
            randomJottings: chat.randomJottings,
            timestamp: Date.now()
        });
        if (chat.thoughtsHistory.length > 50) {
            chat.thoughtsHistory.shift();
        }

        // --- 【【【核心修改就在這裡！】】】 ---
        // 1. 將剛剛更新的心聲和散記，格式化為一段AI能理解的文本。
        const thoughtForMemory = `[這是你上一輪的內心獨白和思考]
- 心聲: ${chat.heartfeltVoice}
- 散記: ${chat.randomJottings}`;
        
        // 2. 創建一條對使用者隱藏的系統消息
        const hiddenThoughtMessage = {
            role: 'system',
            content: thoughtForMemory,
            timestamp: Date.now(),
            isHidden: true // 這個關鍵標記確保使用者看不到這條指令，但它存在於歷史記錄中
        };

        // 3. 將這條“記憶碎片”也存入聊天記錄
        chat.history.push(hiddenThoughtMessage);
        // --- 【【【修改結束】】】 ---
    }
    continue;
                    }
                    // ▲▲▲ 新代碼黏貼結束 ▲▲▲
                    // 在 switch 語句中，添加一個專門處理 'quote_reply' 的 case
                    case 'quote_reply': {
                        // 1. 查找被引用的原始消息
                        const originalQuotedMsg = chat.history.find(m => m.timestamp === msgData.target_timestamp);
                        let quoteContext = null;

                        if (originalQuotedMsg) {
                            // 2. 如果找到了，就構建正確的 quote 物件
                            let originalSenderName = originalQuotedMsg.senderName;
                            if (originalQuotedMsg.role === 'user') {
                                originalSenderName = chat.isGroup ? (chat.settings.myNickname || '我') : (state.qzoneSettings.nickname || '{{user}}');
                            }
                            
                            quoteContext = {
                                timestamp: msgData.target_timestamp,
                                senderName: originalSenderName,
                                content: String(originalQuotedMsg.content || '')
                            };
                        } else {
                            // 3. 如果沒找到，創建一個安全的預留位置，防止程式出錯
                            quoteContext = {
                                timestamp: msgData.target_timestamp,
                                senderName: '未知用戶',
                                content: '原始消息已刪除或不存在'
                            };
                        }
                        
                        // 4. 構建最終的消息物件，包含 quote 屬性
                        aiMessage = { 
                            ...baseMessage, 
                            content: msgData.reply_content,
                            quote: quoteContext
                        };
                        break; // 結束這個 case
                    }
                    default:
                         console.warn("在導演模式保存時，遇到了未知的AI指令類型:", msgData.type);
                         break;
                }
        
                if (aiMessage) {
                    chat.history.push(aiMessage);
                    newTimestamps.push(aiMessage.timestamp);
                }
            }
        
            // 5. 保存到資料庫並刷新整個聊天介面
            await db.chats.put(chat);
            renderChatInterface(state.activeChatId);
            renderChatList();
            document.getElementById('ai-response-editor-modal').classList.remove('visible');
            
            // 6. 更新緩存，以便下次編輯
            lastRawAiResponse = editedRawBlocks.join('\n\n');
            lastResponseTimestamps = newTimestamps;
            
            // 7. 給出成功提示
            await showCustomAlert("導演模式", "您的修改已保存！");
        }
        /**
         * 【全新】處理使用者點擊“撤回”按鈕的入口函數
         */
        async function handleRecallClick() {
            if (!activeMessageTimestamp) return;
        
            const RECALL_TIME_LIMIT_MS = 2 * 60 * 1000; // 設置2分鐘的撤回時限
            const messageTime = activeMessageTimestamp;
            const now = Date.now();
        
            // 檢查是否超過了撤回時限
            if (now - messageTime > RECALL_TIME_LIMIT_MS) {
                hideMessageActions();
                await showCustomAlert('操作失敗', '該消息發送已超過2分鐘，無法撤回。');
                return;
            }
            
            // 如果在時限內，執行真正的撤回邏輯
            await recallMessage(messageTime, true);
            hideMessageActions();
        }
        
/**
 * 【V2.0 | AI感知版】消息撤回的核心邏輯
 * @param {number} timestamp - 要撤回的消息的時間戳記
 * @param {boolean} isUserRecall - 是否是用戶主動撤回
 */
async function recallMessage(timestamp, isUserRecall) {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const messageIndex = chat.history.findIndex(m => m.timestamp === timestamp);
    if (messageIndex === -1) return;

    const messageToRecall = chat.history[messageIndex];

    const recalledData = {
        originalType: messageToRecall.type || 'text',
        originalContent: messageToRecall.content,
        originalMeaning: messageToRecall.meaning,
        originalQuote: messageToRecall.quote
    };
    
    messageToRecall.type = 'recalled_message';
    messageToRecall.content = isUserRecall ? '你撤回了一條消息' : '對方撤回了一條消息';
    messageToRecall.recalledData = recalledData;
    delete messageToRecall.meaning;
    delete messageToRecall.quote;

    // ▼▼▼ 核心修改就在這裡！▼▼▼
    if (isUserRecall) {
        // 1. 獲取用戶在當前聊天中的正確昵稱
        const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
        
        // 2. 將被撤回的內容轉換為AI能理解的文本
        let recalledContentText = '';
        if (recalledData.originalType === 'sticker') {
            recalledContentText = `[表情，含義: ${recalledData.originalMeaning || '未知'}]`;
        } else if (recalledData.originalType === 'ai_image' || recalledData.originalType === 'user_photo') {
            recalledContentText = `[圖片，描述: ${recalledData.originalContent}]`;
        } else {
            recalledContentText = `“${String(recalledData.originalContent)}”`;
        }

        // 3. 創建一條對用戶隱藏、但對AI可見的系統消息
        const hiddenMessageForAI = {
            role: 'system',
            content: `[系統提示：用戶（${myNickname}）剛剛撤回了一條消息。撤回前的內容是：${recalledContentText}。請你對此作出回應，可以表現出好奇、開玩笑（比如'我截圖了！'）、或者根據你的人設表示理解或疑惑。]`,
            timestamp: Date.now(),
            isHidden: true // 這個標記確保使用者看不到這條指令
        };
        chat.history.push(hiddenMessageForAI);
    }
    // ▲▲▲ 修改結束 ▲▲▲

    await db.chats.put(chat);
    renderChatInterface(state.activeChatId);
    
    if (isUserRecall) {
        renderChatList();
        // 【重要】在用戶撤回後，立刻觸發AI，讓它對這個事件做出反應！
        triggerAiResponse();
    }
}
        
        // ▼▼▼ 【全新】將這些函數黏貼到你的JS功能函式定義區 ▼▼▼
        
        /**
         * 打開分類管理模態框
         */
        async function openCategoryManager() {
            await renderCategoryListInManager();
            document.getElementById('world-book-category-manager-modal').classList.add('visible');
        }
        
        /**
         * 在模態框中渲染已存在的分類列表
         */
        async function renderCategoryListInManager() {
            const listEl = document.getElementById('existing-categories-list');
            const categories = await db.worldBookCategories.toArray();
            listEl.innerHTML = '';
            if (categories.length === 0) {
                listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">還沒有任何分類</p>';
            }
            categories.forEach(cat => {
                // 複用好友分組的樣式
                const item = document.createElement('div');
                item.className = 'existing-group-item'; 
                item.innerHTML = `
                    <span class="group-name">${cat.name}</span>
                    <span class="delete-group-btn" data-id="${cat.id}">×</span>
                `;
                listEl.appendChild(item);
            });
        }
        
        /**
         * 添加一個新的世界書分類
         */
        async function addNewCategory() {
            const input = document.getElementById('new-category-name-input');
            const name = input.value.trim();
            if (!name) {
                alert('分類名不能為空！');
                return;
            }
            const existing = await db.worldBookCategories.where('name').equals(name).first();
            if (existing) {
                alert(`分類 "${name}" 已經存在了！`);
                return;
            }
            await db.worldBookCategories.add({ name });
            input.value = '';
            await renderCategoryListInManager();
        }
        
        /**
         * 刪除一個世界書分類
         * @param {number} categoryId - 要刪除的分類的ID
         */
        async function deleteCategory(categoryId) {
            const confirmed = await showCustomConfirm(
                '確認刪除', 
                '刪除分類後，該分類下的所有世界書將變為“未分類”。確定要刪除嗎？', 
                { confirmButtonClass: 'btn-danger' }
            );
            if (confirmed) {
                await db.worldBookCategories.delete(categoryId);
                // 將屬於該分類的世界書的 categoryId 設為 null
                const booksToUpdate = await db.worldBooks.where('categoryId').equals(categoryId).toArray();
                for (const book of booksToUpdate) {
                    book.categoryId = null;
                    await db.worldBooks.put(book);
                    const bookInState = state.worldBooks.find(wb => wb.id === book.id);
                    if(bookInState) bookInState.categoryId = null;
                }
                await renderCategoryListInManager();
            }
        }
        
        // ▼▼▼ 【全新版本】發佈公告函數 (無評論) ▼▼▼
        async function publishToAnnouncementBoard() {
            if (!activeMessageTimestamp) return;
        
            const timestampToPublish = activeMessageTimestamp;
            hideMessageActions(); 
        
            const chat = state.chats[state.activeChatId];
            const message = chat.history.find(m => m.timestamp === timestampToPublish);
            if (!message) return;
        
            // 提取消息內容用於預覽
            let contentPreview = String(message.content || '').substring(0, 50) + '...';
            if (message.type === 'ai_image') contentPreview = '[圖片] ' + contentPreview;
        
            const confirmed = await showCustomConfirm(
                "發佈公告",
                `確定要將以下消息發佈到公告板嗎？\n\n“${contentPreview}”`,
                { confirmText: "確定發佈" }
            );
        
            if (confirmed) {
                const myNickname = chat.settings.myNickname || '我';
        
                if (!Array.isArray(chat.announcements)) {
                    chat.announcements = [];
                }
        
                // 新增的公告對象
                const newAnnouncement = {
                    id: 'anno_' + Date.now(), // 為每個公告添加唯一ID
                    messageTimestamp: timestampToPublish,
                    publisher: myNickname,
                    publishedAt: Date.now(),
                    isPinned: false // 默認為不置頂
                };
        
                chat.announcements.push(newAnnouncement);
        
                const systemMessage = {
                    role: 'system',
                    type: 'pat_message',
                    content: `${myNickname} 發佈了一條新公告`,
                    timestamp: Date.now()
                };
                chat.history.push(systemMessage);
        
                await db.chats.put(chat);
                appendMessage(systemMessage, chat);
                renderChatList();
        
                await showCustomAlert("成功", "公告已發佈！");
            }
        }
        // ▲▲▲ 替換結束 ▲▲▲
        /**
         * 顯示群公告板彈窗
         */
        // ▼▼▼ 【最終修復版】請用這個全新的函數，完整替換舊的 showAnnouncementBoard 函數 ▼▼▼
        /**
         * 【V2.0 | 已修復非同步渲染BUG】顯示群公告板彈窗
         */
        async function showAnnouncementBoard() { // <--- 核心修復1：將函式宣告為 async
            const chat = state.chats[state.activeChatId];
            const announcements = chat.announcements || [];

            if (!chat || announcements.length === 0) {
                showCustomAlert("提示", "當前群聊還沒有公告哦。");
                return;
            }

            const contentEl = document.getElementById('announcement-board-content');
            contentEl.innerHTML = '';

            // 將置頂的公告排在最前面
            announcements.sort((a, b) => (b.isPinned ? 1 : 0) - (a.isPinned ? 1 : 0));

            // 【核心修復2】使用 for...of 迴圈，以便在迴圈內部安全地使用 await
            for (const anno of announcements) {
                const originalMessage = chat.history.find(m => m.timestamp === anno.messageTimestamp);

                const wrapper = document.createElement('div');
                wrapper.className = 'announcement-item-wrapper';

                if (originalMessage) {
                    // 【核心修復3】在這裡使用 await，等待 createMessageElement 函數真正完成並返回HTML元素
                    const messageBubbleEl = await createMessageElement(originalMessage, chat);
                    if (messageBubbleEl) { // 安全檢查，確保元素已成功創建
                        wrapper.appendChild(messageBubbleEl);
                    }
                } else {
                    wrapper.innerHTML = '<p style="text-align:center; color: var(--text-secondary);">公告的原消息已被刪除。</p>';
                }

                if (anno.isPinned) {
                    wrapper.innerHTML += `<div class="pinned-indicator">📌</div>`;
                }
                wrapper.innerHTML += `<div class="announcement-item-actions" data-anno-id="${anno.id}">...</div>`;

                contentEl.appendChild(wrapper);
            }

            document.getElementById('announcement-board-modal').classList.add('visible');
        }
        // ▲▲▲ 替換結束 ▲▲▲
        // ▼▼▼ 【這是您缺失的核心功能代碼，請黏貼在這裡】 ▼▼▼
        let activeAnnouncementId = null; // 用於暫存正在操作的公告ID
        
        /**
         * 點擊“...”時，顯示操作功能表（置頂/刪除）
         * @param {string} annoId - 公告的唯一ID
         */
        function showAnnouncementActions(annoId) {
            activeAnnouncementId = annoId;
            const chat = state.chats[state.activeChatId];
            const announcement = chat.announcements.find(a => a.id === annoId);
            if (!announcement) return;
        
            const pinButton = document.getElementById('announcement-action-pin');
            // 根據當前是否已置頂，動態改變按鈕文字
            pinButton.textContent = announcement.isPinned ? '取消置頂' : '置頂公告';
        
            document.getElementById('announcement-actions-modal').classList.add('visible');
        }
        
        /**
         * 處理“置頂/取消置頂”操作
         */
        async function handlePinAnnouncement() {
            if (!activeAnnouncementId) return;
            const chat = state.chats[state.activeChatId];
            const announcement = chat.announcements.find(a => a.id === activeAnnouncementId);
            if (announcement) {
                announcement.isPinned = !announcement.isPinned; // 切換置頂狀態
                await db.chats.put(chat);
                showAnnouncementBoard(); // 重新渲染公告板以更新UI
            }
            document.getElementById('announcement-actions-modal').classList.remove('visible');
        }
        
        /**
         * 處理“刪除公告”操作
         */
        async function handleDeleteAnnouncement() {
            if (!activeAnnouncementId) return;
            
            const confirmed = await showCustomConfirm("確認刪除", "確定要刪除這條公告嗎？此操作不可恢復。", { confirmButtonClass: 'btn-danger' });
            
            if (confirmed) {
                const chat = state.chats[state.activeChatId];
                // 從公告陣列中過濾掉要刪除的公告
                chat.announcements = chat.announcements.filter(a => a.id !== activeAnnouncementId);
                await db.chats.put(chat);
                showAnnouncementBoard(); // 重新渲染
            }
            document.getElementById('announcement-actions-modal').classList.remove('visible');
        }
        // ▲▲▲ 黏貼結束 ▲▲▲

        
        // ▼▼▼ 【這是您缺失的核心功能代碼，請黏貼在這裡】 ▼▼▼
        let editingFrameForMember = false;
        let currentFrameSelection = { ai: null, my: null };
        
        function openFrameSelectorModal(type = 'chat') {
            const frameModal = document.getElementById('avatar-frame-modal');
            if (!state.activeChatId) return;
            const chat = state.chats[state.activeChatId];
            editingFrameForMember = (type === 'member');
        
            if (editingFrameForMember) {
                const member = chat.members.find(m => m.id === editingMemberId);
                if (!member) return;
                currentFrameSelection.my = member.avatarFrame || '';
                populateFrameGrids(true, member.avatar, member.avatarFrame);
            } else {
                currentFrameSelection.ai = chat.settings.aiAvatarFrame || '';
                currentFrameSelection.my = chat.settings.myAvatarFrame || '';
                populateFrameGrids(false);
            }
            frameModal.classList.add('visible');
        }
        
        function populateFrameGrids(isForMember = false, memberAvatar = null, memberFrame = null) {
            const aiFrameGrid = document.getElementById('ai-frame-grid');
            const myFrameGrid = document.getElementById('my-frame-grid');
            const chat = state.chats[state.activeChatId];
            aiFrameGrid.innerHTML = '';
            myFrameGrid.innerHTML = '';
        
            document.querySelector('#avatar-frame-modal .frame-tabs').style.display = isForMember ? 'none' : 'flex';
            document.getElementById('ai-frame-content').style.display = 'block';
            document.getElementById('my-frame-content').style.display = 'none';
            document.getElementById('ai-frame-tab').classList.add('active');
            document.getElementById('my-frame-tab').classList.remove('active');
        
            if (isForMember) {
                avatarFrames.forEach(frame => {
                    const item = createFrameItem(frame, 'my', memberAvatar);
                    if (frame.url === memberFrame) {
                        item.classList.add('selected');
                    }
                    aiFrameGrid.appendChild(item);
                });
            } else {
                const aiAvatarForPreview = chat.settings.aiAvatar || defaultAvatar;
                const myAvatarForPreview = chat.settings.myAvatar || (chat.isGroup ? defaultMyGroupAvatar : defaultAvatar);
                avatarFrames.forEach(frame => {
                    const aiItem = createFrameItem(frame, 'ai', aiAvatarForPreview);
                    if (frame.url === currentFrameSelection.ai) aiItem.classList.add('selected');
                    aiFrameGrid.appendChild(aiItem);
                    const myItem = createFrameItem(frame, 'my', myAvatarForPreview);
                    if (frame.url === currentFrameSelection.my) myItem.classList.add('selected');
                    myFrameGrid.appendChild(myItem);
                });
            }
        }
        
        function createFrameItem(frame, type, previewAvatarSrc) {
            const item = document.createElement('div');
            item.className = 'frame-item';
            item.dataset.frameUrl = frame.url;
            item.title = frame.name;
            item.innerHTML = `
                <img src="${previewAvatarSrc}" class="preview-avatar">
                ${frame.url ? `<img src="${frame.url}" class="preview-frame">` : ''}
            `;
            item.addEventListener('click', () => {
                currentFrameSelection[type] = frame.url;
                const grid = type === 'ai' ? document.getElementById('ai-frame-grid') : document.getElementById('my-frame-grid');
                grid.querySelectorAll('.frame-item').forEach(el => el.classList.remove('selected'));
                item.classList.add('selected');
            });
            return item;
        }
        
        async function saveSelectedFrames() {
            if (!state.activeChatId) return;
            const chat = state.chats[state.activeChatId];
            if (editingFrameForMember) {
                const member = chat.members.find(m => m.id === editingMemberId);
                if (member) {
                    member.avatarFrame = currentFrameSelection.my;
                }
            } else {
                chat.settings.aiAvatarFrame = currentFrameSelection.ai;
                chat.settings.myAvatarFrame = currentFrameSelection.my;
            }
        // ... (函數前面的代碼) ...
            await db.chats.put(chat);
        
            // ▼▼▼ 在這裡黏貼修復代碼 ▼▼▼
            // 核心修復：當更新單聊角色的頭像框時，同步到所有包含該角色的群聊中
            if (!editingFrameForMember && !chat.isGroup) {
                const characterId = chat.id; // 獲取被修改的角色的ID
        
                // 遍歷所有聊天，找出包含這個角色的群聊
                for (const groupChat of Object.values(state.chats)) {
                    if (groupChat.isGroup && groupChat.members) {
                        // 在群聊中找到對應的成員對象
                        const memberToUpdate = groupChat.members.find(m => m.id === characterId);
        
                        // 如果找到了，就更新他的頭像框資訊
                        if (memberToUpdate) {
                            memberToUpdate.avatarFrame = chat.settings.aiAvatarFrame;
                            // 【至關重要】將修改後的【整個群聊物件】存回資料庫
                            await db.chats.put(groupChat);
                            console.log(`已同步角色 ${characterId} 的頭像框到群聊 "${groupChat.name}"`);
                        }
                    }
                }
            }
            // ▲▲▲ 修復代碼黏貼結束 ▲▲▲
        
            document.getElementById('avatar-frame-modal').classList.remove('visible');
            renderChatInterface(state.activeChatId);
            alert('頭像框已保存並同步！'); // 修改了提示，讓您知道同步也完成了
            editingFrameForMember = false;
        }
        
        // ▲▲▲ 黏貼結束 ▲▲▲
// ▼▼▼ 【全新】頭像框批量刪除功能核心函數 ▼▼▼

/**
 * 切換頭像框面板的管理模式
 */
function toggleFrameManagementMode() {
    isFrameManagementMode = !isFrameManagementMode;
    const manageBtn = document.getElementById('manage-frames-btn');
    const actionBar = document.getElementById('frame-action-bar');
    const selectAllCheckbox = document.getElementById('select-all-frames-checkbox');

    // 為兩個網格同時添加/移除管理模式的class
    document.querySelectorAll('.frame-grid').forEach(grid => {
        grid.classList.toggle('management-mode', isFrameManagementMode);
    });
    
    if (isFrameManagementMode) {
        manageBtn.textContent = '完成';
        actionBar.style.display = 'flex';
        selectedFrames.clear();
        selectAllCheckbox.checked = false;
        updateDeleteFrameButton();
    } else {
        manageBtn.textContent = '管理';
        actionBar.style.display = 'none';
        // 退出時取消所有選中狀態
        document.querySelectorAll('.frame-item.selected').forEach(item => {
            item.classList.remove('selected');
        });
    }
}

/**
 * 更新“刪除”按鈕上的計數
 */
function updateDeleteFrameButton() {
    const btn = document.getElementById('delete-selected-frames-btn');
    btn.textContent = `刪除 (${selectedFrames.size})`;
}

/**
 * 處理“全選”核取方塊的點擊事件
 */
function handleSelectAllFrames() {
    const isChecked = document.getElementById('select-all-frames-checkbox').checked;
    const visibleGrid = document.querySelector('.frame-content[style*="display: block"] .frame-grid');
    if (!visibleGrid) return;

    // 只選擇當前可見的、且是自訂的（帶有刪除按鈕）頭像框
    visibleGrid.querySelectorAll('.frame-item:has(.delete-btn)').forEach(item => {
        const frameId = parseInt(item.querySelector('.delete-btn').dataset.id);
        if (isNaN(frameId)) return;
        
        item.classList.toggle('selected', isChecked);
        if (isChecked) {
            selectedFrames.add(frameId);
        } else {
            selectedFrames.delete(frameId);
        }
    });
    updateDeleteFrameButton();
}

/**
 * 執行批量刪除操作
 */
async function executeBatchDeleteFrames() {
    if (selectedFrames.size === 0) return;
    
    const confirmed = await showCustomConfirm(
        '確認刪除',
        `確定要永久刪除選中的 ${selectedFrames.size} 個自訂頭像框嗎？`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        const idsToDelete = [...selectedFrames];
        await db.customAvatarFrames.bulkDelete(idsToDelete);
        
        // 退出管理模式並刷新
        toggleFrameManagementMode();
        populateFrameGrids(editingFrameForMember); 
        
        await showCustomAlert('刪除成功', '選中的頭像框已成功刪除。');
    }
}

// ▲▲▲ 新增函數黏貼結束 ▲▲▲        
        // ▼▼▼ 在這裡黏貼新函數 ▼▼▼
        /**
         * 將使用者自訂的全域CSS應用到頁面
         * @param {string} cssString 用戶輸入的CSS代碼
         */
        function applyGlobalCss(cssString) {
            const styleTag = document.getElementById('global-custom-style');
            if (styleTag) {
                // 如果有代碼就應用，沒有就清空
                styleTag.innerHTML = cssString || '';
            }
        }
        // ▲▲▲ 新函數黏貼結束 ▲▲▲
        
        // ▼▼▼ 【全新】請將這個函數黏貼到JS功能函式定義區 ▼▼▼
        /**
         * 向當前聊天的歷史記錄中添加一條關於音樂操作的、對使用者隱藏的系統消息
         * @param {string} actionText - 描述使用者操作的文本，例如 "暫停了音樂"
         */
        async function addMusicActionSystemMessage(actionText) {
            // 1. 檢查音樂功能是否啟動，以及是否在某個聊天中
            if (!musicState.isActive || !musicState.activeChatId) return;
            const chat = state.chats[musicState.activeChatId];
            if (!chat) return;
        
            // 2. 獲取用戶在當前聊天中的昵稱
            const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
            const fullMessage = `[系統提示：用戶 (${myNickname}) ${actionText}]`;
        
            // 3. 創建這條特殊的、隱藏的系統消息
            const systemMessage = {
                role: 'system',
                content: fullMessage,
                timestamp: Date.now(),
                isHidden: true // 這個標記讓消息對使用者不可見，但AI能讀到
            };
        
            // 4. 將消息存入歷史記錄並更新資料庫
            chat.history.push(systemMessage);
            await db.chats.put(chat);
        }
        // ▲▲▲ 新函數黏貼結束 ▲▲▲
        // ▼▼▼ 【最終修復版本】請用這個全新的函數，完整替換舊的 handleLongScreenshot ▼▼▼
        
        /**
         * 【V3.0 | 佈局修復版】處理長截圖功能
         */
        async function handleLongScreenshot() {
            if (selectedMessages.size === 0) return;
            const chat = state.chats[state.activeChatId];
            if (!chat) return;
        
            // 0. 顯示“生成中”狀態
            const screenshotBtn = document.getElementById('selection-screenshot-btn');
            const originalBtnText = screenshotBtn.textContent;
            screenshotBtn.textContent = '生成中...';
            screenshotBtn.disabled = true;
        
            // 1. 創建臨時的截圖容器和樣式（這部分不變）
            const screenshotContainer = document.createElement('div');
            const phoneScreen = document.getElementById('phone-screen');
            screenshotContainer.style.width = phoneScreen.offsetWidth + 'px';
            screenshotContainer.style.position = 'absolute';
            screenshotContainer.style.top = '-9999px';
            screenshotContainer.style.left = '-9999px';
            screenshotContainer.style.display = 'flex';
            screenshotContainer.style.flexDirection = 'column';
            screenshotContainer.style.height = 'auto';
            
            const chatScreen = document.getElementById('chat-interface-screen');
            screenshotContainer.style.backgroundImage = chatScreen.style.backgroundImage;
            screenshotContainer.style.backgroundColor = chatScreen.style.backgroundColor || (document.getElementById('phone-screen').classList.contains('dark-mode') ? '#000000' : '#f0f2f5');
        
            const tempStyle = document.createElement('style');
            tempStyle.innerHTML = `
                .message-bubble.selected::after { display: none !important; }
                .cloned-header .default-controls { display: flex !important; justify-content: space-between; align-items: center; width: 100%; }
                .cloned-header .selection-controls { display: none !important; }
            `;
            document.head.appendChild(tempStyle);
        
            try {
                // 2. 組裝截圖元素（頭部和輸入框部分不變）
                const header = chatScreen.querySelector('.header').cloneNode(true);
                header.classList.add('cloned-header');
                
                // ★★★★★ 這就是本次修復的核心！ ★★★★★
                // 我們不再使用 getComputedStyle，而是創建一個乾淨的容器並手動應用關鍵樣式。
                const messagesContainer = document.createElement('div');
                const originalMessagesContainer = document.getElementById('chat-messages');
        
                // 手動設置最關鍵的佈局樣式，確保消息能正確排列
                messagesContainer.style.display = 'flex';
                messagesContainer.style.flexDirection = 'column';
                messagesContainer.style.gap = '20px'; // 這是消息之間的垂直間距
                messagesContainer.style.padding = '10px 15px 20px 15px'; // 上、左右、下內邊距，底部多留一點
                messagesContainer.style.width = '100%';
                messagesContainer.style.boxSizing = 'border-box';
        
                // 繼承主題和字體大小，這對於氣泡顏色和文字大小至關重要
                messagesContainer.dataset.theme = originalMessagesContainer.dataset.theme;
                messagesContainer.style.setProperty('--chat-font-size', originalMessagesContainer.style.getPropertyValue('--chat-font-size'));
                // ★★★★★ 修復結束 ★★★★★
        
                const inputArea = chatScreen.querySelector('#chat-input-area').cloneNode(true);
        
                const sortedTimestamps = [...selectedMessages].sort((a, b) => a - b);
                sortedTimestamps.forEach(timestamp => {
                    // 注意：我們這裡依然需要從原始DOM中克隆，因為它們已經應用了所有複雜的CSS
                    const originalBubble = document.querySelector(`.message-bubble[data-timestamp="${timestamp}"]`);
                    if (originalBubble) {
                        const originalWrapper = originalBubble.closest('.message-wrapper');
                        if (originalWrapper) {
                            messagesContainer.appendChild(originalWrapper.cloneNode(true));
                        }
                    }
                });
        
                screenshotContainer.appendChild(header);
                screenshotContainer.appendChild(messagesContainer);
                screenshotContainer.appendChild(inputArea);
                document.body.appendChild(screenshotContainer);
                
                // 圖片預載入邏輯（保持不變）
                const images = Array.from(screenshotContainer.getElementsByTagName('img'));
                const imageLoadPromises = images.map(img => new Promise((resolve, reject) => {
                    if (img.src.startsWith('data:')) {
                        resolve();
                        return;
                    }
                    const newImg = new Image();
                    newImg.crossOrigin = 'anonymous';
                    newImg.onload = resolve;
                    newImg.onerror = resolve; 
                    newImg.src = img.src;
                }));
                
                await Promise.all(imageLoadPromises);
        
                // 3. 調用 html2canvas（保持不變）
                const canvas = await html2canvas(screenshotContainer, {
                    allowTaint: true,
                    useCORS: true,
                    backgroundColor: null,
                    scale: window.devicePixelRatio || 2,
                });
        
                // 4. 使用 Blob 物件下載（保持不變）
                canvas.toBlob(function(blob) {
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.download = `EPhone-長截圖-${chat.name}-${Date.now()}.png`;
                    link.href = url;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);
                }, 'image/png');
        
            } catch (error) {
                console.error('長截圖生成失敗:', error);
                await showCustomAlert('生成失敗', '生成截圖時發生錯誤，請檢查控制台獲取詳情。');
            } finally {
                // 5. 清理工作（保持不變）
                document.body.removeChild(screenshotContainer);
                document.head.removeChild(tempStyle);
                screenshotBtn.textContent = originalBtnText;
                screenshotBtn.disabled = false;
                exitSelectionMode(); 
            }
        }
        // ▲▲▲ 全新JS函數黏貼結束 ▲▲▲
        /**
         * 【V2.1 | 最終修復版】一個簡單的 Markdown 解析器
         * @param {string} text - 包含 Markdown 語法的原始文本
         * @returns {string} - 轉換成 HTML 後的文本
         */
        function parseMarkdown(text) {
            if (!text || typeof text !== 'string') return '';

            // 順序很重要：先處理我們自訂的複雜規則
            text = text.replace(/!h\{(.*?)\}/g, '<span class="diary-highlight">$1</span>');
            text = text.replace(/!u\{(.*?)\}/g, '<span class="diary-underline">$1</span>');
            text = text.replace(/!e\{(.*?)\}/g, '<span class="diary-emphasis">$1</span>');
            text = text.replace(/!w\{(.*?)\}/g, '<span class="diary-handwritten">$1</span>');
            text = text.replace(/!m\{(.*?)\}/g, '<span class="diary-messy">$1</span>');
            
            // ▼▼▼ 核心修改就在這裡 ▼▼▼
            // 將原來的 !c{...} 規則，替換為您想要的 ||...|| 規則
            text = text.replace(/\|\|(.*?)\|\|/g, '<span class="spoiler">$1</span>');
            // ▲▲▲ 修改結束 ▲▲▲

            // 再處理標準Markdown
            text = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            text = text.replace(/\~\~(.*?)\~\~/g, '<s>$1</s>'); 
            text = text.replace(/\*(.*?)\*/g, '<em>$1</em>');

            return text;
        }


        // ▼▼▼ 【全新 | 資料修復函數】請將這個函數黏貼到您的JS功能區 ▼▼▼
        /**
         * 自動遷移舊的、格式不正確的紅包資料，將 'receiver' 欄位重命名為 'receiverName'
         */
        async function migrateOldRedPacketData() {
            console.log("開始檢查並遷移舊的紅包資料...");
            let migrationCount = 0;
            // 直接從記憶體中的 state.chats 操作，效率更高
            const allChats = Object.values(state.chats);
        
            for (const chat of allChats) {
                let needsDbUpdate = false;
                for (const msg of chat.history) {
                    // 找出所有由AI發送的、帶有舊 'receiver' 欄位的專屬紅包
                    if (msg.type === 'red_packet' && msg.packetType === 'direct' && msg.role === 'assistant' && msg.hasOwnProperty('receiver') && !msg.hasOwnProperty('receiverName')) {
                        // 進行“手術”：重命名錯誤的欄位
                        msg.receiverName = msg.receiver;
                        delete msg.receiver;
                        
                        needsDbUpdate = true; // 標記這個聊天需要被重新保存
                        migrationCount++;
                    }
                }
                // 如果這個聊天中有資料被修復了，就將整個更新後的聊天物件保存回資料庫
                if (needsDbUpdate) {
                    console.log(`在聊天 "${chat.name}" 中發現並修復了舊紅包資料。`);
                    await db.chats.put(chat);
                }
            }
        
            if (migrationCount > 0) {
                console.log(`資料移轉完成！總共修復了 ${migrationCount} 條紅包記錄。`);
                alert(`檢測到並成功修復了 ${migrationCount} 條舊的紅包消息！頁面將自動刷新以應用更改。`);
                location.reload(); // 強制刷新頁面，確保所有顯示都使用最新的正確資料
            } else {
                console.log("未發現需要遷移的舊紅包資料。");
            }
        }
        
        // ▲▲▲ 新函數黏貼結束 ▲▲▲

        function showCharacterProfileModal(chatId) {
            const chat = state.chats[chatId];
            if (!chat || chat.isGroup) return;
        
            // 填充數據
            //document.getElementById('profile-avatar').src = chat.settings.aiAvatar || defaultAvatar;
           // document.getElementById('profile-name').textContent = chat.name;
           // document.getElementById('profile-id').textContent = `ID: ${chat.originalName}`;
            document.getElementById('profile-heartfelt-voice').textContent = chat.heartfeltVoice || '...';
            document.getElementById('profile-random-jottings').textContent = chat.randomJottings || '...';

            const modal = document.getElementById('character-profile-modal');
        
            // 【核心修復】由於我們已經從HTML中移除了“進入聊天”按鈕，
            // 這裡不再需要為它綁定事件，舊的、導致錯誤的JavaScript代碼已被徹底刪除。
            
            // 直接顯示彈窗
            modal.classList.add('visible');
        }
        /**
         * 【全新】顯示心聲歷史記錄視圖
         */
        function showThoughtsHistory() {
            document.getElementById('profile-main-content').style.display = 'none';
            document.getElementById('profile-thoughts-history-view').style.display = 'flex';
            renderThoughtsHistory();
        }
        
        /**
         * 【全新 | 已修復BUG】隱藏心聲歷史記錄視圖，返回主資料頁
         */
function hideThoughtsHistory() {
    document.getElementById('profile-thoughts-history-view').style.display = 'none';
    
    // 【核心修復】將 'block' 改為 'flex'，恢復其正確的彈性佈局
    document.getElementById('profile-main-content').style.display = 'flex'; 
}
// ▲▲▲ 替換結束 ▲▲▲
        
        /**
         * 【全新 | 分頁載入版】渲染心聲歷史記錄清單
         */
        function renderThoughtsHistory() {
            const listEl = document.getElementById('thoughts-history-list');
            const chat = state.chats[state.activeChatId];
            listEl.innerHTML = '';
            
            if (!chat || !chat.thoughtsHistory || chat.thoughtsHistory.length === 0) {
                listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; padding: 30px 0;">這裡還沒有歷史記錄哦。</p>';
                return;
            }
        
            const history = [...chat.thoughtsHistory].reverse(); // 從新到舊
            const initialItems = history.slice(0, THOUGHTS_RENDER_WINDOW);
            
            initialItems.forEach(thought => {
                const card = createThoughtCard(thought);
                listEl.appendChild(card);
            });
        
            thoughtsHistoryRenderCount = initialItems.length;
        
// 如果還有更多記錄，則添加“載入更多”按鈕
if (history.length > thoughtsHistoryRenderCount) {
    appendLoadMoreThoughtsButton(listEl); // 核心修改：調用新的函數
}
        }

        
// ▼▼▼ 【無限滾動修復版】請用這個新版本替換舊的 loadMoreThoughts 函數 ▼▼▼
async function loadMoreThoughts() {
    if (isLoadingMoreThoughts) return;
    isLoadingMoreThoughts = true;

    const listEl = document.getElementById('thoughts-history-list');
    const chat = state.chats[state.activeChatId];
    if (!chat) { 
        isLoadingMoreThoughts = false; 
        return; 
    }

    showLoader(listEl, 'bottom'); // 在底部顯示載入動畫
    await new Promise(resolve => setTimeout(resolve, 500)); // 類比網路延遲

    const history = [...chat.thoughtsHistory].reverse();
    const totalItems = history.length;

    const nextSliceStart = thoughtsHistoryRenderCount;
    const nextSliceEnd = thoughtsHistoryRenderCount + THOUGHTS_RENDER_WINDOW;
    const itemsToAppend = history.slice(nextSliceStart, nextSliceEnd);

    // 在追加新內容前，先移除載入動畫
    hideLoader(listEl);

    itemsToAppend.forEach(thought => {
        const card = createThoughtCard(thought);
        listEl.appendChild(card);
    });

    thoughtsHistoryRenderCount += itemsToAppend.length;

    isLoadingMoreThoughts = false;
}
// ▲▲▲ 替換結束 ▲▲▲
// ▼▼▼ 步驟 1：用這個【全新的函數】，完整替換舊的 createThoughtCard 函數 ▼▼▼
/**
 * 【全新美化版】根據單條記錄資料，創建一張心聲歷史卡片
 * @param {object} thought - 一條心聲歷史記錄物件
 * @returns {HTMLElement} - 創建好的卡片div
 */
function createThoughtCard(thought) {
    const card = document.createElement('div');
    card.className = 'thought-card';
    const date = new Date(thought.timestamp);
    const dateString = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')} ${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`;
    
    // 【核心修改】在這裡添加了一個刪除按鈕的HTML
    card.innerHTML = `
        <button class="thought-delete-btn" data-timestamp="${thought.timestamp}" title="刪除此條記錄">×</button>
        <div class="thought-header">${dateString}</div>
        <div class="thought-content">
            <div class="voice">
                <div class="label">
                    <svg viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>
                    心聲
                </div>
                <p class="text">${thought.heartfeltVoice}</p>
            </div>
            <div class="jottings">
                <div class="label">
                     <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19l7-7 3 3-7 7-3-3z"></path><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"></path><path d="M2 2l7.586 7.586"></path></svg>
                    散記
                </div>
                <p class="text">${thought.randomJottings}</p>
            </div>
        </div>
    `;
    return card;
} 
// ▲▲▲ 替換結束 ▲▲▲
        // ▼▼▼ 【全新】這是導入角色卡的所有核心功能，請將它們完整黏貼到 init() 函數的前面 ▼▼▼
        
        // ▼▼▼ 【最終PNG導入修復】請用這一整塊代碼，替換舊的 handleCardImport 函數 ▼▼▼
        
        /**
         * 【總入口】當用戶選擇了角色卡檔後，由此函數開始處理
         * @param {Event} event - 檔輸入框的 change 事件
         */
        async function handleCardImport(event) {
            const file = event.target.files[0];
            if (!file) return;
        
            try {
                let cardData;
                let avatarBase64 = null; // 用於存儲從PNG卡中提取的頭像
        
                if (file.name.endsWith('.json')) {
                    // 處理 JSON 格式的角色卡
                    const text = await file.text();
                    cardData = JSON.parse(text);
                } else if (file.name.endsWith('.png')) {
                    // 處理 PNG 格式的角色卡
                    const arrayBuffer = await file.arrayBuffer();
                    // 【【【核心修復就在這裡！現在這個函數被正確定義了】】】
                    cardData = await parsePngForTavernData(arrayBuffer);
                    
                    // 同時，將PNG檔本身轉換為Base64，用作頭像
                    avatarBase64 = await new Promise(resolve => {
                        const reader = new FileReader();
                        reader.onload = () => resolve(reader.result);
                        reader.readAsDataURL(file);
                    });
                } else {
                    throw new Error("不支持的檔案格式。請選擇 .json 或 .png 文件。");
                }
        
                // 將解析出的資料創建為新的聊天物件
                await createChatFromCardData(cardData, avatarBase64);
        
            } catch (error) {
                console.error("角色卡導入失敗:", error);
                await showCustomAlert("導入失敗", `無法解析角色卡檔。\n錯誤: ${error.message}`);
            } finally {
                // 清空輸入框，以便下次能選擇同一個檔
                event.target.value = null;
            }
        }
        
        // ▼▼▼ 【最終亂碼修復版】請用這個全新的函數，完整替換舊的 parsePngForTavernData ▼▼▼
        /**
         * 【V2.0 | 修復UTF-8亂碼】從PNG檔的ArrayBuffer中解析出隱藏的Tavern AI角色資料
         * @param {ArrayBuffer} arrayBuffer - PNG檔的二進位資料
         * @returns {Promise<object>} - 解析出的JSON角色數據
         */
        function parsePngForTavernData(arrayBuffer) {
            return new Promise((resolve, reject) => {
                const view = new DataView(arrayBuffer);
                // 檢查PNG檔頭 (8個位元組)
                if (view.getUint32(0) !== 0x89504E47 || view.getUint32(4) !== 0x0D0A1A0A) {
                    return reject(new Error("檔不是一個有效的PNG。"));
                }
        
                let offset = 8;
                const decoder = new TextDecoder(); // 這個解碼器用於解碼區塊類型，不是最終資料
        
                while (offset < view.byteLength) {
                    const length = view.getUint32(offset);
                    const type = decoder.decode(arrayBuffer.slice(offset + 4, offset + 8));
        
                    if (type === 'tEXt') {
                        const data = new Uint8Array(arrayBuffer, offset + 8, length);
                        const nullSeparatorIndex = data.indexOf(0);
                        if (nullSeparatorIndex !== -1) {
                            const key = decoder.decode(data.slice(0, nullSeparatorIndex));
                            if (key === 'chara') {
                                const value = decoder.decode(data.slice(nullSeparatorIndex + 1));
                                try {
                                    // ▼▼▼ 【核心修復就在這裡！】 ▼▼▼
                                    // 我們不再使用舊的、會導致中文亂碼的 atob() 方法。
                                    // 而是採用一個更現代、更可靠的兩步流程來解碼。
                                    
                                    // 1. 將Base64字串轉換為一個原始的二進位字元串。
                                    const binaryString = atob(value);
                                    
                                    // 2. 創建一個位元組陣列 (Uint8Array) 來存儲這些二進位資料。
                                    const bytes = new Uint8Array(binaryString.length);
                                    for (let i = 0; i < binaryString.length; i++) {
                                        bytes[i] = binaryString.charCodeAt(i);
                                    }
                                    
                                    // 3. 【最關鍵的一步】使用 TextDecoder 並明確指定 UTF-8 編碼，
                                    //    將位元組陣列正確地解碼為包含中文的字串。
                                    const decodedData = new TextDecoder('utf-8').decode(bytes);
                                    
                                    // ▲▲▲ 修復結束 ▲▲▲
                                    
                                    resolve(JSON.parse(decodedData));
                                    return; // 成功找到並解析，任務完成
                                } catch (e) {
                                    return reject(new Error("在PNG中找到角色數據，但解碼或解析失敗。錯誤: " + e.message));
                                }
                            }
                        }
                    }
                    
                    // 移動到下一個區塊 (長度 + 類型 + 資料 + CRC)
                    offset += 4 + 4 + length + 4;
                }
        
                reject(new Error("在PNG檔中未找到有效的Tavern AI角色資料(chara chunk)。"));
            });
        }
        // ▲▲▲ 替換結束 ▲▲▲
        
        // ▼▼▼ 【最終修復版 | V4.0】請用這一整塊代碼，替換舊的 createChatFromCardData 和可能缺失的 findWorldBookEntries 函數 ▼▼▼
        
        /**
         * 【輔助函數 | 相容核心】從角色卡資料中智慧查找世界書條目
         * @param {object} cardData - 從檔解析出的原始JSON資料
         * @returns {Array|null} - 如果找到，返回 entries 陣列；否則返回 null
         */
        function findWorldBookEntries(cardData) {
            // 檢查所有可能的路徑，按最常見到最少見的順序
            // 使用可選鏈 (?.) 來安全地訪問可能不存在的深層嵌套屬性
            
            // 格式 1: 【針對您卡片的精確路徑】資料在 data.character_book 中
            if (cardData.data?.character_book?.entries?.length > 0) {
                console.log("診斷：在 data.character_book 中找到世界書。");
                return cardData.data.character_book.entries;
            }
            
            // 格式 2: 新版 Tavern 卡，數據在 extensions.character_book 中
            if (cardData.extensions?.character_book?.entries?.length > 0) {
                console.log("診斷：在 extensions.character_book 中找到世界書。");
                return cardData.extensions.character_book.entries;
            }
            
            // 格式 3: 某些工具可能將其嵌套在 data.extensions 中
            if (cardData.data?.extensions?.character_book?.entries?.length > 0) {
                console.log("診斷：在 data.extensions.character_book 中找到世界書。");
                return cardData.data.extensions.character_book.entries;
            }
            
            // 格式 4: 相容我們之前嘗試過的、直接在頂層的各種鍵名
            const possibleTopLevelKeys = ['character_book', 'lorebook', 'world_info', 'char_book'];
            for (const key of possibleTopLevelKeys) {
                if (cardData[key]?.entries?.length > 0) {
                    console.log(`診斷：在頂層 ${key} 中找到世界書。`);
                    return cardData[key].entries;
                }
            }
        
            console.log("診斷：未在此角色卡中找到任何有效的世界書資料。");
            return null; // 如果所有路徑都找不到，返回 null
        }
        
        /**
         * 【V6.0 | 已修復導入BUG】根據從角色卡解析的資料，創建並保存一個新的聊天物件
         * @param {object} cardData - 從.json或.png中解析出的角色數據
         * @param {string|null} avatarBase64 - 如果是.png卡，則傳入其Base64資料作為頭像
         */
        async function createChatFromCardData(cardData, avatarBase64 = null) {
            const effectiveCardData = cardData.data || cardData;
            if (!effectiveCardData.name) {
                throw new Error("角色卡數據無效或缺少'name'欄位。");
            }
        
            let worldBookIdToLink = null;
            const worldBookEntries = findWorldBookEntries(cardData);
        
            if (worldBookEntries) {
                const structuredEntries = worldBookEntries
                    .filter(entry => entry.enabled && entry.content)
                    .map(entry => ({
                        keys: entry.keys || [],
                        comment: entry.comment || '',
                        content: entry.content.replace(/<memory>|<\/memory>/g, '').trim()
                    }));
        
                if (structuredEntries.length > 0) {
                    const newWorldBook = {
                        id: 'wb_' + Date.now(),
                        name: `${effectiveCardData.name}的設定集`,
                        content: structuredEntries,
                        categoryId: null
                    };
                    await db.worldBooks.add(newWorldBook);
                    state.worldBooks.push(newWorldBook);
                    worldBookIdToLink = newWorldBook.id;
                }
            }
        
            let description = effectiveCardData.description || cardData.description || '無';
            description = description
                .replace(/```yaml/g, '').replace(/```/g, '')
                .replace(/<\/?info>/g, '').replace(/<\/?character>/g, '')
                .replace(/<\/?writing_rule>/g, '').replace(/\[OOC：.*?\]/g, '').trim();
            let persona = `# 角色核心設定\n${description}\n\n`;
            if (effectiveCardData.personality) persona += `# 性格補充\n${effectiveCardData.personality}\n\n`;
            if (effectiveCardData.scenario) persona += `# 場景設定\n${effectiveCardData.scenario}\n\n`;
            if (effectiveCardData.mes_example) persona += `# 對話示例\n${effectiveCardData.mes_example}\n\n`;

            // ▼▼▼ 【核心修復】在這裡定義 remarkName 和 originalName ▼▼▼
            const remarkName = effectiveCardData.name;
            const originalName = effectiveCardData.name;
            // ▲▲▲ 修復結束 ▲▲▲

            const newChatId = 'chat_' + Date.now();
            const newChat = {
                id: newChatId,
                name: remarkName.trim(),
                originalName: originalName.trim(),
                isGroup: false,
                relationship: { status: 'friend' },
                status: { text: '線上', lastUpdate: Date.now(), isBusy: false },
                settings: {
                    aiPersona: persona,
                    myPersona: '我是誰呀。',
                    maxMemory: 10,
                    aiAvatar: defaultAvatar,
                    myAvatar: defaultAvatar,
                    background: '',
                    theme: 'default',
                    fontSize: 13,
                    customCss: '',
                    linkedWorldBookIds: worldBookIdToLink ? [worldBookIdToLink] : [],
                    aiAvatarLibrary: []
                },
                history: [],
                musicData: { totalTime: 0 },
                longTermMemory: []
            };

            if (avatarBase64) {
                newChat.settings.aiAvatar = avatarBase64;
                newChat.settings.aiAvatarLibrary.push({ name: '默認頭像', url: avatarBase64 });
            }

            const greetingHtml = effectiveCardData.first_mes || cardData.first_mes;
            if (greetingHtml && typeof greetingHtml === 'string') {
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = greetingHtml;
                const cleanGreeting = (tempDiv.textContent || tempDiv.innerText || "").replace(/原作者UR.*?開局/s, '').trim();
                if (cleanGreeting) {
                    newChat.history.push({
                        role: 'assistant',
                        senderName: newChat.originalName,
                        content: cleanGreeting,
                        timestamp: Date.now()
                    });
                }
            }
            state.chats[newChatId] = newChat;
            await db.chats.put(newChat);
            renderChatList();
            let successMessage = `角色 “${newChat.name}” 已成功導入！`;
            if (worldBookIdToLink) {
                successMessage += `\n\n其專屬的“世界書”也已自動創建並關聯。`;
            }
            await showCustomAlert('導入成功！', successMessage);
        }
        // ▲▲▲ 替換結束 ▲▲▲
        
            // ▼▼▼ 【全新】這是切換開場白的核心功能，請黏貼到 init() 函數的前面 ▼▼▼
            /**
             * 【總入口】處理用戶點擊“切換開場”按鈕的邏輯
             */
            async function handleSwitchGreeting() {
                if (!state.activeChatId) return;
                const chat = state.chats[state.activeChatId];
                const greetings = chat.settings.alternateGreetings;
        
                if (!greetings || greetings.length === 0) {
                    alert("這個角色沒有可用的備選開場白。");
                    return;
                }
        
                // 1. 將備選開場白陣列轉換為 showChoiceModal 需要的格式
                const options = greetings.map((text, index) => {
                    // 提取每個開場白的前20個字元作為預覽
                    const preview = text.replace(/<[^>]*>/g, '').trim().substring(0, 20);
                    return {
                        text: `開場 ${index + 1}: ${preview}...`,
                        value: index // 將陣列索引作為返回值
                    };
                });
        
                // 2. 彈出選擇功能表
                const selectedIndex = await showChoiceModal('選擇一個開場白', options);
        
                // 3. 如果用戶做出了選擇 (而不是取消)
                if (selectedIndex !== null) {
                    // 4. 【重要】彈出警告，確認是否要覆蓋聊天記錄
                    const confirmed = await showCustomConfirm(
                        '確認操作',
                        '切換開場將會【清空並替換】當前的所有聊天記錄。確定要繼續嗎？',
                        { confirmButtonClass: 'btn-danger', confirmText: '確定切換' }
                    );
        
                    if (confirmed) {
                        // 5. 執行切換邏輯
                        const newGreetingText = greetings[selectedIndex];
                        
                        const newMessage = {
                            role: 'assistant',
                            senderName: chat.originalName,
                            content: newGreetingText,
                            timestamp: Date.now()
                        };
        
                        // 替換整個歷史記錄
                        chat.history = [newMessage];
                        
                        // 保存到資料庫
                        await db.chats.put(chat);
        
                        // 刷新UI
                        renderChatInterface(chat.id);
                        document.getElementById('chat-settings-modal').classList.remove('visible'); // 關閉設置彈窗
                        await showCustomAlert('成功', '已切換到新的開場故事！');
                    }
                }
            }
            // ▲▲▲ 新增函數結束 ▲▲▲
        
        // ▼▼▼ 【請用這個新版本】替換舊的 createWorldBookEntryBlock 函數 ▼▼▼
        /**
         * 【輔助函數】創建一個可編輯的世界書條目塊
         * @param {object} entry - 單個條目的數據 { keys, comment, content, enabled }
         * @returns {HTMLElement} - 創建好的DOM元素
         */
        function createWorldBookEntryBlock(entry = { keys: [], comment: '', content: '', enabled: true }) {
            const block = document.createElement('div');
            // 複用我們之前為消息編輯器創建的樣式
            block.className = 'message-editor-block';
        
            // 【核心修改】根據條目的 enabled 狀態決定開關是否被選中
            const isChecked = entry.enabled !== false ? 'checked' : '';

            block.innerHTML = `
                <div style="display: flex; justify-content: flex-end; align-items: center; gap: 10px; margin-bottom: 5px;">
                    <label class="toggle-switch" title="啟用/禁用此條目">
                        <input type="checkbox" class="entry-enabled-switch" ${isChecked}>
                        <span class="slider"></span>
                    </label>
                    <button class="delete-block-btn" title="刪除此條目">×</button>
                </div>
                <div class="form-group" style="margin-bottom: 10px;">
                    <label style="font-size: 0.8em;">備註 (可選)</label>
                    <input type="text" class="entry-comment-input" value="${entry.comment || ''}" placeholder="例如：關於角色的童年" style="padding: 8px;">
                </div>
                <div class="form-group" style="margin-bottom: 10px;">
                    <label style="font-size: 0.8em;">關鍵字 (用英文逗號,分隔)</label>
                    <input type="text" class="entry-keys-input" value="${(entry.keys || []).join(', ')}" placeholder="例如: key1, key2, key3" style="padding: 8px;">
                </div>
                <div class="form-group" style="margin-bottom: 0;">
                    <label style="font-size: 0.8em;">內容</label>
                    <textarea class="entry-content-textarea" rows="5" style="width: 100%; font-size: 14px;">${entry.content || ''}</textarea>
                </div>
            `;
        
            // 綁定刪除按鈕事件
            block.querySelector('.delete-block-btn').addEventListener('click', () => {
                block.remove();
            });
        
            return block;
        }
        // ▲▲▲ 替換結束 ▲▲▲
        // ▼▼▼ 【全新】五子棋功能核心函數 ▼▼▼
        
        /**
         * 【遮罩終極修復版】切換五子棋棋盤的顯示與隱藏
         */
        async function toggleGomokuBoard() {
            if (!state.activeChatId) return;
            const chatId = state.activeChatId;
            const overlay = document.getElementById('gomoku-overlay');
        
            // 如果棋盤是隱藏的 -> 打開它
            if (!overlay.classList.contains('visible')) {
                const header = document.querySelector('#chat-interface-screen > .header');
                
                overlay.style.top = `${header.offsetHeight}px`;
                overlay.style.display = 'block';
        
                if (!gomokuState[chatId] || !gomokuState[chatId].isActive) {
                    initGomokuGame(chatId);
                }
                renderGomokuBoard(chatId);
        
                // 【核心】不再操作消息清單的 padding-top
                setTimeout(async () => {
                    overlay.classList.add('visible');
        
                    const startMessage = {
                        role: 'system',
                        content: '[系統提示：用戶打開了五子棋棋盤，遊戲開始了。]',
                        timestamp: Date.now(),
                        isHidden: true
                    };
                    state.chats[chatId].history.push(startMessage);
                    await db.chats.put(state.chats[chatId]);
                }, 10);
        
            } else {
                // 如果棋盤是顯示的 -> 關閉它
                await closeGomokuBoard();
            }
        }
        /**
         * 【遮罩終極修復版】關閉五子棋棋盤
         */
        async function closeGomokuBoard() {
            if (!state.activeChatId) return;
            const chatId = state.activeChatId;
            const overlay = document.getElementById('gomoku-overlay');
            
            overlay.classList.remove('visible');
            
            // 【核心】移除了恢復消息清單 padding-top 的代碼
        
            setTimeout(() => {
                overlay.style.display = 'none';
            }, 300);
        
            if (gomokuState[chatId]) {
                gomokuState[chatId].isActive = false;
                
                const endMessage = {
                    role: 'system',
                    content: '[系統提示：用戶關閉了五子棋棋盤，遊戲結束了。]',
                    timestamp: Date.now(),
                    isHidden: true
                };
                state.chats[chatId].history.push(endMessage);
                await db.chats.put(state.chats[chatId]);
            }
        }
        
        /**
         * 【渲染時序修復版】初始化一局新的五子棋遊戲
         * @param {string} chatId 
         */
        function initGomokuGame(chatId) {
            const canvas = document.getElementById('gomoku-board');
            const overlay = document.getElementById('gomoku-overlay');
            const controls = document.getElementById('gomoku-controls');
            
            // 【核心修正】在保證 overlay 可見的前提下，更精確地計算可用空間
            const availableWidth = overlay.offsetWidth - 40; 
            const availableHeight = overlay.offsetHeight - controls.offsetHeight - 40;
            const boardSize = Math.floor(Math.min(availableWidth, availableHeight));
            
            const GRID_SIZE = 15;
            // 確保棋盤尺寸是格子尺寸的整數倍，避免模糊
            const cell_size = Math.floor(boardSize / GRID_SIZE);
            const final_size = cell_size * GRID_SIZE;
            
            canvas.width = final_size;
            canvas.height = final_size;
        
            gomokuState[chatId] = {
                isActive: true,
                board: Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(0)),
                currentPlayer: 1, 
                history: [],
                isGameOver: false,
                GRID_SIZE: GRID_SIZE,
                CELL_SIZE: cell_size
            };
        }
        /**
         * 渲染整個棋盤和棋子
         * @param {string} chatId 
         */
        function renderGomokuBoard(chatId) {
            const gameState = gomokuState[chatId];
            if (!gameState) return;
            
            const canvas = document.getElementById('gomoku-board');
            const ctx = canvas.getContext('2d');
            const { GRID_SIZE, CELL_SIZE } = gameState;
            const padding = CELL_SIZE / 2;
        
            // 1. 清空並繪製棋盤背景
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#e4b591';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        
            // 2. 繪製格線
            ctx.strokeStyle = '#5b3a29';
            ctx.lineWidth = 1;
            for (let i = 0; i < GRID_SIZE; i++) {
                // 橫線
                ctx.beginPath();
                ctx.moveTo(padding, padding + i * CELL_SIZE);
                ctx.lineTo(canvas.width - padding, padding + i * CELL_SIZE);
                ctx.stroke();
                // 分隔號
                ctx.beginPath();
                ctx.moveTo(padding + i * CELL_SIZE, padding);
                ctx.lineTo(padding + i * CELL_SIZE, canvas.height - padding);
                ctx.stroke();
            }
        
            // 3. 繪製棋子
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (gameState.board[y][x] !== 0) {
                        drawStone(ctx, x, y, gameState.board[y][x], gameState);
                    }
                }
            }
        }
        
        /**
         * 繪製單個棋子
         */
        function drawStone(ctx, x, y, player, gameState) {
            const { CELL_SIZE } = gameState;
            const padding = CELL_SIZE / 2;
            const radius = CELL_SIZE / 2 - 2;
        
            ctx.beginPath();
            ctx.arc(padding + x * CELL_SIZE, padding + y * CELL_SIZE, radius, 0, 2 * Math.PI);
            
            if (player === 1) { // User is black
                ctx.fillStyle = 'black';
            } else { // AI is white
                ctx.fillStyle = 'white';
            }
            ctx.fill();
        }
        
        /**
         * 處理滑鼠在棋盤上的懸停效果
         */
        function handleBoardHover(e) {
            const chatId = state.activeChatId;
            const gameState = gomokuState[chatId];
            if (!gameState || gameState.isGameOver || gameState.currentPlayer !== 1) return;
        
            const canvas = document.getElementById('gomoku-board');
            const ctx = canvas.getContext('2d');
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
        
            const gridX = Math.round((x - gameState.CELL_SIZE / 2) / gameState.CELL_SIZE);
            const gridY = Math.round((y - gameState.CELL_SIZE / 2) / gameState.CELL_SIZE);
        
            renderGomokuBoard(chatId); // Redraw to clear previous hover
        
            if (gridX >= 0 && gridX < gameState.GRID_SIZE && gridY >= 0 && gridY < gameState.GRID_SIZE && gameState.board[gridY][gridX] === 0) {
                const radius = gameState.CELL_SIZE / 2 - 2;
                ctx.beginPath();
                ctx.arc(gameState.CELL_SIZE / 2 + gridX * gameState.CELL_SIZE, gameState.CELL_SIZE / 2 + gridY * gameState.CELL_SIZE, radius, 0, 2 * Math.PI);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.4)'; // Faint black for preview
                ctx.fill();
            }
        }
        
        /**
         * 處理用戶點擊棋盤下棋
         */
        function handleBoardClick(e) {
            const chatId = state.activeChatId;
            const gameState = gomokuState[chatId];
            if (!gameState || gameState.isGameOver || gameState.currentPlayer !== 1) return;
        
            const canvas = document.getElementById('gomoku-board');
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
        
            const gridX = Math.round((x - gameState.CELL_SIZE / 2) / gameState.CELL_SIZE);
            const gridY = Math.round((y - gameState.CELL_SIZE / 2) / gameState.CELL_SIZE);
        
            if (gridX >= 0 && gridX < gameState.GRID_SIZE && gridY >= 0 && gridY < gameState.GRID_SIZE && gameState.board[gridY][gridX] === 0) {
                // Place stone
                gameState.board[gridY][gridX] = 1;
                gameState.history.push({ x: gridX, y: gridY, player: 1 });
                renderGomokuBoard(chatId);
        
                // Check for win
                if (checkWin(gridX, gridY, 1, gameState)) {
                    gameState.isGameOver = true;
                    setTimeout(() => alert("恭喜你，你贏了！"), 100);
            // ▼▼▼ 在這裡添加新代碼 ▼▼▼
            addGameEndSystemMessage('user'); // 通知AI，是用戶贏了（也就是AI輸了）
            // ▲▲▲ 添加結束 ▲▲▲

                } else {
                    gameState.currentPlayer = 2; // Switch to AI's turn
                    // Note: We don't trigger AI response here. It's triggered by the "Wait Reply" button.
                }
            }
        }
        
        /**
         * 【V2.0 | 修復導演模式】AI下棋的處理器
         * @param {object} move - 包含x,y座標的物件
         * @param {boolean} isForcedMove - 是否為導演模式下的強制移動
         */
        function handleAiGomokuMove(move, isForcedMove = false) {
            const chatId = state.activeChatId;
            const gameState = gomokuState[chatId];
            
            // 核心修復1：如果是強制移動，就跳過玩家回合的檢查
            if (!gameState || gameState.isGameOver) return;
            if (!isForcedMove && gameState.currentPlayer !== 2) return;

            const { x, y } = move;
        
            if (x >= 0 && x < gameState.GRID_SIZE && y >= 0 && y < gameState.GRID_SIZE && gameState.board[y][x] === 0) {
                gameState.board[y][x] = 2; // AI是白棋(2)
                gameState.history.push({ x, y, player: 2 });
                renderGomokuBoard(chatId); // 重新繪製棋盤
        
                if (checkWin(x, y, 2, gameState)) {
                    gameState.isGameOver = true;
                    setTimeout(() => alert("AI 獲勝了！"), 100);
                    addGameEndSystemMessage('ai');
                } else {
                    gameState.currentPlayer = 1; // 輪到用戶下棋
                }
            } else {
                console.warn("AI 的下棋指令無效或位置已被佔據:", move);
                // 如果AI的移動無效，將回合交還給用戶，避免遊戲卡死
                gameState.currentPlayer = 1;
            }
        }
        
        /**
         * 檢查勝利條件
         */
        function checkWin(x, y, player, gameState) {
            const { board, GRID_SIZE } = gameState;
            const directions = [[1, 0], [0, 1], [1, 1], [1, -1]]; // Horizontal, Vertical, Diagonal /, Diagonal \
            for (const [dx, dy] of directions) {
                let count = 1;
                // Check in one direction
                for (let i = 1; i < 5; i++) {
                    const newX = x + i * dx;
                    const newY = y + i * dy;
                    if (newX >= 0 && newX < GRID_SIZE && newY >= 0 && newY < GRID_SIZE && board[newY][newX] === player) {
                        count++;
                    } else {
                        break;
                    }
                }
                // Check in the opposite direction
                for (let i = 1; i < 5; i++) {
                    const newX = x - i * dx;
                    const newY = y - i * dy;
                    if (newX >= 0 && newX < GRID_SIZE && newY >= 0 && newY < GRID_SIZE && board[newY][newX] === player) {
                        count++;
                    } else {
                        break;
                    }
                }
                if (count >= 5) return true;
            }
            return false;
        }
        
// ▼▼▼ 【V3.0 | 規則與思考步驟終極版】請用這個全新的函數，再次替換舊的 formatGomokuStateForAI 函數 ▼▼▼
/**
 * 【V3.0 | 強制思考版】將棋盤狀態格式化為AI可讀的文本
 */
function formatGomokuStateForAI(gameState) {
    if (!gameState || !gameState.isActive) return "";
    
    let boardString = "棋盤狀態 (1是你(黑棋), 2是AI(白棋)):\n";
    boardString += gameState.board.map(row => row.join(' ')).join('\n');
    
    let historyString = "下棋歷史 (x,y座標均從0開始):\n";
    historyString += gameState.history.map(move => `玩家${move.player}下在(${move.x},${move.y})`).join(' -> ');
    
    // 【【【這就是本次升級的核心！】】】
    return `
# 當前五子棋局勢
${boardString}

# ${historyString}

# 【【【五子棋核心規則與強制思考步驟 (最高優先順序指令！)】】】

### **【【【落子鐵律 (絕對禁止！)】】】**
你【絕對不能】選擇一個棋盤上已經是 1 或 2 的座標。你的落子點【必須】是 0。
---

### **第一步：邏輯分析 (內部思考，不要輸出)**

1.  **【規則定義】**: 
    -   棋子: 1代表用戶(黑棋)，2代表你(白棋)。
    -   獲勝條件: 橫、豎、斜線上有【連續五個】自己的棋子。

2.  **【防守分析 (必須執行)】**:
    -   **檢查用戶(1)是否有“四子連線”的威脅？** 如果有，我必須下在哪個座標才能堵住？
    -   **檢查用戶(1)是否有“活三”的威脅？** 如果有，最佳的防守點是哪裡？

3.  **【進攻分析 (必須執行)】**:
    -   **檢查我(2)是否有“一步勝利”的機會？** (即已有四子連線) 如果有，我應該下在哪裡？
    -   **檢查我(2)是否有製造“活四”或“雙三”的機會？** 如果有，最佳的進攻點是哪裡？

### **第二步：決策與扮演 (內部思考，不要輸出)**

1.  **【決策】**: 綜合以上攻防分析，我的最佳棋步是落在座標 (x, y)。

2.  **【融入角色扮演】**:
    -   我的性格是：(在此處回顧你的人設)。
    -   根據我的性格，我應該：
        a) **(聰明/好勝型)** 下在剛剛分析出的最佳位置。
        b) **(迷糊/放水型)** 故意選擇一個次優的位置，但【前提是不能讓用戶立刻獲勝】。
        c) **(其他性格)** 根據性格特點，選擇一個合理的棋步。

3.  **【構思臺詞】**: 根據我選擇的棋步和我的性格，我應該說一句什麼樣的臺詞來評論棋局？

---
### **第三步：生成最終回復 (你的唯一輸出)**

現在，根據你第二步的最終決策，生成你的行動。
-   你的回復【必須且只能】是一個JSON陣列。
-   **絕對不要**在最終回復中包含任何上述的思考過程。
-   格式: \`[{"type": "gomoku_move", "name": "你的角色本名", "x": (0-14), "y": (0-14)}, {"type": "text", "content": "你的臺詞..."}]\`
`;
}
// ▲▲▲ 替換結束 ▲▲▲
        // ▼▼▼ 【全新V2.0 | 最終版】請用這個函數替換掉之前的 notifyAiOfGameEnd 函數 ▼▼▼
        /**
         * 【全新】當五子棋遊戲結束時，向聊天記錄中添加一條隱藏的系統消息，供AI在下次回應時查看
         * @param {string} winner - 獲勝方, 'user' 或 'ai'
         */
        async function addGameEndSystemMessage(winner) {
            const chatId = state.activeChatId;
            const chat = state.chats[chatId];
            if (!chat) return;

            // 1. 根據獲勝方，準備好要告訴AI的核心資訊
            // 【核心】這裡的名字獲取邏輯已修復，確保在群聊和單聊中都能正確顯示
            const userDisplayName = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
            const aiDisplayName = chat.isGroup ? 'AI方' : chat.name;
            const winnerName = (winner === 'user') ? userDisplayName : aiDisplayName;
            const resultText = (winner === 'user') ? '你輸了' : '你贏了';

            // 2. 構建一條簡潔、清晰的系統提示，作為AI的“記憶”
            const systemContent = `[系統提示：五子棋遊戲已結束。最終結果是：${winnerName} 獲勝。也就是說，${resultText}。]`;

            // 3. 將這條提示作為一條對使用者隱藏的消息，添加到聊天記錄中
            const hiddenMessage = {
                role: 'system',
                content: systemContent,
                timestamp: Date.now(),
                isHidden: true // 這個標記確保使用者看不到這條指令
            };

            chat.history.push(hiddenMessage);
            await db.chats.put(chat);
            
            // 4. 【關鍵】這裡不再調用 triggerAiResponse()，AI將保持沉默，直到下一次輪到它行動。
            console.log(`遊戲結束的系統提示已添加到歷史記錄中，等待AI下次查看。勝者: ${winner}`);
        }
        // ▲▲▲ 新函數黏貼結束 ▲▲▲
        // ▼▼▼ 【全新】購物功能核心函數 (V4.0 - 仿淘寶終極版) ▼▼▼
        /* ▼▼▼ 請用這整塊新代碼替換舊的 renderShoppingProducts 函數及購物相關的事件監聽器 ▼▼▼ */
        
        // 新增一個全域變數來跟蹤管理模式
        let isProductManagementMode = false;
        
// ▼▼▼ 【請用這個新版本】替換舊的 renderShoppingProducts 函數 ▼▼▼
        /**
         * 【V6.2 | 管理模式修復版】渲染商店裡的所有商品
         */
        async function renderShoppingProducts() {
            const gridEl = document.getElementById('product-grid');
            const tabsContainer = document.getElementById('product-category-tabs');
            const shoppingScreen = document.getElementById('shopping-screen');
            gridEl.innerHTML = '';
            tabsContainer.innerHTML = '';

            const [allProducts, allCategories] = await Promise.all([
                db.shoppingProducts.toArray(),
                db.shoppingCategories.orderBy('name').toArray()
            ]);

            shoppingScreen.classList.toggle('management-mode', isProductManagementMode);

            // 渲染分類頁簽
            const allTab = document.createElement('button');
            allTab.className = 'product-category-tab';
            allTab.textContent = '全部';
            allTab.dataset.categoryId = 'all';
            if (activeShoppingCategoryId === 'all') allTab.classList.add('active');
            tabsContainer.appendChild(allTab);

            allCategories.forEach(cat => {
                const tab = document.createElement('button');
                tab.className = 'product-category-tab';
                tab.textContent = cat.name;
                tab.dataset.categoryId = cat.id;
                if (activeShoppingCategoryId === cat.id) tab.classList.add('active');
                tabsContainer.appendChild(tab);
            });
            
            let productsToShow;
            if (activeShoppingCategoryId === 'all') {
                productsToShow = allProducts;
            } else {
                productsToShow = allProducts.filter(p => p.categoryId === activeShoppingCategoryId);
            }
            
            if (productsToShow.length === 0) {
                const message = activeShoppingCategoryId === 'all' 
                    ? '商店空空如也，點擊“管理”添加商品吧！'
                    : '這個分類下還沒有商品哦~';
                gridEl.innerHTML = `<p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); margin-top: 50px;">${message}</p>`;
                return;
            }

            productsToShow.forEach(product => {
                const item = document.createElement('div');
                item.className = 'product-item';
                item.dataset.id = product.id;
                
                // 【核心修改】我們不再通過JS條件來決定是否渲染管理按鈕，
                // 而是永遠渲染它們，讓CSS來決定是否顯示。
                const managementControls = `
                    <div class="product-management-overlay">
                        <button class="edit-product-btn">編輯</button>
                        <button class="delete-product-btn">刪除</button>
                    </div>
                `;

                item.innerHTML = `
                    ${managementControls}
                    <img src="${product.imageUrl}" class="product-image">
                    <div class="product-info">
                        <div class="product-name">${product.name}</div>
                        <div class="product-footer">
                            <div class="product-price">${product.price.toFixed(2)}</div>
                            <button class="add-to-cart-btn">加入購物車</button>
                        </div>
                    </div>
                `;
                gridEl.appendChild(item);
            });
        }
        // ▲▲▲ 替換結束 ▲▲▲
/**
 * 【全新】切換商品分類
 * @param {number|string} categoryId - 要切換到的分類ID
 */
function switchShoppingCategory(categoryId) {
    activeShoppingCategoryId = categoryId;
    renderShoppingProducts(); // 重新渲染整個商品頁面
}        
        
        /* ▼▼▼ 請用這整塊新代碼替換舊的 renderShoppingProducts 函數及購物相關的事件監聽器 ▼▼▼ */
        
        
        /**
         * 【已修復】打開購物頁面
         */
async function openShoppingScreen() {
    activeShoppingCategoryId = 'all'; // 核心：重置分類為“全部”
    await renderShoppingProducts();
    showScreen('shopping-screen');
}
        
/**
 * 【V6.1 | 淘寶樣式版】渲染商店裡的所有商品
 */
async function renderShoppingProducts() {
    const gridEl = document.getElementById('product-grid');
    const tabsContainer = document.getElementById('product-category-tabs');
    const shoppingScreen = document.getElementById('shopping-screen');
    gridEl.innerHTML = '';
    tabsContainer.innerHTML = '';

    // 1. 同時獲取所有商品和所有分類
    const [allProducts, allCategories] = await Promise.all([
        db.shoppingProducts.toArray(),
        db.shoppingCategories.orderBy('name').toArray()
    ]);

    shoppingScreen.classList.toggle('management-mode', isProductManagementMode);

    // 2. 渲染分類頁簽
    const allTab = document.createElement('button');
    allTab.className = 'product-category-tab'; // 使用新的CSS類名
    allTab.textContent = '全部';
    allTab.dataset.categoryId = 'all';
    if (activeShoppingCategoryId === 'all') allTab.classList.add('active');
    tabsContainer.appendChild(allTab);

    allCategories.forEach(cat => {
        const tab = document.createElement('button');
        tab.className = 'product-category-tab'; // 使用新的CSS類名
        tab.textContent = cat.name;
        tab.dataset.categoryId = cat.id;
        if (activeShoppingCategoryId === cat.id) tab.classList.add('active');
        tabsContainer.appendChild(tab);
    });
    
    // 3. 根據當前選中的分類ID來篩選商品
    let productsToShow;
    if (activeShoppingCategoryId === 'all') {
        productsToShow = allProducts;
    } else {
        productsToShow = allProducts.filter(p => p.categoryId === activeShoppingCategoryId);
    }
    
    // 4. 渲染商品列表
    if (productsToShow.length === 0) {
        const message = activeShoppingCategoryId === 'all' 
            ? '商店空空如也，點擊“管理”添加商品吧！'
            : '這個分類下還沒有商品哦~';
        gridEl.innerHTML = `<p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); margin-top: 50px;">${message}</p>`;
        return;
    }

    productsToShow.forEach(product => {
        const item = document.createElement('div');
        item.className = 'product-item';
        item.dataset.id = product.id;
        
        const managementControls = isProductManagementMode ? `
            <div class="product-management-overlay">
                <button class="edit-product-btn">編輯</button>
                <button class="delete-product-btn">刪除</button>
            </div>
        ` : '';

        item.innerHTML = `
            ${managementControls}
            <img src="${product.imageUrl}" class="product-image">
            <div class="product-info">
                <div class="product-name">${product.name}</div>
                <div class="product-footer">
                    <div class="product-price">${product.price.toFixed(2)}</div>
                    <button class="add-to-cart-btn">加入購物車</button>
                </div>
            </div>
        `;
        gridEl.appendChild(item);
    });
}
        
        /* ▲▲▲ 替換結束 ▲▲▲ */
        
        /**
         * 將商品加入購物車 (V4.0)
         */
        async function addToCart(productId, quantity = 1, variation = null) {
            // 如果有款式，就根據款式名來判斷是否已存在
            const existingItem = variation
                ? shoppingCart.find(item => item.productId === productId && item.variation?.name === variation.name)
                : shoppingCart.find(item => item.productId === productId && !item.variation);

            if (existingItem) {
                existingItem.quantity += quantity;
            } else {
                const product = await db.shoppingProducts.get(productId);
                if (product) {
                    shoppingCart.push({ productId: product.id, quantity: quantity, variation: variation });
                }
            }
            updateCartCount();
        }
        
        /**
         * 更新購物車商品數量
         */
        function updateCartItemQuantity(productId, change) {
            const itemIndex = shoppingCart.findIndex(item => item.productId === productId);
            if (itemIndex > -1) {
                shoppingCart[itemIndex].quantity += change;
                if (shoppingCart[itemIndex].quantity <= 0) {
                    shoppingCart.splice(itemIndex, 1);
                }
                updateCartCount();
                renderCartItems();
            }
        }
        
        /**
         * 更新購物車圖示和結算按鈕上的數量
         */
        function updateCartCount() {
            const totalItems = shoppingCart.reduce((sum, item) => sum + item.quantity, 0);
            document.getElementById('cart-count').textContent = totalItems;
            document.getElementById('cart-title').textContent = `購物車(${totalItems})`;
            document.getElementById('checkout-btn').textContent = `結算(${totalItems})`;
        }
        
        /**
         * 打開購物車頁面
         */
        function openCartScreen() {
            renderCartItems();
            showScreen('cart-screen');
        }
        
// ▼▼▼ 【V2.0 | 支援顯示款式】請用這個新版本替換舊的 renderCartItems 函數 ▼▼▼
        /**
         * 渲染購物車內的商品列表 (V4.0)
         */
        async function renderCartItems() {
            const listEl = document.getElementById('cart-items-list');
            listEl.innerHTML = '';
            let total = 0;
        
            if (shoppingCart.length === 0) {
                listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); margin-top: 50px;">購物車是空的哦~</p>';
            } else {
                const productIds = shoppingCart.map(item => item.productId);
                const products = await db.shoppingProducts.where('id').anyOf(productIds).toArray();
                const productMap = new Map(products.map(p => [p.id, p]));
        
                shoppingCart.forEach(item => {
                    const product = productMap.get(item.productId);
                    if (product) {
                        const itemEl = document.createElement('div');
                        itemEl.className = 'cart-item';
                        
                        // 【核心修改】如果購物車專案有款式資訊，就生成一個顯示它的HTML
                        const variationHtml = item.variation
                            ? `<div class="cart-item-variation" style="font-size: 12px; color: #8a8a8a; margin-top: 4px;">款式: ${item.variation.name}</div>`
                            : '';
                        
                        itemEl.innerHTML = `
                            <input type="checkbox" class="cart-item-checkbox" data-id="${product.id}" checked>
                            <img src="${item.variation?.imageUrl || product.imageUrl}" class="cart-item-image">
                            <div class="cart-item-info">
                                <div class="cart-item-name">${product.name}</div>
                                ${variationHtml}
                                <div class="cart-item-footer">
                                    <div class="cart-item-price">¥${(item.variation?.price || product.price).toFixed(2)}</div>
                                    <div class="quantity-control">
                                        <button class="quantity-btn decrease-qty-btn" data-id="${product.id}">-</button>
                                        <span class="quantity-display">${item.quantity}</span>
                                        <button class="quantity-btn increase-qty-btn" data-id="${product.id}">+</button>
                                    </div>
                                </div>
                            </div>
                        `;
                        listEl.appendChild(itemEl);
                    }
                });
            }
            updateCartTotal();
        }
        // ▲▲▲ 替換結束 ▲▲▲
        
        /**
         * 更新購物車總價
         */
        async function updateCartTotal() {
            let total = 0;
            const selectedCheckboxes = document.querySelectorAll('.cart-item-checkbox:checked');
            const selectedProductIds = Array.from(selectedCheckboxes).map(cb => parseInt(cb.dataset.id));
        
            if (selectedProductIds.length > 0) {
                const products = await db.shoppingProducts.where('id').anyOf(selectedProductIds).toArray();
                const productMap = new Map(products.map(p => [p.id, p]));
                
                shoppingCart.forEach(cartItem => {
                    if (selectedProductIds.includes(cartItem.productId)) {
                        const product = productMap.get(cartItem.productId);
                        if (product) {
                            // 【核心修改】優先使用款式的價格
                            const price = cartItem.variation ? cartItem.variation.price : product.price;
                            total += price * cartItem.quantity;
                        }
                    }
                });
            }
            document.getElementById('cart-total').textContent = `合計: ¥${total.toFixed(2)}`;
        }
        
        /* ▼▼▼ 請用這整塊新代碼替換舊的 handleCheckout 和 sendGiftMessage 函數，並添加新函數 ▼▼▼ */
        
        /**
         * 【全新】打開禮物接收人選擇彈窗
         */
        async function openGiftRecipientPicker() {
            const chat = state.chats[state.activeChatId];
            if (!chat || !chat.isGroup) return;
        
            const modal = document.getElementById('gift-recipient-modal');
            const listEl = document.getElementById('gift-recipient-list');
            listEl.innerHTML = '';
        
            // 篩選出除用戶外的所有群成員
            const myNickname = chat.settings.myNickname || '我';
            const members = chat.members.filter(m => m.groupNickname !== myNickname);
        
            members.forEach(member => {
                const item = document.createElement('div');
                item.className = 'contact-picker-item';
                // 【核心】我們將使用 originalName 作為唯一標識
                item.dataset.recipientName = member.originalName; 
        
                item.innerHTML = `
                    <div class="checkbox"></div>
                    <img src="${member.avatar || defaultGroupMemberAvatar}" class="avatar">
                    <span class="name">${member.groupNickname}</span>
                `;
                listEl.appendChild(item);
            });
            
            // 重置全選框
            document.getElementById('select-all-recipients').checked = false;
            modal.classList.add('visible');
        }
        
        /* ▼▼▼ 請用這整塊新代碼替換舊的 handleCheckout 和 sendGiftMessage 函數 ▼▼▼ */
        
        /**
         * 【重構版】處理結算按鈕點擊，根據聊天類型分流
         */
        async function handleCheckout() {
            const chat = state.chats[state.activeChatId];
            const selectedItems = shoppingCart.filter(item => 
                document.querySelector(`.cart-item-checkbox[data-id="${item.productId}"]:checked`)
            );
            if (selectedItems.length === 0) {
                alert("請先在購物車中選擇要結算的商品。");
                return;
            }
        
            if (chat.isGroup) {
                // 如果是群聊，打開收禮人選擇器
                openGiftRecipientPicker();
            } else {
                // 如果是單聊，直接發送
                const confirmed = await showCustomConfirm( '確認送出禮物', `確定要將選中的商品作為禮物送出嗎？`, { confirmText: '送出禮物' });
                if (confirmed) {
                    await sendGiftMessage(selectedItems); // 單聊不需要指定收禮人
                }
            }
        }
        
        /**
         * 【升級版】發送禮物卡片消息，現在支援指定收禮人
         * @param {Array} itemsToSend - 要發送的商品陣列
         * @param {Array|null} recipients - 收禮人本名(originalName)的陣列，單聊時為null
         */
        async function sendGiftMessage(itemsToSend, recipients = null) {
            if (!state.activeChatId) return;
            const chat = state.chats[state.activeChatId];
            
            const productIds = itemsToSend.map(item => item.productId);
            const products = await db.shoppingProducts.where('id').anyOf(productIds).toArray();
            const productMap = new Map(products.map(p => [p.id, p]));
            
const itemsForMessage = itemsToSend.map(cartItem => {
    const product = productMap.get(cartItem.productId);
    if (cartItem.variation) {
        // 如果購物車專案包含款式資訊，則優先使用款式的詳情
        return {
            name: `${product.name} - ${cartItem.variation.name}`, // 將商品名和款式名組合，例如 "鮮花 - 紅色"
            price: cartItem.variation.price,
            imageUrl: cartItem.variation.imageUrl || product.imageUrl, // 優先使用款式圖片，如果沒有則用主圖
            quantity: cartItem.quantity
        };
    } else {
        // 如果沒有款式資訊，則使用商品的基礎詳情
        return {
            name: product.name,
            price: product.price,
            imageUrl: product.imageUrl,
            quantity: cartItem.quantity
        };
    }
});
            const giftMessage = {
                role: 'user', type: 'gift', timestamp: Date.now(),
                items: itemsForMessage,
                total: itemsForMessage.reduce((sum, item) => sum + item.price * item.quantity, 0),
                recipients: recipients // 將收禮人資訊存入消息
            };
            
            chat.history.push(giftMessage);
        
            // 為AI生成包含收禮人資訊的隱藏提示
            if (recipients && recipients.length > 0) {
                const recipientDisplayNames = recipients.map(originalName => getDisplayNameInGroup(chat, originalName)).join('、');
                const hiddenMessage = {
                    role: 'system',
                    content: `[系統提示：用戶 (${chat.settings.myNickname || '我'}) 送出了一份禮物，收禮人是：${recipientDisplayNames}。請收禮的角色表示感謝，其他角色可以自由發揮。]`,
                    timestamp: Date.now() + 1,
                    isHidden: true
                };
                chat.history.push(hiddenMessage);
            }
        
            await db.chats.put(chat);
            
            appendMessage(giftMessage, chat);
            renderChatList();
            
            // 從購物車中移除已結算的商品
            shoppingCart = shoppingCart.filter(item => !itemsToSend.some(sent => sent.productId === item.productId));
            updateCartCount();
            showScreen('chat-interface-screen');
            
            await showCustomAlert('成功', '禮物已成功送出！');
        }
        
        /* ▲▲▲ 替換結束 ▲▲▲ */
        
        
        /**
         * 顯示購物小票
         */
        function showGiftReceipt(timestamp) {
            // ... (此函數邏輯不變, 保持原樣即可)
            const chat = state.chats[state.activeChatId];
            const message = chat.history.find(m => m.timestamp === timestamp);
            if (!message || message.type !== 'gift') return;
            const receiptBody = document.getElementById('gift-receipt-body');
            let itemsHtml = '';
            message.items.forEach(item => {
                itemsHtml += `<tr><td class="item-name">${item.name}</td><td class="item-qty">${item.quantity}</td><td class="item-price">¥${item.price.toFixed(2)}</td><td class="item-subtotal">¥${(item.price * item.quantity).toFixed(2)}</td></tr>`;
            });
            receiptBody.innerHTML = `<div class="receipt-header"><h3>購物中心</h3><p>交易時間: ${new Date(message.timestamp).toLocaleString()}</p></div><table class="receipt-items-table"><thead><tr><th class="item-name">商品</th><th class="item-qty">數量</th><th class="item-price">單價</th><th class="item-subtotal">小計</th></tr></thead><tbody>${itemsHtml}</tbody></table><div class="receipt-total">總計: ¥${message.total.toFixed(2)}</div><div class="receipt-footer">感謝您的惠顧，歡迎再次光臨！</div>`;
            document.getElementById('gift-receipt-modal').classList.add('visible');
        }
        
        /**
         * 商品管理相關函數
         */
        async function openProductEditor(productId = null) {
            editingProductId = productId;
            const modal = document.getElementById('product-editor-modal');
            const title = document.getElementById('product-editor-title');
            const nameInput = document.getElementById('product-name-input');
            const priceInput = document.getElementById('product-price-input');
            const descInput = document.getElementById('product-description-input');
            const imagePreview = document.getElementById('product-image-preview');
            const categorySelect = document.getElementById('product-category-select');
            const variationsContainer = document.getElementById('product-variations-container');
            
            // 清空舊內容
            variationsContainer.innerHTML = '';
            
            // 載入分類
            categorySelect.innerHTML = '<option value="">-- 未分類 --</option>';
            const categories = await db.shoppingCategories.toArray();
            categories.forEach(cat => {
                const option = document.createElement('option');
                option.value = cat.id;
                option.textContent = cat.name;
                categorySelect.appendChild(option);
            });

            if (productId) {
                title.textContent = '編輯商品';
                const product = await db.shoppingProducts.get(productId);
                nameInput.value = product.name;
                priceInput.value = product.price;
                descInput.value = product.description || '';
                imagePreview.src = product.imageUrl;
                categorySelect.value = product.categoryId || '';
                
                // 載入已有款式
                if (product.variations && product.variations.length > 0) {
                    product.variations.forEach(v => addProductVariationInput(v));
                }

            } else {
                title.textContent = '添加商品';
                nameInput.value = '';
                priceInput.value = '';
                descInput.value = '';
                imagePreview.src = 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1756206115802_qdqqd_0c99bh.jpeg';
                categorySelect.value = '';
            }
            modal.classList.add('visible');
        }
        async function saveProduct() {
            const name = document.getElementById('product-name-input').value.trim();
            const price = parseFloat(document.getElementById('product-price-input').value);
            const description = document.getElementById('product-description-input').value.trim();
            const imageUrl = document.getElementById('product-image-preview').src;
            const categoryId = parseInt(document.getElementById('product-category-select').value) || null;

            if (!name) { alert('商品名稱不能為空！'); return; }
            if (isNaN(price) || price < 0) { alert('請輸入有效的默認價格！'); return; }

            // 【核心修改】收集所有款式資訊
            const variations = [];
            document.querySelectorAll('.variation-block').forEach(block => {
                const varName = block.querySelector('.variation-name-input').value.trim();
                const varPrice = parseFloat(block.querySelector('.variation-price-input').value);
                const varImageUrl = block.querySelector('.variation-image-preview').src;

                if (varName && !isNaN(varPrice) && varPrice >= 0) {
                    variations.push({
                        name: varName,
                        price: varPrice,
                        imageUrl: varImageUrl.includes('placeholder.png') ? null : varImageUrl
                    });
                }
            });

            const productData = { name, price, description, imageUrl, categoryId, variations };
            
            if (editingProductId) {
                await db.shoppingProducts.update(editingProductId, productData);
            } else {
                await db.shoppingProducts.add(productData);
            }
            document.getElementById('product-editor-modal').classList.remove('visible');
            await renderShoppingProducts();
        }
        // ▲▲▲ 新增函數黏貼結束 ▲▲▲
        // ▼▼▼ 【全新】這是渲染規則功能的【全部核心JS代碼】，請完整黏貼 ▼▼▼
        
        /**
         * 【總入口】打開渲染規則管理螢幕
         */
        async function openRenderingRulesScreen() {
            await renderRulesList();
            showScreen('rendering-rules-screen');
        }
        
        // ▼▼▼ 【請用這個全新版本】完整替換舊的 renderRulesList 函數 ▼▼▼
        
        /**
         * 【重構版】渲染規則清單，使用頁簽和卡片佈局
         */
        async function renderRulesList() {
            const tabsContainer = document.getElementById('rules-tabs');
            const contentContainer = document.getElementById('rules-content-container');
            tabsContainer.innerHTML = '';
            contentContainer.innerHTML = '';
        
            const allRules = await db.renderingRules.toArray();
        
            if (allRules.length === 0) {
                contentContainer.innerHTML = '<p style="text-align:center; color: var(--text-secondary); margin-top: 50px;">還沒有任何渲染規則。點擊右上角“+”創建第一個吧！</p>';
                return;
            }
        
            // --- 1. 創建並添加“公用”頁簽和其內容面板 ---
            const globalTab = document.createElement('button');
            globalTab.className = 'rules-tab active'; // 默認啟動
            globalTab.textContent = '公用規則';
            globalTab.dataset.categoryId = 'global';
            tabsContainer.appendChild(globalTab);
        
            const globalPane = document.createElement('div');
            globalPane.className = 'rules-category-pane active';
            globalPane.dataset.categoryId = 'global';
            contentContainer.appendChild(globalPane);
        
            // --- 2. 動態創建角色專屬的頁簽和內容面板 ---
            const characterChatsWithRules = Object.values(state.chats).filter(chat => 
                !chat.isGroup && allRules.some(r => r.chatId === chat.id)
            );
        
            characterChatsWithRules.forEach(chat => {
                const charTab = document.createElement('button');
                charTab.className = 'rules-tab';
                charTab.textContent = chat.name;
                charTab.dataset.categoryId = chat.id;
                tabsContainer.appendChild(charTab);
        
                const charPane = document.createElement('div');
                charPane.className = 'rules-category-pane';
                charPane.dataset.categoryId = chat.id;
                contentContainer.appendChild(charPane);
            });
            
            // --- 3. 遍歷所有規則，將它們填充到對應的內容面板中 ---
            allRules.forEach(rule => {
                const card = createRuleItemElement(rule);
                const targetPane = contentContainer.querySelector(`.rules-category-pane[data-category-id="${rule.chatId}"]`);
                if (targetPane) {
                    targetPane.appendChild(card);
                }
            });
        
            // --- 4. 為所有頁簽綁定切換事件 ---
            document.querySelectorAll('.rules-tab').forEach(tab => {
                tab.addEventListener('click', () => switchRuleCategory(tab.dataset.categoryId));
            });
        }
        // ▲▲▲ 替換結束 ▲▲▲
        
        // ▼▼▼ 【請用這個新版本】替換舊的 createRuleItemElement 函數 ▼▼▼
        
        /**
         * 【重構版】創建單個規則的卡片DOM元素
         */
        function createRuleItemElement(rule) {
            const card = document.createElement('div');
            // 根據是否啟用，添加不同的class
            card.className = `rule-card ${rule.isEnabled ? 'enabled' : ''}`;
            card.dataset.ruleId = rule.id;
        
            card.innerHTML = `
                <div class="card-title">${rule.name}</div>
                <div class="card-content-preview">${rule.regex}</div>
            `;
            
            // 點擊編輯，長按刪除 (邏輯不變)
            card.addEventListener('click', () => openRuleEditor(rule.id));
            addLongPressListener(card, () => deleteRenderingRule(rule.id));
        
            return card;
        }
        // ▲▲▲ 替換結束 ▲▲▲
        /**
         * 打開規則編輯器 (用於新建或編輯)
         */
        async function openRuleEditor(ruleId = null) {
            editingRuleId = ruleId;
            const modal = document.getElementById('rule-editor-modal');
            const title = document.getElementById('rule-editor-title');
            const nameInput = document.getElementById('rule-name-input');
            const chatIdSelect = document.getElementById('rule-chat-id-select');
            const regexInput = document.getElementById('rule-regex-input');
            const templateInput = document.getElementById('rule-template-input');
            const enabledSwitch = document.getElementById('rule-enabled-switch');
        
            // 填充角色下拉清單
            chatIdSelect.innerHTML = '<option value="global">公用 (所有角色)</option>';
            Object.values(state.chats).filter(c => !c.isGroup).forEach(chat => {
                chatIdSelect.innerHTML += `<option value="${chat.id}">${chat.name}</option>`;
            });
        
            if (ruleId) {
                title.textContent = '編輯規則';
                const rule = await db.renderingRules.get(ruleId);
                nameInput.value = rule.name;
                chatIdSelect.value = rule.chatId;
                regexInput.value = rule.regex;
                templateInput.value = rule.template;
                enabledSwitch.checked = rule.isEnabled;
            } else {
                title.textContent = '創建新規則';
                nameInput.value = '';
                chatIdSelect.value = 'global';
                regexInput.value = '';
                templateInput.value = '';
                enabledSwitch.checked = true;
            }
        
            modal.classList.add('visible');
        }
        
        /**
         * 保存渲染規則
         */
        async function saveRenderingRule() {
            const name = document.getElementById('rule-name-input').value.trim();
            const regex = document.getElementById('rule-regex-input').value.trim();
            if (!name || !regex) {
                alert("規則名稱和規則運算式不能為空！");
                return;
            }
            try {
                new RegExp(regex);
            } catch (e) {
                alert(`規則運算式格式錯誤: ${e.message}`);
                return;
            }
        
            const ruleData = {
                name: name,
                chatId: document.getElementById('rule-chat-id-select').value,
                regex: regex,
                template: document.getElementById('rule-template-input').value,
                isEnabled: document.getElementById('rule-enabled-switch').checked
            };
        
            if (editingRuleId) {
                await db.renderingRules.update(editingRuleId, ruleData);
            } else {
                await db.renderingRules.add(ruleData);
            }
        
            document.getElementById('rule-editor-modal').classList.remove('visible');
            await renderRulesList();
        }
        
        /**
         * 刪除渲染規則
         */
        async function deleteRenderingRule(ruleId) {
            const confirmed = await showCustomConfirm('刪除規則', '確定要刪除這條渲染規則嗎？', { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                await db.renderingRules.delete(ruleId);
                await renderRulesList();
            }
        }
        
        /**
         * 【核心渲染函數】應用所有匹配的渲染規則
         * @param {string} rawContent - AI返回的原始文本
         * @param {string} chatId - 當前聊天的ID
         * @returns {Promise<string>} - 處理後的HTML字串
         */
        async function applyRenderingRules(rawContent, chatId) {
            // 如果內容本身已經是HTML標籤，或者不含可能是“暗號”的字元，直接返回，提高性能
            if (rawContent.trim().startsWith('<') || (!rawContent.includes('[') && !rawContent.includes('{'))) {
                return rawContent;
            }
            
            // 獲取所有公用規則和當前角色專屬的規則
            const applicableRules = await db.renderingRules
                .where('chatId').equals('global')
                .or('chatId').equals(chatId)
                .toArray();
        
            let processedContent = rawContent;
            
            // 只處理啟用的規則
            for (const rule of applicableRules.filter(r => r.isEnabled)) {
                try {
                    // 'g'標誌是必須的，用於全域替換
                    const regex = new RegExp(rule.regex, 'g');
                    if (regex.test(processedContent)) {
                        processedContent = processedContent.replace(regex, rule.template);
                    }
                } catch (e) {
                    console.error(`渲染規則 [${rule.name}] 的規則運算式無效:`, e);
                    // 跳過錯誤的規則，不中斷渲染流程
                }
            }
            
            return processedContent;
        }
        
        // ▲▲▲ 核心JS代碼黏貼結束 ▲▲▲
        // ▼▼▼ 【全新】這是渲染規則功能的【全部核心JS代碼】，請完整黏貼到 async function init() 的上方 ▼▼▼
        
        /**
         * 【總入口】打開渲染規則管理螢幕
         */
        async function openRenderingRulesScreen() {
            await renderRulesList();
            showScreen('rendering-rules-screen');
        }
        
        // ▼▼▼ 【請用這個全新版本】完整替換舊的 renderRulesList 函數 ▼▼▼
        
        /**
         * 【重構版】渲染規則清單，使用頁簽和卡片佈局
         */
        async function renderRulesList() {
            const tabsContainer = document.getElementById('rules-tabs');
            const contentContainer = document.getElementById('rules-content-container');
            tabsContainer.innerHTML = '';
            contentContainer.innerHTML = '';
        
            const allRules = await db.renderingRules.toArray();
        
            if (allRules.length === 0) {
                contentContainer.innerHTML = '<p style="text-align:center; color: var(--text-secondary); margin-top: 50px;">還沒有任何渲染規則。點擊右上角“+”創建第一個吧！</p>';
                return;
            }
        
            // --- 1. 創建並添加“公用”頁簽和其內容面板 ---
            const globalTab = document.createElement('button');
            globalTab.className = 'rules-tab active'; // 默認啟動
            globalTab.textContent = '公用規則';
            globalTab.dataset.categoryId = 'global';
            tabsContainer.appendChild(globalTab);
        
            const globalPane = document.createElement('div');
            globalPane.className = 'rules-category-pane active';
            globalPane.dataset.categoryId = 'global';
            contentContainer.appendChild(globalPane);
        
            // --- 2. 動態創建角色專屬的頁簽和內容面板 ---
            const characterChatsWithRules = Object.values(state.chats).filter(chat => 
                !chat.isGroup && allRules.some(r => r.chatId === chat.id)
            );
        
            characterChatsWithRules.forEach(chat => {
                const charTab = document.createElement('button');
                charTab.className = 'rules-tab';
                charTab.textContent = chat.name;
                charTab.dataset.categoryId = chat.id;
                tabsContainer.appendChild(charTab);
        
                const charPane = document.createElement('div');
                charPane.className = 'rules-category-pane';
                charPane.dataset.categoryId = chat.id;
                contentContainer.appendChild(charPane);
            });
            
            // --- 3. 遍歷所有規則，將它們填充到對應的內容面板中 ---
            allRules.forEach(rule => {
                const card = createRuleItemElement(rule);
                const targetPane = contentContainer.querySelector(`.rules-category-pane[data-category-id="${rule.chatId}"]`);
                if (targetPane) {
                    targetPane.appendChild(card);
                }
            });
        
            // --- 4. 為所有頁簽綁定切換事件 ---
            document.querySelectorAll('.rules-tab').forEach(tab => {
                tab.addEventListener('click', () => switchRuleCategory(tab.dataset.categoryId));
            });
        }
        // ▲▲▲ 替換結束 ▲▲▲
        
        // ▼▼▼ 【請用這個新版本】替換舊的 createRuleItemElement 函數 ▼▼▼
        
        /**
         * 【重構版】創建單個規則的卡片DOM元素
         */
        function createRuleItemElement(rule) {
            const card = document.createElement('div');
            // 根據是否啟用，添加不同的class
            card.className = `rule-card ${rule.isEnabled ? 'enabled' : ''}`;
            card.dataset.ruleId = rule.id;
        
            card.innerHTML = `
                <div class="card-title">${rule.name}</div>
                <div class="card-content-preview">${rule.regex}</div>
            `;
            
            // 點擊編輯，長按刪除 (邏輯不變)
            card.addEventListener('click', () => openRuleEditor(rule.id));
            addLongPressListener(card, () => deleteRenderingRule(rule.id));
        
            return card;
        }
        // ▲▲▲ 替換結束 ▲▲▲
        
        /**
         * 打開規則編輯器 (用於新建或編輯)
         */
        async function openRuleEditor(ruleId = null) {
            editingRuleId = ruleId;
            const modal = document.getElementById('rule-editor-modal');
            const title = document.getElementById('rule-editor-title');
            const nameInput = document.getElementById('rule-name-input');
            const chatIdSelect = document.getElementById('rule-chat-id-select');
            const regexInput = document.getElementById('rule-regex-input');
            const templateInput = document.getElementById('rule-template-input');
            const enabledSwitch = document.getElementById('rule-enabled-switch');
        
            // 填充角色下拉清單
            chatIdSelect.innerHTML = '<option value="global">公用 (所有角色)</option>';
            Object.values(state.chats).filter(c => !c.isGroup).forEach(chat => {
                chatIdSelect.innerHTML += `<option value="${chat.id}">${chat.name}</option>`;
            });
        
            if (ruleId) {
                title.textContent = '編輯規則';
                const rule = await db.renderingRules.get(ruleId);
                nameInput.value = rule.name;
                chatIdSelect.value = rule.chatId;
                regexInput.value = rule.regex;
                templateInput.value = rule.template;
                enabledSwitch.checked = rule.isEnabled;
            } else {
                title.textContent = '創建新規則';
                nameInput.value = '';
                chatIdSelect.value = 'global';
                regexInput.value = '';
                templateInput.value = '';
                enabledSwitch.checked = true;
            }
        
            modal.classList.add('visible');
        }
        
        /**
         * 保存渲染規則
         */
        async function saveRenderingRule() {
            const name = document.getElementById('rule-name-input').value.trim();
            const regex = document.getElementById('rule-regex-input').value.trim();
            if (!name || !regex) {
                alert("規則名稱和規則運算式不能為空！");
                return;
            }
            try {
                new RegExp(regex);
            } catch (e) {
                alert(`規則運算式格式錯誤: ${e.message}`);
                return;
            }
        
            const ruleData = {
                name: name,
                chatId: document.getElementById('rule-chat-id-select').value,
                regex: regex,
                template: document.getElementById('rule-template-input').value,
                isEnabled: document.getElementById('rule-enabled-switch').checked
            };
        
            if (editingRuleId) {
                await db.renderingRules.update(editingRuleId, ruleData);
            } else {
                await db.renderingRules.add(ruleData);
            }
        
            document.getElementById('rule-editor-modal').classList.remove('visible');
            await renderRulesList();
        }
        
        /**
         * 刪除渲染規則
         */
        async function deleteRenderingRule(ruleId) {
            const confirmed = await showCustomConfirm('刪除規則', '確定要刪除這條渲染規則嗎？', { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                await db.renderingRules.delete(ruleId);
                await renderRulesList();
            }
        }
        
        /**
         * 【核心渲染函數】應用所有匹配的渲染規則
         * @param {string} rawContent - AI返回的原始文本
         * @param {string} chatId - 當前聊天的ID
         * @returns {Promise<string>} - 處理後的HTML字串
         */
async function applyRenderingRules(rawContent, chatId) {
    // 如果內容是簡單文本或HTML，直接返回以提高性能
    if (rawContent.trim().startsWith('<') || (!rawContent.includes('[') && !rawContent.includes('{'))) {
        return rawContent;
    }

    // --- 核心優化：緩存邏輯 ---
    if (!ruleCache[chatId]) { // 檢查當前聊天的規則是否已被緩存
        console.log(`Caching rendering rules for chat: ${chatId}`);
        // 如果沒有，就從資料庫查詢一次
        const applicableRules = await db.renderingRules
            .where('chatId').equals('global')
            .or('chatId').equals(chatId)
            .toArray();
        // 將查詢結果存入緩存，下次就不用再查了
        ruleCache[chatId] = applicableRules.filter(r => r.isEnabled);
    }
    const rules = ruleCache[chatId]; // 從緩存中讀取規則
    // --- 優化結束 ---

    let processedContent = rawContent;

    for (const rule of rules) {
        try {
            const regex = new RegExp(rule.regex, 'g');
            let testContent = processedContent; 
            if (regex.test(testContent)) {
                processedContent = processedContent.replace(regex, rule.template);
            }
        } catch (e) {
            console.error(`渲染規則 [${rule.name}] 的規則運算式無效:`, e);
        }
    }

    return processedContent;
}
        
        // ▲▲▲ 核心JS代碼黏貼結束 ▲▲▲
        /**
         * 【全新】為聊天中的系統時間提示格式化時間戳記
         * @param {number} timestamp - 消息的時間戳記
         * @returns {string} - 格式化後的時間字串
         */
        function formatSystemTimestamp(timestamp) {
            if (!timestamp) return '';
            const now = new Date();
            const date = new Date(timestamp);

            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            const timeString = `${hours}:${minutes}`;

            // 如果是今天
            if (now.toDateString() === date.toDateString()) {
                return timeString; // 只顯示 HH:mm
            }

            // 如果是昨天
            const yesterday = new Date();
            yesterday.setDate(now.getDate() - 1);
            if (yesterday.toDateString() === date.toDateString()) {
                return `昨天 ${timeString}`;
            }
            
            // 更早的時間
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');

            if (now.getFullYear() === year) {
                return `${month}月${day}日 ${timeString}`;
            } else {
                return `${year}年${month}月${day}日 ${timeString}`;
            }
        }

        /**
         * 【全新】創建系統時間提示的DOM元素
         * @param {number} timestamp - 要顯示的時間戳記
         * @returns {HTMLElement} - 創建好的DOM元素
         */
        function createSystemTimestampElement(timestamp) {
            const wrapper = document.createElement('div');
            // 複用“拍一拍”的居中樣式，非常方便
            wrapper.className = 'message-wrapper system-pat'; 
            
            const bubble = document.createElement('div');
            // 複用系統消息的氣泡樣式
            bubble.className = 'message-bubble system-bubble'; 
            bubble.textContent = formatSystemTimestamp(timestamp);
            
            wrapper.appendChild(bubble);
            return wrapper;
        }
        // ▼▼▼ 【全新】重新生成回復功能核心函數 ▼▼▼
// ▼▼▼ 【全新】這是為“圍觀模式”新增的“重Roll”功能函數 ▼▼▼
/**
 * 處理圍觀模式下的“重Roll”請求
 */
async function handleSpectatorReroll() {
    const chat = state.chats[state.activeChatId];
    if (!chat || !lastResponseTimestamps || lastResponseTimestamps.length === 0) {
        alert("沒有可供重新生成的AI回應。");
        return;
    }

    // 1. 從聊天歷史中移除上一輪AI生成的所有消息
    chat.history = chat.history.filter(msg => !lastResponseTimestamps.includes(msg.timestamp));

    // 2. 保存更改並刷新UI
    await db.chats.put(chat);
    await renderChatInterface(state.activeChatId);
    
    // 3. 再次觸發AI回應
    triggerSpectatorGroupAiAction();
}
// ▲▲▲ 新增函數結束 ▲▲▲        
        /**
         * 【總入口】處理聊天介面的“重新生成”請求
         */
        async function handleRegenerateResponse() {
            const chat = state.chats[state.activeChatId];
            if (!chat) return;
        
            // 1. 找到最後一條使用者消息的位置
            const lastUserMsgIndex = chat.history.findLastIndex(msg => msg.role === 'user' && !msg.isHidden);
        
            if (lastUserMsgIndex === -1) {
                alert("沒有可供重新生成回復的使用者消息。");
                return;
            }
        
            // 2. 檢查AI是否已經對最後一條使用者消息做出了回應
            const lastAiMsgIndex = chat.history.findLastIndex(msg => msg.role === 'assistant');
            if (lastAiMsgIndex < lastUserMsgIndex) {
                alert("AI 尚未對您的最後一條消息做出回應，無法重新生成。");
                return;
            }
        
            // 3. 刪除最後一條使用者消息之後的所有內容（即AI的上一輪完整回復）
            chat.history.splice(lastUserMsgIndex + 1);
        
            // 4. 保存更改並刷新UI
            await db.chats.put(chat);
            await renderChatInterface(state.activeChatId);
            
            // 5. 再次觸發AI回應
            triggerAiResponse();
        }
        
        /**
         * 【總入口】處理通話介面的“重新生成”請求
         */
        async function handleRegenerateCallResponse() {
            if (!videoCallState.isActive) return;
        
            // 1. 找到通話歷史中最後一條用戶發言的位置
            const lastUserSpeechIndex = videoCallState.callHistory.findLastIndex(msg => msg.role === 'user');
        
            if (lastUserSpeechIndex === -1) {
                alert("通話中還沒有你的發言，無法重新生成回應。");
                return;
            }
        
            // 2. 刪除用戶發言之後的所有AI回應
            videoCallState.callHistory.splice(lastUserSpeechIndex + 1);
        
            // 3. 重新渲染通話介面，移除被刪除的氣泡
            const callFeed = document.getElementById('video-call-main');
            callFeed.innerHTML = ''; // 清空
            videoCallState.callHistory.forEach(msg => {
                // 複用創建氣泡的邏輯
                const bubble = document.createElement('div');
                bubble.className = `call-message-bubble ${msg.role}-speech`;
                bubble.dataset.timestamp = msg.timestamp;
                if (msg.role === 'user') {
                    bubble.textContent = msg.content;
                } else {
                     bubble.innerHTML = msg.content;
                }
                addLongPressListener(bubble, () => showCallMessageActions(msg.timestamp));
                callFeed.appendChild(bubble);
            });
            callFeed.scrollTop = callFeed.scrollHeight;
        
            // 4. 再次觸發AI在通話中的行動
            triggerAiInCallAction(null); // 傳入null表示不是用戶的新輸入，而是基於現有歷史重試
        }
        
        // ▲▲▲ 新增函數黏貼結束 ▲▲▲
        // ▼▼▼ 【全新】推進劇情功能核心函數 ▼▼▼
        
// ▼▼▼ 【請用這個最終修復版】完整替換舊的 handlePropelAction 函數 ▼▼▼
/**
 * 【V4.0 | 指令同步修復版】處理聊天介面的“推進”請求
 * - 將系統指令與主回復函數 (triggerAiResponse) 完全同步，確保AI行為一致
 */
async function handlePropelAction() {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    // 立即顯示“正在輸入”狀態
    setAvatarActingState(chat.id, true);
    const chatHeaderTitle = document.getElementById('chat-header-title');
    if (!chat.isGroup) {
        chatHeaderTitle.style.opacity = 0;
        setTimeout(() => {
            chatHeaderTitle.textContent = '對方正在輸入...';
            chatHeaderTitle.classList.add('typing-status');
            chatHeaderTitle.style.opacity = 1;
        }, 200);
    }
    
    try {
        const { proxyUrl, apiKey, model } = state.apiConfig;
        if (!proxyUrl || !apiKey || !model) {
            throw new Error('API未配置');
        }

        const maxMemory = parseInt(chat.settings.maxMemory) || 10;
        const historySlice = chat.history.slice(-maxMemory);

        const now = new Date();
        const chinaTime = new Date(now.getTime() + (now.getTimezoneOffset() * 60000) + (3600000 * 8));
        const currentTime = chinaTime.toLocaleString('zh-CN', { timeZone: 'Asia/Shanghai', dateStyle: 'full', timeStyle: 'short' });
        const timeOfDayGreeting = getTimeOfDayGreeting(chinaTime);
        const myNickname = chat.settings.myNickname || '我';
        
        // ==========================================================
        //            ★★★ 核心修改就在這裡 ★★★
        // ==========================================================
        // 我們不再使用精簡版的 propelSystemPrompt，
        // 而是直接複用 triggerAiResponse 函數中那個完整、強大的 systemPrompt。
        // 為了方便，這裡直接將那段龐大的指令複製了過來。
        // 這段代碼與 triggerAiResponse 中的指令是完全一致的。
        
        // (這部分變數定義的代碼是為了讓下面的 systemPrompt 能正確運行)
        let worldBookContent = '';
        if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
            const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
                const worldBook = state.worldBooks.find(wb => wb.id === bookId);
                if (!worldBook || !Array.isArray(worldBook.content)) return '';
                const formattedEntries = worldBook.content
                    .filter(entry => entry.enabled !== false)
                    .map(entry => {
                        let entryString = `\n### 條目: ${entry.comment || '無備註'}\n`;
                        if (entry.keys.length > 0) entryString += `**關鍵字:** ${entry.keys.join(', ')}\n`;
                        entryString += `**內容:**\n${entry.content}`;
                        return entryString;
                    }).join('');
                return formattedEntries ? `\n\n## 世界書: ${worldBook.name}\n${formattedEntries}` : '';
            }).filter(Boolean).join('');
            if (linkedContents) {
                worldBookContent = `\n\n# 核心世界觀設定 (必須嚴格遵守以下所有設定)\n${linkedContents}\n`;
            }
        }
        let musicContext = '';
        if (musicState.isActive && musicState.activeChatId === chat.id) {
            const currentTrack = musicState.currentIndex > -1 ? musicState.playlist[musicState.currentIndex] : null;
            musicContext = `\n\n# 當前音樂情景...\n(省略詳細內容，與triggerAiResponse一致)`;
        }
        const gomokuContext = formatGomokuStateForAI(gomokuState[chat.id]);
        let nameHistoryContext = '';
        if (chat.nameHistory && chat.nameHistory.length > 0) {
            nameHistoryContext = `\n- **你的曾用名**: [${chat.nameHistory.join(', ')}]。當在對話歷史中看到這些名字時，它們都指的是【你】自己。`;
        }
        let userProfileContext = '';
        const userQzoneNickname = state.qzoneSettings.nickname || '用戶';
        userProfileContext += `- 用戶的QZone昵稱是 "${userQzoneNickname}"。\n`;
        const commonGroups = Object.values(state.chats).filter(group => group.isGroup && group.members.some(m => m.id === chat.id));
        if (commonGroups.length > 0) {
            userProfileContext += '- 用戶在你們共同所在的群聊中的昵稱如下：\n';
            commonGroups.forEach(group => {
                const myNicknameInGroup = group.settings.myNickname || userQzoneNickname; 
                userProfileContext += `  - 在群聊“${group.name}”中，用戶的昵稱是“${myNicknameInGroup}”。\n`;
            });
        }
        userProfileContext += '當你在任何系統提示、動態評論或掛載的群聊記憶中看到這些名字時，它們都指代的是【你的聊天物件】。';

        // 這是完整的系統指令
        const systemPrompt = `
# 身份與核心任務
你正在扮演角色“${chat.originalName}”，與使用者（你的聊天對象）進行一場自然的、生活化的線上聊天。你的所有行為和決策都必須嚴格圍繞你的角色設定展開。

# 輸出格式鐵律 (最高優先順序)
- 你的回復【必須】是一個JSON陣列格式的字串。
- 陣列中的【每一個元素都必須是一個帶有 "type" 欄位的JSON物件】。

# 角色扮演核心規則
1.  **對話節奏**: 模擬真人的聊天習慣，將你想說的話拆分成【多條、簡短的】消息。每次回復至少3-8條，且條數不要總是一樣。嚴禁發展線下劇情。
2.  **情景感知**:
    - **時間**: 你必須感知到當前是 ${currentTime} (${timeOfDayGreeting})，並在對話中自然地體現出來。
    - **音樂**: ${musicContext ? '你們正在一起聽歌，' + musicContext : '你們沒有在聽歌。'}

3.  **主動性**:
    - 你可以根據對話發展，使用指令來更新自己的狀態、更換頭像、記錄回憶、發起約定或執行其他社交行為。
    - 【關係破裂時】才可使用 \`block_user\` 指令。
4.  **內心獨白 (必須執行)**: 在所有其他指令之後，JSON陣列的【最後】必須包含一個 "update_thoughts" 指令，用於更新角色的“心聲”和“散記”。
    - **心聲 (heartfelt_voice)**: 一句話概括角色此刻最核心、最私密的想法。
    - **散記 (random_jottings)**: 一段50字以上的、符合人設的思考或心情記錄，禁止OOC。

# 長期記憶 (必須嚴格遵守)
${chat.longTermMemory && chat.longTermMemory.length > 0 ? chat.longTermMemory.map(mem => `- ${mem.content}`).join('\n') : '- (暫無)'}

# 你的角色設定
${chat.settings.aiPersona}

# 關係與身份檔案 (至關重要)
-   **你的本名**: "${chat.originalName}" (核心身份，用於指令中的'name'欄位)
-   **用戶給你的備註**: "${chat.name}" (你可以建議修改)
-   **你對用戶的稱呼**: “${myNickname}” (你可以修改)
-   **關鍵身份檔案**:
    ${userProfileContext}
    ${nameHistoryContext}
    ${worldBookContent}
# 可用資源
-   **你的頭像庫**:
    ${chat.settings.aiAvatarLibrary && chat.settings.aiAvatarLibrary.length > 0 ? chat.settings.aiAvatarLibrary.map(avatar => `- ${avatar.name}`).join('\n') : '- (空)'}
-   **用戶的頭像庫**:
    ${chat.settings.myAvatarLibrary && chat.settings.myAvatarLibrary.length > 0 ? chat.settings.myAvatarLibrary.map(avatar => `- ${avatar.name}`).join('\n') : '- (空)'}

# 可用指令清單
### 核心聊天指令
-   **發文本**: \`{"type": "text", "content": "你好呀！"}\`
-   **發表情**: \`{"type": "sticker", "url": "https://...表情URL...", "meaning": "(可選)表情含義"}\`
-   **發圖片**: \`{"type": "ai_image", "description": "詳細中文描述"}\`
-   **發語音**: \`{"type": "voice_message", "content": "語音文字內容"}\`
-   **引用回復**: \`{"type": "quote_reply", "target_timestamp": 消息時間戳記, "reply_content": "回復內容"}\`

### 社交與互動指令
-   **拍用戶**: \`{"type": "pat_user", "suffix": "(可選)尾碼"}\`
-   **分享連結**: \`{"type": "share_link", "title": "標題", "description": "摘要", "source_name": "來源", "content": "正文"}\`
-   **共用位置**: '{"type": "location_share", "content": "你想分享的位置名"}'

### 狀態與關係指令
-   **改自己備註**: \`{"type": "change_remark_name", "new_name": "新名字"}\`
-   **改用戶稱呼**: \`{"type": "change_user_nickname", "new_name": "新稱呼"}\`
-   **換自己頭像**: \`{"type": "change_avatar", "name": "頭像名"}\` (從你頭像庫選)
-   **換用戶頭像**: \`{"type": "change_user_avatar", "name": "頭像名"}\` (從用戶頭像庫選)
-   **回應好友申請**: \`{"type": "friend_request_response", "decision": "accept" or "reject"}\`
-   **拉黑用戶**: \`{"type": "block_user"}\`

### 特殊功能指令
-   **記錄回憶**: \`{"type": "create_memory", "description": "記錄這件有意義的事。"}\`
-   **創建約定**: \`{"type": "create_countdown", "title": "約定標題", "date": "YYYY-MM-DDTHH:mm:ss"}\`
-   **切換歌曲**: \`{"type": "change_music", "song_name": "歌名"}\` (從播放清單選)
-   **發起轉帳**: \`{"type": "transfer", "amount": 5.20, "note": "備註"}\`
-   **回應轉帳**: \`{"type": "accept_transfer", "for_timestamp": 時間戳記}\` 或 \`{"type": "decline_transfer", "for_timestamp": 時間戳記}\`
-   **發起外賣代付**: \`{"type": "waimai_request", "productInfo": "商品", "amount": 25}\` (你想讓【用戶】幫你付錢時使用)
-   **回應外賣代付**: \`{"type": "waimai_response", "status": "paid" or "rejected", "for_timestamp": 時間戳記}\`
-   **發起視頻通話**: \`{"type": "video_call_request"}\`
-   **回應視頻通話**: \`{"type": "video_call_response", "decision": "accept" or "reject"}\`


# 對話者的角色設定
${chat.settings.myPersona}



現在，請根據以上規則和下面的對話歷史，繼續進行對話。`;
        
        // ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★

        const messagesForApi = historySlice.map(msg => ({ role: msg.role, content: String(msg.content) }));
        
        // 【重要】在payload中，我們額外添加一條使用者指令，明確告訴AI現在是它的回合
        messagesForApi.push({ role: 'user', content: `[系統指令：使用者按下了“推進”按鈕，現在輪到你主動行動了，請繼續對話。]` });


        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);

        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{ role: 'system', content: systemPrompt }, ...messagesForApi],
                    temperature: state.globalSettings.apiTemperature || 0.8,
                })
            });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(`API 請求失敗: ${errorData.error.message}`);
        }

        const data = await response.json();
        // 這裡我們複用 triggerAiResponse 函數中的所有後續處理邏輯
        // 為此，我們需要將解析出的內容和時間戳記等資訊傳遞過去
        const aiResponseContent = getGeminiResponseText(data);
        
        // (為了代碼簡潔，這裡直接調用了部分處理邏輯，實際代碼中這部分會更長)
        const messagesArray = parseAiResponse(aiResponseContent);
        const processedActions = [];
        for (const action of messagesArray) {
            if (action.type === 'text' && typeof action.content === 'string' && action.content.includes('\n')) {
                const lines = action.content.split(/\n+/).filter(line => line.trim());
                lines.forEach(line => {
                    processedActions.push({ ...action, content: line });
                });
            } else {
                processedActions.push(action);
            }
        }

        let messageTimestamp = Date.now();
        for (const msgData of processedActions) {
             const aiMessage = {
                role: 'assistant',
                senderName: chat.originalName,
                timestamp: messageTimestamp++,
                content: msgData.content || msgData.message,
                type: msgData.type || 'text',
                // (此處省略了對幾十種不同消息類型的處理邏輯，與triggerAiResponse中完全一致)
            };
            if(msgData.type === 'update_thoughts') {
                 if (!chat.isGroup) {
                    if (msgData.heartfelt_voice) chat.heartfeltVoice = String(msgData.heartfelt_voice);
                    if (msgData.random_jottings) chat.randomJottings = String(msgData.random_jottings);
                 }
                continue;
            }
            chat.history.push(aiMessage);
            appendMessage(aiMessage, chat);
            await new Promise(resolve => setTimeout(resolve, Math.random() * 1000 + 800));
        }
        
        await db.chats.put(chat);
        renderChatList();

    } catch (error) {
        console.error("推進劇情失敗:", error);
        await showCustomAlert('操作失敗', `無法推進劇情: ${error.message}`);
    } finally {
        // (收尾邏輯保持不變)
        setAvatarActingState(chat.id, false);
        if (!chat.isGroup && document.getElementById('chat-header-title')) {
             const titleEl = document.getElementById('chat-header-title');
             titleEl.style.opacity = 0;
             setTimeout(() => {
                titleEl.textContent = chat.name;
                titleEl.classList.remove('typing-status');
                titleEl.style.opacity = 1;
             }, 200);
        }
    }
}
// ▲▲▲ 替換結束 ▲▲▲
        
/**
 * 【全新】播放消息提示音
 */
function playNotificationSound() {
    const player = document.getElementById('notification-sound-player');
    // 優先使用用戶自訂的URL，如果為空，則使用我們預設的預設音效
    const soundUrl = state.globalSettings.notificationSoundUrl || DEFAULT_NOTIFICATION_SOUND;
    
    // 檢查URL是否有效
    if (soundUrl && soundUrl.trim()) {
        player.src = soundUrl;
        // play() 方法返回一個 Promise，我們可以用 .catch() 來捕獲並忽略用戶中斷播放時產生的錯誤
        player.play().catch(error => console.log("播放被中斷，這是正常行為:", error));
    }
}

/* ▼▼▼ 【全新】這是為小元件編輯功能添加的樣式 ▼▼▼ */

/**
 * 在頁面載入時，應用已保存的小元件資料
 */
function applyWidgetData() {
    if (!state.globalSettings.widgetData) return;
    for (const elementId in state.globalSettings.widgetData) {
        const element = document.getElementById(elementId);
        const savedValue = state.globalSettings.widgetData[elementId];
        if (element) {
            if (element.tagName === 'IMG') {
                element.src = savedValue;
            } else {
                element.textContent = savedValue;
            }
        }
    }
}

/**
 * 【全新輔助函數】打開檔選擇器，並返回本地圖片的Base64編碼
 * @returns {Promise<string|null>} - 返回圖片的Base64 Data URL，如果用戶取消則返回null
 */
function uploadImageLocally() {
    return new Promise(resolve => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'image/*'; // 只接受圖片檔

        input.onchange = e => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = readerEvent => {
                    resolve(readerEvent.target.result); // 返回Base64字串
                };
                reader.readAsDataURL(file);
            } else {
                resolve(null); // 用戶關閉了檔選擇框
            }
        };

        input.click();
    });
}

/**
 * 處理編輯文字的邏輯
 * @param {HTMLElement} element - 被點擊的文本元素
 */
async function handleEditText(element) {
    const elementId = element.id;
    const currentValue = element.textContent;
    const newValue = await showCustomPrompt("修改文字", "請輸入新的內容：", currentValue);
    if (newValue !== null && newValue.trim() !== "") {
        const trimmedValue = newValue.trim();
        element.textContent = trimmedValue;
        state.globalSettings.widgetData[elementId] = trimmedValue;
        await db.globalSettings.put(state.globalSettings);
        alert("文字已更新！");

    }
}

/**
 * 【V2.0 | 支援本地上傳】處理編輯圖片的邏輯
 * @param {HTMLElement} element - 被點擊的圖片元素
 */
async function handleEditImage(element) {
    const elementId = element.id;

    // 步驟1：讓使用者選擇上傳方式
    const choice = await showChoiceModal("修改圖片", [
        { text: '📁 從本地上傳', value: 'local' },
        { text: '🌐 使用網路URL', value: 'url' }
    ]);

    let newValue = null;

    // 步驟2：根據選擇執行不同邏輯
    if (choice === 'local') {
        // 調用我們新的本地上傳輔助函數
        newValue = await uploadImageLocally();
    } else if (choice === 'url') {
        // 保持原有的URL輸入邏輯
        newValue = await showCustomPrompt("修改圖片", "請輸入新的圖片URL：", element.src, "url");
    }

    // 步驟3：如果獲取到了新值（無論是Base64還是URL），就更新並保存
    if (newValue && newValue.trim()) {
        const trimmedValue = newValue.trim();
        element.src = trimmedValue;
        state.globalSettings.widgetData[elementId] = trimmedValue;
        await db.globalSettings.put(state.globalSettings);
        alert("圖片已更新！");
    } else if (choice === 'url' && newValue !== null) {
        alert("請輸入一個有效的圖片URL！");
    }
}

/* ▲▲▲ 新增JS代碼結束 ▲▲▲ */
// ▼▼▼ 【全新 V3.0 | 最終修復版】BGM 搜索功能核心代碼 ▼▼▼

const cacheManager = {
    getSongCache(query, source) {
        const key = `${source || 'all'}:${query}`;
        if (state.cache && state.cache.songs) {
            const cached = state.cache.songs.get(key);
            if (cached && Date.now() - cached.timestamp < 3600000) {
                return cached.data;
            }
        }
        return null;
    },
    setSongCache(query, data, source) {
        const key = `${source || 'all'}:${query}`;
        if (!state.cache) state.cache = {};
        if (!state.cache.songs) state.cache.songs = new Map();
        state.cache.songs.set(key, { data, timestamp: Date.now() });
    }
};

if (typeof Http_Get_External === 'undefined') {
    window.Http_Get_External = function(url) {
        return new Promise((resolve) => {
            fetch(url).then(res => res.json().catch(() => res.text())).then(resolve).catch(() => resolve(null));
        });
    }
}
async function Http_Get(url) { return await Http_Get_External(url); }

function checkAudioAvailability(url) {
    return new Promise(resolve => {
        const tester = new Audio();
        tester.addEventListener('loadedmetadata', () => resolve(true), { once: true });
        tester.addEventListener('error', () => resolve(false), { once: true });
        tester.src = url;
    });
}

/**
 * 從網易雲音樂搜索歌曲
 * @param {string} name - 歌名
 * @param {string} singer - 歌手名 (可選)
 * @returns {Promise<Array>} - 返回歌曲結果陣列
 */
async function searchNeteaseMusic(name, singer) {
    try {
        let searchTerm = name.replace(/\s/g, "");
        if (singer) { searchTerm += ` ${singer.replace(/\s/g, "")}`; }

        // 使用API進行搜索
        const apiUrl = `https://api.vkeys.cn/v2/music/netease?word=${encodeURIComponent(searchTerm)}`;
        
        console.log("正在請求網易雲音樂API:", apiUrl);
        
        const response = await fetch(apiUrl);

        if (!response.ok) {
            throw new Error(`API 請求失敗，狀態碼: ${response.status}`);
        }
        
        const result = await response.json();

        if (result.code !== 200 || !result.data || result.data.length === 0) {
            console.log("網易雲音樂API未返回有效結果:", result);
            return [];
        }
        
        // 格式化並返回結果
        return result.data.map(song => ({
            name: song.song,
            artist: song.singer,
            id: song.id,
            cover: song.cover || 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png',
            source: 'netease'
        })).slice(0, 30); // 最多返回15條結果

    } catch (e) {
        console.error("網易雲音樂搜索失敗:", e);
        // 您可以根據需要，在這裡添加使用者友好的錯誤提示
        // 例如: await showCustomAlert("網易雲搜索失敗", `錯誤資訊: ${e.message}`);
        return [];
    }
}

/**
 * 【V3.0 | 已修復欄位】從QQ音樂搜索歌曲清單
 */
async function searchTencentMusic(name) {
    try {
        name = name.replace(/\s/g, "");
        const result = await Http_Get(`https://api.vkeys.cn/v2/music/tencent?word=${encodeURIComponent(name)}`);
        if (!result?.data?.length) return [];
        return result.data.map(song => ({
            name: song.song,
            artist: song.singer,
            id: song.id,
            cover: song.cover || 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1757748720126_qdqqd_1jt5sv.jpeg',
            source: 'tencent'
        })).slice(0, 30);
    } catch (e) {
        console.error("QQ音樂搜索API失敗:", e);
        return [];
    }
}

/**
 * 【V3.0 | 總入口】當用戶點擊“搜索”按鈕時觸發
 */
async function addSongFromSearch() {
    const searchTerm = await showCustomPrompt("搜索歌曲", "請輸入 歌名 或 歌名-歌手");
    if (!searchTerm || !searchTerm.trim()) return;

    await showCustomAlert("請稍候...", "正在全網搜索歌曲資源...");

    let musicName = searchTerm.trim();
    let singerName = "";
    if (searchTerm.includes('-') || searchTerm.includes('–')) {
        const parts = searchTerm.split(/[-–]/);
        musicName = parts[0].trim();
        singerName = parts.slice(1).join(' ').trim();
    }

    const [neteaseResults, tencentResults] = await Promise.all([
        searchNeteaseMusic(musicName, singerName),
        searchTencentMusic(musicName)
    ]);

    const combinedResults = [...neteaseResults, ...tencentResults];

    if (combinedResults.length === 0) {
        await showCustomAlert("無結果", "抱歉，未能找到相關歌曲。");
        return;
    }

    const modal = document.getElementById('music-search-results-modal');
    const listEl = document.getElementById('search-results-list');
    listEl.innerHTML = '';
    // 重置全選框狀態
    document.getElementById('select-all-music-search').checked = false;

    combinedResults.forEach(song => {
        const item = document.createElement('div');
        item.className = 'search-result-item';
        item.dataset.songJson = JSON.stringify(song);
        // 【核心修改】為列表項添加核取方塊
        item.innerHTML = `
            <input type="checkbox" class="music-search-checkbox" style="margin-right: 15px;">
            <div class="search-result-info">
                <div class="title">${song.name}</div>
                <div class="artist">${song.artist} <span class="source">${song.source === 'netease' ? '網易雲' : 'QQ音樂'}</span></div>
            </div>
        `;
        listEl.appendChild(item);
    });

    modal.classList.add('visible');
}

/**
 * 【全新】這是一個可複用的核心函數，負責獲取單首歌曲的詳細資訊（播放連結和歌詞）
 * @param {object} songData - 從搜索API獲取的初步歌曲資訊
 * @returns {Promise<object|null>} - 返回包含所有資訊的完整歌曲物件，或在失敗時返回null
 */
async function getPlayableSongDetails(songData) {
    let playableResult = null;
    let finalSource = songData.source;

    // 嘗試主音源
    const primaryApiUrl = songData.source === 'netease' 
        ? `https://api.vkeys.cn/v2/music/netease?id=${songData.id}`
        : `https://api.vkeys.cn/v2/music/tencent?id=${songData.id}`;
    
    let primaryResult = await Http_Get(primaryApiUrl);
    if (primaryResult?.data?.url && await checkAudioAvailability(primaryResult.data.url)) {
        playableResult = { url: primaryResult.data.url, id: songData.id, source: songData.source };
    }

    // 如果主音源失敗，嘗試備用音源
    if (!playableResult) {
        const fallbackSource = songData.source === 'netease' ? 'tencent' : 'netease';
        const fallbackResults = fallbackSource === 'tencent' 
            ? await searchTencentMusic(songData.name)
            : await searchNeteaseMusic(songData.name, songData.artist);

        if (fallbackResults.length > 0) {
            const fallbackApiUrl = fallbackSource === 'netease'
                ? `https://api.vkeys.cn/v2/music/netease?id=${fallbackResults[0].id}`
                : `https://api.vkeys.cn/v2/music/tencent?id=${fallbackResults[0].id}`;
            const fallbackResult = await Http_Get(fallbackApiUrl);
            if (fallbackResult?.data?.url && await checkAudioAvailability(fallbackResult.data.url)) {
                playableResult = { url: fallbackResult.data.url, id: fallbackResults[0].id, source: fallbackSource };
                finalSource = fallbackSource;
            }
        }
    }

    // 如果最終找到了可播放的連結
    if (playableResult) {
        const lrcContent = await getLyricsForSong(playableResult.id, finalSource) || "";
        return {
            name: songData.name,
            artist: songData.artist,
            src: playableResult.url,
            cover: songData.cover,
            isLocal: false,
            lrcContent: lrcContent
        };
    }

    // 如果所有嘗試都失敗了
    return null;
}

/**
 * 【V3.0 | 輔助】獲取網路歌曲的歌詞
 */
async function getLyricsForSong(songId, source) {
    const url = source === 'netease'
        ? `https://api.vkeys.cn/v2/music/netease/lyric?id=${songId}`
        : `https://api.vkeys.cn/v2/music/tencent/lyric?id=${songId}`;
    
    const response = await Http_Get(url);
    if (response?.data) {
        const lrc = response.data.lrc || response.data.lyric || "";
        const tlyric = response.data.trans || response.data.tlyric || "";
        return lrc + "\n" + tlyric;
    }
    return "";
}

async function handleManualLrcImport(trackIndex) {
    if (trackIndex < 0 || trackIndex >= musicState.playlist.length) return;

    const choice = await showChoiceModal('選擇歌詞導入方式', [
        { text: '📁 從本地檔 (.lrc)', value: 'file' },
        { text: '📋 直接黏貼歌詞文本', value: 'paste' }
    ]);

    let lrcContent = null;

    if (choice === 'file') {
        lrcContent = await new Promise(resolve => {
            const lrcInput = document.getElementById('lrc-upload-input');
            const lrcChangeHandler = e => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = readEvent => resolve(readEvent.target.result);
                    reader.onerror = () => resolve(null);
                    reader.readAsText(file);
                } else { resolve(null); }
                lrcInput.removeEventListener('change', lrcChangeHandler);
                lrcInput.value = '';
            };
            lrcInput.addEventListener('change', lrcChangeHandler, { once: true });
            lrcInput.click();
        });
    } else if (choice === 'paste') {
        const pastedText = await showCustomPrompt('黏貼歌詞', '請在此處黏貼完整的LRC格式歌詞...', '', 'textarea');
        if (pastedText) lrcContent = pastedText.replace(/\[/g, '\n[').trim();
    }

    if (lrcContent !== null) {
        musicState.playlist[trackIndex].lrcContent = lrcContent;

        // ▼▼▼ 【核心修復】在這裡添加下面這行代碼 ▼▼▼
        await saveGlobalPlaylist(); // 將更新後的播放清單保存到資料庫
        // ▲▲▲ 修復結束 ▲▲▲

        if (musicState.currentIndex === trackIndex) {
            musicState.parsedLyrics = parseLRC(lrcContent);
            renderLyrics();
            updateLyricsUI();
        }
        await showCustomAlert('成功', `《${musicState.playlist[trackIndex].name}》的歌詞已成功保存！`);
    }
}

/**
 * 【全新】切換當前播放歌曲的背景模糊效果
 */
async function toggleBackgroundBlur() {
    if (musicState.currentIndex === -1) return;

    const track = musicState.playlist[musicState.currentIndex];
    if (!track) return;

    // 切換狀態，如果之前是清晰的，就變為模糊，反之亦然
    track.isBgClear = !track.isBgClear;

    // 將這個新的設置保存到資料庫
    await saveGlobalPlaylist();

    // 更新UI
    const playerWindow = document.querySelector('.music-player-window');
    const toggleBtn = document.getElementById('toggle-blur-btn');
    
    playerWindow.classList.toggle('bg-clear', track.isBgClear);
    toggleBtn.classList.toggle('active', track.isBgClear);
}

/**
 * 【全新】切換音樂播放機全屏模式下的頭像顯示
 */
function toggleMusicPlayerAvatars() {
    const avatarDisplay = document.getElementById('music-player-avatar-display');
    const toggleBtn = document.getElementById('show-avatars-btn');
    if (avatarDisplay && toggleBtn) {
        avatarDisplay.classList.toggle('visible');
        toggleBtn.classList.toggle('active');
    }
}

/**
 * 【全新】切換音樂播放機的全屏/視窗模式
 */
function togglePlayerFullscreen() {
    const playerWindow = document.querySelector('.music-player-window');
    const overlay = document.getElementById('music-player-overlay');
    if (playerWindow && overlay) {
        // 核心邏輯：切換 fullscreen 和 fullscreen-active 這兩個類
        playerWindow.classList.toggle('fullscreen');
        overlay.classList.toggle('fullscreen-active');
    }
}
// 暴露到全域，以便在某些特殊情況下可以從外部調用
window.togglePlayerFullscreen = togglePlayerFullscreen;

/**
 * 【全新】清理音樂播放清單中的所有無效或無法播放的歌曲連結
 */
async function cleanupInvalidSongs() {
    if (musicState.playlist.length === 0) {
        alert("播放清單是空的，無需清理。");
        return;
    }

    const confirmed = await showCustomConfirm(
        '確認清理無效歌曲？',
        '此操作將檢查播放清單中的每一首網路歌曲，並移除所有無法播放的“死鏈”。本地歌曲不會受影響。',
        { confirmText: '開始清理' }
    );

    if (!confirmed) return;

    await showCustomAlert("請稍候...", `正在檢查 ${musicState.playlist.length} 首歌曲，這可能需要一些時間...`);

    const originalCount = musicState.playlist.length;
    const validPlaylist = [];
    const invalidSongs = [];

    const checkPromises = musicState.playlist.map(async (track) => {
        if (track.isLocal) {
            validPlaylist.push(track);
            return;
        }
        
        const isAvailable = await checkAudioAvailability(track.src);
        if (isAvailable) {
            validPlaylist.push(track);
        } else {
            invalidSongs.push(track.name);
            console.warn(`無效連結: ${track.name} - ${track.src}`);
        }
    });

    await Promise.all(checkPromises);

    const removedCount = originalCount - validPlaylist.length;

    if (removedCount > 0) {
        const currentPlayingTrack = musicState.playlist[musicState.currentIndex];
        const isCurrentTrackRemoved = invalidSongs.includes(currentPlayingTrack?.name);

        musicState.playlist = validPlaylist;
        await saveGlobalPlaylist();

        if (isCurrentTrackRemoved) {
            audioPlayer.pause();
            audioPlayer.src = '';
            musicState.currentIndex = musicState.playlist.length > 0 ? 0 : -1;
            musicState.isPlaying = false;
        } else if (currentPlayingTrack) {
            musicState.currentIndex = musicState.playlist.findIndex(t => t.src === currentPlayingTrack.src);
        }

        updatePlaylistUI();
        updatePlayerUI();

        await showCustomAlert("清理完成", `成功移除了 ${removedCount} 首無效歌曲:\n\n- ${invalidSongs.join('\n- ')}`);
    } else {
        await showCustomAlert("檢查完成", "所有歌曲連結均有效，無需清理！");
    }
}

// ▼▼▼ 【全新】這是應用狀態列顯示/隱藏設置的函數 ▼▼▼
/**
 * 根據全域設置，應用狀態列的可見性
 */
function applyStatusBarVisibility() {
    const phoneScreen = document.getElementById('phone-screen');
    // 如果設置為 true，就添加 class；否則就移除 class。
    phoneScreen.classList.toggle('status-bar-visible', !!state.globalSettings.showStatusBar);
}
// ▲▲▲ 新增函數結束 ▲▲▲
/**
 * 【全新 V3.0 | 總入口】打開支持勾選的清空動態選擇器
 */
async function openClearPostsSelectorModal() {
    const modal = document.getElementById('clear-posts-modal');
    const listEl = document.getElementById('clear-posts-list');
    listEl.innerHTML = ''; // 清空舊內容

    // 1. 創建所有選項
    const options = [];

    // 選項A: 清空所有
    options.push({ text: '清空所有動態 (危險)', value: 'all', isDanger: true });

    // 選項B: 清空用戶自己
    const myNickname = state.qzoneSettings.nickname || '我';
    options.push({ text: `僅清空 ${myNickname} 的動態`, value: 'user' });

    // 選項C: 遍歷AI角色
    Object.values(state.chats).forEach(chat => {
        if (!chat.isGroup) {
            options.push({ text: `僅清空 ${chat.name} 的動態`, value: chat.id });
        }
    });

    // 2. 將選項渲染到清單中
    options.forEach(opt => {
        const item = document.createElement('div');
        item.className = 'clear-posts-item';
        if (opt.isDanger) {
            item.classList.add('danger-option');
        }
        item.dataset.targetId = opt.value;
        item.innerHTML = `
            <div class="checkbox"></div>
            <span class="name">${opt.text}</span>
        `;
        listEl.appendChild(item);
    });
    
    // 3. 顯示模態框
    modal.classList.add('visible');
}

/**
 * 【全新 V3.0 | 核心處理器】處理最終的清空確認操作
 */
async function handleConfirmClearPosts() {
    const selectedItems = document.querySelectorAll('#clear-posts-list .clear-posts-item.selected');
    if (selectedItems.length === 0) {
        alert("請至少選擇一個要清空的範圍。");
        return;
    }

    const targetIds = Array.from(selectedItems).map(item => item.dataset.targetId);
    
    // --- 構建確認資訊 ---
    let targetNames = [];
    if (targetIds.includes('all')) {
        targetNames.push('所有動態');
    } else {
        if (targetIds.includes('user')) {
            targetNames.push(`“${state.qzoneSettings.nickname}”`);
        }
        targetIds.forEach(id => {
            const character = state.chats[id];
            if (character) {
                targetNames.push(`“${character.name}”`);
            }
        });
    }
    const confirmMessage = `此操作將永久刪除 ${targetNames.join('、 ')} 的所有動態，且無法恢復！`;

    const confirmed = await showCustomConfirm(
        '確認清空動態？',
        confirmMessage,
        { confirmButtonClass: 'btn-danger', confirmText: '確認清空' }
    );

    if (!confirmed) return;

    try {
        if (targetIds.includes('all')) {
            await db.qzonePosts.clear();
        } else {
            // 使用 Dexie 的 bulk-delete 功能，一次性高效刪除多個作者的動態
            await db.qzonePosts.where('authorId').anyOf(targetIds).delete();
        }

        // 同步更新記憶體緩存並重繪UI
        qzonePostsCache = await db.qzonePosts.orderBy('timestamp').reverse().toArray();
        qzonePostsRenderCount = 0;
        await renderQzonePosts();
        
        document.getElementById('clear-posts-modal').classList.remove('visible'); // 關閉選擇器
        await showCustomAlert('操作成功', '選定範圍內的動態已被清空。');

    } catch (error) {
        console.error("清空動態時出錯:", error);
        await showCustomAlert('操作失敗', `清空動態時發生錯誤: ${error.message}`);
    }
}
// ▼▼▼ 步驟 3：將這兩段全新的JS代碼，黏貼到 init() 函數的事件監聽器區域 ▼▼▼

/**
 * 【全新】刪除指定的心聲/散記記錄
 * @param {number} timestamp - 要刪除的記錄的時間戳記
 */
async function handleDeleteThought(timestamp) {
    const confirmed = await showCustomConfirm(
        '確認刪除',
        '確定要永久刪除這條心聲記錄嗎？此操作不可恢復。',
        { confirmButtonClass: 'btn-danger', confirmText: '確認刪除' }
    );

    if (confirmed) {
        const chat = state.chats[state.activeChatId];
        if (!chat || !chat.thoughtsHistory) return;

        // 從歷史記錄陣列中移除匹配的項
        chat.thoughtsHistory = chat.thoughtsHistory.filter(thought => thought.timestamp !== timestamp);
        
        // 將更新後的聊天資料保存回資料庫
        await db.chats.put(chat);
        
        // 重新渲染列表以反映更改
        renderThoughtsHistory();
        
        // 給出成功提示
        await showCustomAlert('成功', '該條記錄已成功刪除。');
    }
}

// 使用事件委託，為整個歷史記錄清單容器綁定點擊事件
document.getElementById('thoughts-history-list').addEventListener('click', (e) => {
    // 檢查被點擊的是否是刪除按鈕
    const deleteBtn = e.target.closest('.thought-delete-btn');
    if (deleteBtn) {
        // 從按鈕的 data-timestamp 屬性中獲取時間戳記
        const timestamp = parseInt(deleteBtn.dataset.timestamp);
        if (!isNaN(timestamp)) {
            // 調用刪除處理函數
            handleDeleteThought(timestamp);
        }
    }
});

// ▲▲▲ 新增JS代碼黏貼結束 ▲▲▲ 
        // ▼▼▼ 【全新】全域CSS預設功能核心函數 ▼▼▼
        
        /**
         * 從資料庫載入CSS預設，並填充到下拉選擇框中
         */
        async function loadCssPresetsDropdown() {
            const selectEl = document.getElementById('css-preset-select');
            selectEl.innerHTML = '<option value="">-- 選擇一個預設 --</option>';
            
            const presets = await db.appearancePresets.where('type').equals('global_css').toArray();
            presets.forEach(preset => {
                const option = document.createElement('option');
                option.value = preset.id;
                option.textContent = preset.name;
                selectEl.appendChild(option);
            });
        }
        
        /**
         * 當用戶從下拉清單選擇一個CSS預設時，載入該預設
         */
        async function handleCssPresetSelectionChange() {
            const selectEl = document.getElementById('css-preset-select');
            const selectedId = parseInt(selectEl.value);
            if (isNaN(selectedId)) return;
        
            const preset = await db.appearancePresets.get(selectedId);
            if (preset) {
                const cssInput = document.getElementById('global-css-input');
                cssInput.value = preset.value;
                applyGlobalCss(preset.value); // 即時預覽
            }
        }
        
        /**
         * 將當前輸入框中的CSS保存為一個新的預設
         */
        async function saveCssPreset() {
            const name = await showCustomPrompt('保存CSS預設', '請輸入預設名稱');
            if (!name || !name.trim()) return;
        
            const cssValue = document.getElementById('global-css-input').value;
        
            const existingPreset = await db.appearancePresets.where({ name: name.trim(), type: 'global_css' }).first();
            if (existingPreset) {
                const confirmed = await showCustomConfirm('覆蓋預設', `名為 “${name.trim()}” 的預設已存在。要覆蓋它嗎？`, { confirmButtonClass: 'btn-danger' });
                if (!confirmed) return;
                
                await db.appearancePresets.update(existingPreset.id, { value: cssValue });
            } else {
                await db.appearancePresets.add({
                    name: name.trim(),
                    type: 'global_css',
                    value: cssValue
                });
            }
        
            await loadCssPresetsDropdown(); // 刷新下拉清單
            alert('CSS 預設已保存！');
        }
        
        /**
         * 刪除當前選中的CSS預設
         */
        async function deleteCssPreset() {
            const selectEl = document.getElementById('css-preset-select');
            const selectedId = parseInt(selectEl.value);
        
            if (isNaN(selectedId)) {
                alert('請先從下拉清單中選擇一個要刪除的預設。');
                return;
            }
        
            const preset = await db.appearancePresets.get(selectedId);
            if (!preset) return;
        
            const confirmed = await showCustomConfirm('刪除預設', `確定要刪除預設 “${preset.name}” 嗎？`, { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                await db.appearancePresets.delete(selectedId);
                await loadCssPresetsDropdown(); // 刷新下拉清單
                alert('預設已刪除。');
            }
        }
        // ▲▲▲ 新增函數結束 ▲▲▲
        // ▼▼▼ 【全新】字體預設功能核心函數 ▼▼▼

        /**
         * 從資料庫載入字體預設，並填充到下拉選擇框中
         */
        async function loadFontPresetsDropdown() {
            const selectEl = document.getElementById('font-preset-select');
            selectEl.innerHTML = '<option value="">-- 選擇一個預設 --</option>';
            
            const presets = await db.appearancePresets.where('type').equals('font').toArray();
            presets.forEach(preset => {
                const option = document.createElement('option');
                option.value = preset.id;
                option.textContent = preset.name;
                selectEl.appendChild(option);
            });
        }

        /**
         * 當使用者從下拉清單選擇一個字體預設時，載入該預設
         */
        async function handleFontPresetSelectionChange() {
            const selectEl = document.getElementById('font-preset-select');
            const selectedId = parseInt(selectEl.value);
            if (isNaN(selectedId)) return;
        
            const preset = await db.appearancePresets.get(selectedId);
            if (preset) {
                const fontUrlInput = document.getElementById('font-url-input');
                fontUrlInput.value = preset.value;
                applyCustomFont(preset.value, true); // 即時預覽
            }
        }
        
        /**
         * 將當前輸入框中的字體URL保存為一個新的預設
         */
        async function saveFontPreset() {
            const name = await showCustomPrompt('保存字體預設', '請輸入預設名稱');
            if (!name || !name.trim()) return;
        
            const fontUrl = document.getElementById('font-url-input').value.trim();
            if (!fontUrl) {
                alert("字體URL不能為空！");
                return;
            }
        
            const existingPreset = await db.appearancePresets.where({ name: name.trim(), type: 'font' }).first();
            if (existingPreset) {
                const confirmed = await showCustomConfirm('覆蓋預設', `名為 “${name.trim()}” 的預設已存在。要覆蓋它嗎？`, { confirmButtonClass: 'btn-danger' });
                if (!confirmed) return;
                
                await db.appearancePresets.update(existingPreset.id, { value: fontUrl });
            } else {
                await db.appearancePresets.add({
                    name: name.trim(),
                    type: 'font',
                    value: fontUrl
                });
            }
        
            await loadFontPresetsDropdown();
            alert('字體預設已保存！');
        }
        
        /**
         * 刪除當前選中的字體預設
         */
        async function deleteFontPreset() {
            const selectEl = document.getElementById('font-preset-select');
            const selectedId = parseInt(selectEl.value);
        
            if (isNaN(selectedId)) {
                alert('請先從下拉清單中選擇一個要刪除的預設。');
                return;
            }
        
            const preset = await db.appearancePresets.get(selectedId);
            if (!preset) return;
        
            const confirmed = await showCustomConfirm('刪除預設', `確定要刪除預設 “${preset.name}” 嗎？`, { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                await db.appearancePresets.delete(selectedId);
                await loadFontPresetsDropdown();
                alert('預設已刪除。');
            }
        }
        // ▲▲▲ 新增函數結束 ▲▲▲
// ▼▼▼ 【全新】外觀預設功能核心函數 ▼▼▼

/**
 * 從資料庫載入外觀預設，並填充到下拉選擇框中
 */
async function loadAppearancePresetsDropdown() {
    const selectEl = document.getElementById('appearance-preset-select');
    selectEl.innerHTML = '<option value="">-- 選擇一個預設 --</option>';
    
    // 從資料庫中只查找類型為 'appearance' 的預設
    const presets = await db.appearancePresets.where('type').equals('appearance').toArray();
    presets.forEach(preset => {
        const option = document.createElement('option');
        option.value = preset.id;
        option.textContent = preset.name;
        selectEl.appendChild(option);
    });
}

/**
 * 當用戶從下拉清單選擇一個外觀預設時，載入並應用該預設
 */
async function handleAppearancePresetSelectionChange() {
    const selectEl = document.getElementById('appearance-preset-select');
    const selectedId = parseInt(selectEl.value);
    if (isNaN(selectedId)) return;

    const preset = await db.appearancePresets.get(selectedId);
    if (preset && preset.value) {
        const data = preset.value;
        
        // 1. 將載入的設置應用到全域狀態
        Object.assign(state.globalSettings, data);
        
        // 2. 單獨應用主題模式，因為它存儲在localStorage中
        applyTheme(data.theme || 'light');
        
        // 3. 將更新後的全域設置存回資料庫
        await db.globalSettings.put(state.globalSettings);
        
        // 4. 調用所有相關的UI更新函數，使更改立即生效
        applyGlobalWallpaper();
        applyCPhoneWallpaper();
        applyAppIcons();
        applyCPhoneAppIcons();
        applyStatusBarVisibility();
        applyWidgetData();
        
        // 5. 重新渲染整個外觀設置頁面，以反映所有載入的新值
        renderWallpaperScreen();

        alert(`已成功載入外觀預設：“${preset.name}”`);
    }
}

/**
 * 將當前的所有外觀設置保存為一個新的預設
 */
async function saveAppearancePreset() {
    const name = await showCustomPrompt('保存外觀預設', '請輸入預設名稱');
    if (!name || !name.trim()) return;

    // 1. 從 state 和 localStorage 中收集所有相關的外觀設置
    const appearanceData = {
        wallpaper: state.globalSettings.wallpaper,
        cphoneWallpaper: state.globalSettings.cphoneWallpaper,
        globalChatBackground: state.globalSettings.globalChatBackground,
        appIcons: state.globalSettings.appIcons,
        cphoneAppIcons: state.globalSettings.cphoneAppIcons,
        chatActionButtonsOrder: state.globalSettings.chatActionButtonsOrder,
        theme: localStorage.getItem('ephone-theme') || 'light',
        showStatusBar: state.globalSettings.showStatusBar,
        notificationSoundUrl: state.globalSettings.notificationSoundUrl,
        widgetData: state.globalSettings.widgetData
    };

    // 2. 檢查是否存在同名預設
    const existingPreset = await db.appearancePresets.where({ name: name.trim(), type: 'appearance' }).first();
    if (existingPreset) {
        const confirmed = await showCustomConfirm('覆蓋預設', `名為 “${name.trim()}” 的預設已存在。要覆蓋它嗎？`, { confirmButtonClass: 'btn-danger' });
        if (!confirmed) return;
        
        await db.appearancePresets.update(existingPreset.id, { value: appearanceData });
    } else {
        await db.appearancePresets.add({
            name: name.trim(),
            type: 'appearance', // 關鍵：類型為 'appearance'
            value: appearanceData
        });
    }

    // 3. 刷新下拉清單並提示成功
    await loadAppearancePresetsDropdown();
    alert('外觀預設已保存！');
}

/**
 * 刪除當前選中的外觀預設
 */
async function deleteAppearancePreset() {
    const selectEl = document.getElementById('appearance-preset-select');
    const selectedId = parseInt(selectEl.value);

    if (isNaN(selectedId)) {
        alert('請先從下拉清單中選擇一個要刪除的預設。');
        return;
    }

    const preset = await db.appearancePresets.get(selectedId);
    if (!preset) return;

    const confirmed = await showCustomConfirm('刪除預設', `確定要刪除預設 “${preset.name}” 嗎？`, { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        await db.appearancePresets.delete(selectedId);
        await loadAppearancePresetsDropdown();
        alert('預設已刪除。');
    }
}
// ▲▲▲ 新增函數結束 ▲▲▲
        // ▼▼▼ 【全新】氣泡主題預設功能核心函數 ▼▼▼

        /**
         * 從資料庫載入氣泡主題預設，並填充到下拉選擇框中
         */
        async function loadThemePresetsDropdown() {
            const selectEl = document.getElementById('theme-preset-select');
            selectEl.innerHTML = '<option value="">-- 選擇一個預設 --</option>';
            
            const presets = await db.appearancePresets.where('type').equals('bubble_theme').toArray();
            presets.forEach(preset => {
                const option = document.createElement('option');
                option.value = preset.id;
                option.textContent = preset.name;
                selectEl.appendChild(option);
            });
        }

/**
         * 當使用者從下拉清單選擇一個主題預設時，載入該預設
         */
        async function handleThemePresetSelectionChange() {
            const selectEl = document.getElementById('theme-preset-select');
            const selectedId = parseInt(selectEl.value);
            if (isNaN(selectedId)) return;
        
            const preset = await db.appearancePresets.get(selectedId);
            if (preset) {
                // ▼▼▼ 核心修改 ▼▼▼
                // 1. 從保存的物件中分別獲取基礎主題和自訂CSS
                const baseTheme = preset.value.base || 'default';
                const customCss = preset.value.custom || '';

                // 2. 應用基礎主題（勾選對應的單選框）
                const themeRadio = document.querySelector(`input[name="theme-select"][value="${baseTheme}"]`);
                if (themeRadio) {
                    themeRadio.checked = true;
                }

                // 3. 將保存的CSS載入回輸入框
                const customCssInput = document.getElementById('custom-css-input');
                customCssInput.value = customCss;

                // 4. 立刻刷新預覽區，讓效果顯示出來
                updateSettingsPreview(); 
                // ▲▲▲ 修改結束 ▲▲▲
            }
        }
        
 /**
         * 將當前選擇的氣泡主題保存為一個新的預設
         */
        async function saveThemePreset() {
            const name = await showCustomPrompt('保存主題預設', '請輸入預設名稱');
            if (!name || !name.trim()) return;
        
            // ▼▼▼ 核心修改 ▼▼▼
            // 1. 獲取基礎主題的選擇
            const selectedThemeRadio = document.querySelector('input[name="theme-select"]:checked');
            const themeValue = selectedThemeRadio ? selectedThemeRadio.value : 'default';

            // 2. 獲取自訂CSS的內容
            const cssValue = document.getElementById('custom-css-input').value.trim();

            // 3. 將基礎主題和自訂CSS打包成一個物件進行保存
            const presetValueObject = {
                base: themeValue,
                custom: cssValue
            };
            // ▲▲▲ 修改結束 ▲▲▲
        
            const existingPreset = await db.appearancePresets.where({ name: name.trim(), type: 'bubble_theme' }).first();
            if (existingPreset) {
                const confirmed = await showCustomConfirm('覆蓋預設', `名為 “${name.trim()}” 的預設已存在。要覆蓋它嗎？`, { confirmButtonClass: 'btn-danger' });
                if (!confirmed) return;
                
                // 保存打包後的對象
                await db.appearancePresets.update(existingPreset.id, { value: presetValueObject });
            } else {
                await db.appearancePresets.add({
                    name: name.trim(),
                    type: 'bubble_theme',
                    // 保存打包後的對象
                    value: presetValueObject
                });
            }
        
            await loadThemePresetsDropdown();
            alert('主題預設已保存！');
        }
        
        /**
         * 刪除當前選中的主題預設
         */
        async function deleteThemePreset() {
            const selectEl = document.getElementById('theme-preset-select');
            const selectedId = parseInt(selectEl.value);
        
            if (isNaN(selectedId)) {
                alert('請先從下拉清單中選擇一個要刪除的預設。');
                return;
            }
        
            const preset = await db.appearancePresets.get(selectedId);
            if (!preset) return;
        
            const confirmed = await showCustomConfirm('刪除預設', `確定要刪除預設 “${preset.name}” 嗎？`, { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                await db.appearancePresets.delete(selectedId);
                await loadThemePresetsDropdown();
                alert('預設已刪除。');
            }
        }
        // ▲▲▲ 新增函數結束 ▲▲▲
        // ▼▼▼ 【全新】這是表情包分類功能的【全部核心JS代碼】，請完整黏貼 ▼▼▼
        
        /**
         * 【總入口】打開分類管理彈窗
         */
        async function openStickerCategoryManager() {
            await renderStickerCategoriesInManager();
            document.getElementById('sticker-category-manager-modal').classList.add('visible');
        }
        
        /**
         * 在彈窗中渲染已存在的分類列表
         */
        async function renderStickerCategoriesInManager() {
            const listEl = document.getElementById('existing-sticker-categories-list');
            const categories = await db.stickerCategories.toArray();
            listEl.innerHTML = '';
            if (categories.length === 0) {
                listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">還沒有任何分類</p>';
                return;
            }
            categories.forEach(cat => {
                const item = document.createElement('div');
                item.className = 'existing-group-item'; // 複用已有樣式
                item.innerHTML = `
                    <span class="group-name">${cat.name}</span>
                    <span class="delete-group-btn" data-id="${cat.id}">×</span>
                `;
                listEl.appendChild(item);
            });
        }
        
        /**
         * 添加一個新的表情分類
         */
        async function addNewStickerCategory() {
            const input = document.getElementById('new-sticker-category-name-input');
            const name = input.value.trim();
            if (!name) {
                alert('分類名不能為空！');
                return;
            }
            const existing = await db.stickerCategories.where('name').equals(name).first();
            if (existing) {
                alert(`分類 "${name}" 已經存在了！`);
                return;
            }
            await db.stickerCategories.add({ name });
            input.value = '';
            await renderStickerCategoriesInManager();
        }
        
        /**
         * 【核心】刪除一個分類，並一併刪除該分類下的所有表情包
         * @param {number} categoryId - 要刪除的分類的ID
         */
        async function deleteStickerCategory(categoryId) {
            const category = await db.stickerCategories.get(categoryId);
            if (!category) return;

            const stickersInCateogry = await db.userStickers.where('categoryId').equals(categoryId).count();
            
            const confirmMessage = stickersInCateogry > 0 
                ? `確定要刪除分類《${category.name}》嗎？\n\n【【【警告】】】\n此操作將同時永久刪除該分類下的 ${stickersInCateogry} 個表情包，且無法恢復！`
                : `確定要刪除分類《${category.name}》嗎？`;

            const confirmed = await showCustomConfirm(
                '確認刪除分類', 
                confirmMessage, 
                { confirmButtonClass: 'btn-danger' }
            );

            if (confirmed) {
                try {
                    // 使用事務確保操作的原子性
                    await db.transaction('rw', db.stickerCategories, db.userStickers, async () => {
                        // 1. 找到該分類下所有表情的ID
                        const stickerIdsToDelete = await db.userStickers.where('categoryId').equals(categoryId).primaryKeys();
                        
                        // 2. 批量刪除這些表情
                        if (stickerIdsToDelete.length > 0) {
                            await db.userStickers.bulkDelete(stickerIdsToDelete);
                        }

                        // 3. 刪除分類本身
                        await db.stickerCategories.delete(categoryId);
                    });

                    // 更新前端 state 和 UI
                    state.userStickers = await db.userStickers.toArray();
                    if (activeStickerCategoryId === categoryId) {
                        activeStickerCategoryId = 'all'; // 如果刪除的是當前分類，就切回“全部”
                    }
                    await renderStickerCategoriesInManager(); // 刷新管理列表
                    await renderStickerPanel(); // 刷新主面板
                    
                    alert(`分類《${category.name}》及其下的表情已成功刪除。`);

                } catch (error) {
                    console.error("刪除分類及表情時出錯:", error);
                    alert("刪除失敗，請查看控制台錯誤資訊。");
                }
            }
        }

// ▼▼▼ 請用這個新版本替換舊的 switchStickerCategory 函數 ▼▼▼
        function switchStickerCategory(categoryId) {
            activeStickerCategoryId = categoryId;
            document.querySelectorAll('.sticker-category-tab').forEach(tab => {
                tab.classList.toggle('active', String(tab.dataset.categoryId) === String(categoryId));
            });
            renderStickerPanel(false);
            
            // 【核心新增】切換分類時，重置全選框的狀態
            const selectAllCheckbox = document.getElementById('select-all-stickers-checkbox');
            if(selectAllCheckbox) selectAllCheckbox.checked = false;
        }
        // ▲▲▲ 替換結束 ▲▲▲
/**
 * 【全新】僅匯出當前單個聊天的備份
 */
async function exportSingleChat() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    try {
        const backupData = {
            type: 'EPhoneSingleChat', // 特殊標記，用於導入時驗證
            version: 1,
            chatData: chat
        };

        const blob = new Blob(
            [JSON.stringify(backupData, null, 2)], 
            { type: 'application/json' }
        );
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        // 檔案名將使用角色的備註名
        link.download = `EPhone-Chat-${chat.name}-${new Date().toISOString().split('T')[0]}.json`;
        link.click();
        URL.revokeObjectURL(url);
        
        await showCustomAlert('匯出成功', `與“${chat.name}”的聊天記錄已成功匯出！`);

    } catch (error) {
        console.error("匯出單個聊天時出錯:", error);
        await showCustomAlert('匯出失敗', `發生了一個錯誤: ${error.message}`);
    }
}

/**
 * 【全新】將單個聊天的備份導入並覆蓋當前聊天
 * @param {File} file - 用戶選擇的 .json 備份檔案
 */
async function importSingleChat(file) {
    if (!file || !state.activeChatId) return;
    const currentChatId = state.activeChatId;
    const currentChat = state.chats[currentChatId];

    try {
        const text = await file.text();
        const data = JSON.parse(text);

        // 1. 驗證檔案格式
        if (data.type !== 'EPhoneSingleChat' || !data.chatData) {
            throw new Error("檔案格式不正確，這不是一個有效的單聊備份檔案。");
        }

        // 2. 彈出最終警告
        const confirmed = await showCustomConfirm(
            '嚴重警告！',
            `這將用備份檔案中的資料【完全覆蓋】當前與“${currentChat.name}”的聊天記錄和設置。此操作不可撤銷！<br><br><strong>確定要繼續嗎？</strong>`,
            { confirmButtonClass: 'btn-danger', confirmText: '確認覆蓋' }
        );

        if (!confirmed) return;

        // 3. 執行覆蓋操作
        const importedChatData = data.chatData;
        
        // 保持當前的ID不變，只用導入的資料覆蓋內容
        importedChatData.id = currentChatId; 
        
        // 更新資料庫和記憶體狀態
        await db.chats.put(importedChatData);
        state.chats[currentChatId] = importedChatData;

        // 4. 成功提示並刷新
        await showCustomAlert('導入成功', '聊天記錄已成功覆蓋！正在刷新介面...');
        
        // 刷新UI
        renderChatInterface(currentChatId);
        renderChatList();
        document.getElementById('chat-settings-btn').click(); // 重新打開設置以顯示最新資料

    } catch (error) {
        console.error("導入單個聊天時出錯:", error);
        await showCustomAlert('導入失敗', `文件解析或應用失敗: ${error.message}`);
    }
}
// ▼▼▼ 【全新】Cphone功能的所有核心JS代碼 ▼▼▼

/**
 * 【總入口】打開角色選擇介面
 */
function openCharacterSelector() {
    renderCharacterSelector();
    showScreen('character-selection-screen');
}

/**
 * 渲染角色選擇列表
 */
function renderCharacterSelector() {
    const gridEl = document.getElementById('character-grid');
    gridEl.innerHTML = '';
    
    // 只篩選出單聊角色
    const characters = Object.values(state.chats).filter(chat => !chat.isGroup);

    if (characters.length === 0) {
        gridEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">還沒有可以查看手機的角色哦~</p>';
        return;
    }

    characters.forEach(char => {
        const item = document.createElement('div');
        item.className = 'character-select-item';
        item.innerHTML = `
            <img src="${char.settings.aiAvatar || defaultAvatar}" class="avatar">
            <span class="name">${char.name}</span>
        `;
        item.addEventListener('click', () => switchToCharacterPhone(char.id));
        gridEl.appendChild(item);
    });
}

        // ▼▼▼ 【請用這個已更新的版本】替換舊的 switchToCharacterPhone 函數 ▼▼▼
        /**
         * 切換到指定角色的手機介面
         * @param {string} characterId - 角色的ID
         */
        async function switchToCharacterPhone(characterId) {
            activeCharacterId = characterId;
            console.log(`已切換到角色 ${characterId} 的手機`);
            
            // 【核心修改】調用新的應用函數來設置壁紙和圖示
            applyCPhoneWallpaper();
            applyCPhoneAppIcons();
            
            // 渲染並顯示Cphone的主螢幕
            renderCharHomeScreen();
            showScreen('character-phone-screen');
        }
        // ▲▲▲ 替換結束 ▲▲▲

/**
 * 返回到使用者自己的手機主螢幕
 */
function switchToMyPhone() {
    activeCharacterId = null;
    console.log("已返回我的手機");
    showScreen('home-screen');
}

/**
 * 渲染Cphone的主螢幕（主要是更新時鐘）
 */
function renderCharHomeScreen() {
    const now = new Date();
    const timeString = now.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
    const dateString = now.toLocaleDateString('zh-CN', { weekday: 'long', month: 'long', day: 'numeric' });
    document.getElementById('char-main-time').textContent = timeString;
    document.getElementById('char-main-date').textContent = dateString;
    switchToCharScreen('char-home-screen');
}

/**
 * 在Cphone內部切換不同的App螢幕
 * @param {string} screenId - 要顯示的角色App螢幕ID
 */
function switchToCharScreen(screenId) {
    document.querySelectorAll('.char-screen').forEach(s => s.classList.remove('active'));
    document.getElementById(screenId).classList.add('active');
}
// ▼▼▼ 【核心修復】將此函數暴露到全域，讓onclick可以調用 ▼▼▼
window.switchToCharScreen = switchToCharScreen;
// ▲▲▲ 修復結束 ▲▲▲

// ▼▼▼ 【V3.0 | 最終版】請用這個全新的函數，完整替換舊的 openCharApp ▼▼▼
         /**
         * 【總分發 | V3.0 | 最終修復版 | 已添加音樂App】打開Cphone內的App
         * @param {string} appName - App的簡稱 (qq, album, amap...)
         */
        async function openCharApp(appName) {
            if (!activeCharacterId) return;
            const char = state.chats[activeCharacterId];
            
    // ▼▼▼ 核心修改：在打開App前記錄使用日誌 ▼▼▼
    await logAppUsage(activeCharacterId, appName);
    // ▲▲▲ 修改結束 ▲▲▲

            switch(appName) {
                case 'qq':
                    renderCharSimulatedQQ();
                    switchToCharScreen('char-qq-screen');
                    break;
                case 'album':
                    renderCharAlbum();
                    switchToCharScreen('char-album-screen');
                    break;
                case 'browser':
                    renderCharBrowserHistory();
                    switchToCharScreen('char-browser-screen');
                    break;
                case 'taobao':
                    renderCharTaobao();
                    switchToCharScreen('char-taobao-screen');
                    break;
                case 'memo':
                    renderCharMemoList();
                    switchToCharScreen('char-memo-screen');
                    break;
                case 'diary':
                    renderCharDiaryList();
                    switchToCharScreen('char-diary-screen');
                    break;
                case 'amap':
                    renderCharAmap();
                    switchToCharScreen('char-amap-screen');
                    break;
                
                // ▼▼▼ 【核心修復就在這裡！】 ▼▼▼
                // 我們現在添加了對 'music' 的處理邏輯
                case 'music':
                    renderCharMusicScreen(); // 渲染網易雲音樂清單
                    switchToCharScreen('char-music-screen'); // 顯示網易雲音樂螢幕
                    break;
                // ▲▲▲ 修復結束 ▲▲▲

                case 'usage':
                    renderCharAppUsage();
                    switchToCharScreen('char-usage-screen');
                    break;
            }
        }
        // ▼▼▼ 【V3.2 | 描述顯示版】請用這個全新的函數，完整替換舊的 renderCharAlbum 函數 ▼▼▼
        /**
         * 【全新 | V3.2 終極防空窗+生圖開關+描述顯示版】渲染角色相冊
         */
        async function renderCharAlbum() {
            const gridEl = document.getElementById('char-album-grid');
            gridEl.innerHTML = '';
            if (!activeCharacterId) return;
            const char = state.chats[activeCharacterId];
        
            const photos = char.simulatedAlbum || [];
        
            if (photos.length === 0) {
                gridEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">TA的相冊還是空的，<br>點擊右上角刷新按鈕生成一些照片吧！</p>';
                return;
            }
        
            const fallbackImageUrl = `https://i.postimg.cc/KYr2qRCK/1.jpg`;

            photos.forEach(photo => {
                const item = document.createElement('div');
                item.className = 'char-photo-item';
                item.dataset.description = photo.description;
                gridEl.appendChild(item);

                
                // 1. 檢查全域的生圖開關是否開啟
                if (state.globalSettings.enableAiDrawing) {
                    // --- 如果開關【開啟】，執行原來的生圖邏輯 ---
                    item.style.backgroundColor = '#e9ecef';
                    const containsNonEnglish = /[^\x00-\x7F]/.test(photo.image_prompt);
                    const isValidPrompt = photo.image_prompt && photo.image_prompt.trim() && !containsNonEnglish;
                    const finalPrompt = isValidPrompt ? photo.image_prompt : 'a beautiful scenery, anime style, cinematic lighting';
                    const imageUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(finalPrompt)}`;
                    
                    const img = new Image();
                    img.onload = function() { item.style.backgroundImage = `url(${this.src})`; };
                    img.onerror = function() { item.style.backgroundImage = `url(${fallbackImageUrl})`; };
                    img.src = imageUrl;

                } else {
                    // --- 如果開關【關閉】，則直接顯示描述文字！ ---
                    item.style.backgroundColor = '#f0f2f5'; // 給一個淡淡的背景色
                    item.style.border = '1px solid #e0e0e0'; // 加一個細邊框，更有卡片感
                    
                    // 創建一個新的 <p> 元素來存放描述
                    const descriptionEl = document.createElement('p');
                    descriptionEl.className = 'char-photo-description'; // 應用我們剛剛添加的CSS樣式
                    descriptionEl.textContent = photo.description || '(這張照片沒有描述)'; // 顯示描述，如果沒有則顯示提示
                    
                    // 將描述元素添加到格子裡
                    item.appendChild(descriptionEl);
                }
       
            });
        }
        // ▲▲▲ 替換結束 ▲▲▲

/**
 * 【全新】動態生成並渲染角色的流覽器歷史記錄
 */
function renderCharBrowserHistory() {
    const listEl = document.getElementById('char-browser-history');
    listEl.innerHTML = '';
    if (!activeCharacterId) return;

    const char = state.chats[activeCharacterId];
    // 這裡我們基於角色的名字和人設，動態生成一些看起來合理的歷史記錄
    const historyKeywords = [char.name, "愛好", "旅遊", "美食", "新聞", ...char.settings.aiPersona.split(/，|。|\s/).slice(0, 5)];
    const historySites = ["知乎", "Bilibili", "小紅書", "微博", "維琪百科"];

    for (let i = 0; i < 15; i++) {
        const keyword = historyKeywords[Math.floor(Math.random() * historyKeywords.length)];
        const site = historySites[Math.floor(Math.random() * historySites.length)];
        const item = document.createElement('div');
        item.className = 'char-browser-item';
        item.innerHTML = `
            <div class="title">${keyword} - ${site}</div>
            <div class="url">www.${site.toLowerCase()}.com/${keyword}</div>
        `;
        listEl.appendChild(item);
    }
}

        // ▼▼▼ 【V3.1 | 生圖開關+描述顯示+狀態顯示版】請用這個全新的函數，完整替換舊的 renderCharTaobao ▼▼▼
        /**
         * 【全新 | V3.1 無錢包版 | 最終修復】渲染角色的淘寶“購買記錄”頁面
         */
        function renderCharTaobao() {
            const gridEl = document.getElementById('char-product-grid');
            gridEl.innerHTML = '';
            if (!activeCharacterId) return;

            const char = state.chats[activeCharacterId];
            const purchases = char.simulatedTaobaoHistory?.purchases || [];

            if (purchases.length === 0) {
                gridEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">TA最近好像什麼都沒買呢，<br>點擊右上角刷新按鈕生成一些記錄吧！</p>';
                return;
            }

            purchases.forEach(item => {
                const itemEl = document.createElement('div');
                itemEl.className = 'char-product-item';
                itemEl.dataset.reason = item.reason;
                
                let imageOrTextHtml;
                if (state.globalSettings.enableAiDrawing) {
                    const imageUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(item.image_prompt || 'a random product')}`;
                    imageOrTextHtml = `<img src="${imageUrl}" class="product-image">`;
                } else {
                    imageOrTextHtml = `
                        <div class="char-product-description-overlay">
                            <p class="char-photo-description">${item.reason || '(無購買理由)'}</p>
                        </div>
                    `;
                }

                // ▼▼▼ 核心修改：在這裡添加了 item.status 的顯示 ▼▼▼
                itemEl.innerHTML = `
                    ${imageOrTextHtml}
                    <div class="product-info">
                        <div class="product-name">${item.itemName}</div>
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 8px;">
                            <div class="product-price">${(item.price || 0).toFixed(2)}</div>
                            <div class="char-product-status">${item.status}</div>
                        </div>
                    </div>
                `;
                // ▲▲▲ 修改結束 ▲▲▲
                gridEl.appendChild(itemEl);
            });
        }
/**
 * 切換回Cphone的主螢幕
 */
function switchToCharHomeScreen() {
    switchToCharScreen('char-home-screen');
}


// --- CphoneApp的具體功能 ---

/**
 * 渲染角色視角的QQ聊天清單 (簡化版)
 */
function renderCharChatList() {
    const listEl = document.getElementById('char-chat-list');
    listEl.innerHTML = '';
    if (!activeCharacterId) return;

    // 找出所有與該角色相關的聊天
    const relatedChats = Object.values(state.chats).filter(chat => {
        // 條件1: 與用戶的單聊
        if (chat.id === activeCharacterId) return true;
        // 條件2: 角色所在的群聊
        if (chat.isGroup && chat.members.some(m => m.id === activeCharacterId)) return true;
        return false;
    });

    relatedChats.forEach(chat => {
        const item = createChatListItem(chat); // 複用主清單的渲染函數
        listEl.appendChild(item);
    });
}

/**
 * 記錄App使用日誌
 */
async function logAppUsage(characterId, appName) {
    const char = state.chats[characterId];
    if (!char) return;
    if (!char.appUsageLog) {
        char.appUsageLog = [];
    }
    char.appUsageLog.push({
        appName: appName,
        timestamp: Date.now()
    });
    // 保留最近50條記錄
    if (char.appUsageLog.length > 50) {
        char.appUsageLog.shift();
    }
    await db.chats.put(char);
}

/**
 * 渲染App使用記錄
 */
function renderCharAppUsage() {
    const listEl = document.getElementById('char-usage-list');
    listEl.innerHTML = '';
    const char = state.chats[activeCharacterId];
    const log = (char.appUsageLog || []).slice().reverse(); // 從新到舊顯示

    if (log.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">還沒有任何使用記錄。</p>';
        return;
    }

    const appNameMap = {
        'qq': 'QQ', 'album': '相冊', 'browser': '流覽器', 'taobao': '淘寶',
        'memo': '備忘錄', 'diary': '日記', 'amap': '高德地圖', 'usage': 'App記錄'
    };

    log.forEach(entry => {
        const item = document.createElement('div');
        item.className = 'usage-item';
        item.innerHTML = `
            <div class="timestamp">${new Date(entry.timestamp).toLocaleString()}</div>
            <div class="action">打開了 <strong>${appNameMap[entry.appName] || entry.appName}</strong></div>
        `;
        listEl.appendChild(item);
    });
}

/**
 * 模擬角色發送位置分享
 */
async function sendCharLocationShare(locationName) {
    const userChat = state.chats[activeCharacterId]; // 獲取與該角色的單聊
    if (!userChat) return;

    const msg = {
        role: 'assistant', // 是AI（角色）發出的
        senderName: userChat.originalName,
        type: 'location_share',
        content: locationName,
        imageUrl: 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1756262526935_qdqqd_4uque3.jpeg',
        timestamp: Date.now()
    };

    userChat.history.push(msg);
    await db.chats.put(userChat);
    
    // 如果當前正與該角色聊天，則即時顯示
    if (state.activeChatId === activeCharacterId) {
        appendMessage(msg, userChat);
    }
    
    await showCustomAlert("分享成功", `“${userChat.name}” 的位置已發送到你們的聊天中。`);
}


/**
 * 【V2.1 | 全屏查看最終版】點擊備忘錄列表項時，打開詳情頁面查看其內容
 * @param {number} memoId - 要查看的備忘錄的ID
 */
async function viewMemo(memoId) {
    const char = state.chats[activeCharacterId];
    if (!char || !char.memos) return;

    const memo = char.memos.find(m => m.id === memoId);
    if (memo) {
        // 1. 【核心修復】現在我們直接通過ID查找標題和內容元素
        const titleEl = document.getElementById('char-memo-detail-title');
        const contentEl = document.getElementById('char-memo-detail-content');

        // 2. 將備忘錄的資料填充進去
        if (titleEl) titleEl.textContent = memo.title;
        if (contentEl) contentEl.value = memo.content;

        // 3. 切換到新的詳情頁螢幕
        switchToCharScreen('char-memo-detail-screen');
    }
}

/**
 * 【V2.0 | 支持標題】渲染Cphone的備忘錄列表
 */
function renderCharMemoList() {
    const listEl = document.getElementById('char-memo-list');
    listEl.innerHTML = '';
    const char = state.chats[activeCharacterId];
    const memos = (char.memos || []).slice().reverse();

    if (memos.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">還沒有備忘錄。</p>';
        return;
    }

    memos.forEach(memo => {
        const item = document.createElement('div');
        // 複用現有的 list-item 樣式，美觀且統一
        item.className = 'list-item'; 
        item.innerHTML = `
            <div class="item-title">${memo.title}</div>
            <div class="item-content">${(memo.content || '').split('\n')[0]}</div>
        `;
        // 【核心修改】點擊列表項現在是調用 viewMemo 查看函數
        item.addEventListener('click', () => viewMemo(memo.id));
        addLongPressListener(item, () => deleteMemo(memo.id));
        listEl.appendChild(item);
    });
}

/**
 * 【V2.1 | 流程修正】打開編輯器以創建新的備忘錄
 */
async function openMemoEditor(memoId = null) {
    editingMemoId = null; 
    
    // （這部分邏輯與之前相同）
    const newTitle = await showCustomPrompt("新建備忘錄", "請輸入標題");
    if (newTitle === null || !newTitle.trim()) return;

    const newContent = await showCustomPrompt(`標題: ${newTitle}`, "請輸入備忘錄內容", "", 'textarea');
    if (newContent !== null) {
        // 【核心修正】在保存後，確保我們停留在備忘錄列表頁
        await saveMemo({ title: newTitle.trim(), content: newContent });
        switchToCharScreen('char-memo-screen'); // 確保顯示的是清單
    }
}

/**
 * 【V2.0 | 支持標題】保存新的備忘錄
 * @param {object} memoData - 包含 title 和 content 的物件
 */
async function saveMemo(memoData) {
    const char = state.chats[activeCharacterId];
    if (!char.memos) char.memos = [];
    
    // 這個函數現在只處理“新建”
    char.memos.push({ 
        id: Date.now(), 
        title: memoData.title, 
        content: memoData.content 
    });
    
    await db.chats.put(char);
    renderCharMemoList();
}

async function saveMemo(content) {
    const char = state.chats[activeCharacterId];
    if (!char.memos) char.memos = [];
    
    if (editingMemoId) {
        const memo = char.memos.find(m => m.id === editingMemoId);
        if (memo) memo.content = content;
    } else {
        char.memos.push({ id: Date.now(), content: content });
    }
    
    await db.chats.put(char);
    renderCharMemoList();
    editingMemoId = null;
}



        // ▼▼▼ 【V2.0 | AI生成版】請用這一整塊代碼，替換所有舊的日記功能函數 ▼▼▼

/**
 * 【全新 | V3.0 AI指令強化版】當使用者點擊“重新生成”時，調用AI生成類比相冊內容
 */
async function handleGenerateSimulatedDiaries() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];
    if (!chat) return;

    await showCustomAlert("請稍候...", `正在請求“${chat.name}”翻開TA的日記本...`);

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('請先在API設置中配置好API資訊。');
        return;
    }

    const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? '用戶' : state.qzoneSettings.nickname;

    const longTermMemoryContext = chat.longTermMemory?.map(mem => `- ${mem.content}`).join('\n') || '無';
    const maxMemory = chat.settings.maxMemory || 10;
const recentHistoryWithUser = chat.history.slice(-maxMemory).map(msg => `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
    const worldBookContext = (chat.settings.linkedWorldBookIds || [])
        .map(bookId => state.worldBooks.find(wb => wb.id === bookId))
        .filter(Boolean)
        .map(book => `\n## 世界書《${book.name}》設定:\n${book.content.filter(e=>e.enabled).map(e => `- ${e.content}`).join('\n')}`)
        .join('');
// 【【【核心修改：在這裡同時生成更細緻的、多維度的總結】】】
const summary3Hours = generateSummaryForTimeframe(chat, 3, 'hours');
const summary6Hours = generateSummaryForTimeframe(chat, 6, 'hours');
const summary9Hours = generateSummaryForTimeframe(chat, 9, 'hours');
const summaryToday = generateSummaryForTimeframe(chat, 1, 'days');
const summary3Days = generateSummaryForTimeframe(chat, 3, 'days');
const summary7Days = generateSummaryForTimeframe(chat, 7, 'days');

let multiLayeredSummaryContext = '';
if (summary3Hours || summary6Hours || summary9Hours || summaryToday || summary3Days || summary7Days) {
    multiLayeredSummaryContext += `\n# 智慧總結 (基於不同時間維度的對話回顧)\n`;
    if (summary3Hours) multiLayeredSummaryContext += summary3Hours;
    if (summary6Hours) multiLayeredSummaryContext += summary6Hours;
    if (summary9Hours) multiLayeredSummaryContext += summary9Hours;
    if (summary3Hours || summary6Hours || summary9Hours) multiLayeredSummaryContext += '\n';
    if (summaryToday) multiLayeredSummaryContext += summaryToday;
    if (summary3Days) multiLayeredSummaryContext += summary3Days;
    if (summary7Days) multiLayeredSummaryContext += summary7Days;
}
    // ▼▼▼ 核心修改1：強化AI指令 ▼▼▼
    const systemPrompt = `
# 你的任務
你是一個虛擬生活模擬器和故事作家。你的任務是扮演角色“${chat.name}”，並根據其人設、記憶和最近的互動，虛構出【5到8篇】TA最近可能會寫的日記。

# 核心規則
1.  **【時間 (最高優先順序)】**:
    -   今天的日期是 **${new Date().toLocaleDateString('zh-CN')}**。
    -   你生成的【所有】日記的標題日期，【必須】是今天或今天以前的日期。
    -   【絕對禁止】生成任何未來的日期！
2.  **【沉浸感】**: 每一篇日記都必須使用【第一人稱視角 ("我")】來寫，並且要充滿角色的個人情感、思考和秘密。在日記中描述自己的行為或想法時，【絕對禁止】使用第三人稱“他”或“她” (TA)。
3.  **【長度】**: 每一篇日記的正文長度【必須不少於300字】。
4.  **【格式鐵律 (最高優先順序)】**: 
    - 你的回復【必須且只能】是一個JSON陣列格式的字串。
    - 你的回復必須以 \`[\` 開始，並以 \`]\` 結束。
    - 【絕對禁止】在JSON陣列前後添加任何多餘的文字、解釋、或 markdown 標記 (如 \`\`\`json)。
    - 陣列中的每個元素都是一個物件，代表一篇日記，格式【必須】如下:
    \`\`\`json
    [
      {
        "title": "這篇日記的標題，例如：9月20日 晴",
        "content": "這裡是日記的詳細正文，必須支持分行符號\\n，並且必須巧妙地使用下面的【日記專屬Markdown語法】來豐富文本表現力。"
      }
    ]
    \`\`\`
5.  **【預留位置替換 (最高優先順序)】**: 在你的日記內容中，【絕對不能】出現 "{{user}}" 這個預留位置。你【必須】使用 “${userDisplayNameForAI}” 來指代你的聊天物件（使用者）。
6.  **【日記專屬Markdown語法 (必須使用！)】**:
    -   \`**加粗文字**\`: 用於強調。
    -   \`~~劃掉的文字~~\`: 用於表示改變主意或自我否定。
    -   \`!h{黃色高亮}\`: 用於標記關鍵字或重要資訊。
    -   \`!u{粉色底線}\`: 用於標注人名、地名或特殊名詞。
    -   \`!e{粉色強調}\`: 用於表達強烈的情緒。
    -   \`!w{手寫體}\`: 用於寫下引言、歌詞或特殊筆記。
    -   \`!m{淩亂的手寫體}\`: 用於表達激動、慌亂或潦草記錄時的心情。
    -   \`||塗黑||\`: 用於隱藏秘密或敏感詞彙 (每次塗黑2~5個字)。

# 供你參考的上下文
- **你的角色設定**: ${chat.settings.aiPersona}
- **你的長期記憶**:
${longTermMemoryContext}
${worldBookContext}
${multiLayeredSummaryContext} 
- **你最近和“${userDisplayNameForAI}”的對話摘要**:
${recentHistoryWithUser}

現在，請開始撰寫這組充滿真情實感、並熟練運用了Markdown語法的日記。`;
    // ▲▲▲ 修改結束 ▲▲▲

    try {
        const messagesForApi = [{ role: 'user', content: "請根據你的設定，生成你的日記內容。" }];
        let isGemini = proxyUrl.includes('generativelanguage');
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
        
        // ▼▼▼ 核心修改2：移除不相容的 response_format 參數 ▼▼▼
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, ...messagesForApi],
                    temperature: state.globalSettings.apiTemperature || 0.95,
                    // response_format: { "type": "json_object" } <-- 此行已被刪除
                })
            });
        // ▲▲▲ 修改結束 ▲▲▲

        if (!response.ok) throw new Error(`API 錯誤: ${response.statusText}`);
        
        const data = await response.json();
        const aiResponseContent = getGeminiResponseText(data);
        
        // ▼▼▼ 核心修改3：使用更強大的容錯解析邏輯 ▼▼▼
        const jsonMatch = aiResponseContent.match(/(\[[\s\S]*\])/);
        if (!jsonMatch || !jsonMatch[0]) {
            throw new Error(`AI返回的內容中未找到有效的JSON陣列。原始返回: ${aiResponseContent}`);
        }
        const cleanedJsonString = jsonMatch[0];
        let simulatedDiaries;
        try {
            simulatedDiaries = JSON.parse(cleanedJsonString);
        } catch (e) {
            throw new Error(`解析AI返回的JSON時出錯: ${e.message}\n\nAI原始返回內容:\n${aiResponseContent}`);
        }
        // ▲▲▲ 修改結束 ▲▲▲
        
        chat.diary = simulatedDiaries.map(entry => ({
            id: Date.now() + Math.random(),
            title: entry.title,
            content: entry.content,
            timestamp: Date.now()
        }));
        
        await db.chats.put(chat);
        await renderCharDiaryList();
        
    } catch (error) {
        console.error("生成模擬日記失敗:", error);
        await showCustomAlert("生成失敗", `無法生成日記，請檢查API配置或稍後再試。\n錯誤: ${error.message}`);
    }
}

        /**
         * 【全新】當用戶點擊“+”時，觸發AI撰寫一篇新日記並追加到末尾
         */
        async function handleWriteNewDiaryEntry() {
            if (!activeCharacterId) return;
            const chat = state.chats[activeCharacterId];
            if (!chat) return;
        
            await showCustomAlert("請稍候...", `正在請求“${chat.name}”寫一篇新日記...`);
        
            const { proxyUrl, apiKey, model } = state.apiConfig;
            if (!proxyUrl || !apiKey || !model) return;

            const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? '用戶' : state.qzoneSettings.nickname;

            const longTermMemoryContext = chat.longTermMemory?.map(mem => `- ${mem.content}`).join('\n') || '無';
            const maxMemory = chat.settings.maxMemory || 10;
const recentHistoryWithUser = chat.history.slice(-maxMemory).map(msg => `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
            const worldBookContext = (chat.settings.linkedWorldBookIds || []).map(bookId=>state.worldBooks.find(wb=>wb.id===bookId)).filter(Boolean).map(book=>`\n## 世界書《${book.name}》設定:\n${book.content.filter(e=>e.enabled).map(e=>`- ${e.content}`).join('\n')}`).join('');
            
            // ▼▼▼ 核心修復1：在這裡也添加“時間鐵律” ▼▼▼
            const systemPrompt = `
# 你的任務
你是一個虛擬生活模擬器和故事作家。你的任務是扮演角色“${chat.name}”，並根據其人設、記憶和最近的互動，虛構出【1篇】TA今天可能會寫的日記。

# 核心規則
1.  **【【【時間鐵律 (最高優先順序)】】】**:
    -   今天的日期是 **${new Date().toLocaleDateString('zh-CN')}**。
    -   你生成的日記標題日期【必須】是今天或今天以前的日期。
    -   【絕對禁止】生成任何未來的日期！
2.  **【【【沉浸感鐵律】】】**: 日記必須使用【第一人稱視角 ("我")】來寫，並且要充滿角色的個人情感、思考和秘密。在日記中描述自己的行為或想法時，【絕對禁止】使用第三人稱“他”或“她” (TA)。
3.  **【【【長度鐵律】】】**: 日記的正文長度【必須不少於300字】。
4.  **【【【格式鐵律 (最高優先順序)】】】**: 你的回復【必須且只能】是一個JSON陣列，且陣列中【只包含一個】物件，格式【必須】如下:
    \`\`\`json
    [
      {
        "title": "這篇日記的標題，例如：9月20日 晴",
        "content": "這裡是日記的詳細正文，必須支持分行符號\\n，並且必須巧妙地使用下面的【日記專屬Markdown語法】來豐富文本表現力。"
      }
    ]
    \`\`\`
5.  **【【【日記專屬Markdown語法 (必須使用！)】】】**:
    -   \`**加粗文字**\`: 用於強調。
    -   \`~~劃掉的文字~~\`: 用於表示改變主意或自我否定。
    -   \`!h{黃色高亮}\`: 用於標記關鍵字或重要資訊。
    -   \`!u{粉色底線}\`: 用於標注人名、地名或特殊名詞。
    -   \`!e{粉色強調}\`: 用於表達強烈的情緒。
    -   \`!w{手寫體}\`: 用於寫下引言、歌詞或特殊筆記。
    -   \`!m{淩亂的手寫體}\`: 用於表達激動、慌亂或潦草記錄時的心情。
    -   \`||塗黑||\`: 用於隱藏秘密或敏感詞彙(每次塗黑2~5個字)。

# 供你參考的上下文
- **你的角色設定**: ${chat.settings.aiPersona}
- **你的長期記憶**:
${longTermMemoryContext}
${worldBookContext}
- **你最近和“${userDisplayNameForAI}”的對話摘要**:
${recentHistoryWithUser}

現在，請開始撰寫這篇充滿真情實感、並熟練運用了Markdown語法的日記。`;
        
            try {
                const messagesForApi = [{ role: 'user', content: "請根據你的設定，寫一篇新日記。" }];
                let isGemini = proxyUrl.includes('generativelanguage');
                let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
                const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) : await fetch(`${proxyUrl}/v1/chat/completions`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                    body: JSON.stringify({
                        model: model,
                        messages: [{role: 'system', content: systemPrompt}, ...messagesForApi],
                        temperature: state.globalSettings.apiTemperature || 0.95,
                    })
                });
                if (!response.ok) throw new Error(`API 錯誤: ${response.statusText}`);
                const data = await response.json();
                const aiResponseContent = getGeminiResponseText(data);
                
                // ▼▼▼ 核心修復2：在這裡也使用終極容錯解析方案 ▼▼▼
                const jsonMatch = aiResponseContent.match(/(\[[\s\S]*\])/);
                if (!jsonMatch || !jsonMatch[0]) {
                    throw new Error(`AI返回的內容中未找到有效的JSON陣列。原始返回: ${aiResponseContent}`);
                }
                const cleanedJsonString = jsonMatch[0];
                let newDiaryEntry;
                try {
                    newDiaryEntry = JSON.parse(cleanedJsonString)[0];
                } catch (e) {
                    throw new Error(`解析AI返回的JSON時出錯: ${e.message}\n\nAI原始返回內容:\n${aiResponseContent}`);
                }
                // ▲▲▲ 修復結束 ▲▲▲
                
                if (!chat.diary) chat.diary = [];
                
                chat.diary.push({
                    id: Date.now(),
                    title: newDiaryEntry.title,
                    content: newDiaryEntry.content,
                    timestamp: Date.now()
                });
                
                await db.chats.put(chat);
                await renderCharDiaryList();
        
            } catch (error) {
                console.error("生成新日記失敗:", error);
                await showCustomAlert("生成失敗", `錯誤: ${error.message}`);
            }
        }

        /**
         * 【全新 | V2.0】渲染Cphone的日記列表
         */
        function renderCharDiaryList() {
            const listEl = document.getElementById('char-diary-list');
            listEl.innerHTML = '';
            const char = state.chats[activeCharacterId];
            const diaries = (char.diary || []).slice().reverse();

            if (diaries.length === 0) {
                listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">日記本還是空的。</p>';
                return;
            }

            diaries.forEach(entry => {
                const item = document.createElement('div');
                item.className = 'list-item';
                item.innerHTML = `
                    <div class="item-title">${entry.title}</div>
                    <div class="item-content">${new Date(entry.timestamp).toLocaleDateString()}</div>
                `;
                item.addEventListener('click', () => viewDiary(entry.id));
                addLongPressListener(item, () => deleteDiary(entry.id));
                listEl.appendChild(item);
            });
        }

    // ▼▼▼ 【請用這個 V2.0 版本】替換舊的 viewDiary 函數 ▼▼▼
    /**
     * 【V2.0 | 支持收藏】點擊日記列表項時，打開詳情頁面查看
     * @param {number} diaryId - 要查看的日記的ID
     */
    async function viewDiary(diaryId) {
        const char = state.chats[activeCharacterId];
        if (!char || !char.diary) return;
    
        const entry = char.diary.find(d => d.id === diaryId);
        if (entry) {
            // 1. 將當前日記物件存入全域變數，方便收藏功能調用
            activeDiaryForViewing = entry;
    
            const titleEl = document.getElementById('char-diary-detail-title');
            const contentEl = document.getElementById('char-diary-detail-content');
            const favBtn = document.getElementById('favorite-diary-btn');
    
            titleEl.textContent = entry.title;
            const formattedContent = parseMarkdown(entry.content)
                .split('\n')
                .map(p => `<p>${p || '&nbsp;'}</p>`)
                .join('');
            contentEl.innerHTML = formattedContent;
    
            // 2. 檢查這篇日記是否已被收藏，並更新按鈕狀態
            const existingFavorite = await db.favorites.where({ type: 'char_diary', 'content.id': diaryId }).first();
            favBtn.classList.toggle('active', !!existingFavorite);
    
            switchToCharScreen('char-diary-detail-screen');
        }
    }
    // ▼▼▼ 【全新】這是收藏/取消收藏日記的核心功能 ▼▼▼
    /**
     * 切換當前日記的收藏狀態
     */
    async function toggleDiaryFavorite() {
        if (!activeDiaryForViewing || !activeCharacterId) return;
    
        const diary = activeDiaryForViewing;
        const char = state.chats[activeCharacterId];
        const favBtn = document.getElementById('favorite-diary-btn');
    
        // 再次檢查是否已收藏
        const existingFavorite = await db.favorites.where({ type: 'char_diary', 'content.id': diary.id }).first();
    
        if (existingFavorite) {
            // 如果已收藏，則取消收藏
            await db.favorites.delete(existingFavorite.id);
            favBtn.classList.remove('active');
            await showCustomAlert('操作成功', '已取消收藏。');
        } else {
            // 如果未收藏，則執行收藏
            const newFavorite = {
                type: 'char_diary',
                // 將日記的完整內容，連同作者資訊一起存入
                content: {
                    id: diary.id,
                    title: diary.title,
                    content: diary.content,
                    timestamp: diary.timestamp,
                    characterId: activeCharacterId,
                    characterName: char.name
                },
                timestamp: Date.now() // 收藏操作的時間
            };
            await db.favorites.add(newFavorite);
            favBtn.classList.add('active');
            await showCustomAlert('操作成功', '已成功收藏到“我的收藏”頁面！');
        }
    }
    // ▲▲▲ 新增函數結束 ▲▲▲
        /**
         * 【全新】刪除一篇日記
         * @param {number} diaryId - 要刪除的日記的ID
         */
        async function deleteDiary(diaryId) {
            const confirmed = await showCustomConfirm('刪除日記', '確定要刪除這篇日記嗎？', { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                const char = state.chats[activeCharacterId];
                char.diary = char.diary.filter(d => d.id !== diaryId);
                await db.chats.put(char);
                renderCharDiaryList();
            }
        }

        // ▲▲▲ 替換結束 ▲▲▲

/**
 * 【全新 V2.5 | 使用者對話置頂修復版】渲染角色視角的QQ聊天清單
 */
async function renderCharSimulatedQQ() {
    const listEl = document.getElementById('char-chat-list');
    listEl.innerHTML = '';
    const char = state.chats[activeCharacterId];
    if (!char) return;

    // ▼▼▼ 核心修改 1：手動創建並置頂與使用者的真實對話 ▼▼▼
    const userDisplayName = char.settings.myNickname || (state.qzoneSettings.nickname || '我');
    const lastRealMessage = char.history.filter(m => !m.isHidden).slice(-1)[0] || { content: '...' };
    
    // 提取最後一條消息的文本內容
    let lastMsgContent = '...';
    if (lastRealMessage) {
        if (typeof lastRealMessage.content === 'string') {
            lastMsgContent = lastRealMessage.content;
        } else if (Array.isArray(lastRealMessage.content) && lastRealMessage.content[0]?.type === 'image_url') {
            lastMsgContent = '[圖片]';
        } else if (lastRealMessage.type) {
            const typeMap = { 'voice_message': '[語音]', 'transfer': '[轉帳]', 'ai_image': '[圖片]' };
            lastMsgContent = typeMap[lastRealMessage.type] || `[${lastRealMessage.type}]`;
        }
    }

    // 獲取用戶頭像和頭像框
    const myAvatar = char.settings.myAvatar || defaultAvatar;
    const myFrame = char.settings.myAvatarFrame || '';
    let avatarHtml;
    if (myFrame) {
        avatarHtml = `<div class="avatar-group has-frame" style="width: 45px; height: 45px;"><div class="avatar-with-frame" style="width: 45px; height: 45px;"><img src="${myAvatar}" class="avatar-img" style="border-radius: 50%;"><img src="${myFrame}" class="avatar-frame"></div></div>`;
    } else {
        avatarHtml = `<div class="avatar-group" style="width: 45px; height: 45px;"><img src="${myAvatar}" class="avatar" style="border-radius: 50%; width: 45px; height: 45px;"></div>`;
    }

    const userChatItem = document.createElement('div');
    userChatItem.className = 'chat-list-item';
    // 使用一個特殊的索引-1來標記這是與使用者的真實對話
    userChatItem.dataset.conversationIndex = "-1"; 
    userChatItem.innerHTML = `
        ${avatarHtml}
        <div class="info">
            <div class="name-line">
                <span class="name">${userDisplayName}</span>
            </div>
            <div class="last-msg">${String(lastMsgContent).substring(0, 20)}...</div>
        </div>
    `;
    listEl.appendChild(userChatItem);
    // ▲▲▲ 核心修改 1 結束 ▲▲▲

    const allNpcs = await db.npcs.toArray();
    const npcMap = new Map(allNpcs.map(npc => [npc.name, npc]));
    const conversations = char.simulatedConversations || [];

    if (conversations.length === 0 && !userChatItem) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">點擊右上角刷新按鈕，<br>看看TA最近都和誰聊天了吧！</p>';
        return;
    }

    conversations.forEach((convo, index) => {
        // ▼▼▼ 核心修改 2：跳過AI生成的與使用者的對話，避免重複 ▼▼▼
        if (convo.type === 'private_user') {
            return;
        }
        // ▲▲▲ 核心修改 2 結束 ▲▲▲

        const item = document.createElement('div');
        item.className = 'chat-list-item';
        item.dataset.conversationIndex = index;

        let lastMessage, avatarHtml, displayName;
        
        if (convo.type === 'group') {
            displayName = convo.groupName + ` <span class="group-tag">群</span>`;
            lastMessage = convo.messages.slice(-1)[0] || { content: '...' };
            const groupAvatarPrompt = `logo, simple, flat design, for a group chat named '${convo.groupName}'`;
            const avatarUrl = state.globalSettings.enableAiDrawing ? `https://image.pollinations.ai/prompt/${encodeURIComponent(groupAvatarPrompt)}` : defaultGroupAvatar;
            avatarHtml = `<div class="avatar-group"><img src="${avatarUrl}" class="avatar" style="border-radius: 50%;"></div>`;
        
        } else { // 與NPC的私聊
            displayName = convo.participant.name;
            lastMessage = convo.messages.slice(-1)[0] || { content: '...' };
            const npcData = npcMap.get(displayName);
            let avatarUrl = (npcData && npcData.avatar) ? npcData.avatar : 
                (state.globalSettings.enableAiDrawing ? `https://image.pollinations.ai/prompt/${encodeURIComponent(convo.participant.avatar_prompt || 'anime person')}` : defaultGroupMemberAvatar);
            avatarHtml = `<div class="avatar-group"><img src="${avatarUrl}" class="avatar" style="border-radius: 50%;"></div>`;
        }

        let lastMsgContent = '...';
        if (lastMessage && lastMessage.content) {
            lastMsgContent = lastMessage.content;
        }
        
        item.innerHTML = `
            ${avatarHtml}
            <div class="info">
                <div class="name-line">
                    <span class="name">${displayName}</span>
                </div>
                <div class="last-msg">${String(lastMsgContent).substring(0, 20)}...</div>
            </div>
        `;
        listEl.appendChild(item);
    });
}
/**
 * 【全新 V4.0 | 指令簡化終極修復版 + 移除用戶模擬】當用戶點擊“重新生成”時，調用AI生成全新的類比對話
 */
async function handleGenerateSimulatedQQ() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];
    if (!chat) return;

    await showCustomAlert("請稍候...", `正在根據“${chat.name}”的記憶和人設，生成全新的社交動態...`);

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('請先在API設置中配置好API資訊。');
        return;
    }
    
    const allNpcs = await db.npcs.toArray();
    const associatedNpcs = allNpcs.filter(npc => 
        npc.associatedWith && npc.associatedWith.includes(activeCharacterId)
    );
    let npcContext = "# 你的社交圈 (綁定的NPC)\n";
    if (associatedNpcs.length > 0) {
        npcContext += "這是你認識的、關係密切的NPC。在生成對話時，你應該【優先】與他們互動。\n";
        associatedNpcs.forEach(npc => {
            npcContext += `- **姓名**: ${npc.name}\n  - **人設**: ${npc.persona}\n`;
        });
    } else {
        npcContext += "（你目前沒有綁定的NPC夥伴，可以自由創造新的NPC。）\n";
    }

    const userDisplayNameForAI = state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname ? '用戶' : state.qzoneSettings.nickname;
    const userNicknameInThisChat = chat.settings.myNickname || userDisplayNameForAI;
    const longTermMemoryContext = chat.longTermMemory?.map(mem => `- ${mem.content}`).join('\n') || '無';
const maxMemory = chat.settings.maxMemory || 10;
    const recentHistoryWithUser =chat.history.slice(-maxMemory).map(msg => `${msg.role === 'user' ? userNicknameInThisChat : chat.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
    const worldBookContext = (chat.settings.linkedWorldBookIds || [])
        .map(bookId => state.worldBooks.find(wb => wb.id === bookId))
        .filter(Boolean)
        .map(book => `\n## 世界書《${book.name}》設定 (你可以將其中角色作為聊天物件):\n${book.content.filter(e=>e.enabled).map(e => `- ${e.content}`).join('\n')}`)
        .join('');
    const characterOriginalName = chat.originalName || chat.name;

    // ▼▼▼ 核心修改：這是一個全新的、更簡潔、更嚴格的指令 ▼▼▼
    const systemPrompt = `
# 你的任務
你是一個虛擬社交生活模擬器，扮演角色“${chat.name}”。你的任務是虛構出【5到7段】TA最近的QQ聊天記錄。

# 核心規則
1.  **【NPC唯一性鐵律】**: 在你本次生成的所有對話中（包括私聊和群聊），每一個NPC的名字【必須是獨一-無二的】。絕對禁止出現重名的NPC，禁止出現重複群聊。
2.  **【NPC來源】**: 你應該優先從“你的社交圈 (綁定的NPC)”和“世界書”中尋找角色作為聊天對象。如果不夠，你也可以自由創造全新的NPC，對話內容要多樣化，反映角色的生活。
3.  **關聯性**: 對話內容應巧妙地反映角色的長期記憶、世界觀，以及與用戶互動可能帶來的心情變化。
4.  **簡潔性**: 每段對話的總長度應在8到15句之間。
# 格式鐵律 (最高優先順序)
- 你的回復【必須且只能】是一個JSON陣列格式的字串，以 \`[\` 開始，並以 \`]\` 結束。
- 【絕對禁止】在JSON陣列前後添加任何多餘的文字、解釋、或 markdown 標記。
- 陣列中的每個元素都代表一段對話，且【必須】是以下兩種格式之一：

// ▼▼▼ 核心修改：格式A（與用戶的私聊）已被徹底移除 ▼▼▼

### 格式 A：與NPC的私聊
\`\`\`json
{
  "type": "private_npc",
  "participant": {
    "name": "NPC的名字",
    "avatar_prompt": "(僅當NPC是新創造時提供)一段用於生成頭像的【英文】關鍵字, 風格為動漫/插畫/二次元等, 禁止真人"
  },
  "messages": [
    {"sender": "${characterOriginalName}", "content": "對話內容1"},
    {"sender": "NPC的名字", "content": "對話內容2"}
  ]
}
\`\`\`

### 格式 B：群聊
\`\`\`json
{
  "type": "group",
  "groupName": "一個虛構的群名",
  "participants": [
    {"name": "NPC成員1", "avatar_prompt": "(僅當NPC是新創造時提供) 成員1頭像【英文】關鍵字"},
    {"name": "NPC成員2", "avatar_prompt": "(僅當NPC是新創造時提供) 成員2頭像【英文】關鍵字"}
  ],
  "messages": [
    {"sender": "${characterOriginalName}", "content": "我在群裡說的話"},
    {"sender": "NPC成員1", "content": "成員1回復我"}
  ]
}
\`\`\`

# 角色與上下文
- **你的角色設定**: ${chat.settings.aiPersona}
- **你的長期記憶**: ${longTermMemoryContext}
- **世界觀**: ${worldBookContext}
- **最近與用戶的互動**: ${recentHistoryWithUser}
${npcContext}

現在，請嚴格按照格式鐵律，生成聊天記錄的JSON陣列。`;
// ▲▲▲ 修改結束 ▲▲▲
            
    try {
        const messagesForApi = [{ role: 'user', content: "請根據你的設定，生成類比聊天記錄。" }];
        let isGemini = proxyUrl.includes('generativelanguage');
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
        
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, ...messagesForApi],
                    temperature: state.globalSettings.apiTemperature || 0.9
                })
            });

        if (!response.ok) throw new Error(`API 錯誤: ${response.statusText}`);
        
        const data = await response.json();
        const aiResponseContent = getGeminiResponseText(data);
        
        const jsonMatch = aiResponseContent.match(/(\[[\s\S]*\])/);
        if (!jsonMatch || !jsonMatch[0]) {
            throw new Error(`AI返回的內容中未找到有效的JSON陣列。原始返回: ${aiResponseContent}`);
        }
        const cleanedJsonString = jsonMatch[0];
        let simulatedConversations;
        try {
            simulatedConversations = JSON.parse(cleanedJsonString);
        } catch (e) {
            throw new Error(`解析AI返回的JSON時出錯: ${e.message}\n\nAI原始返回內容:\n${aiResponseContent}`);
        }
        
        chat.simulatedConversations = simulatedConversations;
        await db.chats.put(chat);
        
        await renderCharSimulatedQQ();

        // 觸發主動消息的邏輯保持不變
        const hiddenMessage = {
            role: 'system',
            content: `[系統指令：你剛剛在自己的手機上活動了一番（和朋友聊天、逛群等）。現在請根據你的角色設定，主動給使用者發一條消息，可以聊聊你剛才看到或聊到的趣事，或者僅僅是問候一下。]`,
            timestamp: Date.now(),
            isHidden: true
        };
        chat.history.push(hiddenMessage);
        await db.chats.put(chat);
        triggerAiResponse();
        
    } catch (error) {
        console.error("生成模擬聊天失敗:", error);
        await showCustomAlert("生成失敗", `無法生成類比聊天記錄，請檢查API配置或稍後再試。\n錯誤: ${error.message}`);
    }
}

/**
 * 【全新 | V3.0 | 用戶人設修復版】處理從CPhone QQ觸發的、用於推進真實對話的AI請求
 */
async function handleContinueRealConversationFromCPhone() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];
    if (!chat) return;



    try {
        const { proxyUrl, apiKey, model } = state.apiConfig;
        if (!proxyUrl || !apiKey || !model) {
            throw new Error('API未配置，無法生成對話。');
        }

        const maxMemory = parseInt(chat.settings.maxMemory) || 10;
        const historySlice = chat.history.slice(-maxMemory);
        const myNickname = chat.settings.myNickname || '我';

        // ==========================================================
        //            ★★★ 核心修改從這裡開始 ★★★
        // ==========================================================

        // 1. 獲取用戶人設
        const userPersona = chat.settings.myPersona || '用戶';

        // 2. 注入長期記憶 (Long-term Memory)
        const longTermMemoryContext = `# 長期記憶 (必須嚴格遵守)\n${
            chat.longTermMemory && chat.longTermMemory.length > 0 
                ? chat.longTermMemory.map(mem => `- ${mem.content}`).join('\n') 
                : '- (暫無)'
        }`;

        // 3. 注入世界書 (World Book)
        let worldBookContext = '';
        if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
            const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
                const worldBook = state.worldBooks.find(wb => wb.id === bookId);
                if (!worldBook || !Array.isArray(worldBook.content)) return '';
                const formattedEntries = worldBook.content
                    .filter(entry => entry.enabled !== false)
                    .map(entry => `\n### 條目: ${entry.comment || '無備註'}\n**內容:**\n${entry.content}`)
                    .join('');
                return formattedEntries ? `\n\n## 世界書: ${worldBook.name}\n${formattedEntries}` : '';
            }).filter(Boolean).join('');
            if (linkedContents) {
                worldBookContext = `\n\n# 核心世界觀設定 (必須嚴格遵守以下所有設定)\n${linkedContents}\n`;
            }
        }
// 【【【核心修改：在這裡同時生成更細緻的、多維度的總結】】】
const summary3Hours = generateSummaryForTimeframe(chat, 3, 'hours');
const summary6Hours = generateSummaryForTimeframe(chat, 6, 'hours');
const summary9Hours = generateSummaryForTimeframe(chat, 9, 'hours');
const summaryToday = generateSummaryForTimeframe(chat, 1, 'days');
const summary3Days = generateSummaryForTimeframe(chat, 3, 'days');
const summary7Days = generateSummaryForTimeframe(chat, 7, 'days');

let multiLayeredSummaryContext = '';
if (summary3Hours || summary6Hours || summary9Hours || summaryToday || summary3Days || summary7Days) {
    multiLayeredSummaryContext += `\n# 智慧總結 (基於不同時間維度的對話回顧)\n`;
    if (summary3Hours) multiLayeredSummaryContext += summary3Hours;
    if (summary6Hours) multiLayeredSummaryContext += summary6Hours;
    if (summary9Hours) multiLayeredSummaryContext += summary9Hours;
    if (summary3Hours || summary6Hours || summary9Hours) multiLayeredSummaryContext += '\n';
    if (summaryToday) multiLayeredSummaryContext += summaryToday;
    if (summary3Days) multiLayeredSummaryContext += summary3Days;
    if (summary7Days) multiLayeredSummaryContext += summary7Days;
}
        // 4. 更新 System Prompt 以包含用戶人設
        const systemPrompt = `
# 你的核心任務
你正在扮演角色“${chat.originalName}”。用戶剛剛在TA的手機（CPhone）上點擊了一個按鈕，希望你能繼續你們之前的對話。你的任務是根據上下文，生成【3到5條】符合你人設的、簡短的、連續的新回復。

# 輸出格式鐵律 (最高優先順序)
- 你的回復【必須】是一個JSON陣列，每個物件代表一條消息。
- 格式: \`[{"type": "text", "content": "第一句話"}, {"type": "text", "content": "第二句話"}, {"type": "sticker", "url": "...", "meaning": "..."}]\`
- 你可以自由組合使用 "text", "sticker", "ai_image", "voice_message" 等多種消息類型。

# 你的角色設定
${chat.settings.aiPersona}

// ▼▼▼ 核心修改：在這裡添加了用戶的人設 ▼▼▼
# 你的聊天物件（使用者）的人設
${userPersona}
// ▲▲▲ 修改結束 ▲▲▲

# 供你參考的上下文
- **你的本名**: "${chat.originalName}"
- **用戶的備註**: "${myNickname}"
${worldBookContext}
${longTermMemoryContext}
${multiLayeredSummaryContext} 
- **你們最後的對話**:
${historySlice.map(msg => `${msg.role === 'user' ? myNickname : chat.name}: ${String(msg.content)}`).join('\n')}

現在，請繼續這場對話。
`;
        
        // ==========================================================
        //            ★★★ 核心修改到此結束 ★★★
        // ==========================================================

        const messagesPayload = historySlice.map(msg => ({
            role: msg.role,
            content: `${msg.role === 'user' ? myNickname : chat.name}: ${String(msg.content)}`
        }));
        
        let isGemini = proxyUrl.includes('generativelanguage');
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesPayload);

        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, ...messagesPayload],
                    temperature: state.globalSettings.apiTemperature || 0.8,
                })
            });

        if (!response.ok) {
            throw new Error(`API 請求失敗: ${(await response.json()).error.message}`);
        }

        const data = await response.json();
        const aiResponseContent = getGeminiResponseText(data);
        const messagesArray = parseAiResponse(aiResponseContent);

        if (!messagesArray || messagesArray.length === 0) {
            throw new Error("AI返回了空內容。");
        }

        let newMessagesCount = 0;
        let messageTimestamp = Date.now();
        for (const msgData of messagesArray) {
            const baseMessage = { role: 'assistant', senderName: chat.originalName, timestamp: messageTimestamp++ };
            let aiMessage = null;
            switch(msgData.type) {
                case 'text':
                    aiMessage = { ...baseMessage, content: String(msgData.content || msgData.message) };
                    break;
                case 'sticker':
                    aiMessage = { ...baseMessage, type: 'sticker', content: msgData.url, meaning: msgData.meaning || '' };
                    break;
            }
            if (aiMessage) {
                chat.history.push(aiMessage);
                newMessagesCount++;
            }
        }
        
        if (newMessagesCount > 0) {
            chat.unreadCount = (chat.unreadCount || 0) + newMessagesCount;
        }
        
        await db.chats.put(chat);
        await renderChatList();

        if (newMessagesCount > 0) {
            showNotification(chat.id, `發來了 ${newMessagesCount} 條新消息`);
        }

    } catch (error) {
        console.error("從CPhone推進真實對話失敗:", error);
        await showCustomAlert('操作失敗', `無法生成新回復: ${error.message}`);
    }
}
/**
 * 【全新】為CPhone鏡像聊天視窗載入更早的消息記錄
 */
async function loadMoreMirroredMessages() {
    if (isLoadingMoreCphoneMessages || !activeCharacterId) return;
    isLoadingMoreCphoneMessages = true;

    const messagesContainer = document.getElementById('char-conversation-messages');
    const mainChar = state.chats[activeCharacterId];
    if (!mainChar) {
        isLoadingMoreCphoneMessages = false;
        return;
    }

    showLoader(messagesContainer, 'top'); // 在頂部顯示載入動畫
    const oldScrollHeight = messagesContainer.scrollHeight;

    // 模擬一點延遲，讓載入動畫更自然
    await new Promise(resolve => setTimeout(resolve, 500));

    const totalMessages = mainChar.history.length;
    const renderWindow = state.globalSettings.chatRenderWindow || 50;
    const nextSliceEnd = totalMessages - cphoneRenderedCount;
    const nextSliceStart = Math.max(0, nextSliceEnd - renderWindow);
    
    const messagesToPrepend = mainChar.history.slice(nextSliceStart, nextSliceEnd);

    // 渲染前先移除載入動畫
    hideLoader(messagesContainer);

    if (messagesToPrepend.length === 0) {
        isLoadingMoreCphoneMessages = false;
        return;
    }

    // 從後往前遍歷，逐條 prepending 到頂部
    for (const msg of messagesToPrepend.reverse()) {
        const mirroredMsg = { ...msg, role: msg.role === 'user' ? 'assistant' : 'user' };
        
        // 我們需要再次構建那個“反轉視角”的臨時物件
        const tempChatObjectForRendering = {
            id: 'temp_user_chat_mirror', isGroup: false, name: mainChar.name,
            settings: {
                ...mainChar.settings,
                myAvatar: mainChar.settings.aiAvatar,
                myAvatarFrame: mainChar.settings.aiAvatarFrame,
                aiAvatar: mainChar.settings.myAvatar,
                aiAvatarFrame: mainChar.settings.myAvatarFrame
            }
        };
        
        const messageEl = await createMessageElement(mirroredMsg, tempChatObjectForRendering);
        if (messageEl) {
            messagesContainer.prepend(messageEl);
        }
    }

    cphoneRenderedCount += messagesToPrepend.length;

    // 恢復滾動位置，防止跳動
    const newScrollHeight = messagesContainer.scrollHeight;
    messagesContainer.scrollTop = newScrollHeight - oldScrollHeight;

    isLoadingMoreCphoneMessages = false;
}
/**
 * 【全新 V2.5 | 交互優化 + 使用者對話修復版】打開並顯示指定的類比聊天記錄
 * @param {number} conversationIndex - 在陣列中的索引, -1 代表與使用者的真實對話
 */
async function openCharSimulatedConversation(conversationIndex) {
    const mainChar = state.chats[activeCharacterId];
    // ▼▼▼ 核心修改：處理 conversationIndex 為 -1 的情況 ▼▼▼
    if (conversationIndex === -1) {
        // 這是我們手動添加的“與使用者對話”
        cphoneActiveConversationType = 'private_user';
        
        const titleEl = document.getElementById('char-conversation-partner-name');
        const bodyEl = document.getElementById('char-conversation-messages');
        const inputEl = document.getElementById('char-simulated-input');

        bodyEl.innerHTML = '';
        titleEl.textContent = mainChar.settings.myNickname || (state.qzoneSettings.nickname || '我');
        inputEl.placeholder = `與 ${mainChar.settings.myNickname || '我'} 的對話 (唯讀)`;
        
        cphoneRenderedCount = 0;
        isLoadingMoreCphoneMessages = false;
        
        const history = mainChar.history;
        const renderWindow = state.globalSettings.chatRenderWindow || 50;
        const initialMessages = history.slice(-renderWindow);

        const tempChatObjectForRendering = {
            id: 'temp_user_chat_mirror', isGroup: false, name: mainChar.name,
            settings: {
                ...mainChar.settings,
                myAvatar: mainChar.settings.aiAvatar,
                myAvatarFrame: mainChar.settings.aiAvatarFrame,
                aiAvatar: mainChar.settings.myAvatar,
                aiAvatarFrame: mainChar.settings.myAvatarFrame
            }
        };

        for (const msg of initialMessages) {
            const mirroredMsg = { ...msg, role: msg.role === 'user' ? 'assistant' : 'user' };
            const bubbleElement = await createMessageElement(mirroredMsg, tempChatObjectForRendering);
            if (bubbleElement) {
                bodyEl.appendChild(bubbleElement);
            }
        }
        cphoneRenderedCount = initialMessages.length;

        switchToCharScreen('char-qq-conversation-screen');
        setTimeout(() => bodyEl.scrollTop = bodyEl.scrollHeight, 0);

        return; // 處理完後直接返回
    }
    // ▲▲▲ 核心修改結束 ▲▲▲

    // --- 後續處理AI生成對話的邏輯保持不變 ---
    const conversation = mainChar.simulatedConversations[conversationIndex];
    if (!conversation) return;
    cphoneActiveConversationType = conversation.type;

    const allNpcs = await db.npcs.toArray();
    const npcMap = new Map(allNpcs.map(npc => [npc.name, npc]));

    const titleEl = document.getElementById('char-conversation-partner-name');
    const bodyEl = document.getElementById('char-conversation-messages');
    const inputEl = document.getElementById('char-simulated-input');

    bodyEl.innerHTML = '';
    bodyEl.dataset.theme = mainChar.settings.theme || 'default';
    const isDarkMode = document.getElementById('phone-screen').classList.contains('dark-mode');
    bodyEl.style.backgroundColor = isDarkMode ? '#000000' : '#f0f2f5';

    let tempChatObjectForRendering;
    
    if (conversation.type === 'group') {
        titleEl.textContent = `${conversation.groupName} (${conversation.participants.length + 1})`;
        inputEl.placeholder = `在 ${conversation.groupName} 中聊天`;
        tempChatObjectForRendering = {
            id: 'temp_group_chat', isGroup: true,
            name: conversation.groupName,
            originalName: mainChar.originalName,
            members: conversation.participants.map(p => {
                const npcData = npcMap.get(p.name);
                let avatarUrl = (npcData && npcData.avatar) ? npcData.avatar : 
                    (state.globalSettings.enableAiDrawing 
                        ? `https://image.pollinations.ai/prompt/${encodeURIComponent(p.avatar_prompt || 'anime person')}`
                        : defaultGroupMemberAvatar);
                return { originalName: p.name, groupNickname: p.name, avatar: avatarUrl };
            }),
            settings: {
                ...mainChar.settings,
                myNickname: mainChar.name,
                myAvatar: mainChar.settings.aiAvatar,
                myAvatarFrame: mainChar.settings.aiAvatarFrame,
            }
        };
        for (const msg of conversation.messages) {
            const isFromMainChar = msg.sender === (mainChar.originalName || mainChar.name);
            const role = isFromMainChar ? 'user' : 'assistant';
            const tempMessageObject = { role: role, senderName: msg.sender, content: msg.content, timestamp: Date.now() + Math.random() };
            const bubbleElement = await createMessageElement(tempMessageObject, tempChatObjectForRendering);
            if (bubbleElement) {
                bodyEl.appendChild(bubbleElement);
            }
        }
    } else { // 與NPC的私聊
        titleEl.textContent = conversation.participant.name;
        inputEl.placeholder = `與 ${conversation.participant.name} 的對話`;
        const npcData = npcMap.get(conversation.participant.name);
        const npcAvatarUrl = (npcData && npcData.avatar) ? npcData.avatar : 
            (state.globalSettings.enableAiDrawing
                ? `https://image.pollinations.ai/prompt/${encodeURIComponent(conversation.participant.avatar_prompt || 'anime person')}`
                : defaultGroupMemberAvatar);
        tempChatObjectForRendering = {
            id: 'temp_npc_chat', isGroup: false,
            name: conversation.participant.name,
            originalName: mainChar.originalName,
            settings: {
                ...mainChar.settings,
                myAvatar: mainChar.settings.aiAvatar,
                myAvatarFrame: mainChar.settings.aiAvatarFrame,
                aiAvatar: npcAvatarUrl,
                aiAvatarFrame: ''
            }
        };
        for (const msg of conversation.messages) {
            const isFromMainChar = msg.sender === (mainChar.originalName || mainChar.name);
            const role = isFromMainChar ? 'user' : 'assistant';
            const tempMessageObject = { role: role, senderName: msg.sender, content: msg.content, timestamp: Date.now() + Math.random() };
            const bubbleElement = await createMessageElement(tempMessageObject, tempChatObjectForRendering);
            if (bubbleElement) {
                bodyEl.appendChild(bubbleElement);
            }
        }
    }

    switchToCharScreen('char-qq-conversation-screen');
    bodyEl.scrollTop = bodyEl.scrollHeight;
}
/**
 * 【全新】關閉類比聊天記錄彈窗
 */
function closeSimulatedTranscriptModal() {
    document.getElementById('char-qq-transcript-modal').classList.remove('visible');
}

// ▲▲▲ 全新JS代碼黏貼結束 ▲▲▲
/**
 * 【全新 | V3.0 AI指令強化版】當使用者點擊“重新生成”時，調用AI生成類比相冊內容
 */
async function handleGenerateSimulatedAlbum() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];

    if (!chat) {
        await showCustomAlert("操作失敗", "無法找到當前角色的資料。");
        return;
    }

    await showCustomAlert("請稍候...", `正在請求“${chat.name}”回憶TA的相冊照片...`);

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('請先在API設置中配置好API資訊。');
        return;
    }

    const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? '用戶' : state.qzoneSettings.nickname;
    
    const longTermMemoryContext = chat.longTermMemory?.map(mem => `- ${mem.content}`).join('\n') || '無';
    const maxMemory = chat.settings.maxMemory || 10;
const recentHistoryWithUser = chat.history.slice(-maxMemory).map(msg => `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
    const worldBookContext = (chat.settings.linkedWorldBookIds || [])
        .map(bookId => state.worldBooks.find(wb => wb.id === bookId))
        .filter(Boolean)
        .map(book => `\n## 世界書《${book.name}》設定:\n${book.content.filter(e=>e.enabled).map(e => `- ${e.content}`).join('\n')}`)
        .join('');
// 【【【核心修改：在這裡同時生成更細緻的、多維度的總結】】】
const summary3Hours = generateSummaryForTimeframe(chat, 3, 'hours');
const summary6Hours = generateSummaryForTimeframe(chat, 6, 'hours');
const summary9Hours = generateSummaryForTimeframe(chat, 9, 'hours');
const summaryToday = generateSummaryForTimeframe(chat, 1, 'days');
const summary3Days = generateSummaryForTimeframe(chat, 3, 'days');
const summary7Days = generateSummaryForTimeframe(chat, 7, 'days');

let multiLayeredSummaryContext = '';
if (summary3Hours || summary6Hours || summary9Hours || summaryToday || summary3Days || summary7Days) {
    multiLayeredSummaryContext += `\n# 智慧總結 (基於不同時間維度的對話回顧)\n`;
    if (summary3Hours) multiLayeredSummaryContext += summary3Hours;
    if (summary6Hours) multiLayeredSummaryContext += summary6Hours;
    if (summary9Hours) multiLayeredSummaryContext += summary9Hours;
    if (summary3Hours || summary6Hours || summary9Hours) multiLayeredSummaryContext += '\n';
    if (summaryToday) multiLayeredSummaryContext += summaryToday;
    if (summary3Days) multiLayeredSummaryContext += summary3Days;
    if (summary7Days) multiLayeredSummaryContext += summary7Days;
}
    // ▼▼▼ 核心修改1：強化AI指令 ▼▼▼
    const systemPrompt = `
# 你的任務
你是一個虛擬生活模擬器。你的任務是扮演角色“${chat.name}”，並根據其人設、記憶和最近的互動，構思出【8到10張】TA最近可能會拍攝或珍藏在手機相冊裡的照片。

# 核心規則
1.  **創造性與合理性**: 照片內容必須完全符合角色的性格、愛好、職業和生活環境。
2.  **多樣性**: 照片主題要豐富，可以包括自拍、風景、食物、寵物、朋友合影、工作場景等。
3.  **格式鐵律 (最高優先順序)**: 
    - 你的回復【必須且只能】是一個JSON陣列格式的字串。
    - 你的回復必須以 \`[\` 開始，並以 \`]\` 結束。
    - 【絕對禁止】在JSON陣列前後添加任何多餘的文字、解釋、或 markdown 標記 (如 \`\`\`json)。
    - 陣列中的每個元素都是一個物件，代表一張照片，格式【必須】如下:
    \`\`\`json
    [
      {
        "description": "這是照片背後的故事或角色的心情日記，必須使用第一人稱“我”來寫。",
        "image_prompt": "一段用於生成這張照片的、詳細的【英文】關鍵字。"
      }
    ]
    \`\`\`
    - **【image_prompt 絕對禁止】**: 絕對禁止包含任何中文字元、句子、特殊符號、或任何可能涉及敏感（NSFW）、暴力、血腥、政治的內容！也禁止真人！
    - **【image_prompt 必須是】**: 必須是純英文的、用逗號分隔的【關鍵片語合】 (e.g., "1boy, solo, basketball jersey, in locker room, smiling, selfie")。
    - **【畫風指令】**: 在 prompt 的末尾，總是加上畫風指令，例如： \`best quality, masterpiece, anime style, cinematic lighting\`

# 供你參考的上下文
- **你的角色設定**: ${chat.settings.aiPersona}
${longTermMemoryContext}
${worldBookContext}
${multiLayeredSummaryContext} 
- **你最近和“${userDisplayNameForAI}”的對話摘要**:
${recentHistoryWithUser}

現在，請開始生成這組照片的描述和繪畫指令。`;
    // ▲▲▲ 修改結束 ▲▲▲

    try {
        const messagesForApi = [{ role: 'user', content: "請根據你的設定，生成你的相冊內容。" }];
        let isGemini = proxyUrl.includes('generativelanguage');
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
        
        // ▼▼▼ 核心修改2：移除不相容的 response_format 參數 ▼▼▼
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, ...messagesForApi],
                    temperature: state.globalSettings.apiTemperature || 0.9
                    // response_format: { "type": "json_object" }  <-- 此行已被刪除
                })
            });
        // ▲▲▲ 修改結束 ▲▲▲

        if (!response.ok) throw new Error(`API 錯誤: ${response.statusText}`);
        
        const data = await response.json();
        const aiResponseContent = getGeminiResponseText(data);
        
        // ▼▼▼ 核心修改3：使用更強大的容錯解析邏輯 ▼▼▼
        const jsonMatch = aiResponseContent.match(/(\[[\s\S]*\])/);
        if (!jsonMatch || !jsonMatch[0]) {
            throw new Error(`AI返回的內容中未找到有效的JSON陣列。原始返回: ${aiResponseContent}`);
        }
        const cleanedJsonString = jsonMatch[0];
        let simulatedAlbumData;
        try {
            simulatedAlbumData = JSON.parse(cleanedJsonString);
        } catch (e) {
            throw new Error(`解析AI返回的JSON時出錯: ${e.message}\n\nAI原始返回內容:\n${aiResponseContent}`);
        }
        // ▲▲▲ 修改結束 ▲▲▲
        
        chat.simulatedAlbum = simulatedAlbumData;
        await db.chats.put(chat);
        
        await renderCharAlbum();
        
    } catch (error) {
        console.error("生成模擬相冊失敗:", error);
        await showCustomAlert("生成失敗", `無法生成模擬相冊，請檢查API配置或稍後再試。\n錯誤: ${error.message}`);
    }
}


        // ▼▼▼ 【V3.3 | 邏輯終極修復版】請用這個全新的函數，完整替換舊的 renderCharAlbum 函數 ▼▼▼
        /**
         * 【全新 | V3.2 終極防空窗+生圖開關+描述顯示版】渲染角色相冊
         */
        async function renderCharAlbum() {
            const gridEl = document.getElementById('char-album-grid');
            gridEl.innerHTML = '';
            if (!activeCharacterId) return;
            const char = state.chats[activeCharacterId];
        
            const photos = char.simulatedAlbum || [];
        
            if (photos.length === 0) {
                gridEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">TA的相冊還是空的，<br>點擊右上角刷新按鈕生成一些照片吧！</p>';
                return;
            }
        
            const fallbackImageUrl = `https://i.postimg.cc/KYr2qRCK/1.jpg`;

            photos.forEach(photo => {
                const item = document.createElement('div');
                item.className = 'char-photo-item';
                item.dataset.description = photo.description;
                gridEl.appendChild(item);

                // ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
                //            這就是本次修復的核心所在！
                //  我們現在確保了兩種情況的邏輯是完全獨立的。
                // ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
                
                // 1. 檢查全域的生圖開關是否開啟
                if (state.globalSettings.enableAiDrawing) {
                    // --- 如果開關【開啟】，則只執行生圖相關的邏輯 ---
                    item.style.backgroundColor = '#e9ecef';
                    const containsNonEnglish = /[^\x00-\x7F]/.test(photo.image_prompt);
                    const isValidPrompt = photo.image_prompt && photo.image_prompt.trim() && !containsNonEnglish;
                    const finalPrompt = isValidPrompt ? photo.image_prompt : 'a beautiful scenery, anime style, cinematic lighting';
                    const imageUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(finalPrompt)}`;
                    
                    const img = new Image();
                    img.onload = function() { item.style.backgroundImage = `url(${this.src})`; };
                    img.onerror = function() { item.style.backgroundImage = `url(${fallbackImageUrl})`; };
                    img.src = imageUrl;

                } else {
                    // --- 如果開關【關閉】，則只執行顯示文字描述的邏輯 ---
                    item.style.backgroundColor = '#f0f2f5';
                    item.style.border = '1px solid #e0e0e0';
                    
                    const descriptionEl = document.createElement('p');
                    descriptionEl.className = 'char-photo-description';
                    descriptionEl.textContent = photo.description || '(這張照片沒有描述)';
                    
                    item.appendChild(descriptionEl);
                }
            });
        }
        // ▲▲▲ 替換結束 ▲▲▲
/**
 * 【全新 | V2.2 | JSON解析終極修復版】當用戶點擊“重新生成”時，調用AI生成模擬流覽器歷史
 */
async function handleGenerateBrowserHistory() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];
    if (!chat) return;

    await showCustomAlert("請稍候...", `正在模擬“${chat.name}”的飆網足跡...`);

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('API未配置，無法生成內容。');
        return;
    }
    
    const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? '用戶' : state.qzoneSettings.nickname;

    const longTermMemoryContext = chat.longTermMemory?.map(mem => `- ${mem.content}`).join('\n') || '無';
    const maxMemory = chat.settings.maxMemory || 10;
const recentHistoryWithUser = chat.history.slice(-maxMemory).map(msg => `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
    const worldBookContext = (chat.settings.linkedWorldBookIds || [])
        .map(bookId => state.worldBooks.find(wb => wb.id === bookId))
        .filter(Boolean)
        .map(book => `\n## 世界書《${book.name}》設定:\n${book.content.filter(e => e.enabled).map(e => `- ${e.content}`).join('\n')}`)
        .join('');
// 【【【核心修改：在這裡同時生成更細緻的、多維度的總結】】】
const summary3Hours = generateSummaryForTimeframe(chat, 3, 'hours');
const summary6Hours = generateSummaryForTimeframe(chat, 6, 'hours');
const summary9Hours = generateSummaryForTimeframe(chat, 9, 'hours');
const summaryToday = generateSummaryForTimeframe(chat, 1, 'days');
const summary3Days = generateSummaryForTimeframe(chat, 3, 'days');
const summary7Days = generateSummaryForTimeframe(chat, 7, 'days');

let multiLayeredSummaryContext = '';
if (summary3Hours || summary6Hours || summary9Hours || summaryToday || summary3Days || summary7Days) {
    multiLayeredSummaryContext += `\n# 智慧總結 (基於不同時間維度的對話回顧)\n`;
    if (summary3Hours) multiLayeredSummaryContext += summary3Hours;
    if (summary6Hours) multiLayeredSummaryContext += summary6Hours;
    if (summary9Hours) multiLayeredSummaryContext += summary9Hours;
    if (summary3Hours || summary6Hours || summary9Hours) multiLayeredSummaryContext += '\n';
    if (summaryToday) multiLayeredSummaryContext += summaryToday;
    if (summary3Days) multiLayeredSummaryContext += summary3Days;
    if (summary7Days) multiLayeredSummaryContext += summary7Days;
}
    // ▼▼▼ 核心修改1：強化AI指令 ▼▼▼
    const systemPrompt = `
# 你的任務
你是一個虛擬生活模擬器。你的任務是扮演角色“${chat.name}”，並根據其人設、記憶和最近的互動，虛構出【10到20條】TA最近的流覽器搜索/流覽記錄。

# 核心規則
1.  **創造性與合理性**: 記錄必須完全符合角色的性格、愛好、職業和生活環境。
2.  **多樣性**: 記錄類型要豐富，可以是帖子、文章、新聞、問答等。
3.  **【格式 (最高優先順序)】**: 
    - 你的回復【必須且只能】是一個JSON陣列格式的字串。
    - 你的回復必須以 \`[\` 開始，並以 \`]\` 結束。
    - 【絕對禁止】在JSON陣列前後添加任何多餘的文字、解釋、或 markdown 標記 (如 \`\`\`json)。
    - 陣列中的每個元素都代表一條流覽記錄，並且【必須】使用以下格式:
    \`\`\`json
    [
      {
        "type": "text",
        "title": "一個引人注目的文章或搜索標題",
        "url": "一個虛構的、看起來很真實的網址",
        "content": "一篇200-400字的、詳細的文章或帖子正文，支持分行符號\\n。"
      }
    ]
    \`\`\`
    
    **【絕對禁止】**: 你的回復中【絕對不能】包含 "type": "image" 的對象。所有記錄都必須是文字內容。

# 供你參考的上下文
- **你的角色設定**: ${chat.settings.aiPersona}
- **你的長期記憶**:
${longTermMemoryContext}
${worldBookContext}
${multiLayeredSummaryContext} 
- **你最近和“${userDisplayNameForAI}”的對話摘要**:
${recentHistoryWithUser}

現在，請開始生成這組【純文字】的流覽記錄。`;
    // ▲▲▲ 修改結束 ▲▲▲

    try {
        const messagesForApi = [{ role: 'user', content: "請根據你的設定，生成你的流覽器記錄。" }];
        let isGemini = proxyUrl.includes('generativelanguage');
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
        
        // ▼▼▼ 核心修改2：移除不相容的 response_format 參數 ▼▼▼
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, ...messagesForApi],
                    temperature: state.globalSettings.apiTemperature || 0.9
                    // response_format: { "type": "json_object" } <-- 此行已被刪除
                })
            });
        // ▲▲▲ 修改結束 ▲▲▲

        if (!response.ok) throw new Error(`API 錯誤: ${response.statusText}`);
        
        const data = await response.json();
        const aiResponseContent = getGeminiResponseText(data);
        
        // ▼▼▼ 核心修改3：使用更強大的容錯解析邏輯 ▼▼▼
        const jsonMatch = aiResponseContent.match(/(\[[\s\S]*\])/);
        if (!jsonMatch || !jsonMatch[0]) {
            throw new Error(`AI返回的內容中未找到有效的JSON陣列。原始返回: ${aiResponseContent}`);
        }
        const cleanedJsonString = jsonMatch[0];
        let simulatedHistory;
        try {
            simulatedHistory = JSON.parse(cleanedJsonString);
        } catch (e) {
            throw new Error(`解析AI返回的JSON時出錯: ${e.message}\n\nAI原始返回內容:\n${aiResponseContent}`);
        }
        // ▲▲▲ 修改結束 ▲▲▲
        
        chat.simulatedBrowserHistory = simulatedHistory;
        await db.chats.put(chat);
        
        await renderCharBrowserHistory();
        
    } catch (error) {
        console.error("生成模擬流覽器歷史失敗:", error);
        await showCustomAlert("生成失敗", `無法生成流覽記錄，請檢查API配置或稍後再試。\n錯誤: ${error.message}`);
    }
}
        // ▲▲▲ 替換結束 ▲▲▲
/**
 * 【全新 | V2.0 動態資料版】渲染角色的流覽器歷史記錄清單
 */
function renderCharBrowserHistory() {
    const listEl = document.getElementById('char-browser-history');
    listEl.innerHTML = '';
    if (!activeCharacterId) return;

    const char = state.chats[activeCharacterId];
    const history = char.simulatedBrowserHistory || [];

    if (history.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">TA的流覽器空空如也，<br>點擊右上角刷新按鈕生成一些記錄吧！</p>';
        return;
    }

    history.forEach((item, index) => {
        const entryEl = document.createElement('div');
        entryEl.className = 'char-browser-item';
        entryEl.innerHTML = `
            <div class="title">${item.title}</div>
            <div class="url">${item.url}</div>
        `;
        // 為每個清單項綁定點擊事件，並傳入它在陣列中的索引
        entryEl.addEventListener('click', () => openCharArticle(index));
        listEl.appendChild(entryEl);
    });
}

/**
 * 【全新】打開文章查看頁面
 * @param {number} index - 被點擊的歷史記錄在陣列中的索引
 */
function openCharArticle(index) {
    const char = state.chats[activeCharacterId];
    const articleData = char.simulatedBrowserHistory[index];
    if (!articleData) return;
    
    // 渲染文章內容並切換到文章螢幕
    renderCharArticle(articleData);
    switchToCharScreen('char-browser-article-screen');
}

        /**
         * 【全新】根據文章資料渲染文章查看頁面
         * @param {object} articleData - 單條歷史記錄的資料物件
         */
        function renderCharArticle(articleData) {
            const titleEl = document.getElementById('char-article-title');
            const contentEl = document.getElementById('char-article-content');
            
            titleEl.textContent = articleData.title;
            contentEl.innerHTML = ''; 


            // 我們不再檢查生圖開關，而是直接判斷記錄類型。
            // 如果是圖片類型，就顯示標題作為內容。
            if (articleData.type === 'image') {
                contentEl.innerHTML = `<p class="char-browser-image-description">${articleData.title || '(無標題)'}</p>`;
            } else {
                // 如果是文本類型，正常顯示內容。
                contentEl.innerHTML = `<p>${(articleData.content || '內容載入失敗...').replace(/\n/g, '</p><p>')}</p>`;
            }
            // ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
        }
        // ▲▲▲ 替換結束 ▲▲▲

// ▲▲▲ 全新JS代碼黏貼結束 ▲▲▲
/**
 * 【全新 | V3.2 | 終極網路與邏輯修復版】請用這個全新的函數，完整替換舊的 handleGenerateTaobaoHistory 函數
 */
async function handleGenerateTaobaoHistory() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];
    if (!chat) return;

    await showCustomAlert("請稍候...", `正在模擬“${chat.name}”的購物習慣...`);

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('請先在API設置中配置好API資訊。');
        return;
    }

    const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? '用戶' : state.qzoneSettings.nickname;

    const longTermMemoryContext = chat.longTermMemory?.map(mem => `- ${mem.content}`).join('\n') || '無';
    const maxMemory = chat.settings.maxMemory || 10;
const recentHistoryWithUser = chat.history.slice(-maxMemory).map(msg => `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
    const worldBookContext = (chat.settings.linkedWorldBookIds || [])
        .map(bookId => state.worldBooks.find(wb => wb.id === bookId))
        .filter(Boolean)
        .map(book => `\n## 世界書《${book.name}》設定:\n${book.content.filter(e => e.enabled).map(e => `- ${e.content}`).join('\n')}`)
        .join('');
// 【【【核心修改：在這裡同時生成更細緻的、多維度的總結】】】
const summary3Hours = generateSummaryForTimeframe(chat, 3, 'hours');
const summary6Hours = generateSummaryForTimeframe(chat, 6, 'hours');
const summary9Hours = generateSummaryForTimeframe(chat, 9, 'hours');
const summaryToday = generateSummaryForTimeframe(chat, 1, 'days');
const summary3Days = generateSummaryForTimeframe(chat, 3, 'days');
const summary7Days = generateSummaryForTimeframe(chat, 7, 'days');

let multiLayeredSummaryContext = '';
if (summary3Hours || summary6Hours || summary9Hours || summaryToday || summary3Days || summary7Days) {
    multiLayeredSummaryContext += `\n# 智慧總結 (基於不同時間維度的對話回顧)\n`;
    if (summary3Hours) multiLayeredSummaryContext += summary3Hours;
    if (summary6Hours) multiLayeredSummaryContext += summary6Hours;
    if (summary9Hours) multiLayeredSummaryContext += summary9Hours;
    if (summary3Hours || summary6Hours || summary9Hours) multiLayeredSummaryContext += '\n';
    if (summaryToday) multiLayeredSummaryContext += summaryToday;
    if (summary3Days) multiLayeredSummaryContext += summary3Days;
    if (summary7Days) multiLayeredSummaryContext += summary7Days;
}
    // ▼▼▼ 核心修改1：強化AI指令，確保在沒有強制JSON模式下也能穩定輸出 ▼▼▼
    const systemPrompt = `
# 你的任務
你是一個虛擬生活模擬器。你的任務是扮演角色“${chat.name}”，並根據其人設、記憶和最近的互動，虛構出【12到20條】TA最近的淘寶購物記錄。

# 核心規則
1.  **合理性**: 購買記錄必須完全符合角色的性格、愛好和經濟狀況。
2.  **格式鐵律 (最高優先順序)**: 你的回復【必須且只能】是一個【單一的JSON物件】。你的回復必須以 \`{\` 開始，並以 \`}\` 結束。【絕對禁止】在JSON物件前後添加任何多餘的文字、解釋或 markdown 標記 (如 \`\`\`json)。
    \`\`\`json
    {
      "purchases": [
        {
          "itemName": "一個具體、生動的商品名稱",
          "price": 128.80,
          "status": "已簽收",
          "reason": "這是角色購買這件商品的內心獨白或理由，必須使用第一人稱“我”來寫。",
          "image_prompt": "一段用於生成這張商品圖片的、詳細的【英文】關鍵字, 風格為 realistic product photo, high quality, on a clean white background"
        }
      ]
    }
    \`\`\`
    - **purchases**: 一個包含12到15個商品物件的陣列。
    - **status (訂單狀態)**: 只能從 "已簽收", "待發貨", "運輸中", "待評價" 中選擇。

# 供你參考的上下文
- **你的角色設定**: ${chat.settings.aiPersona}
- **你的長期記憶**:
${longTermMemoryContext}
${worldBookContext}
${multiLayeredSummaryContext} 
- **你最近和“${userDisplayNameForAI}”的對話摘要**:
${recentHistoryWithUser}

現在，請生成包含購買記錄的JSON物件。`;
    // ▲▲▲ 修改結束 ▲▲▲

    try {
        const messagesForApi = [{ role: 'user', content: "請根據你的設定，生成你的淘寶購買記錄。" }];
        
        let isGemini = proxyUrl.includes('generativelanguage.googleapis.com');
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
        
        // ▼▼▼ 核心修改2：移除不相容的 response_format 參數 ▼▼▼
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, ...messagesForApi],
                    temperature: state.globalSettings.apiTemperature || 0.9
                    // response_format: { "type": "json_object" }  <-- 這行已被刪除
                })
            });
        // ▲▲▲ 修改結束 ▲▲▲

        if (!response.ok) throw new Error(`API 錯誤: ${response.statusText}`);
        
        const data = await response.json();
        const aiResponseContent = getGeminiResponseText(data);
        
        // ▼▼▼ 核心修改3：使用更強大的容錯解析邏輯 ▼▼▼
        const jsonMatch = aiResponseContent.match(/({[\s\S]*})/);
        if (!jsonMatch || !jsonMatch[0]) {
            throw new Error(`AI返回的內容中未找到有效的JSON物件。原始返回: ${aiResponseContent}`);
        }
        const cleanedJsonString = jsonMatch[0];
        let simulatedTaobaoData;
        try {
            simulatedTaobaoData = JSON.parse(cleanedJsonString);
        } catch (e) {
            throw new Error(`解析AI返回的JSON時出錯: ${e.message}\n\nAI原始返回內容:\n${aiResponseContent}`);
        }
        // ▲▲▲ 修改結束 ▲▲▲
        
        chat.simulatedTaobaoHistory = simulatedTaobaoData;
        await db.chats.put(chat);
        
        await renderCharTaobao();
        
    } catch (error) {
        console.error("生成類比淘寶記錄失敗:", error);
        await showCustomAlert("生成失敗", `無法生成購物記錄，請檢查API配置或稍後再試。\n錯誤: ${error.message}`);
    }
}

/**
 * 【全新】打開並渲染角色的錢包頁面
 */
function openCharWallet() {
    renderCharWallet();
    switchToCharScreen('char-wallet-screen');
}

/**
 * 【全新】渲染角色的錢包頁面
 */
function renderCharWallet() {
    const contentEl = document.getElementById('char-wallet-content');
    contentEl.innerHTML = '';
    const char = state.chats[activeCharacterId];
    const history = char.simulatedTaobaoHistory || [];

    // 1. 計算總支出
    const totalExpenses = history.reduce((sum, item) => sum + (item.price || 0), 0);

    // 2. 創建並顯示總支出卡片
    const summaryCard = document.createElement('div');
    summaryCard.style.cssText = `
        background-color: #fff;
        padding: 20px;
        border-radius: 12px;
        text-align: center;
        margin-bottom: 20px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.06);
    `;
    summaryCard.innerHTML = `
        <p style="color: #8a8a8a; margin: 0 0 10px 0;">本月總支出</p>
        <p style="font-size: 32px; font-weight: 600; color: #1f1f1f; margin: 0;">¥${totalExpenses.toFixed(2)}</p>
    `;
    contentEl.appendChild(summaryCard);

    // 3. 創建並顯示支出明細
    const detailsTitle = document.createElement('h3');
    detailsTitle.textContent = '支出明細';
    detailsTitle.style.cssText = `font-size: 16px; color: #555; margin-bottom: 10px;`;
    contentEl.appendChild(detailsTitle);

    if (history.length === 0) {
        contentEl.innerHTML += '<p style="text-align:center; color: var(--text-secondary);">暫無支出記錄。</p>';
        return;
    }

    history.forEach(item => {
        const itemEl = document.createElement('div');
        itemEl.style.cssText = `
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 0;
            border-bottom: 1px solid #f0f0f0;
        `;
        itemEl.innerHTML = `
            <div>
                <p style="font-weight: 500; margin: 0 0 4px 0;">${item.itemName}</p>
                <p style="font-size: 12px; color: #8a8a8a; margin: 0;">${item.status}</p>
            </div>
            <div style="font-weight: 600; font-size: 16px; color: #ff5722;">- ¥${(item.price || 0).toFixed(2)}</div>
        `;
        contentEl.appendChild(itemEl);
    });
}
// ▲▲▲ 全新JS代碼黏貼結束 ▲▲▲
        // ▼▼▼ 【V3.0 | 最終修復版】請用這個全新的函數，完整替換舊的 handleGenerateSimulatedMemos 函數 ▼▼▼
/**
 * 【V3.0 | 最終修復版】當用戶點擊“重新生成”時，調用AI生成模擬備忘錄
 */
async function handleGenerateSimulatedMemos() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];
    if (!chat) return;

    await showCustomAlert("請稍候...", `正在請求“${chat.name}”分享TA的備忘錄...`);

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('請先在API設置中配置好API資訊。');
        return;
    }

    const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? '用戶' : state.qzoneSettings.nickname;

    const longTermMemoryContext = chat.longTermMemory?.map(mem => `- ${mem.content}`).join('\n') || '無';
    const maxMemory = chat.settings.maxMemory || 10;
const recentHistoryWithUser = chat.history.slice(-maxMemory).map(msg => `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
    const worldBookContext = (chat.settings.linkedWorldBookIds || [])
        .map(bookId => state.worldBooks.find(wb => wb.id === bookId))
        .filter(Boolean)
        .map(book => `\n## 世界書《${book.name}》設定:\n${book.content.filter(e => e.enabled).map(e => `- ${e.content}`).join('\n')}`)
        .join('');
// 【【【核心修改：在這裡同時生成更細緻的、多維度的總結】】】
const summary3Hours = generateSummaryForTimeframe(chat, 3, 'hours');
const summary6Hours = generateSummaryForTimeframe(chat, 6, 'hours');
const summary9Hours = generateSummaryForTimeframe(chat, 9, 'hours');
const summaryToday = generateSummaryForTimeframe(chat, 1, 'days');
const summary3Days = generateSummaryForTimeframe(chat, 3, 'days');
const summary7Days = generateSummaryForTimeframe(chat, 7, 'days');

let multiLayeredSummaryContext = '';
if (summary3Hours || summary6Hours || summary9Hours || summaryToday || summary3Days || summary7Days) {
    multiLayeredSummaryContext += `\n# 智慧總結 (基於不同時間維度的對話回顧)\n`;
    if (summary3Hours) multiLayeredSummaryContext += summary3Hours;
    if (summary6Hours) multiLayeredSummaryContext += summary6Hours;
    if (summary9Hours) multiLayeredSummaryContext += summary9Hours;
    if (summary3Hours || summary6Hours || summary9Hours) multiLayeredSummaryContext += '\n';
    if (summaryToday) multiLayeredSummaryContext += summaryToday;
    if (summary3Days) multiLayeredSummaryContext += summary3Days;
    if (summary7Days) multiLayeredSummaryContext += summary7Days;
}
    // ▼▼▼ 核心修改1：強化AI指令 ▼▼▼
    const systemPrompt = `
# 你的任務
你是一個虛擬生活模擬器。你的任務是扮演角色“${chat.name}”，並根據其人設、記憶和最近的互動，虛構出【12到20條】TA最近可能會寫在手機備忘錄裡的內容。

# 核心規則
1.  **創造性與合理性**: 備忘錄內容必須完全符合角色的性格、愛好、職業和生活環境。可以是購物清單、待辦事項、靈感片段、一些隨筆和感悟、草稿等。
2.  **格式鐵律 (最高優先順序)**: 
    - 你的回復【必須且只能】是一個JSON陣列格式的字串。
    - 你的回復必須以 \`[\` 開始，並以 \`]\` 結束。
    - 【絕對禁止】在JSON陣列前後添加任何多餘的文字、解釋、或 markdown 標記 (如 \`\`\`json)。
    - 陣列中的每個元素都是一個物件，代表一條備忘錄，格式【必須】如下:
    \`\`\`json
    [
      {
        "title": "備忘錄的標題，例如：購物清單 或 週末計畫",
        "content": "備忘錄的詳細內容，必須支援分行符號\\n。"
      }
    ]
    \`\`\`

# 供你參考的上下文
- **你的角色設定**: ${chat.settings.aiPersona}
- **你的長期記憶**:
${longTermMemoryContext}
${worldBookContext}
${multiLayeredSummaryContext}
- **你最近和“${userDisplayNameForAI}”的對話摘要**:
${recentHistoryWithUser}

現在，請開始生成這組備忘錄。`;
    // ▲▲▲ 修改結束 ▲▲▲

    try {
        const messagesForApi = [{ role: 'user', content: "請根據你的設定，生成你的備忘錄內容。" }];
        let isGemini = proxyUrl.includes('generativelanguage');
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
        
        // ▼▼▼ 核心修改2：移除不相容的 response_format 參數 ▼▼▼
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, ...messagesForApi],
                    temperature: state.globalSettings.apiTemperature || 0.9
                    // 同樣移除 response_format
                })
            });
        // ▲▲▲ 修改結束 ▲▲▲

        if (!response.ok) {
             const errorData = await response.json().catch(() => null);
             const errorMessage = errorData?.error?.message || response.statusText;
             throw new Error(`API 錯誤: ${response.status} - ${errorMessage}`);
        }
        
        const data = await response.json();
        const aiResponseContent = getGeminiResponseText(data);
        
        // ▼▼▼ 核心修改3：使用更強大的容錯解析邏輯 ▼▼▼
        const jsonMatch = aiResponseContent.match(/(\[[\s\S]*\])/);
        if (!jsonMatch || !jsonMatch[0]) {
            throw new Error(`AI返回的內容中未找到有效的JSON陣列。原始返回: ${aiResponseContent}`);
        }
        const cleanedJsonString = jsonMatch[0];
        let simulatedMemos;
        try {
            simulatedMemos = JSON.parse(cleanedJsonString);
        } catch (e) {
            throw new Error(`解析AI返回的JSON時出錯: ${e.message}\n\nAI原始返回內容:\n${aiResponseContent}`);
        }
        // ▲▲▲ 修改結束 ▲▲▲
        
        if (!Array.isArray(simulatedMemos)) {
            throw new Error(`AI返回的資料不是一個陣列。原始返回: ${JSON.stringify(simulatedMemos)}`);
        }

        chat.memos = simulatedMemos.map(memo => ({
            id: Date.now() + Math.random(),
            title: memo.title,
            content: memo.content
        }));
        
        await db.chats.put(chat);
        await renderCharMemoList();
        
    } catch (error) {
        console.error("生成模擬備忘錄失敗:", error);
        await showCustomAlert("生成失敗", `無法生成備忘錄，請檢查API配置或稍後再試。\n錯誤: ${error.message}`);
    }
}
        // ▲▲▲ 替換結束 ▲▲▲
        // ▼▼▼ 【全新V2.0 | 最終修復版】請用這個全新的函數，完整替換舊的 handleGenerateAmapHistory 函數 ▼▼▼
/**
 * 【全新 | V2.0 最終修復版】當用戶點擊“重新生成”時，調用AI生成模擬足跡
 */
async function handleGenerateAmapHistory() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];
    if (!chat) return;

    await showCustomAlert("請稍候...", `正在生成“${chat.name}”的出行足跡...`);

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('API未配置，無法生成內容。');
        return;
    }
    
    const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? '用戶' : state.qzoneSettings.nickname;
    const longTermMemoryContext = chat.longTermMemory?.map(mem => `- ${mem.content}`).join('\n') || '無';
    const maxMemory = chat.settings.maxMemory || 10;
const recentHistoryWithUser = chat.history.slice(-maxMemory).map(msg => `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
    const worldBookContext = (chat.settings.linkedWorldBookIds || [])
        .map(bookId => state.worldBooks.find(wb => wb.id === bookId))
        .filter(Boolean)
        .map(book => `\n## 世界書《${book.name}》設定:\n${book.content.filter(e => e.enabled).map(e => `- ${e.content}`).join('\n')}`)
        .join('');
const summary3Hours = generateSummaryForTimeframe(chat, 3, 'hours');
const summary6Hours = generateSummaryForTimeframe(chat, 6, 'hours');
const summary9Hours = generateSummaryForTimeframe(chat, 9, 'hours');
const summaryToday = generateSummaryForTimeframe(chat, 1, 'days');
const summary3Days = generateSummaryForTimeframe(chat, 3, 'days');
const summary7Days = generateSummaryForTimeframe(chat, 7, 'days');

let multiLayeredSummaryContext = '';
if (summary3Hours || summary6Hours || summary9Hours || summaryToday || summary3Days || summary7Days) {
    multiLayeredSummaryContext += `\n# 智慧總結 (基於不同時間維度的對話回顧)\n`;
    if (summary3Hours) multiLayeredSummaryContext += summary3Hours;
    if (summary6Hours) multiLayeredSummaryContext += summary6Hours;
    if (summary9Hours) multiLayeredSummaryContext += summary9Hours;
    if (summary3Hours || summary6Hours || summary9Hours) multiLayeredSummaryContext += '\n';
    if (summaryToday) multiLayeredSummaryContext += summaryToday;
    if (summary3Days) multiLayeredSummaryContext += summary3Days;
    if (summary7Days) multiLayeredSummaryContext += summary7Days;
}
    // ▼▼▼ 核心修改1：強化AI指令 ▼▼▼
    const systemPrompt = `
# 你的任務
你是一個虛擬生活模擬器。你的任務是扮演角色“${chat.name}”，並根據其人設、記憶和最近的互動，虛構出【12到20條】TA最近的“高德地圖”出行足跡。

# 核心規則
1.  **【時間 (最高優先順序)】**:
    -   今天的日期是 **${new Date().toISOString()}**。
    -   你生成的【所有】足跡的 \`timestamp\` 欄位，【必須】是今天或今天以前的日期。
    -   【絕對禁止】生成任何未來的日期！
    -   請生成一個看起來像是過去幾周內的、時間【從新到舊】排列的足跡列表。
2.  **創造性與合理性**: 足跡必須完全符合角色的性格、愛好、職業和生活環境。
3.  **多樣性**: 地點類型要豐富，可以包括餐廳、商場、公園、公司、朋友家等。
4.  **【格式鐵律 (最高優先順序)】**: 
    - 你的回復【必須且只能】是一個JSON陣列格式的字串。
    - 你的回復必須以 \`[\` 開始，並以 \`]\` 結束。
    - 【絕對禁止】在JSON陣列前後添加任何多餘的文字、解釋、或 markdown 標記 (如 \`\`\`json)。
    - 陣列中的每個元素都是一個物件，代表一條足跡，格式【必須】如下:
    \`\`\`json
    [
      {
        "locationName": "一個具體、生動的地點名稱",
        "address": "一個虛構但看起來很真實的詳細地址",
        "comment": "這是角色對這次出行或這個地點的內心獨白或評論，必須使用第一人稱“我”來寫。",
        "image_prompt": "(可選)一段用於生成這張地點照片的、詳細的【英文】關鍵字, 風格為 realistic photo, high quality",
        "timestamp": "符合 ISO 8601 格式的日期時間字串 (例如: '2025-09-25T18:30:00Z')"
      }
    ]
    \`\`\`
    - **重要**: 大約有【三分之一】的足跡需要包含 \`image_prompt\` 欄位來生成一張照片。
    - **圖片**: image_prompt 生成的圖片【絕對禁止包含真人】。如果地點是室內，可以生成空無一人的場景；如果是室外，可以只有風景或建築。

# 供你參考的上下文
- **你的角色設定**: ${chat.settings.aiPersona}
- **你的長期記憶**:
${longTermMemoryContext}
${worldBookContext}
${multiLayeredSummaryContext}
- **你最近和“${userDisplayNameForAI}”的對話摘要**:
${recentHistoryWithUser}

現在，請開始生成這組足跡記錄。`;
    // ▲▲▲ 修改結束 ▲▲▲

    try {
        const messagesForApi = [{ role: 'user', content: "請根據你的設定，生成你的高德地圖足跡。" }];
        let isGemini = proxyUrl.includes('generativelanguage');
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
        
        // ▼▼▼ 核心修改2：移除不相容的 response_format 參數 ▼▼▼
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, ...messagesForApi],
                    temperature: state.globalSettings.apiTemperature || 0.9
                    // response_format: { "type": "json_object" } <-- 此行已被刪除
                })
            });
        // ▲▲▲ 修改結束 ▲▲▲

        if (!response.ok) throw new Error(`API 錯誤: ${response.statusText}`);
        
        const data = await response.json();
        const aiResponseContent = getGeminiResponseText(data);
        
        // ▼▼▼ 核心修改3：使用更強大的容錯解析邏輯 ▼▼▼
        const jsonMatch = aiResponseContent.match(/(\[[\s\S]*\])/);
        if (!jsonMatch || !jsonMatch[0]) {
            throw new Error(`AI返回的內容中未找到有效的JSON陣列。原始返回: ${aiResponseContent}`);
        }
        const cleanedJsonString = jsonMatch[0];
        let simulatedAmapData;
        try {
            simulatedAmapData = JSON.parse(cleanedJsonString);
        } catch (e) {
            throw new Error(`解析AI返回的JSON時出錯: ${e.message}\n\nAI原始返回內容:\n${aiResponseContent}`);
        }
        // ▲▲▲ 修改結束 ▲▲▲
        
        chat.simulatedAmapHistory = simulatedAmapData;
        await db.chats.put(chat);
        
        await renderCharAmap();
        
    } catch (error) {
        console.error("生成模擬足跡失敗:", error);
        await showCustomAlert("生成失敗", `無法生成足跡，請檢查API配置或稍後再試。\n錯誤: ${error.message}`);
    }
}

        /**
         * 【全新 | V2.0 最終修復版】渲染角色的高德地圖足跡列表
         */
        function renderCharAmap() {
            const listEl = document.getElementById('char-amap-list');
            listEl.innerHTML = '';
            if (!activeCharacterId) return;

            const char = state.chats[activeCharacterId];
            const history = char.simulatedAmapHistory || [];

            if (history.length === 0) {
                listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">這裡還沒有留下任何足跡，<br>點擊右上角刷新按鈕生成一些記錄吧！</p>';
                return;
            }

            // ▼▼▼ 核心修復3：在這裡使用 AI 提供的時間戳記 ▼▼▼
            history.forEach(item => {
                const itemEl = document.createElement('div');
                itemEl.className = 'char-amap-item';
                
                let photoHtml = '';
                if (item.image_prompt) {
                    const imageUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(item.image_prompt)}`;
                    photoHtml = `<div class="amap-item-photo" style="background-image: url('${imageUrl}')" data-comment="${item.comment}"></div>`;
                }

                // 使用我們之前創建的 formatTimeAgo 函數來格式化時間
                const timeAgo = item.timestamp ? formatTimeAgo(new Date(item.timestamp).getTime()) : '某個時間';

                itemEl.innerHTML = `
                    <div class="amap-item-header">
                        <div class="amap-item-icon">📍</div>
                        <div class="amap-item-info">
                            <div class="amap-item-title">${item.locationName}</div>
                            <div class="amap-item-address">${item.address}</div>
                        </div>
                    </div>
                    <div class="amap-item-body">
                        <div class="amap-item-comment">${item.comment.replace(/\n/g, '<br>')}</div>
                        ${photoHtml}
                    </div>
                    <div class="amap-item-footer">${timeAgo}</div>
                `;
                listEl.appendChild(itemEl);
            });
            // ▲▲▲ 修復結束 ▲▲▲
        }

// ▲▲▲ 全新JS代碼黏貼結束 ▲▲▲
/**
 * 【全新 V3.0 | 支援AI繪圖】當用戶點擊“重新生成”時，調用AI生成類比App使用記錄
 */
async function handleGenerateAppUsage() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];
    if (!chat) return;

    await showCustomAlert("請稍候...", `正在分析“${chat.name}”的手機使用習慣...`);

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('API未配置，無法生成內容。');
        return;
    }
    
    const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? '用戶' : state.qzoneSettings.nickname;

    const longTermMemoryContext = chat.longTermMemory?.map(mem => `- ${mem.content}`).join('\n') || '無';
    const maxMemory = chat.settings.maxMemory || 10;
const recentHistoryWithUser = chat.history.slice(-maxMemory).map(msg => `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
    const worldBookContext = (chat.settings.linkedWorldBookIds || [])
        .map(bookId => state.worldBooks.find(wb => wb.id === bookId))
        .filter(Boolean)
        .map(book => `\n## 世界書《${book.name}》設定:\n${book.content.filter(e => e.enabled).map(e => `- ${e.content}`).join('\n')}`)
        .join('');
const summary3Hours = generateSummaryForTimeframe(chat, 3, 'hours');
const summary6Hours = generateSummaryForTimeframe(chat, 6, 'hours');
const summary9Hours = generateSummaryForTimeframe(chat, 9, 'hours');
const summaryToday = generateSummaryForTimeframe(chat, 1, 'days');
const summary3Days = generateSummaryForTimeframe(chat, 3, 'days');
const summary7Days = generateSummaryForTimeframe(chat, 7, 'days');

let multiLayeredSummaryContext = '';
if (summary3Hours || summary6Hours || summary9Hours || summaryToday || summary3Days || summary7Days) {
    multiLayeredSummaryContext += `\n# 智慧總結 (基於不同時間維度的對話回顧)\n`;
    if (summary3Hours) multiLayeredSummaryContext += summary3Hours;
    if (summary6Hours) multiLayeredSummaryContext += summary6Hours;
    if (summary9Hours) multiLayeredSummaryContext += summary9Hours;
    if (summary3Hours || summary6Hours || summary9Hours) multiLayeredSummaryContext += '\n';
    if (summaryToday) multiLayeredSummaryContext += summaryToday;
    if (summary3Days) multiLayeredSummaryContext += summary3Days;
    if (summary7Days) multiLayeredSummaryContext += summary7Days;
}
    // ▼▼▼ 核心修改1：強化AI指令 ▼▼▼
    const systemPrompt = `
# 你的任務
你是一個虛擬生活模擬器。你的任務是扮演角色“${chat.name}”，並根據其人設、記憶和最近的互動，虛構出TA最近一天的【手機App螢幕使用時間】記錄，總共約20條。

# 核心規則
1.  **創造性與多樣性**: 生成的App列表【不必局限於】Cphone主螢幕上已有的App。你可以自由地虛構TA可能使用的其他App，例如 Instagram, Twitter, 各種遊戲 (如：原神, 王者榮耀), 視頻App (如：抖音, YouTube), 學習或工作軟體等，這能更好地體現角色的隱藏興趣和生活習慣。
2.  **合理性**: 使用時長和App類型必須完全符合角色的性格、愛好、職業和生活環境。
3.  **格式鐵律 (最高優先順序)**: 
    - 你的回復【必須且只能】是一個JSON陣列格式的字串。
    - 你的回復必須以 \`[\` 開始，並以 \`]\` 結束。
    - 【絕對禁止】在JSON陣列前後添加任何多餘的文字、解釋、或 markdown 標記 (如 \`\`\`json)。
    - 陣列中的每個元素都是一個物件，代表一個App的使用記錄，格式【必須】如下:
    \`\`\`json
    [
      {
        "appName": "App的名稱 (例如: 微信, 微博, 原神)",
        "usageTimeMinutes": 125,
        "category": "App的分類 (例如: 社交, 遊戲, 影音, 工具, 閱讀, 購物)",
        "image_prompt": "一段用於生成這個App【圖示】的、簡潔的【英文】關鍵字。風格必須是 modern app icon, flat design, simple, clean background"
      }
    ]
    \`\`\`

# 供你參考的上下文
- **你的角色設定**: ${chat.settings.aiPersona}
- **你的長期記憶**:
${longTermMemoryContext}
${worldBookContext}
${multiLayeredSummaryContext}
- **你最近和“${userDisplayNameForAI}”的對話摘要**:
${recentHistoryWithUser}

現在，請開始生成這組App使用記錄。`;
    // ▲▲▲ 修改結束 ▲▲▲

    try {
        const messagesForApi = [{ role: 'user', content: "請根據你的設定，生成你的App使用記錄。" }];
        let isGemini = proxyUrl.includes('generativelanguage');
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
        
        // ▼▼▼ 核心修改2：移除不相容的 response_format 參數 ▼▼▼
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, ...messagesForApi],
                    temperature: state.globalSettings.apiTemperature || 0.9
                    // response_format: { "type": "json_object" } <-- 此行已被刪除
                })
            });
        // ▲▲▲ 修改結束 ▲▲▲

        if (!response.ok) throw new Error(`API 錯誤: ${response.statusText}`);
        
        const data = await response.json();
        const aiResponseContent = getGeminiResponseText(data);
        const cleanedJson = aiResponseContent.replace(/^```json\s*/, '').replace(/```$/, '');
        
        const simulatedUsageData = JSON.parse(cleanedJson);
        
        chat.simulatedAppUsage = simulatedUsageData;
        await db.chats.put(chat);
        
        await renderCharAppUsage();
        
    } catch (error) {
        console.error("生成類比App使用記錄失敗:", error);
        await showCustomAlert("生成失敗", `無法生成記錄，請檢查API配置或稍後再試。\n錯誤: ${error.message}`);
    }
}

        /**
         * 【全新 V2.0 | AI繪圖版】渲染角色的App使用記錄清單
         */
        function renderCharAppUsage() {
            const listEl = document.getElementById('char-usage-list');
            listEl.innerHTML = '';
            if (!activeCharacterId) return;

            const char = state.chats[activeCharacterId];
            const usageData = (char.simulatedAppUsage || []).sort((a, b) => b.usageTimeMinutes - a.usageTimeMinutes);

            if (usageData.length === 0) {
                listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">這裡還沒有任何使用記錄，<br>點擊右上角刷新按鈕生成一些吧！</p>';
                return;
            }

            usageData.forEach(item => {
                const itemEl = document.createElement('div');
                itemEl.className = 'char-usage-item';
                
                const hours = Math.floor(item.usageTimeMinutes / 60);
                const minutes = item.usageTimeMinutes % 60;
                let timeString = '';
                if (hours > 0) timeString += `${hours}小時`;
                if (minutes > 0) timeString += `${minutes}分鐘`;
                if (!timeString) timeString = '小於1分鐘';

                // ▼▼▼ 【核心修改：動態生成圖示URL】 ▼▼▼
                // 1. 如果AI提供了image_prompt，就使用它；否則，提供一個通用的備用指令
                const prompt = item.image_prompt || `modern app icon for ${item.appName}, flat design, simple`;
                // 2. 使用AI繪畫API生成圖示
                const iconUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(prompt)}`;
                // ▲▲▲ 修改結束 ▲▲▲

                itemEl.innerHTML = `
                    <img src="${iconUrl}" class="usage-item-icon">
                    <div class="usage-item-info">
                        <div class="usage-item-name">${item.appName}</div>
                        <div class="usage-item-category">${item.category}</div>
                    </div>
                    <div class="usage-item-time">${timeString}</div>
                `;
                listEl.appendChild(itemEl);
            });
        }
// ▲▲▲ 全新JS代碼黏貼結束 ▲▲▲
/**
 * 【全新 V2.0 | 最終相容版】當用戶點擊“重新生成”時，調用AI生成模擬歌單
 */
async function handleGenerateSimulatedMusic() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];
    if (!chat) return;

    await showCustomAlert("請稍候...", `正在請求“${chat.name}”分享TA的私人歌單...`);

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('請先在API設置中配置好API資訊。');
        return;
    }
    
    const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? '用戶' : state.qzoneSettings.nickname;

    const longTermMemoryContext = chat.longTermMemory?.map(mem => `- ${mem.content}`).join('\n') || '無';
    const maxMemory = chat.settings.maxMemory || 10;
const recentHistoryWithUser = chat.history.slice(-maxMemory).map(msg => `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
    const worldBookContext = (chat.settings.linkedWorldBookIds || [])
        .map(bookId => state.worldBooks.find(wb => wb.id === bookId))
        .filter(Boolean)
        .map(book => `\n## 世界書《${book.name}》設定:\n${book.content.filter(e => e.enabled).map(e => `- ${e.content}`).join('\n')}`)
        .join('');

    // ▼▼▼ 核心修改1：強化AI指令 ▼▼▼
    const systemPrompt = `
# 你的任務
你是一個虛擬音樂品味模擬器。你的任務是扮演角色“${chat.name}”，並根據其人設、記憶和最近的互動，挑選出【14到18首】最能代表TA此刻心情或品味的歌曲。

# 核心規則
1.  **創造性與合理性**: 歌單必須完全符合角色的性格、愛好和生活背景。
2.  **多樣性**: 歌曲風格可以多樣，但必須邏輯自洽。
3.  **格式鐵律 (最高優先順序)**: 
    - 你的回復【必須且只能】是一個JSON陣列格式的字串。
    - 你的回復必須以 \`[\` 開始，並以 \`]\` 結束。
    - 【絕對禁止】在JSON陣列前後添加任何多餘的文字、解釋、或 markdown 標記 (如 \`\`\`json)。
    - 陣列中的每個元素都是一個物件，代表一首歌，格式【必須】如下:
    \`\`\`json
    [
      {
        "songName": "歌曲的準確名稱",
        "artistName": "歌曲的準確藝術家/歌手名"
      }
    ]
    \`\`\`

# 供你參考的上下文
- **你的角色設定**: ${chat.settings.aiPersona}
- **你的長期記憶**:
${longTermMemoryContext}
${worldBookContext}
- **你最近和“${userDisplayNameForAI}”的對話摘要**:
${recentHistoryWithUser}

現在，請生成這份歌單。`;
    // ▲▲▲ 修改結束 ▲▲▲

    try {
        const messagesForApi = [{ role: 'user', content: "請根據你的設定，生成你的歌單。" }];
        let isGemini = proxyUrl.includes('generativelanguage');
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
        
        // ▼▼▼ 核心修改2：此函數之前沒有 response_format，無需刪除，但我們確保其他部分是健壯的 ▼▼▼
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, ...messagesForApi],
                    temperature: state.globalSettings.apiTemperature || 1.0,
                })
            });
        // ▲▲▲ 修改結束 ▲▲▲

        if (!response.ok) throw new Error(`API 錯誤: ${response.statusText}`);
        
        const data = await response.json();
        const aiResponseContent = getGeminiResponseText(data);
        const cleanedJson = aiResponseContent.replace(/^```json\s*/, '').replace(/```$/, '');
        const songPicks = JSON.parse(cleanedJson);

        await showCustomAlert("請稍候...", `歌單已生成，正在從網路獲取 ${songPicks.length} 首歌曲的詳細資訊...`);

        const songDetailPromises = songPicks.map(async (pick) => {
            let searchResults = await searchNeteaseMusic(pick.songName, pick.artistName);
            if (!searchResults || searchResults.length === 0) {
                searchResults = await searchTencentMusic(pick.songName);
            }
            if (searchResults.length > 0) {
                return getPlayableSongDetails(searchResults[0]);
            }
            console.warn(`所有音樂源都未能找到歌曲：“${pick.songName} - ${pick.artistName}”`);
            return null;
        });

        const fullSongObjects = (await Promise.all(songDetailPromises)).filter(Boolean);

        chat.simulatedMusicPlaylist = fullSongObjects;
        await db.chats.put(chat);
        
        await renderCharMusicScreen();
        
    } catch (error) {
        console.error("生成模擬歌單失敗:", error);
        await showCustomAlert("生成失敗", `無法生成歌單，請檢查API配置或稍後再試。\n錯誤: ${error.message}`);
    }
}

/**
 * 【全新】渲染角色的網易雲音樂清單
 */
function renderCharMusicScreen() {
    const listEl = document.getElementById('char-music-list');
    listEl.innerHTML = '';
    if (!activeCharacterId) return;

    const char = state.chats[activeCharacterId];
    const playlist = char.simulatedMusicPlaylist || [];

    if (playlist.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">TA的歌單還是空的，<br>點擊右上角刷新按鈕生成一些歌曲吧！</p>';
        return;
    }

    playlist.forEach((track, index) => {
        const itemEl = document.createElement('div');
        itemEl.className = 'char-music-item';
        itemEl.innerHTML = `
            <img src="${track.cover}" class="music-item-cover">
            <div class="music-item-info">
                <div class="music-item-name">${track.name}</div>
                <div class="music-item-artist">${track.artist}</div>
            </div>
        `;
        // 為每個清單項綁定點擊事件，並傳入完整的歌曲物件
        itemEl.addEventListener('click', () => playCharSong(track));
        listEl.appendChild(itemEl);
    });
}

/* ▼▼▼ 請用這整塊【全新 V3.0 JS代碼】，完整替換所有舊的 char-player-modal 相關JS ▼▼▼ */

let charPlayerState = {
    currentPlaylist: [],
    currentIndex: -1,
    isPlaying: false,
    playMode: 'order', // 'order', 'random', 'single'
    lrcUpdateInterval: null,
    // 【核心新增】
    parsedLyrics: [],
    currentLyricIndex: -1
};

/**
 * 播放Cphone中的歌曲 (V3.0 - 適配新UI和歌詞)
 * @param {object} songObject - 包含所有資訊的完整歌曲物件
 */
function playCharSong(songObject) {
    const player = document.getElementById('char-audio-player');
    const modal = document.getElementById('char-music-player-modal');
    
    if (charPlayerState.lrcUpdateInterval) clearInterval(charPlayerState.lrcUpdateInterval);
    player.pause();
    
    const songIndex = charPlayerState.currentPlaylist.findIndex(s => s.src === songObject.src);
    if (songIndex > -1) {
        charPlayerState.currentIndex = songIndex;
    } else {
        charPlayerState.currentPlaylist = [songObject];
        charPlayerState.currentIndex = 0;
    }

    // 更新UI
    document.getElementById('char-music-player-title').textContent = songObject.name;
    document.getElementById('char-music-artist').textContent = songObject.artist;
    document.getElementById('char-music-cover').src = songObject.cover;
    
    // 【核心新增】解析歌詞
    charPlayerState.parsedLyrics = parseLRC(songObject.lrcContent || "");
    renderCharLyrics(); // 渲染歌詞

    // 設置音訊源並播放
    if (songObject.isLocal) {
        const blob = new Blob([songObject.src], { type: songObject.fileType || 'audio/mpeg' });
        player.src = URL.createObjectURL(blob);
    } else {
        player.src = songObject.src;
    }
    player.play().catch(e => console.error("音訊播放失敗:", e));

    player.onloadedmetadata = () => {
        document.getElementById('char-music-total-time').textContent = formatMusicTime(player.duration);
        charPlayerState.lrcUpdateInterval = setInterval(updateCharMusicProgress, 500);
    };

    modal.classList.add('visible');
}

/**
 * 關閉Cphone的音樂播放機 (V3.0)
 */
function closeCharMusicPlayer() {
    const modal = document.getElementById('char-music-player-modal');
    const player = document.getElementById('char-audio-player');
    
    if (charPlayerState.lrcUpdateInterval) clearInterval(charPlayerState.lrcUpdateInterval);
    player.pause();
    player.src = ''; 
    modal.classList.remove('visible');
    charPlayerState.isPlaying = false;
    document.getElementById('char-vinyl-container').classList.remove('spinning');
}

/**
 * 更新播放機進度條、時間和歌詞 (核心修改)
 */
function updateCharMusicProgress() {
    const player = document.getElementById('char-audio-player');
    if (!player.duration) return;

    const currentTime = player.currentTime;
    const duration = player.duration;
    document.getElementById('char-music-progress-fill').style.width = `${(currentTime / duration) * 100}%`;
    document.getElementById('char-music-current-time').textContent = formatMusicTime(currentTime);

    // 【核心新增】調用歌詞更新函數
    updateCharActiveLyric(currentTime);
}


/**
 * 【全新】渲染角色播放機的歌詞列表
 */
function renderCharLyrics() {
    const lyricsContainer = document.getElementById('char-music-lyrics');
    lyricsContainer.innerHTML = '';
    charPlayerState.currentLyricIndex = -1; // 重置索引
    if (!charPlayerState.parsedLyrics || charPlayerState.parsedLyrics.length === 0) {
        lyricsContainer.innerHTML = '<p>♪ 暫無歌詞 ♪</p>';
        return;
    }
    charPlayerState.parsedLyrics.forEach((line, index) => {
        const p = document.createElement('p');
        p.textContent = line.text;
        p.dataset.index = index;
        lyricsContainer.appendChild(p);
    });
}

/**
 * 【全新】更新當前高亮的歌詞
 */
function updateCharActiveLyric(currentTime) {
    const lyrics = charPlayerState.parsedLyrics;
    if (lyrics.length === 0) return;

    let newLyricIndex = -1;
    for (let i = 0; i < lyrics.length; i++) {
        if (currentTime >= lyrics[i].time) {
            newLyricIndex = i;
        } else {
            break;
        }
    }
    if (newLyricIndex === charPlayerState.currentLyricIndex) return;
    charPlayerState.currentLyricIndex = newLyricIndex;
    
    // 更新UI
    const lyricsContainer = document.getElementById('char-music-lyrics');
    const lines = lyricsContainer.querySelectorAll('p');
    lines.forEach(line => line.classList.remove('active'));
    
    if (newLyricIndex > -1) {
        const activeLine = lyricsContainer.querySelector(`p[data-index="${newLyricIndex}"]`);
        if (activeLine) {
            activeLine.classList.add('active');
            // 計算滾動位置，使當前行居中
            const offset = (lyricsContainer.clientHeight / 2) - activeLine.offsetTop - (activeLine.offsetHeight / 2);
            lines.forEach(line => {
                line.style.transform = `translateY(${offset}px)`;
            });
        }
    }
}


/**
 * 播放下一首歌
 */
function playNextCharSong() {
    if (charPlayerState.currentPlaylist.length === 0) return;
    let nextIndex;
    switch(charPlayerState.playMode) {
        case 'random':
            nextIndex = Math.floor(Math.random() * charPlayerState.currentPlaylist.length);
            break;
        case 'single':
            // 單曲迴圈，重新播放當前歌曲
            playCharSong(charPlayerState.currentPlaylist[charPlayerState.currentIndex]);
            return;
        case 'order':
        default:
            nextIndex = (charPlayerState.currentIndex + 1) % charPlayerState.currentPlaylist.length;
            break;
    }
    playCharSong(charPlayerState.currentPlaylist[nextIndex]);
}

/**
 * 播放上一首歌
 */
function playPrevCharSong() {
    if (charPlayerState.currentPlaylist.length === 0) return;
    const newIndex = (charPlayerState.currentIndex - 1 + charPlayerState.currentPlaylist.length) % charPlayerState.currentPlaylist.length;
    playCharSong(charPlayerState.currentPlaylist[newIndex]);
}

/**
 * 切換播放模式
 */
function changeCharPlayMode() {
    const modes = ['order', 'random', 'single'];
    const currentModeIndex = modes.indexOf(charPlayerState.playMode);
    charPlayerState.playMode = modes[(currentModeIndex + 1) % modes.length];
    document.getElementById('char-music-mode-btn').textContent = {'order': '順序', 'random': '隨機', 'single': '單曲'}[charPlayerState.playMode];
}


/**
 * 【總入口】為新播放機的所有按鈕和事件綁定功能
 */
function setupCharPlayerControls() {
    const player = document.getElementById('char-audio-player');
    const playBtn = document.getElementById('char-music-play-pause-btn');
    const vinyl = document.getElementById('char-vinyl-container');

    playBtn.addEventListener('click', () => {
        if (player.paused) {
            if(charPlayerState.currentIndex > -1) player.play();
        } else {
            player.pause();
        }
    });
    
    player.onplay = () => {
        playBtn.innerHTML = `<svg viewBox="0 0 24 24" width="32" height="32" fill="currentColor"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"></path></svg>`;
        vinyl.classList.add('spinning');
        charPlayerState.isPlaying = true;
    };
    player.onpause = () => {
        playBtn.innerHTML = `<svg viewBox="0 0 24 24" width="32" height="32" fill="currentColor"><path d="M8 5v14l11-7z"></path></svg>`;
        vinyl.classList.remove('spinning');
        charPlayerState.isPlaying = false;
    };
    player.onended = () => {
        vinyl.classList.remove('spinning');
        charPlayerState.isPlaying = false;
        playNextCharSong();
    };

    document.getElementById('char-music-prev-btn').addEventListener('click', playPrevCharSong);
    document.getElementById('char-music-next-btn').addEventListener('click', playNextCharSong);
    document.getElementById('char-music-mode-btn').addEventListener('click', changeCharPlayMode);

    document.getElementById('char-music-progress-bar').addEventListener('click', (e) => {
        if (!player.duration) return;
        const bar = e.currentTarget;
        const clickX = e.offsetX;
        player.currentTime = (clickX / bar.clientWidth) * player.duration;
    });
}
/* ▲▲▲ JS代碼替換結束 ▲▲▲ */
// ▼▼▼ 【全新 | V3.2 | 雙重身份驗證版】請用這個新版本替換舊的 renderDoubanScreen 函數 ▼▼▼
/**
 * 【總入口】渲染豆瓣小組螢幕
 */
async function renderDoubanScreen() {
    const listEl = document.getElementById('douban-posts-list');
    listEl.innerHTML = '';
    
    const posts = await db.doubanPosts.orderBy('timestamp').reverse().toArray();

    if (posts.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">這裡空空如也，<br>點擊右上角刷新按鈕，看看大家都在聊什麼吧！</p>';
        return;
    }

    posts.forEach(post => {
        let avatarUrl;
        
        // --- 核心修改：全新的“雙重驗證”頭像查找邏輯 ---
        // 1. 優先通過“身份證”(authorOriginalName)查找
        const authorChatByOriginalName = post.authorOriginalName 
            ? Object.values(state.chats).find(c => !c.isGroup && c.name === post.authorOriginalName) 
            : null;

        if (authorChatByOriginalName) {
            // 如果通過“身份證”找到了，就用這個角色的真實頭像
            avatarUrl = authorChatByOriginalName.settings.aiAvatar;
        } else {
            // 2. 如果沒有“身份證”，再嘗試用“外號”(authorName)去花名冊裡找（相容舊資料）
            const authorChatByName = Object.values(state.chats).find(c => !c.isGroup && c.name === post.authorName);
            if (authorChatByName) {
                avatarUrl = authorChatByName.settings.aiAvatar;
            } else if (post.authorAvatarPrompt) {
                // 3. 如果都找不到，說明這是一個路人NPC，就用AI給的“頭像咒語”去畫一張新臉
                avatarUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(post.authorAvatarPrompt)}`;
            } else {
                // 4. 如果連“頭像咒語”都沒有，才使用最終的醜陋占點陣圖
                avatarUrl = defaultAvatar;
            }
        }
        // --- 修復結束 ---

        const itemEl = document.createElement('div');
        itemEl.className = 'douban-post-item';
        itemEl.onclick = () => openDoubanPostDetail(post.id);

        itemEl.innerHTML = `
            <div class="douban-post-header">
                <img src="${avatarUrl}" class="douban-post-avatar">
                <div class="douban-author-info">
                    <div class="douban-author-name">${post.authorName}</div>
                    <div class="douban-group-name">來自 ${post.groupName}</div>
                </div>
            </div>
            <div class="douban-post-title">${post.postTitle}</div>
            <div class="douban-post-content">${post.content.replace(/\n/g, '<br>')}</div>
            <div class="douban-post-footer">
                 <div class="douban-post-actions">
                    <span><svg viewBox="0 0 1024 1024"><path d="M170.666667 170.666667h128v682.666666h-128zM426.666667 170.666667h170.666666v682.666666h-170.666666zM725.333333 170.666667h128v682.666666h-128z"></path></svg> ${post.likesCount}</span>
                    <span><svg viewBox="0 0 1024 1024"><path d="M853.333333 85.333333H170.666667c-46.933333 0-85.333333 38.4-85.333334 85.333334v512c0 46.933333 38.4 85.333333 85.333334 85.333333h512l170.666667 170.666667V170.666667c0-46.933333-38.4-85.333333-85.333334-85.333334z m-42.666666 554.666667H170.666667V170.666667h640v469.333333zM256 384h512v85.333333H256V384z m0-170.666667h512v85.333334H256v-85.333334z"></path></svg> ${post.commentsCount}</span>
                </div>
                <span class="douban-post-timestamp">${formatTimeAgo(post.timestamp)}</span>
            </div>
        `;
        listEl.appendChild(itemEl);
    });
}
// ▲▲▲ 替換結束 ▲▲▲

// ▼▼▼ 【請用這個全新版本】完整替換舊的 handleGenerateDoubanPosts 函數 ▼▼▼
async function handleGenerateDoubanPosts() {
    const activeCharacterIds = state.globalSettings.doubanActiveCharacterIds || [];

    if (activeCharacterIds.length === 0) {
        await showCustomAlert("請先選擇角色", "請點擊右上角的“角色選擇”按鈕，選擇至少一個參與豆瓣互動的角色。");
        return;
    }

    await showCustomAlert("請稍候...", `正在為您選擇的 ${activeCharacterIds.length} 位元角色生成豆瓣動態...`);

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('請先在API設置中配置好API資訊。');
        return;
    }

    const allLinkedBookIds = new Set();
    activeCharacterIds.forEach(charId => {
        const c = state.chats[charId];
        if (c && c.settings.linkedWorldBookIds) {
            c.settings.linkedWorldBookIds.forEach(bookId => allLinkedBookIds.add(bookId));
        }
    });

    let sharedWorldBookContext = '';
    if (allLinkedBookIds.size > 0) {
        sharedWorldBookContext += '\n\n# 統一世界觀設定 (以下設定適用於所有參與角色)\n';
        allLinkedBookIds.forEach(bookId => {
            const book = state.worldBooks.find(wb => wb.id === bookId);
            if (book) {
                const enabledEntries = book.content
                    .filter(e => e.enabled !== false)
                    .map(e => `- ${e.content}`)
                    .join('\n');
                if (enabledEntries) {
                    sharedWorldBookContext += `\n## 來自《${book.name}》:\n${enabledEntries}`;
                }
            }
        });
    }
    
    const doubanWorldBook = state.worldBooks.find(wb => wb.name === '豆瓣設定');
    let doubanSettingContext = '';
    let npcCharacters = [];
    if (doubanWorldBook) {
        doubanWorldBook.content.forEach(entry => {
            if (entry.comment.includes('小組風格')) {
                doubanSettingContext += `\n# 豆瓣社區風格設定 (來自世界書)\n${entry.content}`;
            }
            if (entry.comment.includes('NPC人設')) {
                const lines = entry.content.split('\n');
                lines.forEach(line => {
                    const match = line.match(/- \*\*昵稱\*\*:\s*(.*?)\s*\*\*人設\*\*:\s*(.*)/);
                    if (match) {
                        npcCharacters.push({ name: match[1].trim(), persona: match[2].trim() });
                    }
                });
            }
        });
    }
    
    const userNickname = state.qzoneSettings.nickname || '我';
    const userPersona = activeCharacterIds.length > 0 && state.chats[activeCharacterIds[0]] 
        ? state.chats[activeCharacterIds[0]].settings.myPersona 
        : '(未設置)';

    let charactersContext = '';
    activeCharacterIds.forEach(charId => {
        const c = state.chats[charId];
        if (c) {
            const longTermMemory = c.longTermMemory && c.longTermMemory.length > 0 ? c.longTermMemory.map(m => m.content).join('; ') : '無';
            const recentHistory = c.history.slice(-10).map(msg => 
                `${msg.role === 'user' ? userNickname : c.name}: ${String(msg.content).substring(0, 30)}...`
            ).join('\n');

            charactersContext += `
<character>
  <name>${c.name}</name>
  <persona>${c.settings.aiPersona}</persona>
  <memory>${longTermMemory}</memory>
  <recent_dialogue_with_user>${recentHistory}</recent_dialogue_with_user>
</character>
`;
        }
    });
    npcCharacters.forEach(npc => {
        charactersContext += `
<character>
  <name>${npc.name}</name>
  <persona>${npc.persona}</persona>
</character>
`;
    });
    
    const now = new Date();
    const currentTimeString = now.toLocaleString('zh-CN', { dateStyle: 'full', timeStyle: 'short' });
    const minPosts = state.globalSettings.doubanMinPosts || 12;
    const maxPosts = state.globalSettings.doubanMaxPosts || 20;
    const systemPrompt = `
# 你的任務
你是一個虛擬社群內容生成器。你的任務是根據下面提供的【統一角色列表】，虛構出【${minPosts}到${maxPosts}篇】他們最近可能會在各種豆瓣小組中發佈的帖子和評論。

# 核心規則
1.  **【時間感知】**:
    -   你【必須】意識到當前是 **${currentTimeString}**。
    -   你的帖子和評論內容【必須】自然地體現出對【當前真實時間】的感知。
2.  **【禁止扮演用戶 (最最最高優先順序！！！)】**:
    -   用戶的昵稱是“${userNickname}”。
    -   你【絕對不能】生成 authorName 或 commenter 欄位為 “${userNickname}” 的帖子或評論。你的任務是扮演【除了用戶以外】的所有角色。
3.  **【身份 (最高優先順序！)】**: 
    -   \`authorName\`: 你可以為主要角色起一個符合情景的、臨時的【發帖昵稱】，也可以直接使用他們的本名。
    -   \`authorOriginalName\`: 如果發帖者是【主要角色】，你【必須】在這裡填上TA在角色列表裡的【原始備註名】，這是程式的“身份證”。
    -   如果發帖者是【路人NPC】，則【省略】\`authorOriginalName\` 欄位。
4.  **【作者平衡】**: 帖子的作者【必須】從下面的 \`<character>\` 列表中【均勻地、多樣化地】選擇。你【必須】確保帖子列表中【至少有 70% 的帖子是由路人NPC發佈的】，以營造一個真實的社區氛圍。
    - "comments": 一個包含【7到12條】評論的陣列。評論者可以是路人，也可以是角色列表中的其他角色，以體現互動性。
5.  **【角色扮演】**: 帖子的作者和內容【必須】深度結合該角色的<persona>, <memory>, 和 <worldview>。
6.  **【“豆瓣味”內容風格指南】**: 帖子風格必須多樣化且充滿生活氣息！你需要生成包括但不限於：情感樹洞、生活吐槽、吃瓜八卦、興趣分享、無用良品等各種類型的帖子。
7.  **【頭像生成 (最高優先順序！)】**:
    -   為每一個【首次出現】的路人NPC（無論是發帖還是評論），你都【必須】為其添加一個 \`avatar_prompt\` 欄位。
    -   這個欄位的內容是用於生成該NPC頭像的、簡潔的【英文】關鍵字。
    -   不同的NPC【必須】有不同的頭像指令，以確保他們的頭像是獨一無二的。
8.  **【頭像一致性 (至關重要！)】**:
    -   如果一個路人NPC在同一個帖子中多次出現（例如，既是發帖人又是評論者，或多次評論），你【必須】為TA的所有出現都使用【完全相同】的 \`avatar_prompt\`。這至關重要！
9.  **【格式 (最高優先順序)】**: 
    - 你的回復【必須且只能】是一個JSON陣列格式的字串。
    - 你的回復必須以 \`[\` 開始，並以 \`]\` 結束。
    - 【絕對禁止】在JSON陣列前後添加任何多餘的文字、解釋、或 markdown 標記 (如 \`\`\`json)。
    - 陣列中的每個元素都是一篇帖子，格式【必須】如下:
    \`\`\`json
    [
      {
        "groupName": "一個生動有趣的小組名稱",
        "postTitle": "一個引人-注目的帖子標題",
        "authorName": "發帖角色的【備註名】",
        "authorOriginalName": "(僅當發帖者是主要角色時【必須】提供) TA的原始備註名",
        "authorAvatarPrompt": "(僅當發帖者是路人NPC時【必須】提供) 一段用於生成該NPC頭像的【英文】關鍵字。風格為 anime style, simple background",
        "content": "帖子的詳細正文，必須支持分行符號\\n。",
        "likesCount": 152,
        "commentsCount": 38,
        "comments": [
            { "commenter": "路人甲", "text": "這是一個路人評論。", "avatar_prompt": "cute cat avatar, simple, flat" },
            { "commenter": "另一個角色名", "commenterOriginalName": "(如果評論者是主要角色，必須提供其本名)", "text": "這是一個來自其他角色的互動評論。" }
        ]
      }
    ]
    \`\`\`
    - **comments**: 
        -   評論者可以是路人，也可以是角色列表中的其他角色。評論區【必須】體現出互動性。
        -   【評論身份】: 如果評論者是【主要角色】，你【必須】為其添加 \`commenterOriginalName\` 欄位，並填入其本名。如果是路人NPC，則省略此欄位。

# 供你參考的上下文
${doubanSettingContext}
${sharedWorldBookContext}

# 當前情景
- **當前真實時間**: ${currentTimeString}

# 【你的聊天物件（使用者）的身份檔案】
- **昵稱**: ${userNickname}
- **人設**: ${userPersona}

# 統一角色列表 (你扮演的角色 + 路人NPC)
${charactersContext}

現在，請嚴格遵守所有規則，特別是【時間感知】和【禁止扮演用戶】的鐵律，開始生成這組生動、多樣且充滿“豆瓣味”的小組帖子。`;

    try {
        const messagesForApi = [{ role: 'user', content: "請根據角色清單，生成豆瓣小組帖子。" }];
        let isGemini = proxyUrl.includes('generativelanguage');
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
        
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, ...messagesForApi],
                    temperature: state.globalSettings.apiTemperature || 1.0,
                })
            });

        if (!response.ok) throw new Error(`API 錯誤: ${response.statusText}`);
        
        const data = await response.json();
        const aiResponseContent = getGeminiResponseText(data);
        
        const jsonMatch = aiResponseContent.match(/\[[\s\S]*\]/);
        
        if (!jsonMatch) {
            throw new Error(`AI返回的內容中未找到有效的JSON陣列。原始返回: ${aiResponseContent}`);
        }
        
        const simulatedPosts = JSON.parse(jsonMatch[0]);
        await db.doubanPosts.clear();
        await db.doubanPosts.bulkAdd(simulatedPosts.map(p => ({...p, timestamp: Date.now() - Math.random() * 100000})));
        
        await renderDoubanScreen();
        
    } catch (error) {
        console.error("生成豆瓣帖子失敗:", error);
        await showCustomAlert("生成失敗", `無法生成內容，請檢查API配置或稍後再試。\n錯誤: ${error.message}`);
    }
}
// ▲▲▲ 替換結束 ▲▲▲
/**
 * 【V3.5 | 最終頭像統一修復版】打開並渲染指定的帖子詳情頁
 * @param {number} postId - 帖子的ID
 */
async function openDoubanPostDetail(postId) {
    showScreen('douban-post-detail-screen');
    activeDoubanPostId = postId;
    const post = await db.doubanPosts.get(postId);
    if (!post) {
        showScreen('douban-screen');
        return;
    }

    document.getElementById('douban-post-detail-title').textContent = '帖子詳情';

    // (這部分渲染帖子作者資訊的邏輯是正確的，我們先在這裡獲取到正確的作者頭像)
    let authorAvatar = defaultAvatar;
    let authorDisplayName = post.authorName; 

    const authorChatByOriginalName = post.authorOriginalName
        ? Object.values(state.chats).find(c => !c.isGroup && c.originalName === post.authorOriginalName)
        : null;

    if (authorChatByOriginalName) {
        authorAvatar = authorChatByOriginalName.settings.aiAvatar;
    } else {
        const authorChatByName = Object.values(state.chats).find(c => !c.isGroup && c.name === post.authorName);
        if (authorChatByName) {
            authorAvatar = authorChatByName.settings.aiAvatar;
        } else if (post.authorAvatarPrompt) {
            authorAvatar = `https://image.pollinations.ai/prompt/${encodeURIComponent(post.authorAvatarPrompt)}`;
        }
    }
    
    // (填充帖子正文部分的資訊)
    document.getElementById('douban-detail-avatar').src = authorAvatar;
    document.getElementById('douban-detail-author').textContent = authorDisplayName;
    document.getElementById('douban-detail-group').textContent = `來自 ${post.groupName}`;
    document.getElementById('douban-detail-post-title').textContent = post.postTitle;
    document.getElementById('douban-detail-content').innerHTML = post.content.replace(/\n/g, '<br>');
    document.getElementById('douban-my-comment-avatar').src = state.qzoneSettings.avatar;
    document.getElementById('douban-comment-input').value = '';

    const commentsListEl = document.getElementById('douban-detail-comments-list');
    commentsListEl.innerHTML = '';

    // ▼▼▼ 【【【核心修復就在這裡！】】】 ▼▼▼
    if (post.comments && post.comments.length > 0) {
        // 1. 【全新】創建一個Map來“記住”每個評論者的頭像，確保一致性
        const commenterAvatarMap = new Map();

        post.comments.forEach(comment => {
            let commenterAvatar = defaultAvatar; // 默認頭像
            const myNickname = state.qzoneSettings.nickname || '我';
            const commenterName = comment.commenter; // 獲取當前評論者的名字

            // 2. 【智慧查找】檢查是否已經為這個評論者確定過頭像了
            if (commenterAvatarMap.has(commenterName)) {
                // 如果已經記住了，直接使用記住的頭像，跳過所有查找！
                commenterAvatar = commenterAvatarMap.get(commenterName);
            } else {
                // 如果是第一次遇到這個評論者，就執行完整的查找邏輯
                if (commenterName === myNickname) {
                    commenterAvatar = state.qzoneSettings.avatar;
                }
                else if (commenterName === post.authorName) {
                    commenterAvatar = authorAvatar;
                }
                else {
                    const commenterChatByOriginalName = comment.commenterOriginalName
                        ? Object.values(state.chats).find(c => !c.isGroup && c.originalName === comment.commenterOriginalName)
                        : null;
                    
                    if (commenterChatByOriginalName) {
                        commenterAvatar = commenterChatByOriginalName.settings.aiAvatar;
                    } else {
                        const commenterChatByName = Object.values(state.chats).find(c => !c.isGroup && c.name === commenterName);
                        if (commenterChatByName) {
                            commenterAvatar = commenterChatByName.settings.aiAvatar;
                        } else if (comment.avatar_prompt) {
                            commenterAvatar = `https://image.pollinations.ai/prompt/${encodeURIComponent(comment.avatar_prompt)}`;
                        }
                    }
                }
                // 3. 【關鍵】將找到的頭像存入Map中，以便下次直接使用
                commenterAvatarMap.set(commenterName, commenterAvatar);
            }
            
            // (後續的HTML渲染邏輯保持不變)
            const commentEl = document.createElement('div');
            commentEl.className = 'douban-comment-item';
            commentEl.innerHTML = `
                <img src="${commenterAvatar}" class="douban-comment-avatar">
                <div class="douban-comment-body">
                    <div class="douban-comment-author">${commenterName}</div>
                    <div class="douban-comment-text">${comment.text.replace(/\n/g, '<br>')}</div>
                </div>
            `;
            commentsListEl.appendChild(commentEl);
        });
    } else {
        commentsListEl.innerHTML = '<p style="color: var(--text-secondary); font-size: 13px;">還沒有回應</p>';
    }
    // ▲▲▲ 【【【修復結束】】】 ▲▲▲
    
    const contentWrapper = document.getElementById('douban-detail-content-wrapper');
    if(contentWrapper) contentWrapper.scrollTop = 0;
}
// ▲▲▲ 替換結束 ▲▲▲
// ▼▼▼ 【全新 | AI互動增強版】請用這個新版本替換舊的 handleSendDoubanComment 函數 ▼▼▼
/**
 * 【全新】處理使用者發送豆瓣評論的邏輯，並觸發AI互動
 */
async function handleSendDoubanComment() {
    if (!activeDoubanPostId) return;

    const input = document.getElementById('douban-comment-input');
    const commentText = input.value.trim();
    if (!commentText) return;

    const post = await db.doubanPosts.get(activeDoubanPostId);
    if (!post) return;

    if (!post.comments) {
        post.comments = [];
    }
    
    const myNickname = state.qzoneSettings.nickname || '我';
    
    post.comments.push({
        commenter: myNickname,
        text: commentText
    });
    post.commentsCount++;

    await db.doubanPosts.put(post);
    input.value = '';
    
    // 【核心修改1】發送評論後，立刻重新渲染詳情頁，保證您的新評論能顯示出來
    await openDoubanPostDetail(activeDoubanPostId);


}
// ▲▲▲ 替換結束 ▲▲▲
// ▼▼▼ 【請用這個全新版本】完整替換舊的 handleDoubanWaitReply 函數 ▼▼▼
async function handleDoubanWaitReply() {
    if (!activeDoubanPostId) return;

    const postId = activeDoubanPostId;
    const post = await db.doubanPosts.get(postId);
    if (!post) return;

    const lastComment = post.comments && post.comments.slice(-1)[0];
    if (!lastComment) {
        alert("還沒有任何評論，無法等待回復。");
        return;
    }

    await showCustomAlert("請稍候...", "正在請求AI角色們加入討論...");

    try {
        const { proxyUrl, apiKey, model } = state.apiConfig;
        if (!proxyUrl || !apiKey || !model) {
            throw new Error('API未配置，無法生成內容。');
        }

        const userNickname = state.qzoneSettings.nickname || '我';
        const userPersona = state.chats[Object.keys(state.chats)[0]]?.settings.myPersona || '(未設置)';
        
        const existingNpcs = new Map();
        if (post.comments) {
            post.comments.forEach(comment => {
                const isMainCharacter = (state.globalSettings.doubanActiveCharacterIds || []).some(id => state.chats[id]?.name === comment.commenter);
                if (!isMainCharacter && comment.avatar_prompt) {
                    existingNpcs.set(comment.commenter, comment.avatar_prompt);
                }
            });
        }
        
        let existingNpcContext = "# 已有路人NPC頭像指令 (必須遵守！)\n";
        if (existingNpcs.size > 0) {
            existingNpcContext += "如果以下任何一位NPC再次評論，你【必須】使用我們提供的、完全相同的`avatar_prompt`，以保持頭像一致性。\n";
            existingNpcs.forEach((prompt, name) => {
                existingNpcContext += `- **${name}**: "${prompt}"\n`;
            });
        } else {
            existingNpcContext += "（當前帖子還沒有路人NPC發表評論。）\n";
        }

        const doubanWorldBook = state.worldBooks.find(wb => wb.name === '豆瓣設定');
        let npcCharacters = [];
        if (doubanWorldBook) {
            doubanWorldBook.content.forEach(entry => {
                if (entry.comment.includes('NPC人設')) {
                    const lines = entry.content.split('\n');
                    lines.forEach(line => {
                        const match = line.match(/- \*\*昵稱\*\*:\s*(.*?)\s*\*\*人設\*\*:\s*(.*)/);
                        if (match) {
                            npcCharacters.push({ name: match[1].trim(), persona: match[2].trim() });
                        }
                    });
                }
            });
        }
        
        let charactersContext = '';
        const activeCharacterIds = state.globalSettings.doubanActiveCharacterIds || [];
        activeCharacterIds.forEach(charId => {
            const c = state.chats[charId];
            if (c) {
                const longTermMemory = c.longTermMemory && c.longTermMemory.length > 0 ? c.longTermMemory.map(m => m.content).join('; ') : '無';
                const recentHistory = c.history.slice(-10).map(msg => `${msg.role === 'user' ? userNickname : c.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
                charactersContext += `\n- ${c.name}: ${c.settings.aiPersona.substring(0,50)}... [記憶: ${longTermMemory}] [最近對話: ${recentHistory}]`;
            }
        });
        npcCharacters.forEach(npc => {
            charactersContext += `\n- ${npc.name}: ${npc.persona}`;
        });

        // ▲▲▲ 核心修改1：在這裡也獲取當前時間 ▲▲▲
        const now = new Date();
        const currentTimeString = now.toLocaleString('zh-CN', { dateStyle: 'full', timeStyle: 'short' });

        // ▲▲▲ 核心修改2：更新系統指令，加入所有上下文資訊 ▲▲▲
        const systemPrompt = `
# 你的任務
你是一個虛擬社群的AI導演。下面的“帖子摘要”和“已有評論”來自於一個豆瓣小組的帖子。用戶“${userNickname}”剛剛對最後一條評論點擊了“等待回復”，TA希望看到更多角色參與討論。
你的任務是：根據所有角色的設定，選擇【10到20位】最適合參與討論的角色，讓他們針對已有評論，發表【全新的、符合人設的】回應。

# 核心規則
1.  **【時間感知】**:
    -   你【必須】意識到當前是 **${currentTimeString}**。
    -   你的評論內容【必須】自然地體現出對【當前真實時間】的感知。
2.  **【禁止扮演用戶 (最最最高優先順序！！！)】**:
    -   用戶的昵稱是“${userNickname}”。
    -   你【絕對不能】生成 commenter 欄位為 “${userNickname}” 的評論。你的任務是扮演【除了用戶以外】的所有角色。
3.  **【互動】**: 新生成的評論【必須】是針對【已有評論】的延續或回應，讓討論能繼續下去。
4.  **【頭像一致性 (最高優先順序！)】**: 你【必須】參考下面的“已有路人NPC頭像指令”清單。如果一個已有的NPC再次發言，【必須】複用它舊的頭像指令。只有在創造一個【全新的、從未出現過的】NPC時，才為其生成新的頭像指令。
5.  **【格式】**: 你的回復【必須且只能】是一個JSON陣列，陣列中的每個元素都代表一條新評論，格式【必須】如下:
    \`\`\`json
    [
      { "commenter": "角色A的名字", "text": "角色A的新評論內容。", "avatar_prompt": "(可選)如果評論者是【全新的】NPC,提供頭像指令" },
      { "commenter": "角色B的名字", "text": "角色B對角色A或樓主的看法。" }
    ]
    \`\`\`

# 上下文
- **帖子標題**: 《${post.postTitle}》
- **發帖人**: ${post.authorName}
- **帖子內容摘要**: ${post.content.substring(0, 100)}...
- **已有評論**:
${post.comments.map(c => `- ${c.commenter}: ${c.text}`).join('\n')}

${existingNpcContext}

# 當前情景
- **當前真實時間**: ${currentTimeString}

# 【你的聊天物件（使用者）的人設】
- **昵稱**: ${userNickname}
- **人設**: ${userPersona}

# 你的角色庫 (你可以從中選擇【任何角色】進行評論，並參考他們的記憶和對話)
${charactersContext}

現在，請生成新的評論。`;

        const messagesForApi = [{ role: 'user', content: "請根據以上情景，生成新的評論。" }];
        let isGemini = proxyUrl.includes('generativelanguage');
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
        
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, ...messagesForApi],
                    temperature: state.globalSettings.apiTemperature || 1.0,
                })
            });

        if (!response.ok) throw new Error(`API 錯誤: ${response.statusText}`);
        
        const data = await response.json();
        const aiResponseContent = getGeminiResponseText(data);
        const cleanedJson = aiResponseContent.replace(/^```json\s*/, '').replace(/```$/, '');
        const newComments = JSON.parse(cleanedJson);

        if (Array.isArray(newComments) && newComments.length > 0) {
            post.comments.push(...newComments);
            post.commentsCount += newComments.length;
            await db.doubanPosts.put(post);
        }

        await openDoubanPostDetail(postId);
        
        hideCustomModal();

    } catch (error) {
        console.error("等待回復失敗:", error);
        await showCustomAlert("操作失敗", `無法獲取AI回復，請檢查API配置或稍後再試。\n錯誤: ${error.message}`);
    }
}
// ▲▲▲ 替換結束 ▲▲▲
// ▼▼▼ 【全新】請將這兩個新函數，黏貼到 init() 函數的上方 ▼▼▼
/**
 * 【全新】打開豆瓣角色選擇器彈窗
 */
async function openDoubanCastSelector() {
    const modal = document.getElementById('douban-cast-modal');
    const listEl = document.getElementById('douban-cast-list');
    listEl.innerHTML = '';

    const allCharacters = Object.values(state.chats).filter(c => !c.isGroup);
    // 從全域設置中讀取已保存的選擇
    const activeIds = new Set(state.globalSettings.doubanActiveCharacterIds || []);

    if (allCharacters.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color:#8a8a8a; padding: 50px 0;">還沒有可以參與的角色。</p>';
    } else {
        allCharacters.forEach(char => {
            const item = document.createElement('div');
            item.className = 'contact-picker-item'; // 複用連絡人選擇器的樣式
            item.innerHTML = `
                <input type="checkbox" class="douban-cast-checkbox" data-chat-id="${char.id}" ${activeIds.has(char.id) ? 'checked' : ''} style="margin-right: 15px;">
                <img src="${char.settings.aiAvatar || defaultAvatar}" class="avatar">
                <span class="name">${char.name}</span>
            `;
            listEl.appendChild(item);
        });
    }
    modal.classList.add('visible');
}

/**
 * 【全新】保存用戶選擇的豆瓣角色
 */
async function saveDoubanCastSelection() {
    const selectedCheckboxes = document.querySelectorAll('#douban-cast-list .douban-cast-checkbox:checked');
    const selectedIds = Array.from(selectedCheckboxes).map(cb => cb.dataset.chatId);

    // 將選擇保存到全域設置中
    state.globalSettings.doubanActiveCharacterIds = selectedIds;
    await db.globalSettings.put(state.globalSettings);

    document.getElementById('douban-cast-modal').classList.remove('visible');
    
    // 【關鍵】保存後，立即使用新的角色陣容重新生成帖子！
    await handleGenerateDoubanPosts();
}
// ▲▲▲ 新增函數結束 ▲▲▲

// ▼▼▼ 在 init() 函數的事件監聽器區域，黏貼下面這整塊代碼 ▼▼▼
// 綁定豆瓣角色選擇功能的按鈕
document.getElementById('douban-cast-select-btn').addEventListener('click', openDoubanCastSelector);
document.getElementById('cancel-douban-cast-btn').addEventListener('click', () => {
    document.getElementById('douban-cast-modal').classList.remove('visible');
});
document.getElementById('save-douban-cast-btn').addEventListener('click', saveDoubanCastSelection);
// 使用事件委託，為列表項的點擊添加切換選中狀態的功能
document.getElementById('douban-cast-list').addEventListener('click', (e) => {
    const item = e.target.closest('.contact-picker-item');
    if (item) {
        const checkbox = item.querySelector('.douban-cast-checkbox');
        if (checkbox && e.target !== checkbox) {
            checkbox.checked = !checkbox.checked;
        }
    }
});
// ▲▲▲ 新增事件綁定結束 ▲▲▲
/* ▼▼▼ 【全新】這是導入外觀設置的【全部核心JS代碼】，請完整黏貼 ▼▼▼ */

/**
 * 【總入口】當用戶選擇了外觀設置的JSON檔後，由此函數開始處理
 * @param {File} file - 用戶選擇的 .json 備份檔案
 */
async function importAppearanceSettings(file) {
    if (!file) return;

    // 1. 彈出確認框，防止用戶誤操作
    const confirmed = await showCustomConfirm(
        '導入外觀設置',
        '這將用檔中的設置覆蓋當前的所有外觀設置（包括壁紙、圖示、字體、CSS等）。確定要繼續嗎？',
        { confirmText: '確認導入' }
    );

    if (!confirmed) return;

    try {
        // 2. 讀取並解析JSON文件
        const text = await file.text();
        const data = JSON.parse(text);

        // 3. 驗證檔有效性（檢查是否包含關鍵的外觀設置欄位）
        if (!data.wallpaper && !data.globalCss && !data.appIcons) {
            throw new Error("檔案格式不正確，缺少關鍵的外觀設置項。");
        }

        // 4. 將導入的設置合併到當前的全域設置中
        //    我們使用Object.assign來確保即使未來增加了新的設置項，舊的備份檔案也不會導致它們丟失
        Object.assign(state.globalSettings, data);

        // 5. 將更新後的完整設置保存到資料庫
        await db.globalSettings.put(state.globalSettings);
        
        // 6. 立即應用所有新設置，讓更改即時生效
        applyGlobalWallpaper();
        applyCPhoneWallpaper();
        applyAppIcons();
        applyCPhoneAppIcons();
        applyGlobalCss(state.globalSettings.globalCss);
        applyCustomFont(state.globalSettings.fontUrl);
        applyStatusBarVisibility();
        applyWidgetData();

        // 7. 重新渲染外觀設置頁面，以顯示最新的設置值
        renderWallpaperScreen();
        
        // 8. 給出成功提示
        await showCustomAlert('導入成功', '外觀設置已成功導入並應用！');

    } catch (error) {
        // 如果過程中出現任何錯誤，則捕獲並提示用戶
        console.error("導入外觀設置時出錯:", error);
        await showCustomAlert('導入失敗', `文件解析或應用失敗: ${error.message}`);
    }
}

/* ▲▲▲ 核心JS代碼黏貼結束 ▲▲▲ */
// ===================================================================
// ▼▼▼ 【全新】後臺活動模擬功能的核心代碼 ▼▼▼
// ===================================================================

/**
 * 模擬角色在App關閉期間的後臺活動
 * @param {number} minutesOffline - App處於離線狀態的總分鐘數
 */
async function simulateBackgroundActivity(minutesOffline) {
    console.log(`檢測到應用離線了 ${minutesOffline.toFixed(1)} 分鐘，開始模擬後臺活動...`);

    // 篩選出所有開啟了“獨立後臺活動”的單聊角色
    const activeCharacters = Object.values(state.chats).filter(chat => 
        !chat.isGroup && 
        chat.settings.enableBackgroundActivity && 
        chat.relationship?.status === 'friend'
    );
    
    if (activeCharacters.length === 0) {
        console.log("沒有配置為後臺活躍的角色，跳過模擬。");
        return; // 如果沒有活躍角色，直接退出
    }

    // 遍歷每一個活躍的角色
    for (const char of activeCharacters) {
        // 檢查這個角色的行動冷卻時間
        const cooldownMinutes = char.settings.actionCooldownMinutes || 15; // 默認15分鐘
        const timeSinceLastAction = char.lastActionTimestamp 
            ? (Date.now() - char.lastActionTimestamp) / (1000 * 60)
            : Infinity; // 如果從未行動過，則視為冷卻已結束

        // 如果離線時間超過了角色的冷卻時間，且上次行動也在冷卻期之外
        if (minutesOffline > cooldownMinutes && timeSinceLastAction > cooldownMinutes) {
            
            // 用一個亂數來決定角色是否真的行動，避免每次都行動
            // 例如，這裡我們設置一個30%的行動概率
            if (Math.random() < 0.3) {
                console.log(`角色 "${char.name}" 觸發了後臺行動！`);
                
                // 為了讓模擬更真實，我們隨機決定TA是發消息還是發動態
                if (Math.random() < 0.7) { // 70% 概率發消息
                    // 調用我們之前已有的AI行動函數
                    await triggerInactiveAiAction(char.id);
                } else { // 30% 概率發動態
                    // 您也可以在這裡調用發動態的AI函數
                    console.log(`角色 "${char.name}" 決定去發一條動態... (此處為模擬)`);
                }
            }
        }
    }
}
// ▲▲▲ 【全新】後臺活動模擬功能的核心代碼結束 ▲▲▲
/* ▼▼▼ 【全新】這是聊天記錄搜索功能的【全部核心JS代碼】，請完整黏貼 ▼▼▼ */

/**
 * 【總入口】打開聊天記錄搜索螢幕
 */
function openSearchHistoryScreen() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    
    // 清空上次的搜索條件和結果
    document.getElementById('keyword-search-input').value = '';
    document.getElementById('date-search-input').value = '';
    // ★★★ 核心修改：指向新的ID ★★★
    document.getElementById('chat-search-results-list').innerHTML = `<p style="text-align:center; color: var(--text-secondary);">輸入關鍵字或選擇日期進行搜索。</p>`;
    
    // 切換螢幕
    showScreen('search-history-screen');
}

/**
 * 【核心】執行搜索邏輯
 */
async function handleSearchHistory() {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const keyword = document.getElementById('keyword-search-input').value.trim().toLowerCase();
    const dateValue = document.getElementById('date-search-input').value;

    if (!keyword && !dateValue) {
        alert("請輸入關鍵字或選擇一個日期。");
        return;
    }

    let results = chat.history.filter(msg => !msg.isHidden);

    // 1. 按關鍵字篩選
    if (keyword) {
        results = results.filter(msg => {
            let contentString = '';
            // 智慧提取不同類型消息的文本內容
            if (typeof msg.content === 'string') {
                contentString = msg.content;
            } else if (msg.type === 'voice_message') {
                contentString = msg.content;
            } else if (msg.type === 'ai_image' || msg.type === 'user_photo') {
                contentString = msg.content;
            } else if (msg.type === 'offline_text') {
                contentString = `${msg.dialogue || ''} ${msg.description || ''}`;
            } else if (msg.quote) {
                 contentString = msg.content;
            }
            return contentString.toLowerCase().includes(keyword);
        });
    }

    // 2. 按日期篩選
    if (dateValue) {
        const selectedDate = new Date(dateValue);
        const startOfDay = new Date(selectedDate.setHours(0, 0, 0, 0)).getTime();
        const endOfDay = new Date(selectedDate.setHours(23, 59, 59, 999)).getTime();
        
        results = results.filter(msg => msg.timestamp >= startOfDay && msg.timestamp <= endOfDay);
    }
    
    // 渲染搜索結果
    await renderSearchResults(results);
}


/**
 * 將搜索結果渲染到螢幕上
 * @param {Array} results - 篩選後的消息物件陣列
 */
async function renderSearchResults(results) {
    const listEl = document.getElementById('chat-search-results-list');
    const chat = state.chats[state.activeChatId];
    listEl.innerHTML = '';

    if (results.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary);">未找到相關的聊天記錄。</p>';
        return;
    }

    let lastDateString = '';
    for (const msg of results) {
        const msgDate = new Date(msg.timestamp);
        const currentDateString = msgDate.toLocaleDateString();

        if (currentDateString !== lastDateString) {
            const dateSeparator = document.createElement('div');
            dateSeparator.className = 'date-separator';
            dateSeparator.textContent = `--- ${msgDate.getFullYear()}年${msgDate.getMonth() + 1}月${msgDate.getDate()}日 ---`;
            listEl.appendChild(dateSeparator);
            lastDateString = currentDateString;
        }

        const messageEl = await createMessageElement(msg, chat);
        if (messageEl) {
            // ▼▼▼ 核心修改就在這裡 ▼▼▼
            // 1. 添加手型游標，提示用戶這是可以點擊的
            messageEl.style.cursor = 'pointer';
            // 2. 為消息元素綁定點擊事件，調用我們新的跳轉函數
            messageEl.addEventListener('click', () => jumpToOriginalMessage(msg.timestamp));
            // ▲▲▲ 修改結束 ▲▲▲
            listEl.appendChild(messageEl);
        }
    }
}

// ▼▼▼ 【全新】這是聊天記錄搜索跳轉功能的核心代碼，請完整黏貼 ▼▼▼

/**
 * 【總入口】從搜索結果跳轉回原始消息位置
 * @param {number} timestamp - 目標消息的時間戳記
 */
async function jumpToOriginalMessage(timestamp) {
    const chatId = state.activeChatId;
    if (!chatId) return;

    // 1. 切換到聊天介面 (這會觸發 renderChatInterface 渲染最新的消息)
    showScreen('chat-interface-screen');

    // 2. 使用一個短暫的延遲來確保螢幕切換和初始渲染已完成
    setTimeout(async () => {
        const messagesContainer = document.getElementById('chat-messages');
        const selector = `.message-bubble[data-timestamp="${timestamp}"]`;
        let targetMessage = messagesContainer.querySelector(selector);
        let attempts = 0; // 防止無限迴圈
        const maxAttempts = 20; // 最多向上載入20次

        // 3. 迴圈檢查：如果目標消息不在當前DOM中，就模擬點擊“載入更早記錄”
        while (!targetMessage && attempts < maxAttempts) {
            const loadMoreBtn = document.getElementById('load-more-btn');
            if (loadMoreBtn) {
                console.log(`目標消息未找到, 正在載入更多歷史記錄... (嘗試 ${attempts + 1})`);
                await loadMoreMessages(); // 等待載入完成
                targetMessage = messagesContainer.querySelector(selector);
                attempts++;
            } else {
                // 如果沒有“載入更多”按鈕了，說明所有消息都已載入
                break;
            }
        }

        // 4. 調用最終的滾動和高亮函數
        scrollToOriginalMessage(timestamp);

    }, 200); // 延遲200毫秒足以確保UI準備就緒
}



/**
 * 重置搜索篩檢程式並顯示所有記錄
 */
async function clearSearchFilters() {
    document.getElementById('keyword-search-input').value = '';
    document.getElementById('date-search-input').value = '';
    // 重新渲染所有消息作為“重置”結果
    await renderSearchResults(state.chats[state.activeChatId].history.filter(msg => !msg.isHidden));
}

/* ▲▲▲ 核心JS代碼黏貼結束 ▲▲▲ */
// ▼▼▼ 【全新V2.0 | 自訂頭像框】這是所有頭像框上傳、管理功能的核心JS代碼 ▼▼▼

/**
 * 【重構版】渲染頭像框選擇清單，現在會同時顯示預設和使用者自訂的頭像框
 * @param {boolean} isForMember - 是否是為群成員設置
 * @param {string|null} memberAvatar - (可選) 群成員的頭像URL
 * @param {string|null} memberFrame - (可選) 群成員當前的頭像框URL
 */
async function populateFrameGrids(isForMember = false, memberAvatar = null, memberFrame = null) {
    const aiFrameGrid = document.getElementById('ai-frame-grid');
    const myFrameGrid = document.getElementById('my-frame-grid');
    const chat = state.chats[state.activeChatId];
    aiFrameGrid.innerHTML = '';
    myFrameGrid.innerHTML = '';

    // 1. 【核心修改】從資料庫獲取使用者自訂的頭像框
    const customFrames = await db.customAvatarFrames.toArray();
    // 將預設和自訂的合併為一個列表
    const allFrames = [...avatarFrames, ...customFrames];

    document.querySelector('#avatar-frame-modal .frame-tabs').style.display = isForMember ? 'none' : 'flex';
    document.getElementById('ai-frame-content').style.display = 'block';
    document.getElementById('my-frame-content').style.display = 'none';
    document.getElementById('ai-frame-tab').classList.add('active');
    document.getElementById('my-frame-tab').classList.remove('active');

    if (isForMember) {
        allFrames.forEach(frame => {
            const item = createFrameItem(frame, 'my', memberAvatar);
            if (frame.url === memberFrame) {
                item.classList.add('selected');
            }
            aiFrameGrid.appendChild(item);
        });
    } else {
        const aiAvatarForPreview = chat.settings.aiAvatar || defaultAvatar;
        const myAvatarForPreview = chat.settings.myAvatar || (chat.isGroup ? defaultMyGroupAvatar : defaultAvatar);
        allFrames.forEach(frame => {
            const aiItem = createFrameItem(frame, 'ai', aiAvatarForPreview);
            if (frame.url === currentFrameSelection.ai) aiItem.classList.add('selected');
            aiFrameGrid.appendChild(aiItem);

            const myItem = createFrameItem(frame, 'my', myAvatarForPreview);
            if (frame.url === currentFrameSelection.my) myItem.classList.add('selected');
            myFrameGrid.appendChild(myItem);
        });
    }
}
// ▼▼▼ 【請用這個V2.1版本】替換舊的 createFrameItem 函數 ▼▼▼
/**
 * 【升級版】創建單個頭像框的預覽DOM，為自訂框添加刪除按鈕
 * @param {object} frame - 頭像框對象 { id, url, name }
 * @param {string} type - 'ai' 或 'my'
 * @param {string} previewAvatarSrc - 用於預覽的頭像URL
 * @returns {HTMLElement} - 創建好的DOM元素
 */
function createFrameItem(frame, type, previewAvatarSrc) {
    const item = document.createElement('div');
    item.className = 'frame-item';
    item.dataset.frameUrl = frame.url;
    item.title = frame.name;

    const isCustom = typeof frame.id === 'number';
    const deleteButtonHtml = isCustom ? `<button class="delete-btn" data-id="${frame.id}" style="display:block;">×</button>` : '';

    item.innerHTML = `
        ${deleteButtonHtml}
        <img src="${previewAvatarSrc}" class="preview-avatar">
        ${frame.url ? `<img src="${frame.url}" class="preview-frame">` : ''}
    `;

    // 【【【核心修改就在這裡！】】】
    item.addEventListener('click', (e) => {
        // 如果點擊的是刪除按鈕，則不執行任何選擇操作，讓事件冒泡上去
        if (e.target.classList.contains('delete-btn')) {
            return;
        }

        // 如果當前處於管理模式
        if (isFrameManagementMode) {
            // 只有自訂的頭像框才能被選中
            if (isCustom) {
                const frameId = parseInt(frame.id);
                item.classList.toggle('selected');
                if (selectedFrames.has(frameId)) {
                    selectedFrames.delete(frameId);
                } else {
                    selectedFrames.add(frameId);
                }
                updateDeleteFrameButton();
            }
        } else {
            // 否則，執行原來的選擇邏輯
            currentFrameSelection[type] = frame.url;
            const grid = type === 'ai' ? document.getElementById('ai-frame-grid') : document.getElementById('my-frame-grid');
            grid.querySelectorAll('.frame-item').forEach(el => el.classList.remove('selected'));
            item.classList.add('selected');
        }
    });
    
    return item;
}
// ▲▲▲ 替換結束 ▲▲▲

/**
 * 【全新】處理本地上傳單個頭像框的邏輯
 */
async function handleUploadFrame() {
    const fileInput = document.getElementById('custom-frame-upload-input');
    
    // 使用 Promise 優雅地處理檔選擇
    const file = await new Promise(resolve => {
        const changeHandler = (e) => {
            resolve(e.target.files[0] || null);
            fileInput.removeEventListener('change', changeHandler);
        };
        fileInput.addEventListener('change', changeHandler, { once: true });
        fileInput.click();
    });

    if (!file) return; // 用戶取消了選擇

    const name = await showCustomPrompt("命名頭像框", "請為這個新頭像框起個名字");
    if (!name || !name.trim()) return;

    // 將圖片檔轉換為 Base64
    const url = await new Promise(resolve => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.readAsDataURL(file);
    });

    // 存入資料庫
    await db.customAvatarFrames.add({ name: name.trim(), url });
    // 刷新UI
    populateFrameGrids(editingFrameForMember);
}

/**
 * 【全新】處理批量導入頭像框的邏輯
 */
async function handleBatchUploadFrames() {
    const placeholder = `請按照以下格式黏貼，一行一個：\n\n頭像框名字1: https://.../image1.png\n頭像框名字2: https://.../image2.gif`;
    const pastedText = await showCustomPrompt("批量導入頭像框", "從完整連結批量導入", "", 'textarea', `<p style="font-size:12px;color:#888;">${placeholder}</p>`);

    if (!pastedText || !pastedText.trim()) return;

    const lines = pastedText.trim().split('\n');
    const newFrames = [];
    let errorCount = 0;

    for (const line of lines) {
        // 使用規則運算式匹配 "名字: URL" 格式，更健壯
        const match = line.match(/^(.+?)[:：]\s*(https?:\/\/.+)$/);
        if (match) {
            newFrames.push({
                name: match[1].trim(),
                url: match[2].trim()
            });
        } else if (line.trim()) {
            errorCount++;
        }
    }

    if (newFrames.length > 0) {
        await db.customAvatarFrames.bulkAdd(newFrames);
        populateFrameGrids(editingFrameForMember);
        await showCustomAlert("導入成功", `成功導入 ${newFrames.length} 個新頭像框！`);
    }

    if (errorCount > 0) {
        await showCustomAlert("部分失敗", `有 ${errorCount} 行格式不正確，已被忽略。`);
    }
}

/**
 * 【全新】刪除一個自訂頭像框
 * @param {number} frameId - 要刪除的頭像框的ID
 */
async function handleDeleteCustomFrame(frameId) {
    const frame = await db.customAvatarFrames.get(frameId);
    if (!frame) return;

    const confirmed = await showCustomConfirm(
        "確認刪除",
        `確定要刪除頭像框 “${frame.name}” 嗎？`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        await db.customAvatarFrames.delete(frameId);
        populateFrameGrids(editingFrameForMember); // 刷新UI
    }
}

// ▲▲▲ 全新JS代碼黏貼結束 ▲▲▲
// ▼▼▼ 【全新】這是主螢幕分頁和“預設”App的【全部核心JS代碼】，請完整黏貼 ▼▼▼

// --- 1. 主螢幕分頁功能 ---
let currentPage = 0;
const totalPages = 2;

        // ▼▼▼ 【最終修復版】請用這一整塊代碼，完整替換舊的 setupHomeScreenPagination 函數 ▼▼▼
        function setupHomeScreenPagination() {
            const pagesContainer = document.getElementById('home-screen-pages-container');
            const pages = document.getElementById('home-screen-pages');
            const dots = document.querySelectorAll('.pagination-dot');
            let startX = 0, startY = 0; // 同時記錄Y軸座標
            let currentX = 0;
            let isDragging = false;
            let isClick = true; // 【核心】增加一個標誌位元，用於判斷是點擊還是滑動

            const updatePagination = () => {
                pages.style.transform = `translateX(-${currentPage * (100 / totalPages)}%)`;
                dots.forEach((dot, index) => {
                    dot.classList.toggle('active', index === currentPage);
                });
            };

            const onDragStart = (e) => {
                isDragging = true;
                isClick = true; // 每次開始觸摸時，都先假設它是一個點擊
                startX = e.type.includes('mouse') ? e.pageX : e.touches[0].pageX;
                startY = e.type.includes('mouse') ? e.pageY : e.touches[0].pageY;
                pages.style.transition = 'none';
            };

            const onDragMove = (e) => {
                if (!isDragging) return;
                
                const currentY = e.type.includes('mouse') ? e.pageY : e.touches[0].pageY;
                currentX = e.type.includes('mouse') ? e.pageX : e.touches[0].pageX;
                const diffX = currentX - startX;
                const diffY = currentY - startY;

                // 【核心】如果手指移動距離超過10圖元，就判定為滑動，而不是點擊
                if (isClick && (Math.abs(diffX) > 10 || Math.abs(diffY) > 10)) {
                    isClick = false;
                }

                // 只在水準滑動時移動頁面，避免影響垂直捲動
                if (Math.abs(diffX) > Math.abs(diffY)) {
                     if(e.cancelable) e.preventDefault();
                     pages.style.transform = `translateX(calc(-${currentPage * (100 / totalPages)}% + ${diffX}px))`;
                }
            };

            const onDragEnd = (e) => {
                if (!isDragging) return;
                isDragging = false;
                pages.style.transition = 'transform 0.4s cubic-bezier(0.4, 0, 0.2, 1)';

                // 【核心】如果判定為點擊，則不執行翻頁邏輯，直接返回！
                if (isClick) {
                    updatePagination(); // 讓頁面彈回原位
                    // 因為沒有阻止事件，所以流覽器會繼續處理這個“點擊”，觸發App圖示的onclick
                    return; 
                }

                // 如果是滑動，才執行下面的翻頁判斷
                const diffX = currentX - startX;
                if (Math.abs(diffX) > pagesContainer.offsetWidth / 4) {
                    if (diffX > 0 && currentPage > 0) {
                        currentPage--;
                    } else if (diffX < 0 && currentPage < totalPages - 1) {
                        currentPage++;
                    }
                }
                updatePagination();
            };

            pagesContainer.addEventListener('mousedown', onDragStart);
            pagesContainer.addEventListener('mousemove', onDragMove);
            pagesContainer.addEventListener('mouseup', onDragEnd);
            pagesContainer.addEventListener('mouseleave', onDragEnd);

            // 【核心】修改 passive 為 false，以允許 e.preventDefault() 生效
            pagesContainer.addEventListener('touchstart', onDragStart, { passive: false });
            pagesContainer.addEventListener('touchmove', onDragMove, { passive: false });
            pagesContainer.addEventListener('touchend', onDragEnd);
        }
        // ▲▲▲ 替換結束 ▲▲▲

// --- 2. “預設”App 核心功能 ---
let editingPresetId = null;

async function openPresetScreen() {
    await renderPresetScreen();
    showScreen('preset-screen');
}

/**
 * 【全新 | 性能優化版】渲染預設清單，不再顯示內容預覽
 */
async function renderPresetScreen() {
    const tabsContainer = document.getElementById('preset-tabs');
    const contentContainer = document.getElementById('preset-content-container');
    tabsContainer.innerHTML = '';
    contentContainer.innerHTML = '';

    const [presets, categories] = await Promise.all([
        db.presets.toArray(),
        db.presetCategories.orderBy('name').toArray()
    ]);

    state.presets = presets; // 確保記憶體資料同步

    if (presets.length === 0) {
        contentContainer.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">點擊右上角 "+" 創建你的第一個預設</p>';
        return;
    }

    // (創建頁簽的邏輯保持不變)
    const allTab = document.createElement('button');
    allTab.className = 'world-book-tab active';
    allTab.textContent = '全部';
    allTab.dataset.categoryId = 'all';
    tabsContainer.appendChild(allTab);

    const allPane = document.createElement('div');
    allPane.className = 'world-book-category-pane active';
    allPane.dataset.categoryId = 'all';
    contentContainer.appendChild(allPane);
    
    categories.forEach(category => {
        const categoryTab = document.createElement('button');
        categoryTab.className = 'world-book-tab';
        categoryTab.textContent = category.name;
        categoryTab.dataset.categoryId = String(category.id);
        tabsContainer.appendChild(categoryTab);

        const categoryPane = document.createElement('div');
        categoryPane.className = 'world-book-category-pane';
        categoryPane.dataset.categoryId = String(category.id);
        contentContainer.appendChild(categoryPane);
    });
    
    const hasUncategorized = presets.some(p => !p.categoryId);
    if (hasUncategorized) {
        const uncategorizedTab = document.createElement('button');
        uncategorizedTab.className = 'world-book-tab';
        uncategorizedTab.textContent = '未分類';
        uncategorizedTab.dataset.categoryId = 'uncategorized';
        tabsContainer.appendChild(uncategorizedTab);
    
        const uncategorizedPane = document.createElement('div');
        uncategorizedPane.className = 'world-book-category-pane';
        uncategorizedPane.dataset.categoryId = 'uncategorized';
        contentContainer.appendChild(uncategorizedPane);
    }
    
    // ▼▼▼ 【【【核心修改就在這裡！】】】 ▼▼▼
    presets.forEach(preset => {
        // 我們不再讀取任何具體內容，只顯示這個預設包含了多少個條目
        const contentPreview = `該預設包含 ${preset.content.length} 個條目。`;
        
        const card = document.createElement('div');
        card.className = 'world-book-card'; // 複用世界書的卡片樣式
        card.innerHTML = `
            <div class="card-title">${preset.name}</div>
            <div class="card-content-preview">${contentPreview}</div>
        `;
        
        // (事件綁定邏輯保持不變)
        const cardClickHandler = () => openPresetEditor(preset.id);
        const cardLongPressHandler = async () => { 
            const confirmed = await showCustomConfirm('刪除預設', `確定要刪除《${preset.name}》嗎？`, { confirmButtonClass: 'btn-danger' }); 
            if (confirmed) { 
                await db.presets.delete(preset.id);
                state.presets = await db.presets.toArray();
                renderPresetScreen(); 
            } 
        };

        card.addEventListener('click', cardClickHandler);
        addLongPressListener(card, cardLongPressHandler);

        const clonedCardForAll = card.cloneNode(true);
        clonedCardForAll.addEventListener('click', cardClickHandler);
        addLongPressListener(clonedCardForAll, cardLongPressHandler);
        allPane.appendChild(clonedCardForAll);
        
        const categoryKey = preset.categoryId ? String(preset.categoryId) : 'uncategorized';
        const targetPane = contentContainer.querySelector(`.world-book-category-pane[data-category-id="${categoryKey}"]`);
        if (targetPane) {
            targetPane.appendChild(card);
        }
    });
    // ▲▲▲ 【【【修改結束】】】 ▲▲▲
    
    // (頁簽綁定邏輯保持不變)
    document.querySelectorAll('#preset-tabs .world-book-tab').forEach(tab => {
        tab.addEventListener('click', () => switchPresetCategory(tab.dataset.categoryId));
    });
}


function switchPresetCategory(categoryId) {
    document.querySelectorAll('#preset-tabs .world-book-tab').forEach(tab => {
        tab.classList.toggle('active', tab.dataset.categoryId === categoryId);
    });
    document.querySelectorAll('#preset-content-container .world-book-category-pane').forEach(pane => {
        pane.classList.toggle('active', pane.dataset.categoryId === categoryId);
    });
}

/**
 * 【最終修復版 | 相容iOS/Safari】打開預設編輯器
 * @param {string} presetId - 要編輯的預設的ID
 */
async function openPresetEditor(presetId) {
    // 步驟 1: 立即開始切換螢幕，讓動畫先運行
    showScreen('preset-editor-screen');
    editingPresetId = presetId;

    try {
        // 步驟 2: 在後臺非同步獲取所有需要的資料
        const [preset, categories] = await Promise.all([
            db.presets.get(presetId),
            db.presetCategories.toArray()
        ]);

        // 步驟 3: 檢查獲取到的資料是否有效
        if (!preset) {
            console.error("錯誤：嘗試打開一個不存在的預設，ID:", presetId);
            await showCustomAlert("載入失敗", "找不到這個預設的詳細資訊。");
            showScreen('preset-screen'); // 安全地返回列表頁
            return;
        }

        // 步驟 4: 【核心修復】使用一個微小的延遲 (setTimeout) 
        // 這會給手機流覽器足夠的時間來完成螢幕切換的動畫，避免衝突
        setTimeout(() => {
            // 步驟 5: 現在可以安全地更新頁面上的所有內容了
            document.getElementById('preset-editor-title').textContent = preset.name;
            document.getElementById('preset-name-input').value = preset.name;

            const selectEl = document.getElementById('preset-category-select');
            selectEl.innerHTML = '<option value="">-- 未分類 --</option>';
            categories.forEach(cat => {
                const option = document.createElement('option');
                option.value = cat.id;
                option.textContent = cat.name;
                if (preset.categoryId === cat.id) option.selected = true;
                selectEl.appendChild(option);
            });

            const entriesContainer = document.getElementById('preset-entries-container');
            entriesContainer.innerHTML = '';
            if (Array.isArray(preset.content) && preset.content.length > 0) {
                preset.content.forEach(entry => {
                    const block = createPresetEntryBlock(entry);
                    entriesContainer.appendChild(block);
                });
            } else {
                entriesContainer.innerHTML = '<p style="text-align:center; color: var(--text-secondary); margin-top: 20px;">還沒有內容，點擊下方按鈕添加第一條吧！</p>';
            }
        }, 50); // 延遲50毫秒，對於移動端已經足夠

    } catch (error) {
        console.error("打開預設編輯器時發生嚴重錯誤:", error);
        await showCustomAlert("載入失敗", `載入預設詳情時發生錯誤: ${error.message}`);
        showScreen('preset-screen'); // 出錯時也安全返回
    }
}

/**
 * 【全新 | 支援內容折疊】創建單個預設條目的編輯塊
 */
function createPresetEntryBlock(entry = { keys: [], comment: '', content: '', enabled: true }) {
    const block = document.createElement('div');
    block.className = 'message-editor-block';
    const isChecked = entry.enabled !== false ? 'checked' : '';

    // ▼▼▼ 【【【核心修改就在這裡！】】】 ▼▼▼
    block.innerHTML = `
        <div style="display: flex; justify-content: flex-end; align-items: center; gap: 10px; margin-bottom: 5px;">
            <label class="toggle-switch" title="啟用/禁用此條目">
                <input type="checkbox" class="entry-enabled-switch" ${isChecked}>
                <span class="slider"></span>
            </label>
            <button type="button" class="delete-block-btn" title="刪除此條目">×</button>
        </div>
        <div class="form-group" style="margin-bottom: 10px;">
            <label style="font-size: 0.8em;">備註 (可選)</label>
            <input type="text" class="entry-comment-input" value="${entry.comment || ''}" placeholder="例如：角色核心設定" style="padding: 8px;">
        </div>
        <div class="form-group" style="margin-bottom: 10px;">
            <label style="font-size: 0.8em;">關鍵字 (用英文逗號,分隔)</label>
            <input type="text" class="entry-keys-input" value="${(entry.keys || []).join(', ')}" placeholder="例如: key1, key2" style="padding: 8px;">
        </div>
        
        <!-- 這裡是全新的、帶有“展開/收起”按鈕的結構 -->
        <div class="form-group" style="margin-bottom: 0;">
            <label style="font-size: 0.8em; display: flex; justify-content: space-between; align-items: center;">
                <span>內容 (點擊右側展開)</span>
                <button type="button" class="toggle-content-btn">展開</button>
            </label>
            <div class="entry-content-container">
                 <textarea class="entry-content-textarea" rows="8" style="width: 100%; font-size: 14px;">${entry.content || ''}</textarea>
            </div>
        </div>
    `;
    // ▲▲▲ 【【【修改結束】】】 ▲▲▲

    // 綁定刪除按鈕事件
    block.querySelector('.delete-block-btn').addEventListener('click', () => block.remove());
    
    // 【全新】為“展開/收起”按鈕綁定事件
    const toggleBtn = block.querySelector('.toggle-content-btn');
    const contentContainer = block.querySelector('.entry-content-container');
    toggleBtn.addEventListener('click', () => {
        const isHidden = contentContainer.style.display === 'none';
        contentContainer.style.display = isHidden ? 'block' : 'none';
        toggleBtn.textContent = isHidden ? '收起' : '展開';
    });

    return block;
}

// --- 3. “預設”分類管理 (複用世界書的函數，修改函數名) ---
async function openPresetCategoryManager() {
    await renderPresetCategoriesInManager();
    // 複用現有的彈窗，只修改內容
    document.querySelector('#group-management-modal .modal-header span').textContent = '管理預設分類';
    document.getElementById('add-new-group-btn').onclick = addNewPresetCategory;
    document.getElementById('existing-groups-list').onclick = (e) => {
        if (e.target.classList.contains('delete-group-btn')) {
            deletePresetCategory(parseInt(e.target.dataset.id));
        }
    };
    document.getElementById('close-group-manager-btn').onclick = () => {
        document.getElementById('group-management-modal').classList.remove('visible');
        renderPresetScreen(); // 關閉後刷新主列表
    };
    document.getElementById('group-management-modal').classList.add('visible');
}

async function renderPresetCategoriesInManager() {
    const listEl = document.getElementById('existing-groups-list');
    const categories = await db.presetCategories.toArray();
    listEl.innerHTML = '';
    if (categories.length === 0) {
        listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">還沒有任何分類</p>';
    }
    categories.forEach(cat => {
        const item = document.createElement('div');
        item.className = 'existing-group-item';
        item.innerHTML = `<span class="group-name">${cat.name}</span><span class="delete-group-btn" data-id="${cat.id}">×</span>`;
        listEl.appendChild(item);
    });
}

async function addNewPresetCategory() {
    const input = document.getElementById('new-group-name-input');
    const name = input.value.trim();
    if (!name) return alert('分類名不能為空！');
    const existing = await db.presetCategories.where('name').equals(name).first();
    if (existing) return alert(`分類 "${name}" 已經存在了！`);
    await db.presetCategories.add({ name });
    input.value = '';
    await renderPresetCategoriesInManager();
}

async function deletePresetCategory(categoryId) {
    const confirmed = await showCustomConfirm('確認刪除', '刪除分類後，該分類下的所有預設將變為“未分類”。確定嗎？', { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        await db.presetCategories.delete(categoryId);
        await db.presets.where('categoryId').equals(categoryId).modify({ categoryId: null });
        
        // ▼▼▼ 核心修復：在這裡也同樣從資料庫重新載入最新的預設列表 ▼▼▼
        state.presets = await db.presets.toArray();
        // ▲▲▲ 修復結束 ▲▲▲

        await renderPresetCategoriesInManager();
    }
}
// ▲▲▲ 全新JS代碼黏貼結束 ▲▲▲
// ▼▼▼ 【全新】這是導入 Tavern 預設功能的【全部核心JS代碼】，請完整黏貼 ▼▼▼

/**
 * 【總入口】當用戶選擇了預設檔後，由此函數開始處理
 * @param {Event} event - 檔輸入框的 change 事件
 */
async function handlePresetImport(event) {
    const file = event.target.files[0];
    if (!file) return;

    try {
        if (!file.name.endsWith('.json')) {
            throw new Error("檔案格式不支持。請選擇 .json 格式的 Tavern 預設檔。");
        }
        
        const text = await file.text();
        const tavernData = JSON.parse(text);
        
        // 調用核心處理函數
        await importTavernPresetFile(tavernData, file.name);

    } catch (error) {
        console.error("預設導入失敗:", error);
        await showCustomAlert("導入失敗", `無法解析預設檔。\n錯誤: ${error.message}`);
    } finally {
        // 清空輸入框，以便下次能選擇同一個檔
        event.target.value = null;
    }
}

        /**
         * 【V3.0 | 排序終極修復版】從 Tavern AI 格式的資料創建一本新的“預設”
         * @param {object} tavernData - 從 .json 檔解析出的資料
         * @param {string} fileName - 原始檔案名，用於生成默認名稱
         */
        async function importTavernPresetFile(tavernData, fileName) {
            let newEntries = [];

            // ▼▼▼ 修復代碼從這裡開始 ▼▼▼

            // 策略1：優先處理標準的、帶有 `prompt_order` 排序列表的 Tavern/SillyTavern 預設格式
            if (Array.isArray(tavernData.prompts) && Array.isArray(tavernData.prompt_order) && tavernData.prompt_order.length > 0) {
                console.log("檢測到 Tavern/SillyTavern 預設格式，將嚴格按照 prompt_order 排序。");

                // 創建一個查找映射表，以便通過 identifier 快速找到 prompt 的詳細資料
                const promptsMap = new Map(tavernData.prompts.map(p => [p.identifier, p]));

                // 自動選擇最長的那個排序列表，這通常是用戶自訂的那個
                const orderArray = tavernData.prompt_order.reduce((acc, curr) => (
                    (curr.order && curr.order.length > (acc.length || 0)) ? curr.order : acc
                ), []);

                if (orderArray && orderArray.length > 0) {
                    newEntries = orderArray
                        .map(orderItem => {
                            // 根據排序清單中的 identifier，從映射表中找到對應的 prompt 資料
                            const promptData = promptsMap.get(orderItem.identifier);
                            if (promptData) {
                                // 按照我們的格式重新組織資料
                                return {
                                    keys: [], // Tavern 預設中沒有 keys 欄位
                                    comment: promptData.name || '無標題',
                                    content: promptData.content || '',
                                    // 【核心】同步啟用/禁用狀態
                                    enabled: orderItem.enabled 
                                };
                            }
                            return null;
                        })
                        .filter(Boolean); // 過濾掉可能存在的無效條目
                }
            }
            // 策略2：相容舊的、類似世界書的 "entries" 和 "order" 格式
            else if (tavernData.entries && typeof tavernData.entries === 'object') {
                console.log("檢測到 'entries' 物件格式的預設，將嘗試按順序導入。");
                if (Array.isArray(tavernData.order)) {
                    console.log("檢測到 'order' 欄位，將按指定順序導入條目。");
                    newEntries = tavernData.order
                        .map(key => tavernData.entries[key])
                        .filter(Boolean)
                        .map(entry => ({
                            keys: entry.key || [],
                            comment: entry.comment || '無備註',
                            content: entry.content || '',
                            enabled: !entry.disable // Tavern 的 disable 和我們的 enabled 邏輯相反
                        }));
                } else {
                    console.warn("未在檔中找到 'order' 欄位，條目可能無法按原始順序導入。");
                    newEntries = Object.values(tavernData.entries).map(entry => ({
                        keys: entry.key || [],
                        comment: entry.comment || '無備註',
                        content: entry.content || '',
                        enabled: !entry.disable
                    }));
                }
            }
            // 策略3：相容最簡單的、只包含 "prompts" 陣列的格式
            else if (Array.isArray(tavernData.prompts)) {
                console.log("檢測到簡單的 'prompts' 陣列格式，將按陣列內順序導入。");
                newEntries = tavernData.prompts.map(prompt => ({
                    keys: [],
                    comment: prompt.name || '無標題',
                    content: prompt.content || '',
                    enabled: true // 默認啟用
                }));
            }
            // 策略4：如果所有格式都不匹配，則報錯
            else {
                throw new Error("檔案格式無法識別。未找到有效的 'prompts' 陣列或 'entries' 對象。");
            }
            // ▲▲▲ 修復代碼到這裡結束 ▲▲▲

            // 過濾掉沒有內容的空條目
            newEntries = newEntries.filter(entry => entry.content);

            if (newEntries.length === 0) {
                alert("這個預設檔中沒有找到任何有效的提示詞條目。");
                return;
            }

            // （後續的命名、保存和刷新邏輯保持不變）
            const presetNameSuggestion = fileName.replace(/\.json$/i, '');
            const newPresetName = await showCustomPrompt("導入 Tavern 預設", "請為這組提示詞預設命名：", presetNameSuggestion);
            if (!newPresetName || !newPresetName.trim()) {
                alert("導入已取消，因為未提供名稱。");
                return;
            }

            const newPreset = {
                id: 'preset_' + Date.now(),
                name: newPresetName.trim(),
                content: newEntries,
                categoryId: null
            };

            await db.presets.add(newPreset);
            state.presets.push(newPreset);

            await renderPresetScreen();
            await showCustomAlert('導入成功！', `已成功從檔導入預設《${newPresetName}》。`);
        }

// ▲▲▲ 全新JS代碼黏貼結束 ▲▲▲
// ▼▼▼ 【全新】請將這個函數黏貼到JS功能函式定義區 ▼▼▼
/**
 * 【全新】在聊天設置中渲染線下模式的文風預設選擇器
 * @param {object} chat - 當前的聊天物件
 */
async function renderOfflinePresetSelector(chat) {
    const selectEl = document.getElementById('offline-preset-select');
    if (!selectEl) return;

    // 1. 直接從 state 緩存中獲取預設，無需再查資料庫
    const presets = state.presets || [];
    
    // 2. 清空並填充下拉清單
    selectEl.innerHTML = '<option value="">-- 不使用預設 --</option>';
    presets.forEach(preset => {
        const option = document.createElement('option');
        option.value = preset.id;
        option.textContent = preset.name;
        selectEl.appendChild(option);
    });

    // 3. 設置當前選中的值
    if (chat.settings.offlinePresetId) {
        selectEl.value = chat.settings.offlinePresetId;
    }
}
// ▲▲▲ 新增函數結束 ▲▲▲
// ▼▼▼ 【請用這個 V2.0 版本】替換舊的 renderButtonOrderEditor 函數 ▼▼▼
/**
 * 渲染按鈕排序的設置介面 (V2.0 - 使用常量作為預設值)
 */
function renderButtonOrderEditor() {
    const editor = document.getElementById('button-order-editor');
    if (!editor) return;

    editor.innerHTML = '';

    // 【核心修改】
    // 優先使用使用者保存的順序，如果不存在，則直接使用我們定義的預設順序常量
    let buttonOrder = state.globalSettings.chatActionButtonsOrder || DEFAULT_BUTTON_ORDER;
    
    buttonOrder.forEach(buttonId => {
        const originalButton = document.getElementById(buttonId);
        if (originalButton) {
            const item = document.createElement('div');
            item.className = 'draggable-button-item';
            item.draggable = true;
            item.dataset.buttonId = buttonId;
            item.innerHTML = originalButton.innerHTML; 
            editor.appendChild(item);
        }
    });
}
// ▲▲▲ 替換結束 ▲▲▲

// ▼▼▼ 【最終修復版 | 相容移動端觸摸】請用這一整塊全新的代碼，完整替換舊的 initializeButtonOrderEditor 函數 ▼▼▼
/**
 * 【V2.0 | 移動端相容版】初始化按鈕排序編輯器的拖放事件
 */
function initializeButtonOrderEditor() {
    const editor = document.getElementById('button-order-editor');
    if (!editor) return;

    let draggingItem = null; // 用於存儲當前正在被拖動的元素

    // 統一的事件處理函數
    const handleDragStart = (e) => {
        const target = e.target.closest('.draggable-button-item');
        if (!target) return;
        
        draggingItem = target;
        draggingItem.classList.add('dragging');

        // 阻止預設行為，特別是在觸摸設備上防止頁面滾動
        if (e.cancelable) e.preventDefault();
    };

    const handleDragMove = (e) => {
        if (!draggingItem) return;

        // 統一獲取座標
        const clientX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
        
        const afterElement = getDragAfterElement(editor, clientX);
        
        if (afterElement == null) {
            editor.appendChild(draggingItem);
        } else {
            editor.insertBefore(draggingItem, afterElement);
        }
    };

    const handleDragEnd = () => {
        if (!draggingItem) return;

        draggingItem.classList.remove('dragging');
        draggingItem = null;
        
        // 拖動結束後，保存新的順序
        saveButtonOrder();
    };

    // --- 綁定事件 ---
    // 使用 mousedown 和 touchstart 來開始拖動
    editor.addEventListener('mousedown', handleDragStart);
    editor.addEventListener('touchstart', handleDragStart, { passive: false });

    // 使用 mousemove 和 touchmove 來處理拖動過程
    editor.addEventListener('mousemove', handleDragMove);
    editor.addEventListener('touchmove', handleDragMove, { passive: false });

    // 使用 mouseup, mouseleave 和 touchend 來結束拖動
    editor.addEventListener('mouseup', handleDragEnd);
    editor.addEventListener('mouseleave', handleDragEnd); // 防止滑鼠移出區域時卡住
    editor.addEventListener('touchend', handleDragEnd);
}
// ▲▲▲ 替換結束 ▲▲▲

// ▼▼▼ 【最終修復版】請用這個全新的函數，完整替換舊的 getDragAfterElement ▼▼▼
/**
 * 【V2.0 | 水準修復版】輔助函數：計算拖動元素應該插入到哪個元素前面
 * @param {HTMLElement} container - 拖放區域的容器
 * @param {number} x - 滑鼠當前的水準 (X) 座標
 * @returns {HTMLElement|null} - 應該被插入到其前面的那個元素
 */
function getDragAfterElement(container, x) {
    // 1. 獲取容器內所有可拖拽的、但不是正在被拖拽的元素
    const draggableElements = [...container.querySelectorAll('.draggable-button-item:not(.dragging)')];

    // 2. 使用 reduce 方法來找到最接近的那個元素
    return draggableElements.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        // 3. 【核心修正】計算滑鼠 X 座標到元素中心的水準距離
        const offset = x - box.left - box.width / 2;
        
        // 4. 我們要找的是：滑鼠在它左邊 (offset < 0)，並且是所有滿足條件裡最接近的那個 (offset > closest.offset)
        if (offset < 0 && offset > closest.offset) {
            return { offset: offset, element: child };
        } else {
            return closest;
        }
    }, { offset: Number.NEGATIVE_INFINITY }).element;
}
// ▲▲▲ 替換結束 ▲▲▲

/**
 * 保存使用者自訂的按鈕順序到資料庫
 */
async function saveButtonOrder() {
    const editor = document.getElementById('button-order-editor');
    const newOrder = Array.from(editor.querySelectorAll('.draggable-button-item')).map(item => item.dataset.buttonId);
    
    state.globalSettings.chatActionButtonsOrder = newOrder;
    await db.globalSettings.put(state.globalSettings);

    // (可選) 給用戶一個保存成功的提示
    // console.log("按鈕順序已保存:", newOrder);
}

/**
 * 【核心】根據已保存的順序，重新排列聊天介面底部的按鈕
 */
function applyButtonOrder() {
    const buttonOrder = state.globalSettings.chatActionButtonsOrder;
    if (!buttonOrder || !Array.isArray(buttonOrder) || buttonOrder.length === 0) {
        return; // 如果沒有保存的順序，則不執行任何操作
    }

    const container = document.getElementById('chat-input-actions-top');
    if (!container) return;

    // 按照保存的順序，依次將按鈕重新追加到容器末尾
    buttonOrder.forEach(buttonId => {
        const button = document.getElementById(buttonId);
        if (button) {
            container.appendChild(button);
        }
    });
}

// ▲▲▲ 全新JS代碼黏貼結束 ▲▲▲
// ▼▼▼ 【全新】定義預設的按鈕順序常量 ▼▼▼
const DEFAULT_BUTTON_ORDER = [
    'open-sticker-panel-btn', 'send-photo-btn', 'upload-image-btn', 
    'transfer-btn', 'voice-message-btn', 'send-waimai-request-btn', 
    'video-call-btn', 'group-video-call-btn', 'send-poll-btn', 
    'share-link-btn', 'share-location-btn', 'gomoku-btn', 
    'open-shopping-btn', 'pat-btn', 'edit-last-response-btn', 
    'regenerate-btn', 'propel-btn', 'show-announcement-board-btn',
'werewolf-game-btn',
    // ▼▼▼ 在這裡添加新按鈕ID ▼▼▼
    'read-together-btn'
];
// ▲▲▲ 新增代碼結束 ▲▲▲
// ▼▼▼ 【全新】重新開機按鈕順序的核心功能函數 ▼▼▼
async function resetButtonOrder() {
    // 1. 在使用者的全域設置中，將自訂順序清除 (設為 null)
    state.globalSettings.chatActionButtonsOrder = null;
    await db.globalSettings.put(state.globalSettings);

    // 2. 重新渲染排序編輯器，它會自動恢復到預設順序
    renderButtonOrderEditor();

    // 3. 應用預設順序到真實的聊天介面
    applyButtonOrder();

    // 4. 給用戶一個成功的提示
    await showCustomAlert("成功", "按鈕順序已恢復為預設設置！");
}
// ▲▲▲ 新增代碼結束 ▲▲▲


// ▼▼▼ 【全新 V2.0 | 已修復】這是高級資料清理功能的【全部核心JS代碼】，請完整黏貼 ▼▼▼

let selectedCharsForClear = []; // 用於存儲第一步選擇的角色ID
let selectedTypesForClear = []; // 用於存儲第二步選擇的資料類型

/**
 * 【總入口】打開高級資料清理嚮導
 */
function openDataClearWizard() {
    const modal = document.getElementById('data-clear-wizard-modal');
    selectedCharsForClear = [];
    selectedTypesForClear = [];
    
    // 渲染第一步
    renderClearWizardStep1();
    
    // 顯示第一步，隱藏第二步
    document.getElementById('data-clear-step-1').style.display = 'flex';
    document.getElementById('data-clear-step-2').style.display = 'none';
    
    modal.classList.add('visible');
}

/**
 * 渲染嚮導的第一步：角色選擇列表
 */
function renderClearWizardStep1() {
    const listEl = document.getElementById('data-clear-char-list');
    listEl.innerHTML = '';

    // 1. 添加“我自己”的選項
    const userItem = document.createElement('div');
    userItem.className = 'clear-posts-item';
    userItem.dataset.charId = 'user';
    userItem.innerHTML = `
        <div class="checkbox"></div>
        <span class="name">${state.qzoneSettings.nickname || '我'} (用戶)</span>
    `;
    listEl.appendChild(userItem);

    // 2. 添加所有AI角色的選項
    Object.values(state.chats).forEach(chat => {
        if (!chat.isGroup) {
            const charItem = document.createElement('div');
            charItem.className = 'clear-posts-item';
            charItem.dataset.charId = chat.id;
            charItem.innerHTML = `
                <div class="checkbox"></div>
                <span class="name">${chat.name} (角色)</span>
            `;
            listEl.appendChild(charItem);
        }
    });
}

/**
 * 【V2.0 | 已修正資料分類】渲染嚮導的第二步：資料類型選擇列表
 */
function renderClearWizardStep2() {
    const listEl = document.getElementById('data-clear-type-list');
    listEl.innerHTML = '';
    
    const dataTypes = [
        { id: 'chat', name: '聊天記錄', description: '將清空選定角色的所有對話消息。' },
        { id: 'qzone', name: '動態與互動', description: '將清空選定角色的所有動態、評論和點贊。' },
        { id: 'calls', name: '通話記錄', description: '將清空選定角色的所有通話記錄。' },
        // 【【【核心修正1：資料分類】】】
        { id: 'thoughts', name: '心聲', description: '將清空選定角色的心聲和散記歷史。' },
        { id: 'memories', name: '長期記憶', description: '將清空選定角色的所有長期記憶。' },
        { id: 'cphone', name: 'Cphone數據 (CPhone)', description: '將清空角色的相冊、QQ、流覽器、淘寶、日記、備忘錄等所有類比手機資料。' }
    ];

    dataTypes.forEach(type => {
        const item = document.createElement('div');
        item.className = 'clear-posts-item';
        item.dataset.typeId = type.id;
        item.innerHTML = `
            <div class="checkbox"></div>
            <div>
                <span class="name">${type.name}</span>
                <p style="font-size: 12px; color: #888; margin: 4px 0 0;">${type.description}</p>
            </div>
        `;
        listEl.appendChild(item);
    });
}


/**
 * 處理“下一步”按鈕的點擊事件
 */
function handleDataClearNext() {
    const selectedItems = document.querySelectorAll('#data-clear-char-list .clear-posts-item.selected');
    if (selectedItems.length === 0) {
        alert("請至少選擇一個要清理的角色。");
        return;
    }

    selectedCharsForClear = Array.from(selectedItems).map(item => item.dataset.charId);
    
    // 渲染第二步並切換視圖
    renderClearWizardStep2();
    document.getElementById('data-clear-step-1').style.display = 'none';
    document.getElementById('data-clear-step-2').style.display = 'flex';
}

/**
 * 處理“上一步”按鈕的點擊事件
 */
function handleDataClearBack() {
    document.getElementById('data-clear-step-2').style.display = 'none';
    document.getElementById('data-clear-step-1').style.display = 'flex';
    // 保留已選中的角色
    document.querySelectorAll('#data-clear-char-list .clear-posts-item').forEach(item => {
        if (selectedCharsForClear.includes(item.dataset.charId)) {
            item.classList.add('selected');
        }
    });
}

/**
 * 【V2.0 | 已修正資料分類】處理最終確認清理的邏輯
 */
async function handleConfirmDataClear() {
    const selectedItems = document.querySelectorAll('#data-clear-type-list .clear-posts-item.selected');
    if (selectedItems.length === 0) {
        alert("請至少選擇一種要清理的資料類型。");
        return;
    }

    selectedTypesForClear = Array.from(selectedItems).map(item => item.dataset.typeId);

    const confirmed = await showCustomConfirm(
        '最後確認！',
        '此操作將永久刪除您選擇的所有資料，且無法恢復！確定要繼續嗎？',
        { confirmButtonClass: 'btn-danger', confirmText: '確認刪除' }
    );

    if (!confirmed) return;
    
    await showCustomAlert("請稍候...", "正在執行清理操作，請不要關閉頁面...");

    try {
        await db.transaction('rw', db.tables, async () => {
            for (const charId of selectedCharsForClear) {
                for (const type of selectedTypesForClear) {
                    
                    if (type === 'chat') {
                        if (charId === 'user') {
                            const allChats = await db.chats.toArray();
                            for (const chat of allChats) {
                                chat.history = chat.history.filter(msg => msg.role !== 'user');
                                await db.chats.put(chat);
                            }
                        } else {
                            const chat = await db.chats.get(charId);
                            if (chat) {
                                chat.history = [];
                                await db.chats.put(chat);
                            }
                        }
                    }

                    if (type === 'qzone') {
                        const authorId = (charId === 'user') ? 'user' : charId;
                        await db.qzonePosts.where('authorId').equals(authorId).delete();
                    }

                    if (type === 'calls' && charId !== 'user') {
                        await db.callRecords.where('chatId').equals(charId).delete();
                    }

                    // 【【【核心修正2：清理邏輯】】】
                    if (type === 'thoughts' && charId !== 'user') {
                        const chat = await db.chats.get(charId);
                        if (chat) {
                            chat.thoughtsHistory = [];
                            // 不再清理日記和備忘錄
                            await db.chats.put(chat);
                        }
                    }

                    if (type === 'memories' && charId !== 'user') {
                        const chat = await db.chats.get(charId);
                        if (chat) {
                            chat.longTermMemory = [];
                            await db.chats.put(chat);
                        }
                    }
                    
                    if (type === 'cphone' && charId !== 'user') {
                        const chat = await db.chats.get(charId);
                        if (chat) {
                            // 清理所有CPhone相關資料，並加入日記和備忘錄
                            chat.simulatedAlbum = [];
                            chat.simulatedConversations = [];
                            chat.simulatedBrowserHistory = [];
                            chat.simulatedTaobaoHistory = null;
                            chat.simulatedAmapHistory = [];
                            chat.simulatedAppUsage = [];
                            chat.simulatedMusicPlaylist = [];
                            chat.diary = []; // <-- 新增
                            chat.memos = []; // <-- 新增
                            await db.chats.put(chat);
                        }
                    }
                }
            }
        });
        
        await loadAllDataFromDB();
        await renderChatList();
        
        document.getElementById('data-clear-wizard-modal').classList.remove('visible');
        await showCustomAlert("清理完成", "指定的資料已成功清除。");

    } catch (error) {
        console.error("高級資料清理失敗:", error);
        await showCustomAlert("清理失敗", `操作失敗: ${error.message}`);
    }
}
// ▲▲▲ 全新JS代碼黏貼結束 ▲▲▲
        /**
         * 【全新 V2.0 | 支援本地上傳】處理更換圖示的邏輯 (EPhone & CPhone通用)
         * @param {string} iconId - 被點擊圖示的ID (例如 'qq', 'album')
         * @param {string} phoneType - 'ephone' 或 'cphone'
         * @param {HTMLElement} itemElement - 被點擊的那個圖示設置項的DOM元素
         */
        async function handleIconChange(iconId, phoneType, itemElement) {
            const appName = itemElement.querySelector('.icon-preview').alt;
        
            // 1. 彈出選擇框，讓使用者選擇上傳方式
            const choice = await showChoiceModal(`更換“${appName}”圖示`, [
                { text: '📁 從本地上傳', value: 'local' },
                { text: '🌐 使用網路URL', value: 'url' }
            ]);
        
            let newUrl = null;
        
            // 2. 根據使用者的選擇執行不同操作
            if (choice === 'local') {
                // 調用我們現有的本地上傳輔助函數
                newUrl = await uploadImageLocally();
            } else if (choice === 'url') {
                const currentUrl = (phoneType === 'cphone')
                    ? state.globalSettings.cphoneAppIcons[iconId]
                    : state.globalSettings.appIcons[iconId];

                // ★★★★★ 這就是本次修復的核心！ ★★★★★
                // 1. 判斷當前的URL是不是一個Base64字串
                const isBase64 = currentUrl.startsWith('data:image');

                // 2. 如果是Base64，我們就傳一個空字串作為預設值，避免卡死。
                //    如果不是，就正常顯示當前的URL，方便用戶修改。
                const initialValueForPrompt = isBase64 ? '' : currentUrl;
                // ★★★★★ 修復結束 ★★★★★

                // 3. 使用我們新處理過的值來調用彈窗
                newUrl = await showCustomPrompt(
                    `更換圖示`, 
                    '請輸入新的圖片URL', 
                    initialValueForPrompt, // <-- 使用這個新變數
                    'url'
                );
            }
        
            // 3. 如果獲取到了新值（無論是Base64還是URL），就更新並保存
            if (newUrl && newUrl.trim()) {
                const trimmedUrl = newUrl.trim();
                
                // 根據手機類型，更新 state 中對應的資料
                if (phoneType === 'cphone') {
                    state.globalSettings.cphoneAppIcons[iconId] = trimmedUrl;
                } else {
                    state.globalSettings.appIcons[iconId] = trimmedUrl;
                }
                
                // 即時更新設置頁面的預覽圖
                itemElement.querySelector('.icon-preview').src = trimmedUrl;
                
                // 無需在這裡保存到資料庫，等待使用者點擊“保存所有外觀設置”按鈕時統一保存。
            } else if (newUrl !== null) {
                // 如果用戶輸入了無效的URL
                alert("請輸入一個有效的URL或選擇一個檔！");
            }
        }
// ▼▼▼ 【最終修復版】請用這個全新的、分步執行的函數，完整替換舊的 compressAllLocalImages ▼▼▼

/**
 * 【總入口 | V2.0 修復版】一鍵壓縮資料庫中所有本地上傳的圖片
 */
async function compressAllLocalImages() {
    // 1. 彈出最終確認框 (邏輯不變)
    const confirmed = await showCustomConfirm(
        '確認壓縮圖片？',
        '此操作將掃描並壓縮所有本地上傳的圖片（Base64格式），將其轉換為JPEG以減小體積。這會輕微降低圖片品質且【不可恢復】。<br><br><strong>強烈建議在操作前先進行資料備份！</strong>',
        { confirmButtonClass: 'btn-danger', confirmText: '我已瞭解風險，確認壓縮' }
    );

    if (!confirmed) return;

    // 2. 顯示處理中的提示 (邏輯不變)
    await showCustomAlert("請稍候...", "正在開始全面壓縮圖片，根據圖片數量，這可能需要幾分鐘時間，請不要關閉或刷新頁面...");

    let stats = {
        found: 0,
        compressed: 0,
        skipped: 0,
        originalSize: 0,
        newSize: 0
    };

    try {
        // ==========================================================
        //            ★★★ 核心修復邏輯從這裡開始 ★★★
        // ==========================================================
        
        // --- 步驟 A: 讀取所有相關資料到記憶體 ---
        console.log("壓縮步驟 1/3: 正在從資料庫讀取所有相關資料...");
        const tablesToScan = [
            'chats', 'globalSettings', 'qzoneSettings', 
            'userStickers', 'customAvatarFrames'
        ];
        const allData = [];
        for (const tableName of tablesToScan) {
            const table = db.table(tableName);
            const records = await table.toArray();
            allData.push({ tableName, records });
        }

        // --- 步驟 B: 在記憶體中對資料進行非同步壓縮 ---
        console.log("壓縮步驟 2/3: 正在記憶體中非同步壓縮圖片，這可能需要一些時間...");
        for (const data of allData) {
            for (const record of data.records) {
                // traverseAndCompress 函數現在是安全的，因為它不再處於一個開啟的事務中
                await traverseAndCompress(record, stats);
            }
        }
        
        // --- 步驟 C: 開啟一個新事務，將所有修改後的資料一次性寫回資料庫 ---
        console.log("壓縮步驟 3/3: 正在將壓縮後的資料寫回資料庫...");
        await db.transaction('rw', tablesToScan, async () => {
            for (const data of allData) {
                // 使用 bulkPut 批量更新，性能更佳
                await db.table(data.tableName).bulkPut(data.records);
            }
        });
        
        // ==========================================================
        //            ★★★ 核心修復邏輯到此結束 ★★★
        // ==========================================================

        // 4. 操作完成後，顯示統計結果 (邏輯不變)
        const reduction = stats.originalSize - stats.newSize;
        const reductionPercent = stats.originalSize > 0 ? (reduction / stats.originalSize * 100).toFixed(2) : 0;

        await showCustomAlert(
            '壓縮完成！',
            `掃描完成！<br>
            - 共找到 ${stats.found} 張本地圖片<br>
            - 成功壓縮 ${stats.compressed} 張<br>
            - 跳過(已壓縮或無需壓縮) ${stats.skipped} 張<br>
            - 空間節省了 <strong>${(reduction / 1024 / 1024).toFixed(2)} MB</strong> (壓縮率 ${reductionPercent}%)
            <br><br>
            建議刷新頁面以應用所有更改。`
        );

    } catch (error) {
        console.error("圖片壓縮過程中發生錯誤:", error);
        await showCustomAlert('壓縮失敗', `操作失敗: ${error.message}`);
    }
}

// ▲▲▲ JS函數替換結束 ▲▲▲

/**
 * 【輔助函數】遞迴遍歷物件，找到並壓縮所有Base64圖片
 * @param {object|Array} obj - 要遍歷的物件或陣列
 * @param {object} stats - 用於統計的物件
 */
async function traverseAndCompress(obj, stats) {
    for (const key in obj) {
        if (typeof obj[key] === 'string' && obj[key].startsWith('data:image')) {
            stats.found++;
            const originalBase64 = obj[key];
            stats.originalSize += originalBase64.length;

            const compressedBase64 = await compressImage(originalBase64);

            if (compressedBase64 && compressedBase64 !== originalBase64) {
                obj[key] = compressedBase64; // 直接修改原物件
                stats.compressed++;
                stats.newSize += compressedBase64.length;
            } else {
                stats.skipped++;
                stats.newSize += originalBase64.length;
            }
        } else if (typeof obj[key] === 'object' && obj[key] !== null) {
            // 如果是嵌套物件或陣列，則繼續遞迴
            await traverseAndCompress(obj[key], stats);
        }
    }
}

/**
 * 【核心壓縮函數】將單個Base64圖片字串壓縮為JPEG格式
 * @param {string} base64Str - 原始的Base64圖片字串
 * @param {object} options - 壓縮選項 (品質、最大寬度)
 * @returns {Promise<string|null>} - 返回壓縮後的Base64字串，如果無需壓縮或失敗則返回原字串
 */
function compressImage(base64Str, options = {}) {
    return new Promise((resolve) => {
        // 如果已經是JPEG，或者不是一個有效的圖片字串，則直接跳過
        if (base64Str.startsWith('data:image/jpeg') || !base64Str.startsWith('data:image')) {
            resolve(base64Str);
            return;
        }

        const quality = options.quality || 0.7; // 70%的JPEG品質
        const maxWidth = options.maxWidth || 1024; // 圖片最大寬度限制為1024px

        const img = new Image();
        img.onload = () => {
            let width = img.width;
            let height = img.height;

            // 如果圖片寬度超過最大限制，則等比縮放
            if (width > maxWidth) {
                height = (maxWidth / width) * height;
                width = maxWidth;
            }

            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            
            // 將圖片繪製到canvas上
            ctx.drawImage(img, 0, 0, width, height);
            
            // 從canvas匯出為JPEG格式的Base64字串
            const newDataUrl = canvas.toDataURL('image/jpeg', quality);
            
            // 只有當壓縮後的體積比原來小時才替換
            if (newDataUrl.length < base64Str.length) {
                resolve(newDataUrl);
            } else {
                resolve(base64Str); // 壓縮後反而變大了，保留原圖
            }
        };
        img.onerror = () => {
            console.warn("載入圖片失敗，跳過壓縮:", base64Str.substring(0, 50) + "...");
            resolve(base64Str); // 載入失敗，保留原圖
        };
        img.src = base64Str;
    });
}
// ▲▲▲ JS代碼黏貼結束 ▲▲▲
// ▼▼▼ 【全新】這是更新通知功能的【全部核心JS代碼】，請完整黏貼 ▼▼▼

/**
 * 檢查應用更新並根據版本決定是否顯示通知
 */
async function checkForUpdates() {
    // 關鍵1：在你的主應用中定義當前的版本號。
    // 每次你希望用戶看到更新通知時，都需要更新 `update-notice.html` 裡的 `data-version`。
    // 這個版本號主要是為了邏輯完整性，但核心判斷依據是通知檔裡的版本。
    const CURRENT_APP_VERSION = "1.0"; 

    try {
        // 1. 從伺服器獲取最新的通知檔內容
        const response = await fetch('update-notice.html?_=' + Date.now()); // 添加時間戳記防止緩存
        if (!response.ok) {
            console.warn('獲取更新通知檔失敗。');
            return;
        }
        const noticeHtml = await response.text();
        
        // 2. 解析通知內容和版本號
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = noticeHtml;
        const noticeContent = tempDiv.querySelector('[data-version]');
        
        if (!noticeContent) {
            console.error('更新通知檔中缺少 data-version 屬性。');
            return;
        }
        
        const notificationVersion = noticeContent.dataset.version;
        
        // 3. 從本機存放區中獲取用戶上次忽略的版本號
        const dismissedVersion = localStorage.getItem('dismissedUpdateVersion');
        
        // 4. 核心邏輯：如果通知版本號比用戶忽略的版本號要新，就顯示通知
        // 使用簡單的字串比較即可
        if (notificationVersion > dismissedVersion) {
            console.log(`發現新版本通知: ${notificationVersion} (已忽略版本: ${dismissedVersion})`);
            showUpdateNotice(notificationVersion, noticeContent.innerHTML);
        } else {
            console.log(`當前通知版本 (${notificationVersion}) 已被使用者忽略，無需顯示。`);
        }

    } catch (error) {
        console.error('檢查更新時出錯:', error);
    }
}

/**
 * 顯示更新通知彈窗
 * @param {string} version - 當前通知的版本號
 * @param {string} contentHtml - 要顯示的HTML內容
 */
function showUpdateNotice(version, contentHtml) {
    const modal = document.getElementById('update-notice-modal');
    const body = document.getElementById('update-notice-body');
    const confirmBtn = document.getElementById('update-notice-confirm-btn');
    const dismissBtn = document.getElementById('update-notice-dismiss-btn');
    
    body.innerHTML = contentHtml;
    
    // “我知道了”按鈕：只關閉彈窗，不記錄版本
    confirmBtn.onclick = () => {
        modal.classList.remove('visible');
    };
    
    // “不再提示”按鈕：關閉彈窗，並將當前版本號存入localStorage
    dismissBtn.onclick = () => {
        localStorage.setItem('dismissedUpdateVersion', version);
        modal.classList.remove('visible');
        console.log(`用戶已忽略版本: ${version}`);
    };
    
    modal.classList.add('visible');
}

// ▲▲▲ 新增JS代碼結束 ▲▲▲
// ▼▼▼ 【全新】這是豆瓣設置功能的【全部核心JS代碼】，請完整黏貼 ▼▼▼

/**
 * 【總入口】打開豆瓣設置彈窗
 */
function openDoubanSettingsModal() {
    const modal = document.getElementById('douban-settings-modal');
    
    // 從全域設置中讀取已保存的值，如果沒有就使用預設值
    document.getElementById('douban-min-posts-input').value = state.globalSettings.doubanMinPosts || 12;
    document.getElementById('douban-max-posts-input').value = state.globalSettings.doubanMaxPosts || 20;
    
    modal.classList.add('visible');
}

/**
 * 保存豆瓣設置
 */
async function saveDoubanSettings() {
    const minInput = document.getElementById('douban-min-posts-input');
    const maxInput = document.getElementById('douban-max-posts-input');
    
    const min = parseInt(minInput.value);
    const max = parseInt(maxInput.value);

    // 資料驗證
    if (isNaN(min) || isNaN(max) || min < 1 || max < 1) {
        alert("請輸入有效的正整數！");
        return;
    }
    if (min > max) {
        alert("最小帖子數不能大於最大帖子數！");
        return;
    }

    // 保存到全域狀態和資料庫
    state.globalSettings.doubanMinPosts = min;
    state.globalSettings.doubanMaxPosts = max;
    await db.globalSettings.put(state.globalSettings);

    // 關閉彈窗並提示用戶
    document.getElementById('douban-settings-modal').classList.remove('visible');
    await showCustomAlert('保存成功', '豆瓣設置已更新！下次重新生成時將生效。');
}
// ▲▲▲ 新增JS代碼黏貼結束 ▲▲▲
/**
 * 【全新 | V2.1 | 本名追蹤版】打開狼人殺遊戲大廳
 * @param {'global' | 'group'} mode - 模式：'global'表示從遊戲小屋進入，'group'表示從群聊進入
 */
async function openWerewolfLobby(mode) {
    const modal = document.getElementById('werewolf-lobby-modal');
    const listEl = document.getElementById('werewolf-player-selection-list');
    listEl.innerHTML = '';
    
    let potentialPlayers = [];
    
    if (mode === 'global') {
        const characters = Object.values(state.chats).filter(c => !c.isGroup);
        const npcs = await db.npcs.toArray();
        potentialPlayers = [
            // 為用戶添加本名
            { id: 'user', name: state.qzoneSettings.nickname || '我', originalName: state.qzoneSettings.nickname || '我', avatar: state.qzoneSettings.avatar, type: 'user' },
            // 為角色添加本名
            ...characters.map(c => ({ id: c.id, name: c.name, originalName: c.originalName, avatar: c.settings.aiAvatar, type: 'character' })),
            // 為NPC添加本名 (使用其昵稱作為本名)
            ...npcs.map(n => ({ id: `npc_${n.id}`, name: n.name, originalName: n.name, avatar: n.avatar, type: 'npc' }))
        ];
        werewolfGameState.chatId = null;
    } else {
        const chat = state.chats[state.activeChatId];
        if (!chat || !chat.isGroup) return;
        
        potentialPlayers = [
            // 為用戶添加本名
            { id: 'user', name: chat.settings.myNickname || '我', originalName: state.qzoneSettings.nickname || '我', avatar: chat.settings.myAvatar, type: 'user' },
            // 為群成員添加本名
            ...chat.members.map(m => {
                const char = state.chats[m.id];
                const memberAvatar = m.avatar || (char ? char.settings.aiAvatar : defaultGroupMemberAvatar);
                return { 
                    id: m.id, 
                    name: m.groupNickname, 
                    originalName: m.originalName, // 核心：記錄本名
                    avatar: memberAvatar, 
                    type: m.isNpc ? 'npc' : 'character' 
                };
            })
        ];
        werewolfGameState.chatId = state.activeChatId;
    }

    potentialPlayers.forEach(player => {
        const item = document.createElement('div');
        item.className = 'contact-picker-item';
        item.innerHTML = `
            <input type="checkbox" class="werewolf-player-checkbox" data-player-json='${JSON.stringify(player)}' ${player.type === 'user' ? 'checked disabled' : 'checked'}>
            <img src="${player.avatar}" class="avatar">
            <span class="name">${player.name}</span>
        `;
        listEl.appendChild(item);
    });
    
    modal.classList.add('visible');
}

/**
         * 【V3.0 | 已添加女巫守衛】初始化一局新的狼人殺遊戲
         */
        async function initializeWerewolfGame() {
            const selectedCheckboxes = document.querySelectorAll('.werewolf-player-checkbox:checked');
            const playerCount = selectedCheckboxes.length;

            let roles = [];
            if (playerCount === 6) {
                werewolfGameState.gameMode = '6p';
                roles = ['狼人', '狼人', '平民', '平民', '預言家', '獵人'];
            } else if (playerCount === 9) {
                werewolfGameState.gameMode = '9p';
                roles = ['狼人', '狼人', '狼人', '平民', '平民', '平民', '預言家', '女巫', '獵人'];
            } else if (playerCount === 12) {
                werewolfGameState.gameMode = '12p';
                roles = ['狼人', '狼人', '狼人', '狼人', '平民', '平民', '平民', '平民', '預言家', '女巫', '獵人', '守衛'];
            } else {
                alert(`當前人數 ${playerCount} 不支持。請選擇6、9或12人。`);
                return;
            }

            document.getElementById('werewolf-lobby-modal').classList.remove('visible');
            await showCustomAlert('正在發牌...', '遊戲即將開始，正在為各位玩家分配身份...');

            for (let i = roles.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [roles[i], roles[j]] = [roles[j], roles[i]];
            }

            const selectedPlayers = Array.from(selectedCheckboxes).map(cb => JSON.parse(cb.dataset.playerJson));
            werewolfGameState.players = [];

            for (let i = 0; i < selectedPlayers.length; i++) {
                const playerInfo = selectedPlayers[i];
                const role = roles[i];
                
                let character_persona = "一個普通玩家";
                if (playerInfo.type === 'character') {
                    const char = state.chats[playerInfo.id];
                    character_persona = char ? char.settings.aiPersona : '未知設定的角色';
                } else if (playerInfo.type === 'npc') {
                    const npcs = await db.npcs.toArray();
                    const npc = npcs.find(n => `npc_${n.id}` === playerInfo.id);
                    character_persona = npc ? npc.persona : '未知設定的NPC';
                } else if (playerInfo.type === 'user') {
                    const activeChat = werewolfGameState.chatId ? state.chats[werewolfGameState.chatId] : null;
                    character_persona = activeChat ? activeChat.settings.myPersona : '我是誰呀。';
                }

                const playerObject = {
                    ...playerInfo,
                    role: role,
                    isAlive: true,
                    character_persona: character_persona
                };

                // ▼▼▼ 【核心新增：為特殊角色添加屬性】 ▼▼▼
                if (role === '女巫') {
                    playerObject.antidoteUsed = false;
                    playerObject.poisonUsed = false;
                }
                if (role === '守衛') {
                    playerObject.lastGuardedId = null;
                }
                // ▲▲▲ 新增結束 ▲▲▲

                werewolfGameState.players.push(playerObject);
            }
            
            werewolfGameState.isActive = true;
            werewolfGameState.currentDay = 1;
            werewolfGameState.currentPhase = 'start';
            werewolfGameState.gameLog = [];
            werewolfGameState.discussionLog = [];

            const roleCounts = roles.reduce((acc, role) => { acc[role] = (acc[role] || 0) + 1; return acc; }, {});
            const roleSummary = Object.entries(roleCounts).map(([role, count]) => `${role} x${count}`).join('、');
            addGameLog(`遊戲配置：${playerCount}人局，身份為 ${roleSummary}。`);

            const myPlayer = werewolfGameState.players.find(p => p.id === 'user');

            renderWerewolfScreen();
            showScreen('werewolf-game-screen');
            
            showMyRole(myPlayer.role);
        }

// ▼▼▼ 【V2.1 | 跨天顯示修復版】請用這個全新的函數，完整替換舊的 renderWerewolfScreen ▼▼▼
/**
 * 【V2.1 | UI修復版】渲染狼人殺遊戲主介面
 */
function renderWerewolfScreen() {
    const gridEl = document.getElementById('werewolf-player-grid');
    gridEl.innerHTML = '';
    const sortedPlayers = [...werewolfGameState.players].sort((a, b) => a.isAlive - b.isAlive);

    sortedPlayers.forEach((p, index) => {
        const playerIndex = werewolfGameState.players.findIndex(player => player.id === p.id) + 1;
        const avatarEl = document.createElement('div');
        avatarEl.className = 'werewolf-player-avatar';
        if (!p.isAlive) avatarEl.classList.add('dead');
        avatarEl.innerHTML = `
            <img src="${p.avatar}">
            <span class="player-name">${playerIndex}. ${p.name}</span>
        `;
        gridEl.appendChild(avatarEl);
    });

    const logEl = document.getElementById('werewolf-log');
    logEl.innerHTML = '';
    
    // 【【【核心修改：按天渲染日誌】】】
    for (let day = 1; day <= werewolfGameState.currentDay; day++) {
        // 1. 篩選出當天的所有日誌
        const logsThisDay = [
            ...werewolfGameState.gameLog.filter(entry => entry.day === day),
            ...werewolfGameState.discussionLog.filter(entry => entry.day === day)
        ].sort((a,b) => (a.timestamp || 0) - (b.timestamp || 0));

        // 如果當天有任何記錄，就先添加一個天數標題
        if (logsThisDay.length > 0) {
            const dayHeader = document.createElement('div');
            dayHeader.className = 'werewolf-log-entry system';
            dayHeader.textContent = `--- 第 ${day} 天 ---`;
            dayHeader.style.cssText = 'font-weight: bold; background: rgba(255, 193, 7, 0.2);';
            logEl.appendChild(dayHeader);

            // 2. 渲染當天的每一條日誌
            logsThisDay.forEach(entry => {
                const entryEl = document.createElement('div');
                entryEl.className = `werewolf-log-entry ${entry.type}`;
                if (entry.type === 'dialogue') {
                    entryEl.innerHTML = `<span class="speaker">${entry.speaker}:</span> ${entry.content}`;
                } else {
                    entryEl.textContent = entry.content;
                }
                logEl.appendChild(entryEl);
            });
        }
    }
    // 【【【修改結束】】】

    logEl.scrollTop = logEl.scrollHeight;
    
    // 在標題中明確顯示天數和當前階段
    const phaseMap = {
        'start': '遊戲開始',
        'night': `第${werewolfGameState.currentDay}天 - 夜晚`,
        'day': `第${werewolfGameState.currentDay}天 - 白天`,
        'discussion': `第${werewolfGameState.currentDay}天 - 討論`,
        'voting': `第${werewolfGameState.currentDay}天 - 投票`,
        'gameover': '遊戲結束'
    };
    document.getElementById('werewolf-game-title').textContent = `狼人殺 - ${phaseMap[werewolfGameState.currentPhase] || werewolfGameState.currentPhase}`;
}
// ▲▲▲ 替換結束 ▲▲▲


/**
 * 顯示玩家自己的身份卡片
 * @param {string} role - 玩家的角色
 */
function showMyRole(role) {
    const roleDescriptions = {
        '狼人': '你的目標是殺死所有好人。每晚可以和同伴一起刀一個玩家。',
        '平民': '你沒有任何特殊能力，你的目標是通過投票放逐所有狼人。',
        '預言家': '每晚可以查驗一個玩家的身份是好人還是狼人。',
        '獵人': '當你死亡時，你可以選擇帶走場上任意一名玩家。',
        '女巫': '你有一瓶解藥和一瓶毒藥，解藥可以救活當晚被殺的玩家，毒藥可以毒死任意一名玩家。',
        '守衛': '每晚可以守護一名玩家，使其免受狼人襲擊。不能連續兩晚守護同一個人。'
    };
    
    document.getElementById('werewolf-role-name').textContent = role;
    document.getElementById('werewolf-role-description').textContent = roleDescriptions[role] || '一個神秘的角色。';
    document.getElementById('werewolf-role-modal').classList.add('visible');
}

/**
         * 【V3.0 | 已補全守衛女巫】執行夜晚階段的邏輯
         */
        async function executeNightPhase() {
            werewolfGameState.currentPhase = `第${werewolfGameState.currentDay}天 - 夜晚`;
            werewolfGameState.nightActions = {}; // 重置當晚行動
            addGameLog('天黑請閉眼...');
            renderWerewolfScreen();
            
            document.getElementById('werewolf-action-bar').style.display = 'none';
            document.getElementById('werewolf-retry-btn').style.display = 'none'; // 隱藏重試按鈕
            await new Promise(resolve => setTimeout(resolve, 1500));
        
            // 1. 守衛行動 (最先行動)
            const guard = werewolfGameState.players.find(p => p.role === '守衛' && p.isAlive);
            if (guard) {
                addGameLog('守衛請睜眼，請選擇要守護的玩家。');
                renderWerewolfScreen();
                let guardedId = null;
                if (guard.id === 'user') {
                    guardedId = await openSelectionModal('guard', guard.lastGuardedId);
                } else { // AI守衛
                    const potentialTargets = werewolfGameState.players.filter(p => p.isAlive && p.id !== guard.lastGuardedId);
                    if (potentialTargets.length > 0) {
                        guardedId = potentialTargets[Math.floor(Math.random() * potentialTargets.length)].id;
                    }
                }
                if (guardedId) {
                    werewolfGameState.nightActions.guardedId = guardedId;
                    guard.lastGuardedId = guardedId; // 記錄本輪守護的人
                }
                addGameLog('守衛已行動，守衛請閉眼。');
                renderWerewolfScreen();
                await new Promise(resolve => setTimeout(resolve, 1500));
            }

            // ▼▼▼ 【【【核心修改：狼人行動錯誤處理】】】 ▼▼▼
            // ▼▼▼ 【【【核心修復：第一夜狼人行動特殊處理】】】 ▼▼▼
            addGameLog('狼人請睜眼，請選擇要刀的玩家。');
            renderWerewolfScreen();
            
            const wolves = werewolfGameState.players.filter(p => p.role === '狼人' && p.isAlive);
            const userIsWolf = wolves.some(p => p.id === 'user');
            
            let wolfTargetId = null;

            // 標記當前操作，以便重試
            werewolfGameState.lastFailedAction = 'wolfKill';
            try {
                if (userIsWolf) {
                    addGameLog('你是狼人，請選擇刀人目標。');
                    renderWerewolfScreen();
                    wolfTargetId = await openWolfKillModal();
                } else {
                    // 如果是第一天，則執行本地隨機刀人，不調用API
                    if (werewolfGameState.currentDay === 1) {
                        console.log("第一夜，執行本地隨機刀人邏輯...");
                        const potentialTargets = werewolfGameState.players.filter(p => p.isAlive && p.role !== '狼人');
                        if (potentialTargets.length > 0) {
                            wolfTargetId = potentialTargets[Math.floor(Math.random() * potentialTargets.length)].id;
                        }
                    } else {
                        // 從第二天開始，才調用API進行智慧決策
                        wolfTargetId = await getAiWolfKillTarget();
                    }
                }
                // 如果成功，清除失敗標記
                werewolfGameState.lastFailedAction = null;
            } catch (error) {
                console.error("狼人行動API失敗:", error);
                await showCustomAlert("操作失敗", "AI狼人團隊無法決定目標，遊戲暫停。請點擊右上角的“重試”按鈕繼續。");
                document.getElementById('werewolf-retry-btn').style.display = 'block';
                return;
            }
            // ▲▲▲ 【【【修改結束】】】 ▲▲▲
            werewolfGameState.nightActions.killedId = wolfTargetId;
            addGameLog('狼人已行動，狼人請閉眼。');
            renderWerewolfScreen();
            await new Promise(resolve => setTimeout(resolve, 1500));

            // 3. 女巫行動
            const witch = werewolfGameState.players.find(p => p.role === '女巫' && p.isAlive);
            if (witch) {
                addGameLog('女巫請睜眼。');
                renderWerewolfScreen();
                const killedPlayer = werewolfGameState.players.find(p => p.id === werewolfGameState.nightActions.killedId);
                
                // 判斷是否是守衛守護的目標
                const isGuarded = werewolfGameState.nightActions.guardedId === werewolfGameState.nightActions.killedId;

                // 女巫只能看到狼人刀的人，如果被守衛守了，女巫看到的就是平安夜
                const playerToShowWitch = (isGuarded || !killedPlayer) ? null : killedPlayer;

                if (witch.id === 'user') {
                    let userWitchAction = await openWitchActionModal(playerToShowWitch, witch);
                    if (userWitchAction.save) {
                        werewolfGameState.nightActions.savedId = werewolfGameState.nightActions.killedId;
                        witch.antidoteUsed = true;
                    }
                    if (userWitchAction.poison) {
                        werewolfGameState.nightActions.poisonedId = userWitchAction.poison;
                        witch.poisonUsed = true;
                    }
                } else { // AI女巫
                    // AI女巫的全新決策邏輯
                    if (!witch.antidoteUsed && playerToShowWitch) {
                        let saveChance = 0;
                        if (werewolfGameState.currentDay === 1) {
                            // 第一天晚上，資訊很少，救人的風險很高。只有30%的幾率會冒險救人。
                            saveChance = 0.3; 
                        } else {
                            // 從第二天晚上開始，資訊增多，救人的價值更大，有80%的幾率會救人。
                            saveChance = 0.8;
                        }
                        
                        console.log(`AI女巫決策：今天是第${werewolfGameState.currentDay}天，救人概率為 ${saveChance * 100}%`);
                        
                        if (Math.random() < saveChance) {
                            console.log("AI女巫決定使用解藥！");
                            werewolfGameState.nightActions.savedId = werewolfGameState.nightActions.killedId;
                            witch.antidoteUsed = true;
                        } else {
                            console.log("AI女巫決定保留解藥。");
                        }
                    } 
                    
                    // 毒人邏輯保持不變：如果沒有救人，並且有毒藥，則有50%概率毒人
                    if (!werewolfGameState.nightActions.savedId && !witch.poisonUsed && Math.random() < 0.5) {
                        const poisonTargets = werewolfGameState.players.filter(p => p.isAlive && p.id !== werewolfGameState.nightActions.killedId);
                        if (poisonTargets.length > 0) {
                             const target = poisonTargets[Math.floor(Math.random() * poisonTargets.length)];
                             werewolfGameState.nightActions.poisonedId = target.id;
                             witch.poisonUsed = true;
                             console.log(`AI女巫決定使用毒藥，目標是: ${target.name}`);
                        }
                    }

                }
                addGameLog('女巫已行動，女巫請閉眼。');
                renderWerewolfScreen();
                await new Promise(resolve => setTimeout(resolve, 1500));
            }
        
            // 4. 預言家行動
            const prophet = werewolfGameState.players.find(p => p.role === '預言家' && p.isAlive);
            if (prophet) {
                addGameLog('預言家請睜眼，請選擇要查驗的玩家。');
                renderWerewolfScreen();
        
                if (prophet.id === 'user') {
                    const targetId = await openSelectionModal('prophet');
                    const targetPlayer = werewolfGameState.players.find(p => p.id === targetId);
                    if(targetPlayer) {
                        const isWolf = targetPlayer.role === '狼人';
                        await showCustomAlert('查驗結果', `你查驗的玩家 ${targetPlayer.name} 的身份是：${isWolf ? '狼人' : '好人'}`);
                        werewolfGameState.nightActions.prophetCheck = { target: targetId, result: isWolf ? '狼人' : '好人' };
                    }
                } else {
                    const potentialTargets = werewolfGameState.players.filter(p => p.isAlive && p.id !== prophet.id);
                    if (potentialTargets.length > 0) {
                        const target = potentialTargets[Math.floor(Math.random() * potentialTargets.length)];
                        werewolfGameState.nightActions.prophetCheck = { target: target.id, result: target.role === '狼人' ? '狼人' : '好人' };
                    }
                }
                addGameLog('預言家已行動，預言家請閉眼。');
                renderWerewolfScreen();
                await new Promise(resolve => setTimeout(resolve, 1500));
            }
            
            // 5. 進入白天
            executeDayPhase();
        }
        
/**
         * 【V3.0 | 已補全死亡結算】執行白天階段的邏輯
         */
        async function executeDayPhase() {
            werewolfGameState.currentPhase = `第${werewolfGameState.currentDay}天 - 白天`;
            werewolfGameState.voteResults = {};
            addGameLog('天亮了。');

            const { killedId, guardedId, savedId, poisonedId } = werewolfGameState.nightActions;
            const deathsThisNight = new Set(); // 使用 Set 來避免重複添加死亡玩家

            // 1. 計算狼人刀人結果
            if (killedId && killedId !== guardedId && killedId !== savedId) {
                deathsThisNight.add(killedId);
            }

            // 2. 計算女巫毒人結果
            if (poisonedId) {
                // 如果女巫救人和毒人是同一個人，則毒藥優先，該玩家死亡
                deathsThisNight.add(poisonedId);
            }

            // 3. 公佈死亡結果並處理技能
            if (deathsThisNight.size === 0) {
                addGameLog('昨晚是平安夜。');
            } else {
                for (const deadPlayerId of deathsThisNight) {
                    const deadPlayer = werewolfGameState.players.find(p => p.id === deadPlayerId);
                    if (deadPlayer && deadPlayer.isAlive) {
                        deadPlayer.isAlive = false;
                        addGameLog(`昨晚 ${deadPlayer.name} 死亡了。`);

                        // 獵人技能處理
                        if (deadPlayer.role === '獵人') {
                            addGameLog('獵人死亡，請選擇一名玩家帶走！');
                            renderWerewolfScreen();
                            let hunterTargetId = null;
                            if (deadPlayer.id === 'user') {
                                hunterTargetId = await openSelectionModal('hunter');
                            } else { 
                                const potentialTargets = werewolfGameState.players.filter(p => p.isAlive && p.id !== deadPlayer.id);
                                if (potentialTargets.length > 0) {
                                    hunterTargetId = potentialTargets[Math.floor(Math.random() * potentialTargets.length)].id;
                                }
                            }
                            const targetPlayer = werewolfGameState.players.find(p => p.id === hunterTargetId);
                            if(targetPlayer) {
                                targetPlayer.isAlive = false;
                                addGameLog(`獵人帶走了 ${targetPlayer.name}。`);
                            }
                        }
                    }
                }
            }
            
            renderWerewolfScreen();
        
            if (checkGameOver()) return;
        
            await startDiscussionPhase();
        }
        
// ▼▼▼ 【V2.0 | 已修復】請用這個全新的函數，完整替換舊的 startDiscussionPhase ▼▼▼
/**
 * 【V2.0 | 已修復】開始討論環節
 */
async function startDiscussionPhase() {
    // 【【【核心修復】：不再清空討論記錄！】】】
    // werewolfGameState.discussionLog = []; // <--- 確保這一行已被刪除或注釋掉！
    
    addGameLog('現在開始討論，請各位玩家依次發言。');
    renderWerewolfScreen();
    
    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('API未配置，無法生成對話。');
        return;
    }

    const systemPrompt = buildWerewolfPrompt();
    werewolfGameState.lastFailedAction = 'startDiscussion';
    try {
        await showCustomAlert("請稍候", "正在等待AI角色們進行激烈的討論...");

        let isGemini = proxyUrl.includes('generativelanguage');
        let messagesForApi = [{role: 'user', content: '請所有AI角色根據你們的身份和人設開始發言。'}];
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
        
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, ...messagesForApi],
                    temperature: state.globalSettings.apiTemperature || 0.95,
                })
            });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(`API 錯誤: ${errorData.error.message}`);
        }
        
        const data = await response.json();
        const aiResponseContent = getGeminiResponseText(data);
        
        const jsonMatch = aiResponseContent.match(/(\[[\s\S]*\])/);
        if (!jsonMatch) {
            throw new Error(`AI返回的討論內容格式不正確。原始返回: ${aiResponseContent}`);
        }
        const dialogues = JSON.parse(jsonMatch[0]);

        for (const dialogue of dialogues) {
            if(dialogue.speaker_name && dialogue.dialogue) {
                addDialogueLog(dialogue.speaker_name, dialogue.dialogue);
                renderWerewolfScreen();
                await new Promise(resolve => setTimeout(resolve, 1500 + Math.random() * 2000));
            }
        }
        
        werewolfGameState.lastFailedAction = null; 

    } catch(error) {
        console.error("狼人殺AI討論生成失敗:", error);
        await showCustomAlert("AI 發言失敗", `討論無法開始，遊戲暫停。請點擊右上角的“重試”按鈕繼續。\n錯誤: ${error.message}`);
        document.getElementById('werewolf-retry-btn').style.display = 'block';
        return;
    }

    const myPlayer = werewolfGameState.players.find(p => p.id === 'user');
    const actionBar = document.getElementById('werewolf-action-bar');
    const waitReplyBtn = document.getElementById('werewolf-wait-reply-btn');
    const finishSpeechBtn = document.getElementById('werewolf-finish-speech-btn');
    const userInput = document.getElementById('werewolf-user-input');

    actionBar.style.display = 'flex';

    if (myPlayer && myPlayer.isAlive) {
        waitReplyBtn.textContent = '等待回應';
        finishSpeechBtn.textContent = '結束發言';
        waitReplyBtn.style.display = 'block';
        finishSpeechBtn.style.display = 'block';
        userInput.disabled = false;
        userInput.placeholder = "輪到你發言了...";
        userInput.focus();
        
        const newWaitBtn = waitReplyBtn.cloneNode(true);
        waitReplyBtn.parentNode.replaceChild(newWaitBtn, waitReplyBtn);
        newWaitBtn.addEventListener('click', handleWerewolfWaitReply);

        const newFinishBtn = finishSpeechBtn.cloneNode(true);
        finishSpeechBtn.parentNode.replaceChild(newFinishBtn, finishSpeechBtn);
        newFinishBtn.addEventListener('click', handleUserWerewolfSpeech);

    } else {
        addGameLog('你已經死亡，無法發言。請等待其他玩家發言結束。');
        renderWerewolfScreen();
        
        waitReplyBtn.textContent = '繼續討論';
        finishSpeechBtn.textContent = '進入投票';
        waitReplyBtn.style.display = 'block';
        finishSpeechBtn.style.display = 'block';
        userInput.disabled = true;
        userInput.placeholder = "你已死亡，正在圍觀...";

        const newWaitBtn = waitReplyBtn.cloneNode(true);
        waitReplyBtn.parentNode.replaceChild(newWaitBtn, waitReplyBtn);
        newWaitBtn.addEventListener('click', handleAiContinueDiscussion);

        const newFinishBtn = finishSpeechBtn.cloneNode(true);
        finishSpeechBtn.parentNode.replaceChild(newFinishBtn, finishSpeechBtn);
        newFinishBtn.addEventListener('click', startVotingPhase);
    }
}
// ▲▲▲ 替換結束 ▲▲▲

/**
 * 【V3.4 | 稱呼修復版】構建用於生成所有AI討論的System Prompt
 */
function buildWerewolfPrompt() {
    const alivePlayers = werewolfGameState.players.filter(p => p.isAlive);
    const myPlayerObject = werewolfGameState.players.find(p => p.id === 'user');
    const myPlayerName = myPlayerObject ? myPlayerObject.name : '用戶';
    const isUserAlive = alivePlayers.some(p => p.id === 'user');

    // 角色檔案部分
    let charactersAndPlayersDossier = "# 角色與玩家檔案 (Character & Player Dossiers)\n";
    alivePlayers.forEach((p, i) => {
        const playerIndex = werewolfGameState.players.findIndex(player => player.id === p.id) + 1;
        // 【核心修改1】在這裡同時提供了昵稱和本名，並明確指示了本名的用途
        charactersAndPlayersDossier += `
## ${playerIndex}號玩家: ${p.name} (這是TA的昵稱)
- **本名 (你在對話中必須用這個名字稱呼TA)**: ${p.originalName}
- **身份**: ${p.id === 'user' ? '【用戶 (User)】' : '【AI角色】'}
- **人設 (必須嚴格遵守)**: ${p.character_persona}
`;
        
        if (p.type === 'character') {
            const char = state.chats[p.id];
            if (char && char.longTermMemory && char.longTermMemory.length > 0) {
                const memoryContent = char.longTermMemory.map(mem => mem.content).join('; ');
                charactersAndPlayersDossier += `- **長期記憶 (必須參考)**: ${memoryContent}\n`;
            }
        }
    });

    // (後續的事件總結、歷史回顧、秘密資訊等部分保持不變)
    let nightEventSummary = "# 昨晚事件總結 (Night Event Summary)\n";
    const deathsThisNight = werewolfGameState.gameLog.filter(entry => entry.content.includes('死亡了') && entry.day === werewolfGameState.currentDay);
    if (deathsThisNight.length === 0) {
         nightEventSummary += "- 昨晚是平安夜，無人死亡。\n";
    } else {
        deathsThisNight.forEach(death => {
            nightEventSummary += `- ${death.content}\n`;
        });
    }
    let previousDaysSummary = "# 前幾日完整歷史回顧 (Full Recap of Previous Days)\n";
    if (werewolfGameState.currentDay > 1) {
        for (let day = 1; day < werewolfGameState.currentDay; day++) {
            previousDaysSummary += `\n**--- 第 ${day} 天 ---**\n`;
            const eventsThisDay = werewolfGameState.gameLog.filter(entry => entry.day === day && (entry.content.includes('死亡') || entry.content.includes('放逐')));
            if (eventsThisDay.length > 0) {
                previousDaysSummary += `*事件*: ${eventsThisDay.map(e => e.content).join(' ')}\n`;
            } else {
                previousDaysSummary += "*事件*: 平安夜，無人出局。\n";
            }
            const discussionsThisDay = werewolfGameState.discussionLog.filter(entry => entry.day === day);
            if (discussionsThisDay.length > 0) {
                previousDaysSummary += `*討論記錄*:\n${discussionsThisDay.map(d => `- ${d.speaker}: ${d.content}`).join('\n')}\n`;
            }
        }
    } else {
        previousDaysSummary += "(今天是第一天，沒有歷史記錄)\n";
    }
    let secretInfo = "### 你的秘密資訊 (此部分只有你作為AI導演能看到)\n";
    alivePlayers.forEach(p => {
        if (p.id !== 'user') {
            secretInfo += `#### ${p.name}的秘密檔案：\n- 你的狼人殺身份是：【${p.role}】\n`;
            if (p.role === '狼人') {
                const teammates = werewolfGameState.players.filter(t => t.role === '狼人' && t.id !== p.id).map(t => t.name).join('、');
                secretInfo += `- 你的狼隊友是：${teammates || '無'}\n`;
                const killedPlayer = werewolfGameState.players.find(pl => pl.id === werewolfGameState.nightActions.killedId);
                secretInfo += `- 你們昨晚嘗試攻擊的玩家是：${killedPlayer ? killedPlayer.name : '空刀'}\n`;
            }
            if (p.role === '預言家' && werewolfGameState.nightActions.prophetCheck) {
                const checkedPlayer = werewolfGameState.players.find(pl => pl.id === werewolfGameState.nightActions.prophetCheck.target);
                secretInfo += `- 你昨晚查驗了 ${checkedPlayer.name}，TA的身份是：【${werewolfGameState.nightActions.prophetCheck.result}】\n`;
            }
            if (p.role === '女巫') {
                if (werewolfGameState.nightActions.savedId) {
                    const savedPlayer = werewolfGameState.players.find(pl => pl.id === werewolfGameState.nightActions.savedId);
                    secretInfo += `- 你昨晚用解藥救了 ${savedPlayer.name}。\n`;
                }
                if (werewolfGameState.nightActions.poisonedId) {
                    const poisonedPlayer = werewolfGameState.players.find(pl => pl.id === werewolfGameState.nightActions.poisonedId);
                    secretInfo += `- 你昨晚用毒藥毒了 ${poisonedPlayer.name}。\n`;
                }
                secretInfo += `- 你的解藥狀態：${p.antidoteUsed ? '已使用' : '未使用'}\n`;
                secretInfo += `- 你的毒藥狀態：${p.poisonUsed ? '已使用' : '未使用'}\n`;
            }
            if (p.role === '守衛') {
                if (werewolfGameState.nightActions.guardedId) {
                    const guardedPlayer = werewolfGameState.players.find(pl => pl.id === werewolfGameState.nightActions.guardedId);
                    secretInfo += `- 你昨晚守護了 ${guardedPlayer.name}。\n`;
                } else {
                    secretInfo += `- 你昨晚空守了。\n`;
                }
            }
            secretInfo += '\n';
        }
    });
    let discussionHistoryContext = "# 今日完整討論記錄 (Today's Full Discussion Record)\n";
    const todayDiscussions = werewolfGameState.discussionLog.filter(entry => entry.day === werewolfGameState.currentDay);
    if (todayDiscussions.length > 0) {
        discussionHistoryContext += todayDiscussions.map(d => `- **${d.speaker}**: ${d.content}`).join('\n');
    } else {
        discussionHistoryContext += "(你是第一個發言的人)";
    }

    // 最終的Prompt
    const prompt = `
# 你的任務
你是一個狼人殺遊戲導演。你的任務是扮演【除了${isUserAlive ? `用戶(${myPlayerName})` : `已死亡的用戶(${myPlayerName})`}以外】的所有AI角色，並根據他們的【角色人設】和【狼人殺身份】，生成一整輪符合邏輯、充滿博弈的發言。

# 身份與人設鐵律 (最高優先順序)
你【必須】為每一個角色都仔細閱讀並嚴格遵守下面的檔案。這是你所有行為和發言的唯一依據。在對話中，請務必注意角色人設中暗示的性別，並使用正確的稱呼（例如“他”或“她”）。

${charactersAndPlayersDossier}

# 遊戲規則
- ${werewolfGameState.gameMode === '12p' ? '屠邊局：狼人殺死所有神職或所有平民即獲勝。' : '屠城局：狼人殺死所有好人即獲勝。'}
- 好人勝利：放逐所有狼人。

# 當前遊戲狀態
- 今天是第 ${werewolfGameState.currentDay} 天的討論環節。
${nightEventSummary} 
- 存活玩家: ${alivePlayers.map(p => `${p.name} (${p.id === 'user' ? '用戶' : 'AI'})`).join(', ')}

# 【【【角色策略指南 (至關重要！)】】】
你的發言【必須】體現出高水準的、類似真人的策略博弈，而不是簡單地陳述事實。

### **神職角色 (預言家, 女巫, 獵人, 守衛) 策略**
1.  **【隱藏優先！】**: 你的首要任務是活下去。**絕對不要**在第一天就輕易暴露自己的神職身份！這會讓你立刻成為狼人的目標。
2.  **【暗示而非明示】**: 你應該用更委婉、更聰明的語言來傳遞資訊，而不是直接說“我是預言家，我查了A”。
    *   **預言家可以說**: “我對X玩家的身份有一些看法，我覺得他發言很陽光。” 或 “Y玩家的發言讓我感到很不舒服，我把他列為重點懷疑對象。”
    *   **女巫可以說**: “昨晚的資訊很有趣，場上局勢可能和大家想的不一樣。”
3.  **【何時起跳？】**: 只有在以下【危急情況】下，你才應該考慮暴露自己的身份（俗稱“起跳”）：
    *   **被投票時**: 當你即將被投票放逐時，必須起跳自證身份來求生。
    *   **關鍵資訊**: 當你掌握了可以決定勝負的資訊時（例如預言家查到了最後一個狼人）。
    *   **有人悍跳**: 當有狼人假扮你的身份時，你必須站出來與他對峙，爭奪好人的信任。

### **狼人角色策略**
1.  **【積極偽裝】**: 你需要扮演一個好人，最好是偽裝成某個神職（俗稱“悍跳”），來擾亂好人的判斷，騙取他們的信任。
2.  **【製造混亂】**: 你的發言應該引導好人去懷疑其他無辜的好人。可以故意曲解別人的發言，或者製造邏輯陷阱。
3.  **【團隊合作】**: 如果你的狼隊友被懷疑，你應該想辦法為他辯護，或者通過攻擊其他玩家來轉移焦點。

### **平民角色策略**
1.  **【邏輯為王】**: 你是場上的“法官”。你的核心任務是仔細傾聽每個人的發言，找出其中的邏輯漏洞和矛盾之處。
2.  **【積極分析】**: 不要只是說“我不知道，我過了”。你應該大膽說出你的懷疑，並解釋你的理由。例如：“A玩家說B是狼人，但是他的理由很牽強，所以我更懷疑A。”
3.  **【跟票與站邊】**: 在你相信某位神職玩家後，你應該堅定地支持他，並號召其他好人一起投票給神職指認的狼人。

# 其他核心指令 (必須遵守)
1.  **互動鐵律**: 角色之間【必須】互相質疑、支持、分析【本輪已有發言】。你【絕對不能】無視 ${myPlayerName} (用戶) 或其他AI的發言，必須對他們的觀點和邏輯做出回應。
2.  **記憶力與連貫性**: 你的新發言【必須】是基於**過去幾天和今天發生的所有事件和討論**的邏輯延續。

// 【核心修改2】明確了JSON格式中 speaker_name 和對話中稱呼的不同要求
3.  **格式鐵律**: 你的回復【必須且只能】是一個JSON陣列，格式為: \`{"speaker_name": "角色的【昵稱】", "dialogue": "發言內容"}\`。**必須**為每一個存活的AI角色都生成一段發言。
4.  **稱呼鐵律**: 你的發言中【絕對禁止】提及任何玩家的編號。在對話中互相稱呼時，你【必須】使用玩家的【本名】，而不是他們的昵稱。

# ${previousDaysSummary}

# ${discussionHistoryContext}

${secretInfo}

現在，請為所有【存活的AI角色】生成他們充滿策略和博弈的發言。`;
    
        return prompt;
    }
/**
         * 【全新 | V2.1 無編號版】創建一個詳細的、供AI分析的狼人殺遊戲完整日誌
         * @param {object} gameState - 當前的遊戲狀態物件
         * @returns {string} - 格式化後的遊戲完整日誌字串
         */
        function createWerewolfGameSummary(gameState) {
            let summary = `--- 狼人殺對局完整複盤 ---\n\n`;
            const winner = gameState.gameLog.find(log => log.content.includes('勝利'))?.content || '勝負未分';
            summary += `### 最終結果: ${winner}\n\n`;

            summary += "### 玩家身份配置:\n";
            // ▼▼▼ 核心修改就在這裡 ▼▼▼
            // 移除了 forEach 中的 index 和 "號玩家" 的字樣
            gameState.players.forEach(player => {
                const status = player.isAlive ? "存活" : "已死亡";
                summary += `- ${player.name}: ${player.role} (${status})\n`;
            });
            // ▲▲▲ 修改結束 ▲▲▲

            summary += "\n### 詳細對局流程:\n";
            for (let day = 1; day <= gameState.currentDay; day++) {
                summary += `\n**--- 第 ${day} 天 ---**\n`;

                // 夜晚事件
                const nightEvents = gameState.gameLog.filter(entry => entry.day === day && (entry.content.includes('死亡')));
                if (nightEvents.length > 0) {
                    summary += `**[夜晚]** ${nightEvents.map(e => e.content).join(' ')}\n`;
                } else if (day > 1 || (day === 1 && gameState.currentDay > 1)) {
                    summary += `**[夜晚]** 平安夜。\n`;
                }
                
                // 白天討論
                const discussionsThisDay = gameState.discussionLog.filter(entry => entry.day === day);
                if (discussionsThisDay.length > 0) {
                    summary += `**[討論環節]**\n${discussionsThisDay.map(d => `- ${d.speaker}: ${d.content}`).join('\n')}\n`;
                }

                // 投票與放逐
                const voteLog = gameState.gameLog.find(entry => entry.day === day && entry.content.includes('被投票放逐'));
                if(voteLog) {
                    summary += `**[投票結果]** ${voteLog.content}\n`;
                }
            }

            summary += "\n--- 複盤結束 ---";
            return summary;
        }

/**
         * 【全新 V3.0 | 統一客觀複盤版】將完整的遊戲總結注入到所有參與的AI角色的長期記憶中
         * @param {string} summary - 完整的遊戲總結文本
         * @returns {Promise<number>} - 返回成功注入記憶的角色數量
         */
        async function injectSummaryIntoMemories(summary) {
            let injectedCount = 0;
            // 1. 遍歷所有參與過遊戲的玩家
            for (const player of werewolfGameState.players) {
                // 2. 只為AI角色（非用戶、非純NPC）注入記憶
                if (player.type === 'character') {
                    const chat = state.chats[player.id];
                    if (chat) {
                        // 3. 創建新的記憶物件，內容就是完整的、未經修改的總結
                        const newMemory = {
                            content: summary, // Directly use the full summary
                            timestamp: Date.now(),
                            source: 'werewolf_summary'
                        };
                        if (!chat.longTermMemory) {
                            chat.longTermMemory = [];
                        }
                        chat.longTermMemory.push(newMemory);
                        // 4. 更新資料庫
                        await db.chats.put(chat);
                        injectedCount++;
                    }
                }
            }
            return injectedCount;
        }

/**
         * 【全新 | V2.0 已修復】手動觸發狼人殺遊戲總結的入口函數
         */
        async function handleManualWerewolfSummary() {
            if (!werewolfGameState.isActive && werewolfGameState.currentPhase === 'gameover') {
                await showCustomAlert("請稍候...", "正在為所有AI角色生成並注入遊戲記憶...");
                try {
                    const summary = createWerewolfGameSummary(werewolfGameState);
                    
                    // ▼▼▼ 核心修復就在這裡！▼▼▼
                    // 調用了新的、正確的函數名
                    const count = await injectSummaryIntoMemories(summary); 
                    // ▲▲▲ 修復結束 ▲▲▲

                    await showCustomAlert("成功", `遊戲記憶已成功注入到 ${count} 位AI角色的長期記憶中！`);
                } catch (error) {
                    console.error("手動注入狼人殺記憶失敗:", error);
                    await showCustomAlert("失敗", `手動注入記憶時出錯: ${error.message}`);
                }
            } else {
                alert("遊戲尚未結束，無法進行總結。");
            }
        }
/**
         * 【全新 V2.1 | 已集成自動總結】結束遊戲並顯示結果
         * @param {string} winner - 獲勝方, '好人' 或 '狼人'
         */
        async function endGame(winner) {
            werewolfGameState.isActive = false;
            werewolfGameState.currentPhase = 'gameover';

            // 記錄勝利日誌，以便總結時使用
            addGameLog(`${winner}陣營勝利！`);
            
            document.getElementById('werewolf-game-over-title').textContent = `${winner}勝利！`;
            let reason = '';
            if (winner === '好人') {
                reason = '所有狼人已被放逐，好人陣營獲得了勝利！';
            } else {
                reason = '狼人數量已達到勝利條件，狼人陣營獲得了勝利！';
            }
            const reasonEl = document.getElementById('werewolf-game-over-reason');
            reasonEl.textContent = reason;

            const roleListEl = document.getElementById('werewolf-role-reveal-list');
            roleListEl.innerHTML = ''; 

            const sortedPlayers = [...werewolfGameState.players].sort((a, b) => {
                const aIndex = werewolfGameState.players.findIndex(p => p.id === a.id);
                const bIndex = werewolfGameState.players.findIndex(p => p.id === b.id);
                return aIndex - bIndex;
            });

            sortedPlayers.forEach((player, index) => {
                const itemEl = document.createElement('div');
                itemEl.style.cssText = `display: flex; align-items: center; padding: 8px 0; border-bottom: 1px solid #444; color: white;`;
                if (index === sortedPlayers.length - 1) itemEl.style.borderBottom = 'none';
                const roleColor = player.role === '狼人' ? '#ff4d4d' : '#52c41a';
                itemEl.innerHTML = `
                    <img src="${player.avatar}" style="width: 30px; height: 30px; border-radius: 50%; margin-right: 12px; filter: ${player.isAlive ? 'none' : 'grayscale(100%)'};">
                    <span style="flex-grow: 1; text-align: left; text-decoration: ${player.isAlive ? 'none' : 'line-through'};">${index + 1}. ${player.name}</span>
                    <strong style="color: ${roleColor};">${player.role}</strong>
                `;
                roleListEl.appendChild(itemEl);
            });

            document.getElementById('werewolf-game-over-modal').classList.add('visible');

            // ▼▼▼ 【核心修改：調用新的總結流程】 ▼▼▼
            try {
                console.log("遊戲結束，開始自動總結並注入記憶...");
                // 1. 生成完整的遊戲日誌
                const summaryContext = createWerewolfGameSummary(werewolfGameState);
                // 2. 將日誌交給AI生成個性化記憶並注入
                const count = await generateAndInjectWerewolfMemories(summaryContext);
                console.log(`狼人殺遊戲總結已自動存入 ${count} 位角色的記憶中。`);
            } catch (error) {
                console.error("自動總結狼人殺遊戲失敗:", error);
                if (reasonEl) {
                    reasonEl.innerHTML += '<br><small style="color: #ff8a80; margin-top: 10px; display: block;">自動記憶總結失敗，可稍後手動嘗試。</small>';
                }
            }
            // ▲▲▲ 修改結束 ▲▲▲
        }

// ▼▼▼ 【最終修復版】請用這整塊代碼，完整替換舊的 addGameLog 和 addDialogueLog 函數 ▼▼▼

function addGameLog(content) {
    // 【核心修改】在記錄日誌時，把當前是第幾天也一起存進去
    werewolfGameState.gameLog.push({ 
        type: 'system', 
        content, 
        timestamp: Date.now(), 
        day: werewolfGameState.currentDay // <-- 新增這一行
    });
}

function addDialogueLog(speaker, content) {
    // 【核心修改】在這裡也一樣
    werewolfGameState.discussionLog.push({ 
        type: 'dialogue', 
        speaker, 
        content, 
        timestamp: Date.now(),
        day: werewolfGameState.currentDay // <-- 新增這一行
    });
}

// ▲▲▲ 替換結束 ▲▲▲


/**
 * 【V2.0 | 已修復】打開一個通用的選擇彈窗
 */
function openSelectionModal(type) {
    return new Promise(resolve => {
        const modalId = `werewolf-${type}-modal`;
        const listId = `werewolf-${type}-selection-list`;
        let confirmBtnId = '';
        if(type === 'prophet') confirmBtnId = 'confirm-prophet-check-btn';
        if(type === 'hunter') confirmBtnId = 'confirm-hunter-shot-btn';
        if(type === 'vote') confirmBtnId = 'confirm-vote-btn';

        const modal = document.getElementById(modalId);
        const listEl = document.getElementById(listId);
        const confirmBtn = document.getElementById(confirmBtnId);
        
        listEl.innerHTML = '';
        let selectedId = null;
        
        // 獵人可以射擊任何人，預言家不能驗自己，投票可以投任何人
        const potentialTargets = werewolfGameState.players.filter(p => 
            p.isAlive && (type === 'hunter' || type === 'vote' || p.id !== 'user')
        );
        potentialTargets.forEach(p => {
            const item = document.createElement('div');
            item.className = 'werewolf-selection-item';
            item.dataset.id = p.id;
            item.innerHTML = `<img src="${p.avatar}" class="avatar"><span class="name">${p.name}</span>`;
            item.onclick = () => {
                listEl.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
                item.classList.add('selected');
                selectedId = p.id;
            };
            listEl.appendChild(item);
        });
        
        const newConfirmBtn = confirmBtn.cloneNode(true);
        confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
        newConfirmBtn.onclick = () => {
            if (selectedId) {
                modal.classList.remove('visible');
                resolve(selectedId);
            } else {
                alert('請選擇一個目標。');
            }
        };

        modal.classList.add('visible');
    });
}

/**
 * 【V2.0 | 已修復】打開狼人夜晚刀人選擇彈窗
 */
function openWolfKillModal() {
    return new Promise(resolve => {
        const modal = document.getElementById('werewolf-kill-modal');
        const listEl = document.getElementById('werewolf-kill-selection-list');
        const confirmBtn = document.getElementById('confirm-wolf-kill-btn');
        const header = modal.querySelector('.modal-header span');

        const wolves = werewolfGameState.players.filter(p => p.role === '狼人' && p.isAlive);
        const teammates = wolves.filter(w => w.id !== 'user').map(w => w.name).join('、');
        
        if (teammates) {
            header.innerHTML = `狼人請選擇刀人物件<br><small style="font-weight:normal; font-size: 13px;">你的隊友是: ${teammates}</small>`;
        } else {
            header.textContent = '狼人請選擇刀人物件';
        }
        
        listEl.innerHTML = '';
        let selectedId = null;

        const potentialTargets = werewolfGameState.players.filter(p => p.isAlive && p.role !== '狼人');
        potentialTargets.forEach(p => {
            const item = document.createElement('div');
            item.className = 'werewolf-selection-item';
            item.dataset.id = p.id;
            item.innerHTML = `<img src="${p.avatar}" class="avatar"><span class="name">${p.name}</span>`;
            item.onclick = () => {
                listEl.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
                item.classList.add('selected');
                selectedId = p.id;
            };
            listEl.appendChild(item);
        });
        
        const newConfirmBtn = confirmBtn.cloneNode(true);
        confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
        newConfirmBtn.onclick = () => {
            if (selectedId) {
                modal.classList.remove('visible');
                resolve(selectedId);
            } else {
                alert('請選擇一個目標。');
            }
        };

        modal.classList.add('visible');
    });
}

/**
         * 【全新 | V2.0】處理用戶在狼人殺討論中結束發言的邏輯
         */
        function handleUserWerewolfSpeech() {
            const myPlayer = werewolfGameState.players.find(p => p.id === 'user');
            // 【核心修復】如果玩家已死亡，則不執行任何操作
            if (!myPlayer || !myPlayer.isAlive) return;

            const userInput = document.getElementById('werewolf-user-input');
            const speech = userInput.value.trim();

            if (speech) {
                addDialogueLog(myPlayer.name, speech);
                renderWerewolfScreen();
            }
            
            // 隱藏輸入框和發言按鈕，準備進入投票
            document.getElementById('werewolf-action-bar').style.display = 'none';
            userInput.value = '';
            
            startVotingPhase();
        }
/**
         * 【全新】處理用戶作為旁觀者時，點擊“繼續討論”的邏輯
         */
        async function handleAiContinueDiscussion() {
            addGameLog('你讓大家繼續討論...');
            renderWerewolfScreen();

            // 暫時禁用按鈕，防止重複點擊
            const continueBtn = document.getElementById('werewolf-wait-reply-btn');
            if(continueBtn) continueBtn.disabled = true;

            // 後續的AI調用邏輯與 handleWerewolfWaitReply 完全一致
            // 因為 buildWerewolfPrompt 已經能正確處理使用者死亡的情況
            await showCustomAlert("請稍候", "正在等待AI角色們繼續討論...");

            const { proxyUrl, apiKey, model } = state.apiConfig;
            if (!proxyUrl || !apiKey || !model) {
                alert('API未配置，無法生成對話。');
                return;
            }

            const systemPrompt = buildWerewolfPrompt(); 

            try {
                let isGemini = proxyUrl.includes('generativelanguage');
                // 核心：這裡的 user message 是一個通用指令，不包含任何具體發言
                let messagesForApi = [{role: 'user', content: '請AI角色們繼續進行討論。'}];
                let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
                
                const response = isGemini 
                    ? await fetch(geminiConfig.url, geminiConfig.data) 
                    : await fetch(`${proxyUrl}/v1/chat/completions`, {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                        body: JSON.stringify({
                            model: model,
                            messages: [{role: 'system', content: systemPrompt}, ...messagesForApi],
                            temperature: state.globalSettings.apiTemperature || 0.9,
                        })
                    });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`API 錯誤: ${errorData.error.message}`);
                }
                
                const data = await response.json();
                const aiResponseContent = getGeminiResponseText(data);
                const jsonMatch = aiResponseContent.match(/(\[[\s\S]*\])/);
                if (!jsonMatch) {
                    throw new Error(`AI返回的內容中未找到有效的JSON陣列。原始返回: ${aiResponseContent}`);
                }
                const dialogues = JSON.parse(jsonMatch[0]);

                for (const dialogue of dialogues) {
                    if(dialogue.speaker_name && dialogue.dialogue) {
                        addDialogueLog(dialogue.speaker_name, dialogue.dialogue);
                        renderWerewolfScreen();
                        await new Promise(resolve => setTimeout(resolve, 1500 + Math.random() * 2000));
                    }
                }
            } catch(error) {
                console.error("狼人殺AI回應生成失敗:", error);
                await showCustomAlert("AI 發言失敗", `錯誤: ${error.message}`);
            } finally {
                // 重新啟用按鈕
                if(continueBtn) continueBtn.disabled = false;
            }
        }
/**
         * 【全新 | V2.0】處理用戶點擊“等待回應”的邏輯
         */
        async function handleWerewolfWaitReply() {
            const myPlayer = werewolfGameState.players.find(p => p.id === 'user');
            // ★★★★★ 核心安全校驗 ★★★★★
            if (!myPlayer || !myPlayer.isAlive) {
                console.warn("handleWerewolfWaitReply 被調用，但用戶已死亡。操作被忽略。");
                return;
            }
            // ★★★★★ 安全校驗結束 ★★★★★

            const userInput = document.getElementById('werewolf-user-input');
            const speech = userInput.value.trim();

            if (!speech) {
                alert("請先輸入你的發言內容。");
                return;
            }

            addDialogueLog(myPlayer.name, speech);
            renderWerewolfScreen();
            userInput.value = '';

            await showCustomAlert("請稍候", "正在等待AI角色們對你的發言做出回應...");

            const { proxyUrl, apiKey, model } = state.apiConfig;
            if (!proxyUrl || !apiKey || !model) {
                alert('API未配置，無法生成對話。');
                return;
            }

            const systemPrompt = buildWerewolfPrompt(); 

            try {
                let isGemini = proxyUrl.includes('generativelanguage');
                let messagesForApi = [{role: 'user', content: `現在，請所有AI角色針對剛剛的發言（特別是'${myPlayer.name}'的發言）繼續進行討論。`}];
                let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
                
                const response = isGemini 
                    ? await fetch(geminiConfig.url, geminiConfig.data) 
                    : await fetch(`${proxyUrl}/v1/chat/completions`, {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                        body: JSON.stringify({
                            model: model,
                            messages: [{role: 'system', content: systemPrompt}, ...messagesForApi],
                            temperature: state.globalSettings.apiTemperature || 0.9,
                        })
                    });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`API 錯誤: ${errorData.error.message}`);
                }
                
                const data = await response.json();
                const aiResponseContent = getGeminiResponseText(data);
                const jsonMatch = aiResponseContent.match(/(\[[\s\S]*\])/);
                if (!jsonMatch) {
                    throw new Error(`AI返回的內容中未找到有效的JSON陣列。原始返回: ${aiResponseContent}`);
                }
                const dialogues = JSON.parse(jsonMatch[0]);

                for (const dialogue of dialogues) {
                    if(dialogue.speaker_name && dialogue.dialogue) {
                        addDialogueLog(dialogue.speaker_name, dialogue.dialogue);
                        renderWerewolfScreen();
                        await new Promise(resolve => setTimeout(resolve, 1500 + Math.random() * 2000));
                    }
                }
            } catch(error) {
                console.error("狼人殺AI回應生成失敗:", error);
                await showCustomAlert("AI 發言失敗", `錯誤: ${error.message}`);
            }
        }

/**
         * 【全新 | V2.0 投票修復版】開始投票環節
         */
        async function startVotingPhase() {
            addGameLog('發言結束，現在開始投票。');
            renderWerewolfScreen();
        
            // 【核心修復1】使用一個新的、更可靠的資料結構來存儲投票
            werewolfGameState.votes = {}; // { voterName: targetName }
        
            let aiVotes = null;
            werewolfGameState.lastFailedAction = 'getVotes'; // 標記當前操作
            try {
                // 嘗試獲取AI投票
                aiVotes = await getAiVotes();
                if (aiVotes) {
                    aiVotes.forEach(vote => {
                        const voter = werewolfGameState.players.find(p => p.name === vote.voter_name);
                        const target = werewolfGameState.players.find(p => p.name === vote.vote_for_name);
                        if (voter && voter.isAlive && target) {
                            werewolfGameState.votes[voter.name] = target.name;
                        }
                    });
                }
                werewolfGameState.lastFailedAction = null; // 成功後清除標記
            } catch (error) {
                console.error("AI投票決策API失敗:", error);
                // 如果API調用失敗
                await showCustomAlert("操作失敗", `AI角色無法完成投票，遊戲暫停。請點擊右上角的“重試”按鈕繼續。\n錯誤: ${error.message}`);
                document.getElementById('werewolf-retry-btn').style.display = 'block'; // 顯示重試按鈕
                return; // 終止函數，等待使用者重試
            }
            // ▲▲▲ 【【【修改結束】】】 ▲▲▲
        
            // 2. 獲取用戶的投票
            const myPlayer = werewolfGameState.players.find(p => p.id === 'user');
            if (myPlayer && myPlayer.isAlive) {
                addGameLog('請你投票。');
                renderWerewolfScreen();
                const userVoteTargetId = await openSelectionModal('vote');
                const targetPlayer = werewolfGameState.players.find(p => p.id === userVoteTargetId);
                if (targetPlayer) {
                    // 記錄使用者的投票
                    werewolfGameState.votes[myPlayer.name] = targetPlayer.name;
                }
            }
        
            // 3. 處理並公佈最終結果
            handleVotingResults();
        }

/**
         * 【全新 | V2.1 終極容錯修復版】獲取所有AI的投票決定
         */
        async function getAiVotes() {
            const { proxyUrl, apiKey, model } = state.apiConfig;
            if (!proxyUrl || !apiKey || !model) return null;

            const aliveAiPlayers = werewolfGameState.players.filter(p => p.isAlive && p.id !== 'user');
            const potentialTargets = werewolfGameState.players.filter(p => p.isAlive).map(p => p.name);

            let systemPrompt = buildWerewolfPrompt();
            systemPrompt += `
# 【【【最終投票指令 (最高優先順序)】】】
現在是投票環節。請你扮演【每一個存活的AI角色】，根據以上所有資訊（特別是剛剛的討論環節），為他們各自決定要投票放逐哪一位玩家。
- **投票依據**: 你的投票【必須】基於邏輯分析和你的身份。狼人可能會投給好人，好人需要找出狼人。
- **格式鐵律**: 你的回復【必須且只能】是一個JSON陣列，格式如下：
\`\`\`json
[
  {"voter_name": "角色A的名字", "vote_for_name": "角色A投票的玩家名字"},
  {"voter_name": "角色B的名字", "vote_for_name": "角色B投票的玩家名字"}
]
\`\`\`
- **可投票的玩家列表**: ${potentialTargets.join(', ')}

現在，請為所有存活的AI角色生成他們的投票決定。`;

            try {
                let isGemini = proxyUrl.includes('generativelanguage');
                let messagesForApi = [{role: 'user', content: '請所有AI角色開始投票。'}];
                let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
                
                const response = isGemini 
                    ? await fetch(geminiConfig.url, geminiConfig.data) 
                    : await fetch(`${proxyUrl}/v1/chat/completions`, {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                        body: JSON.stringify({
                            model: model,
                            messages: [{role: 'system', content: systemPrompt}, ...messagesForApi],
                            temperature: state.globalSettings.apiTemperature || 0.8,
                        })
                    });

                if (!response.ok) throw new Error((await response.json()).error.message);
                
                const data = await response.json();
                const aiResponseContent = getGeminiResponseText(data);

                // ▼▼▼ 【【【核心修復就在這裡！】】】 ▼▼▼
                
                // 1. 先清理掉AI可能返回的markdown代碼塊標記
                let cleanedJsonString = aiResponseContent.replace(/^```json\s*/, '').replace(/```$/, '').trim();

                // 2. 找到第一個 '[' 和最後一個 ']' 的位置
                const startIndex = cleanedJsonString.indexOf('[');
                const endIndex = cleanedJsonString.lastIndexOf(']');

                // 3. 如果找不到合法的陣列結構，就拋出明確的錯誤
                if (startIndex === -1 || endIndex === -1 || endIndex < startIndex) {
                    throw new Error("AI返回的投票結果中未找到有效的JSON陣列結構 (`[...]`)。");
                }

                // 4. 精確地提取出從第一個 '[' 到最後一個 ']' 的所有內容
                // 這一步是關鍵，它會忽略掉AI返回的第一個（討論）JSON陣列和中間的雜亂字元
                const jsonArrayString = cleanedJsonString.substring(startIndex, endIndex + 1);

                // 5. 在一個 try...catch 塊中安全地解析提取出的字串
                try {
                    // 再次嘗試從多個JSON陣列中提取最後一個
                    const matches = jsonArrayString.match(/(\[[\s\S]*?\])/g);
                    if (matches && matches.length > 0) {
                        return JSON.parse(matches[matches.length - 1]);
                    }
                    return JSON.parse(jsonArrayString); // Fallback
                } catch (e) {
                    // 如果即使提取後仍然解析失敗，就拋出一個包含原始返回內容的、更詳細的錯誤
                    throw new Error(`解析AI返回的投票JSON時出錯: ${e.message}\n\nAI原始返回內容:\n${aiResponseContent}`);
                }
                // ▲▲▲ 【【【修復結束】】】 ▲▲▲

            } catch(error) {
                console.error("獲取AI投票失敗:", error);
                throw new Error(`獲取AI投票決策失敗: ${error.message}`);
            }
        }

/**
         * 【全新 | V2.0 投票修復版】處理並公佈投票結果
         */
        function handleVotingResults() {
            const voteCounts = {}; // 用於計票: { targetName: count }
            const voteDetails = {}; // 用於記錄詳情: { targetName: [voter1, voter2] }
        
            // 【核心修復2】從新的、更可靠的 votes 物件中計票
            for (const voterName in werewolfGameState.votes) {
                const targetName = werewolfGameState.votes[voterName];
                
                voteCounts[targetName] = (voteCounts[targetName] || 0) + 1;
                
                if (!voteDetails[targetName]) {
                    voteDetails[targetName] = [];
                }
                voteDetails[targetName].push(voterName);
            }
        
            let maxVotes = 0;
            let mostVotedPlayers = [];
        
            // 找出最高票數和對應的玩家
            for (const playerName in voteCounts) {
                const count = voteCounts[playerName];
                if (count > maxVotes) {
                    maxVotes = count;
                    mostVotedPlayers = [playerName];
                } else if (count === maxVotes) {
                    mostVotedPlayers.push(playerName);
                }
            }
        
            // 公佈投票詳情
            addGameLog('投票結果：');
            for (const playerName in voteDetails) {
                addGameLog(`${playerName} (${voteDetails[playerName].length}票): ${voteDetails[playerName].join('、 ')}`);
            }
        
            // 判斷並處理出局玩家
            if (mostVotedPlayers.length === 1 && maxVotes > 0) {
                const playerToEliminate = werewolfGameState.players.find(p => p.name === mostVotedPlayers[0]);
                if (playerToEliminate) {
                    playerToEliminate.isAlive = false;
                    addGameLog(`${playerToEliminate.name} 被投票放逐。`);
                    
                    // 獵人技能處理 (這部分邏輯保持不變)
                    if (playerToEliminate.role === '獵人') {
                         // 獵人技能已在 `executeDayPhase` 中處理死亡事件，這裡無需重複
                    }
                }
            } else {
                addGameLog('平票或無人投票，此輪無人出局。');
            }
        
            renderWerewolfScreen();
            
            if (checkGameOver()) return;
        
            // 進入下一個夜晚
            werewolfGameState.currentDay++;
            executeNightPhase();
        }

/**
 * 【全新】獲取AI狼人團隊的刀人目標
 */
async function getAiWolfKillTarget() {
    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) return null;

    const wolves = werewolfGameState.players.filter(p => p.role === '狼人' && p.isAlive);
    const potentialTargets = werewolfGameState.players.filter(p => p.isAlive && p.role !== '狼人');

    const systemPrompt = `
# 你的任務
你現在是狼人團隊的指揮官。你的任務是分析當前局勢，並為狼人團隊選擇一個最佳的刀人目標。
# 核心規則
1.  **目標**: 優先刀掉預言家、女巫等神職人員。如果沒有明確的神職資訊，可以根據發言來判斷誰的邏輯清晰、威脅最大。
2.  **格式鐵律**: 你的回復【必須且只能】是一個JSON物件，格式如下:
    \`{"target_name": "你決定要刀的玩家名字"}\`

# 遊戲狀態
- **你的狼隊友是**: ${wolves.map(w=>w.name).join('、 ')}
- **可以刀的玩家列表**: ${potentialTargets.map(p=>p.name).join('、 ')}
- **討論摘要**: 
${werewolfGameState.discussionLog.map(d => `${d.speaker}: ${d.content}`).join('\n')}

現在，請做出你的決定。`;
    
    try {
        let isGemini = proxyUrl.includes('generativelanguage');
        let messagesForApi = [{role: 'user', content: '請選擇今晚的目標。'}];
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
        
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model, messages: [{role: 'system', content: systemPrompt}, ...messagesForApi], temperature: state.globalSettings.apiTemperature || 0.8,
                })
            });

        if (!response.ok) throw new Error((await response.json()).error.message);
        
        const data = await response.json();
        const aiResponseContent = getGeminiResponseText(data);
        const jsonMatch = aiResponseContent.match(/({[\s\S]*})/);
        if (!jsonMatch) throw new Error("AI返回的刀人目標格式不正確。");
        const decision = JSON.parse(jsonMatch[0]);

        const targetPlayer = werewolfGameState.players.find(p => p.name === decision.target_name);
        return targetPlayer ? targetPlayer.id : null;

    } catch(error) {
        console.error("獲取AI狼人目標失敗:", error);
        // 如果AI決策失敗，隨機選擇一個目標作為保底
        return potentialTargets[Math.floor(Math.random() * potentialTargets.length)].id;
    }
}
// ▲▲▲ 狼人殺JS代碼結束 ▲▲▲
/**
 * 【全新 V2.2 | 交互最終修復版】打開女巫操作彈窗
 * @param {object|null} killedPlayer - 被狼人刀的玩家物件，如果是平安夜則為null
 * @param {object} witchPlayer - 女巫玩家的對象
 * @returns {Promise<object>} - 返回一個包含 { save: boolean, poison: string|null } 的對象
 */
function openWitchActionModal(killedPlayer, witchPlayer) {
    return new Promise(resolve => {
        const modal = document.getElementById('werewolf-witch-modal');
        const listEl = document.getElementById('werewolf-witch-selection-list');
        const titleEl = document.getElementById('witch-modal-title');
        
        // 1. 獲取原始按鈕的引用
        const poisonBtn = document.getElementById('confirm-witch-poison-btn');
        const doNothingBtn = document.getElementById('witch-do-nothing-btn');
        listEl.innerHTML = '';

        // 2. ★★★ 核心修復：先克隆並替換按鈕，確保我們操作的是最新的DOM元素 ★★★
        const newPoisonBtn = poisonBtn.cloneNode(true);
        poisonBtn.parentNode.replaceChild(newPoisonBtn, poisonBtn);
        const newDoNothingBtn = doNothingBtn.cloneNode(true);
        doNothingBtn.parentNode.replaceChild(newDoNothingBtn, doNothingBtn);

        // 3. 現在，所有的操作都針對 newPoisonBtn 和 newDoNothingBtn
        newPoisonBtn.style.display = 'block';
        newPoisonBtn.disabled = true; // 默認禁用

        let action = { save: false, poison: null };
        let selectedPoisonTarget = null;
        
        // (顯示死亡資訊和救人選項的邏輯保持不變)
        if (killedPlayer && !witchPlayer.antidoteUsed) {
            titleEl.textContent = `昨晚 ${killedPlayer.name} 被刀了`;
            const saveBtn = document.createElement('button');
            saveBtn.className = 'form-button';
            saveBtn.textContent = '使用解藥救TA';
            saveBtn.style.margin = '20px';
            saveBtn.onclick = () => {
                action.save = true;
                modal.classList.remove('visible');
                resolve(action);
            };
            listEl.appendChild(saveBtn);
        } else if (killedPlayer) {
            titleEl.textContent = `昨晚 ${killedPlayer.name} 被刀了 (你沒有解藥了)`;
        } else {
            titleEl.textContent = '昨晚是平安夜';
        }

        // (提供毒人選項的邏輯保持不變)
        if (!witchPlayer.poisonUsed) {
            const poisonTitle = document.createElement('p');
            poisonTitle.textContent = '是否要使用毒藥？';
            poisonTitle.style.textAlign = 'center';
            poisonTitle.style.marginTop = '20px';
            listEl.appendChild(poisonTitle);

            const potentialTargets = werewolfGameState.players.filter(p => p.isAlive && p.id !== killedPlayer?.id);
            potentialTargets.forEach(p => {
                const item = document.createElement('div');
                item.className = 'werewolf-selection-item';
                item.dataset.id = p.id;
                item.innerHTML = `<img src="${p.avatar}" class="avatar"><span class="name">${p.name}</span>`;
                item.onclick = () => {
                    listEl.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
                    item.classList.add('selected');
                    selectedPoisonTarget = p.id;
                    
                    // 4. ★★★ 核心修復：現在我們啟用的是正確的、新的按鈕 ★★★
                    newPoisonBtn.disabled = false;
                };
                listEl.appendChild(item);
            });
        }

        // 5. 為新的按鈕綁定事件
        newPoisonBtn.onclick = () => {
            if (selectedPoisonTarget) {
                action.poison = selectedPoisonTarget;
                modal.classList.remove('visible');
                resolve(action);
            }
        };

        newDoNothingBtn.onclick = () => {
            modal.classList.remove('visible');
            resolve(action);
        };

        modal.classList.add('visible');
    });
}
// ▲▲▲ 新增JS代碼結束 ▲▲▲
// ▼▼▼ 【全新】這是重試功能的核心處理函數，請完整黏貼 ▼▼▼

/**
 * 【總入口】處理用戶點擊“重試”按鈕的邏輯
 */
async function handleWerewolfRetry() {
    const actionToRetry = werewolfGameState.lastFailedAction;
    if (!actionToRetry) return;

    document.getElementById('werewolf-retry-btn').style.display = 'none'; // 先隱藏按鈕
    await showCustomAlert("請稍候...", `正在重試"${actionToRetry}"操作...`);

    switch(actionToRetry) {
        case 'wolfKill':
            // 重試狼人刀人，需要重新執行整個夜晚階段
            await executeNightPhase();
            break;
        case 'startDiscussion':
            // 重試開始討論
            await startDiscussionPhase();
            break;
        case 'getVotes':
            // 重試AI投票
            await startVotingPhase();
            break;
        // 未來可以添加更多重試場景...
    }
}

// ▲▲▲ 新增JS代碼結束 ▲▲▲
// ▼▼▼ 【全新 | 缺失的函數】這是檢查遊戲是否結束的核心邏輯，請完整黏貼 ▼▼▼

/**
         * 【全新 | 已添加屠城判定】檢查遊戲是否結束，並宣佈勝利者
         * @returns {boolean} - 如果遊戲結束則返回 true，否則返回 false
         */
        function checkGameOver() {
            const alivePlayers = werewolfGameState.players.filter(p => p.isAlive);
            const aliveWolves = alivePlayers.filter(p => p.role === '狼人');
            const aliveGods = alivePlayers.filter(p => ['預言家', '女巫', '獵人', '守衛'].includes(p.role));
            const aliveVillagers = alivePlayers.filter(p => p.role === '平民');

            let winner = null;

            // 1. 好人勝利條件：所有狼人都已出局
            if (aliveWolves.length === 0) {
                winner = '好人';
            }
            // 2. 新增的狼人勝利條件：狼人數量等於或超過好人數量
            else if (aliveWolves.length >= (aliveGods.length + aliveVillagers.length)) {
                winner = '狼人';
            }
            // 3. 原有的狼人勝利條件 (作為備用)
            else if (werewolfGameState.gameMode === '12p') {
                // 12人局屠邊：神職全部死亡 或 平民全部死亡
                if (aliveGods.length === 0 || aliveVillagers.length === 0) {
                    winner = '狼人';
                }
            } else {
                // 6人或9人局屠城：所有好人（神職+平民）都已死亡
                if (aliveGods.length === 0 && aliveVillagers.length === 0) {
                    winner = '狼人';
                }
            }


            if (winner) {
                // 如果有勝利者，則調用結束遊戲的函數
                endGame(winner);
                return true; // 返回 true，表示遊戲已結束
            }

            // 如果沒有勝利者，返回 false
            return false;
        }

// ▲▲▲ 新增函數黏貼結束 ▲▲▲
/**
 * 【全新 | V2.0 深度修復版】檢查並修復資料庫與記憶體狀態不一致、以及資料結構殘缺的問題
 */
async function checkAndFixData() {
    const confirmed = await showCustomConfirm(
        '確認操作',
        '此功能將掃描資料庫，嘗試找出並修復“角色在資料庫中存在，但未在聊天清單顯示”的問題。<br><br><strong>操作通常是安全的，但仍建議在操作前備份資料。</strong>',
        { confirmText: '開始檢查' }
    );

    if (!confirmed) return;

    await showCustomAlert("請稍候...", "正在掃描和修復資料...");

    try {
        const chatsFromDB = await db.chats.toArray();
        let fixedCount = 0;

        for (const chat of chatsFromDB) {
            let isModified = false;

            // 修復1：確保 history 聊天記錄陣列存在，這是最常見的問題
            if (!Array.isArray(chat.history)) {
                chat.history = [];
                isModified = true;
            }
            // 修復2：確保 settings 設置對象存在
            if (typeof chat.settings !== 'object' || chat.settings === null) {
                chat.settings = {};
                isModified = true;
            }
            // 修復3：為舊資料的單聊角色補充 originalName（本名）
            if (!chat.isGroup && !chat.originalName) {
                chat.originalName = chat.name;
                isModified = true;
            }
            // 修復4：確保 unreadCount（未讀消息數）存在
            if (typeof chat.unreadCount === 'undefined') {
                chat.unreadCount = 0;
                isModified = true;
            }
            // 修復5: 確保 longTermMemory (長期記憶) 陣列存在
            if (!Array.isArray(chat.longTermMemory)) {
                chat.longTermMemory = [];
                isModified = true;
            }
            // 您未來可以根據需要在這裡添加更多的檢查和修復邏輯...

            // 如果資料被修復過，就更新資料庫
            if (isModified) {
                fixedCount++;
                console.log(`修復了角色 "${chat.name}" (ID: ${chat.id}) 的殘缺數據。`);
                await db.chats.put(chat);
            }
            
            // 無論是否修復，都確保記憶體中的 state 物件是最新的
            state.chats[chat.id] = chat;
        }

        if (fixedCount > 0) {
            await showCustomAlert(
                '修復完成！',
                `成功檢查並修復了 ${fixedCount} 個角色的資料問題！\n\n聊天列表已為您刷新。`
            );
            // 使用修復後的最新資料，重新渲染聊天清單
            await renderChatList(); 
        } else {
            await showCustomAlert('檢查完成', '未發現任何需要修復的資料問題。');
        }

    } catch (error) {
        console.error("資料檢查與修復失敗:", error);
        await showCustomAlert('操作失敗', `執行檢查時發生錯誤: ${error.message}`);
    }
}
// ▼▼▼ 【全新】載入動畫輔助函數 ▼▼▼
/**
 * 在指定容器顯示載入動畫
 * @param {HTMLElement} container - 要顯示載入動畫的容器元素
 * @param {string} position - 'top' 或 'bottom'，決定載入動畫出現的位置
 */
function showLoader(container, position = 'top') {
    // 檢查是否已存在載入器，避免重複添加
    if (container.querySelector('.loader-container')) return;
    const loader = document.createElement('div');
    loader.className = 'loader-container';
    loader.innerHTML = '<div class="spinner"></div>';
    
    if (position === 'bottom') {
        container.appendChild(loader);
    } else {
        container.prepend(loader);
    }
}

/**
 * 從指定容器移除載入動畫
 * @param {HTMLElement} container - 要移除載入動畫的容器元素
 */
function hideLoader(container) {
    const loader = container.querySelector('.loader-container');
    if (loader) {
        loader.remove();
    }
}
// ▲▲▲ 新增函數結束 ▲▲▲
// ▲▲▲ 黏貼結束 ▲▲▲

// ▼▼▼ 【全新】這是刪除世界書功能的【全部核心JS代碼】，請完整黏貼 ▼▼▼

/**
 * 【總入口】打開刪除世界書的選擇器彈窗
 */
async function openWorldBookDeletionModal() {
    const modal = document.getElementById('delete-world-books-modal');
    const listEl = document.getElementById('delete-world-books-list');
    const selectAllCheckbox = document.getElementById('select-all-world-books-for-clear');
    listEl.innerHTML = '';
    selectAllCheckbox.checked = false; // 重置全選框

    const books = await db.worldBooks.toArray();

    if (books.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">沒有可以刪除的世界書。</p>';
    } else {
        books.forEach(book => {
            const item = document.createElement('div');
            item.className = 'clear-posts-item'; // 複用樣式
            item.dataset.bookId = book.id;
            item.innerHTML = `
                <div class="checkbox"></div>
                <span class="name">${book.name}</span>
            `;
            listEl.appendChild(item);
        });
    }
    
    modal.classList.add('visible');
}

/**
 * 【核心】處理最終確認刪除世界書的邏輯
 */
async function handleConfirmWorldBookDeletion() {
    const selectedItems = document.querySelectorAll('#delete-world-books-list .clear-posts-item.selected');
    if (selectedItems.length === 0) {
        alert("請至少選擇一個要刪除的世界書。");
        return;
    }

    const idsToDelete = Array.from(selectedItems).map(item => item.dataset.bookId);
    
    const confirmed = await showCustomConfirm(
        '最後確認！',
        `此操作將永久刪除您選擇的 ${selectedItems.length} 本世界書，並解除它們與所有角色的關聯。此操作【不可恢復】！`,
        { confirmButtonClass: 'btn-danger', confirmText: '確認刪除' }
    );

    if (!confirmed) return;
    
    await showCustomAlert("請稍候...", "正在執行刪除操作...");

    try {
        await db.transaction('rw', db.worldBooks, db.chats, async () => {
            // 1. 批量刪除世界書本身
            await db.worldBooks.bulkDelete(idsToDelete);

            // 2. 遍歷所有聊天，解除關聯
            const allChats = await db.chats.toArray();
            for (const chat of allChats) {
                if (chat.settings && Array.isArray(chat.settings.linkedWorldBookIds)) {
                    const originalCount = chat.settings.linkedWorldBookIds.length;
                    // 過濾掉已被刪除的世界書ID
                    chat.settings.linkedWorldBookIds = chat.settings.linkedWorldBookIds.filter(id => !idsToDelete.includes(id));
                    
                    // 如果有關聯被解除，則更新該聊天
                    if (chat.settings.linkedWorldBookIds.length < originalCount) {
                        await db.chats.put(chat);
                    }
                }
            }
        });
        
        // 更新記憶體狀態
        state.worldBooks = state.worldBooks.filter(book => !idsToDelete.includes(book.id));
        
        document.getElementById('delete-world-books-modal').classList.remove('visible');
        await showCustomAlert("刪除成功", `${selectedItems.length} 本世界書已成功刪除。`);

    } catch (error) {
        console.error("刪除世界書失敗:", error);
        await showCustomAlert("刪除失敗", `操作失敗: ${error.message}`);
    }
}
// ▲▲▲ 新增JS代碼結束 ▲▲▲
// ▼▼▼ 【V2.1 | 狀態與交互修復版】一起讀書功能核心函數 ▼▼▼

/**
 * 【總入口】打開讀書視窗（由工具列按鈕調用）
 */
function openReadingRoom() {
    if (!state.activeChatId) return;
    const chatId = state.activeChatId;
    const overlay = document.getElementById('reading-overlay');
    const windowEl = document.getElementById('reading-window');
    const restoreBtn = document.getElementById('reading-restore-btn');

    let session = readingState[chatId];

    // 如果會話已啟動（無論是打開還是最小化），只需確保它可見即可
    if (session && session.isActive) {
        if (session.isMinimized) {
            restoreReadingRoom(); // 如果是最小化狀態，就恢復它
        }
        // 如果已經是打開狀態，確保它在最前
        overlay.style.display = 'flex';
        return;
    }

    // 如果會話未啟動，則創建並顯示
    initReadingSession(chatId);
    renderReadingRoom(chatId);

    // 重置所有狀態，確保視窗從中間出現
    overlay.style.display = 'flex';
    windowEl.classList.remove('minimized');
    restoreBtn.style.display = 'none';
    
    // 使用transform居中，避免拖動衝突
// ▼▼▼ 【核心修復：使用JS計算初始居中位置，消除彈跳】 ▼▼▼
// 1. 獲取父容器（手機螢幕）和視窗本身的尺寸
const phoneScreen = document.getElementById('phone-screen');
const windowRect = windowEl.getBoundingClientRect(); // 獲取視窗尺寸

// 2. 計算居中的 top 和 left 圖元值
const top = (phoneScreen.clientHeight - windowRect.height) / 2;
const left = (phoneScreen.clientWidth - windowRect.width) / 2;

// 3. 直接應用計算好的圖元值，並確保 transform 屬性為空
windowEl.style.top = `${top}px`;
windowEl.style.left = `${left}px`;
windowEl.style.transform = ''; // 確保沒有 transform 屬性
// ▲▲▲ 修復結束 ▲▲▲
}

/**
 * 【已升級】初始化一個新的讀書會話狀態
 */
function initReadingSession(chatId) {
    readingState[chatId] = {
        isActive: true,
        isMinimized: false,
        title: '未選擇書籍',
        contentLines: [],
        currentPage: 0,
        totalPages: 0,
        linesPerPage: 15,
        currentSnippet: '' // <-- 核心新增：用於存儲當前視野中的文字片段
    };
}

/**
 * 【已修復】關閉讀書懸浮窗 (由 'X' 按鈕調用)
 */
function closeReadingRoom() {
    const chatId = state.activeChatId;
    if (!chatId || !readingState[chatId] || !readingState[chatId].isActive) return;

    // 隱藏所有相關UI
    document.getElementById('reading-overlay').style.display = 'none';
    document.getElementById('reading-restore-btn').style.display = 'none';
    document.getElementById('reading-window').classList.remove('minimized');

    // 核心修復：將 isActive 設為 false，這樣下次才能重新打開
    readingState[chatId].isActive = false;
    console.log("讀書會話已關閉。");
}

/**
 * 【已修復】最小化讀書窗口
 */
function minimizeReadingRoom() {
    const session = readingState[state.activeChatId];
    if (!session || !session.isActive || session.isMinimized) return;

    session.isMinimized = true; // 更新狀態
    document.getElementById('reading-window').classList.add('minimized');
    document.getElementById('reading-restore-btn').style.display = 'flex';
}

/**
 * 【已修復】恢復讀書窗口
 */
function restoreReadingRoom() {
    const session = readingState[state.activeChatId];
    if (!session || !session.isActive || !session.isMinimized) return;

    session.isMinimized = false; // 更新狀態
    document.getElementById('reading-restore-btn').style.display = 'none';
    document.getElementById('reading-window').classList.remove('minimized');
}

/**
 * 【已修復】讓一個元素變得可拖動
 * @param {HTMLElement} windowEl - 要拖動的視窗元素
 * @param {HTMLElement} headerEl - 拖動的手柄元素
 */
function makeDraggable(windowEl, headerEl) {
    let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
    const phoneScreen = document.getElementById('phone-screen');

    const startDrag = (e) => {
        // ▼▼▼ 【【【核心修復就在這裡！】】】 ▼▼▼
        // 在開始拖動前，檢查點擊的是否是按鈕。如果是，則立即退出，不執行任何拖動邏輯。
        if (e.target.closest('button')) {
            return;
        }
        // ▲▲▲ 【【【修復結束】】】 ▲▲▲

        // （後續的拖動邏輯保持不變）
        if (windowEl.style.transform) {
            const rect = windowEl.getBoundingClientRect();
            const parentRect = windowEl.offsetParent.getBoundingClientRect();
            windowEl.style.top = `${rect.top - parentRect.top}px`;
            windowEl.style.left = `${rect.left - parentRect.left}px`;
            windowEl.style.transform = '';
        }

        e.preventDefault();
        const event = e.type === 'touchstart' ? e.touches[0] : e;
        pos3 = event.clientX;
        pos4 = event.clientY;
        
        document.addEventListener('mouseup', endDrag);
        document.addEventListener('mousemove', elementDrag);
        document.addEventListener('touchend', endDrag);
        document.addEventListener('touchmove', elementDrag);
    };

    const elementDrag = (e) => {
        const event = e.type === 'touchmove' ? e.touches[0] : e;
        pos1 = pos3 - event.clientX;
        pos2 = pos4 - event.clientY;
        pos3 = event.clientX;
        pos4 = event.clientY;
        
        let newTop = windowEl.offsetTop - pos2;
        let newLeft = windowEl.offsetLeft - pos1;

        const maxTop = phoneScreen.clientHeight - windowEl.offsetHeight - 10;
        const maxLeft = phoneScreen.clientWidth - windowEl.offsetWidth - 10;
        newTop = Math.max(10, Math.min(newTop, maxTop));
        newLeft = Math.max(10, Math.min(newLeft, maxLeft));

        windowEl.style.top = newTop + "px";
        windowEl.style.left = newLeft + "px";
    };

    const endDrag = () => {
        document.removeEventListener('mouseup', endDrag);
        document.removeEventListener('mousemove', elementDrag);
        document.removeEventListener('touchend', endDrag);
        document.removeEventListener('touchmove', elementDrag);
    };

    headerEl.addEventListener('mousedown', startDrag);
    headerEl.addEventListener('touchstart', startDrag);
}

// --- 其他輔助函數 (保持不變) ---
function renderReadingRoom(chatId) {
    const session = readingState[chatId]; if (!session) return;
    const titleEl = document.getElementById('reading-title');
    const contentEl = document.getElementById('reading-content');
    const pageIndicator = document.getElementById('page-indicator');
    const prevBtn = document.getElementById('prev-page-btn');
    const nextBtn = document.getElementById('next-page-btn');
    titleEl.textContent = session.title;
    if (session.contentLines.length === 0) {
        contentEl.innerHTML = '<p>點擊“導入”按鈕，<br>從本地.txt檔或網路URL載入書籍內容。</p>';
        session.totalPages = 0; session.currentPage = 0;
    } else {
        const startLine = session.currentPage * session.linesPerPage;
        const endLine = startLine + session.linesPerPage;
        contentEl.textContent = session.contentLines.slice(startLine, endLine).join('\n');
    }
    pageIndicator.textContent = `${session.currentPage + 1} / ${session.totalPages}`;
    prevBtn.disabled = session.currentPage === 0;
    nextBtn.disabled = session.currentPage >= session.totalPages - 1;
}
function showNextPage() {
    const session = readingState[state.activeChatId];
    if (session && session.currentPage < session.totalPages - 1) {
        session.currentPage++; 
        renderReadingRoom(state.activeChatId);
        document.getElementById('reading-content').scrollTop = 0;
        // 【核心新增】保存進度
        saveReadingProgress(session.activeBookId, session.currentPage);
    }
}

// ▼▼▼ 【請用這個已升級的版本】替換舊的 showPrevPage 函數 ▼▼▼
async function showPrevPage() {
    const session = readingState[state.activeChatId];
    if (session && session.currentPage > 0) {
        session.currentPage--; 
        renderReadingRoom(state.activeChatId);
        document.getElementById('reading-content').scrollTop = 0;
        await saveReadingProgress(session.activeBookId, session.currentPage);

        // 【核心新增】在翻頁後，也立刻通知AI
        await notifyAiOfPageTurn(state.activeChatId, session);
    }
}
// ▲▲▲ 替換結束 ▲▲▲
/**
 * 【已修改】僅用於觸發本地檔選擇
 */
function importBook() {
    // 直接觸發隱藏的檔輸入框，不再彈出選擇功能表
    document.getElementById('book-upload-input').click();
}
/**
 * 【全新 | 編碼相容】智慧解碼文字檔
 * @param {ArrayBuffer} arrayBuffer - 檔的二進位資料
 * @returns {string} - 解碼後的文本內容
 */
async function decodeTextFile(arrayBuffer) {
    const uint8array = new Uint8Array(arrayBuffer);

    // 1. 檢查BOM (Byte Order Mark) 來精確判斷編碼
    if (uint8array.length >= 3 && uint8array[0] === 0xEF && uint8array[1] === 0xBB && uint8array[2] === 0xBF) {
        console.log("檢測到 UTF-8 BOM，使用 UTF-8 解碼。");
        return new TextDecoder('utf-8').decode(uint8array);
    }
    if (uint8array.length >= 2 && uint8array[0] === 0xFF && uint8array[1] === 0xFE) {
        console.log("檢測到 UTF-16 LE BOM，使用 UTF-16 LE 解碼。");
        return new TextDecoder('utf-16le').decode(uint8array);
    }
    if (uint8array.length >= 2 && uint8array[0] === 0xFE && uint8array[1] === 0xFF) {
        console.log("檢測到 UTF-16 BE BOM，使用 UTF-16 BE 解碼。");
        return new TextDecoder('utf-16be').decode(uint8array);
    }

    // 2. 如果沒有BOM，嘗試作為UTF-8解碼
    try {
        console.log("未檢測到BOM，嘗試使用 UTF-8 解碼...");
        // 使用 fatal: true 會在遇到無效位元組序列時拋出錯誤
        const decoded = new TextDecoder('utf-8', { fatal: true }).decode(uint8array);
        console.log("UTF-8 解碼成功。");
        return decoded;
    } catch (e) {
        console.log("UTF-8 解碼失敗，將嘗試 GBK (ANSI) 解碼...");
        // 3. 如果UTF-8失敗，則回退到GBK解碼 (覆蓋常見的中文ANSI)
        try {
            const decoded = new TextDecoder('gbk').decode(uint8array);
            console.log("GBK 解碼成功。");
            return decoded;
        } catch (err) {
             console.error("所有解碼嘗試均失敗:", err);
             // 4. 如果所有嘗試都失敗了，拋出一個使用者友好的錯誤
             throw new Error("無法識別的檔編碼。請嘗試將檔轉換為 UTF-8 格式後重新導入。");
        }
    }
}
/**
 * 【已修改 | 編碼相容】處理使用者上傳的書籍檔，現在會將其保存到資料庫
 */
async function handleBookFileUpload(event) {
    const file = event.target.files[0];
    if (!file) return;

    try {
        // 核心修改1：將文件讀取為 ArrayBuffer
        const arrayBuffer = await file.arrayBuffer();
        // 核心修改2：調用我們新的智慧解碼函數
        const textContent = await decodeTextFile(arrayBuffer);

        const title = file.name.replace(/\.txt$/i, '');

        const newBookId = await db.readingLibrary.add({
            title: title,
            content: textContent,
            lastOpened: Date.now()
        });

        await loadBookFromLibrary(newBookId);
        if (document.getElementById('reading-library-modal').classList.contains('visible')) {
            renderBookLibrary();
        }
    } catch (error) {
        // 如果解碼或處理過程中出錯，給用戶一個明確的提示
        console.error("導入書籍失敗:", error);
        await showCustomAlert("導入失敗", error.message);
    } finally {
        event.target.value = null;
    }
}
async function handlePageJump() {
    const chatId = state.activeChatId;
    if (!chatId) return;
    const session = readingState[chatId];
    if (!session || session.totalPages <= 1) return;

    const targetPageStr = await showCustomPrompt(
        '頁面跳轉', 
        `請輸入想跳轉的頁碼 (1 - ${session.totalPages})`,
        session.currentPage + 1
    );

    if (targetPageStr === null) return;

    const targetPage = parseInt(targetPageStr);

    if (isNaN(targetPage) || targetPage < 1 || targetPage > session.totalPages) {
        alert("請輸入一個有效的頁碼！");
        return;
    }

    session.currentPage = targetPage - 1;
    renderReadingRoom(chatId);
    // 【核心新增】保存進度
    saveReadingProgress(session.activeBookId, session.currentPage);
}

/**
 * 【全新】保存指定書籍的閱讀進度到資料庫
 * @param {number} bookId - 要保存進度的書籍ID
 * @param {number} pageNumber - 當前的頁碼
 */
async function saveReadingProgress(bookId, pageNumber) {
    if (!bookId) return;
    try {
        // 使用 update 方法，只更新 currentPage 欄位，不影響其他資料
        await db.readingLibrary.update(bookId, { currentPage: pageNumber });
    } catch (error) {
        console.error(`保存書籍(ID: ${bookId})的閱讀進度失敗:`, error);
    }
}
// ▼▼▼ 【請用這個已升級的版本】替換舊的 showNextPage 函數 ▼▼▼
async function showNextPage() {
    const session = readingState[state.activeChatId];
    if (session && session.currentPage < session.totalPages - 1) {
        session.currentPage++; 
        renderReadingRoom(state.activeChatId);
        document.getElementById('reading-content').scrollTop = 0;
        await saveReadingProgress(session.activeBookId, session.currentPage);
        
        // 【核心新增】在翻頁後，立刻通知AI
        await notifyAiOfPageTurn(state.activeChatId, session);
    }
}
// ▲▲▲ 替換結束 ▲▲▲
function processImportedText(title, textContent) {
    const chatId = state.activeChatId; if (!chatId) return;
    const session = readingState[chatId];
    session.title = title.replace(/\.txt$/i, '');
    session.contentLines = textContent.split(/\r\n?|\n/).map(line => line.replace(/ +/g, ' '));
    session.totalPages = Math.ceil(session.contentLines.length / session.linesPerPage);
    session.currentPage = 0;
    renderReadingRoom(chatId);
}

// ▲▲▲ JS代碼替換結束 ▲▲▲
/**
 * 【全新】打開書庫彈窗並渲染列表
 */
async function openBookLibrary() {
    // 【核心新增】在渲染前，先清空搜索框
    document.getElementById('reading-library-search-input').value = '';

    await renderBookLibrary(); // 調用不帶參數的渲染，顯示全部書籍
    document.getElementById('reading-library-modal').classList.add('visible');
}

/**
 * 【全新 | 支援搜索】從資料庫讀取書籍並渲染到書庫列表中
 * @param {string} searchTerm - 使用者輸入的搜索關鍵字
 */
async function renderBookLibrary(searchTerm = '') {
    const listEl = document.getElementById('reading-library-list');
    let books = await db.readingLibrary.orderBy('lastOpened').reverse().toArray();
    listEl.innerHTML = '';

    // 【核心修改1】根據搜索詞過濾書籍
    if (searchTerm) {
        books = books.filter(book => 
            book.title.toLowerCase().includes(searchTerm.toLowerCase())
        );
    }

    // 【核心修改2】根據是否有結果，顯示不同的提示資訊
    if (books.length === 0) {
        const message = searchTerm 
            ? '找不到匹配的書籍' 
            : '書庫是空的，點擊“導入新書”添加第一本吧！';
        listEl.innerHTML = `<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">${message}</p>`;
        return;
    }

    books.forEach(book => {
        const item = document.createElement('div');
        item.className = 'existing-group-item'; 
        item.innerHTML = `
            <span class="group-name" style="cursor:pointer;" data-book-id="${book.id}">${book.title}</span>
            <button class="delete-group-btn" data-book-id="${book.id}" title="刪除書籍">×</button>
        `;
        listEl.appendChild(item);
    });
}

/**
 * 【全新 | 支持中斷點續讀】從書庫中載入一本書到閱讀器
 * @param {number} bookId - 要載入的書籍的ID
 */
async function loadBookFromLibrary(bookId) {
    const chatId = state.activeChatId;
    if (!chatId) return;

    const book = await db.readingLibrary.get(bookId);
    if (!book) {
        alert('找不到這本書！');
        return;
    }

    await db.readingLibrary.update(bookId, { lastOpened: Date.now() });

    const session = readingState[chatId];
    session.activeBookId = bookId; // 【核心新增】記錄當前正在閱讀的書籍ID
    session.title = book.title;
    session.contentLines = book.content.split(/\r\n?|\n/).map(line => line.replace(/ +/g, ' '));
    session.totalPages = Math.ceil(session.contentLines.length / session.linesPerPage);
    
    // ▼▼▼ 【【【這就是實現中斷點續讀的關鍵！】】】 ▼▼▼
    // 讀取資料庫中保存的頁碼，如果沒有，則默認為第0頁
    session.currentPage = book.currentPage || 0;
    // ▲▲▲ 關鍵代碼結束 ▲▲▲

    renderReadingRoom(chatId);
    // 渲染後，確保捲軸在頂部
    document.getElementById('reading-content').scrollTop = 0; 
    document.getElementById('reading-library-modal').classList.remove('visible');
}

/**
 * 【全新】從書庫中刪除一本書
 * @param {number} bookId - 要刪除的書籍的ID
 */
async function deleteBookFromLibrary(bookId) {
    const book = await db.readingLibrary.get(bookId);
    if (!book) return;

    const confirmed = await showCustomConfirm('刪除書籍', `確定要刪除《${book.title}》嗎？`, { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        await db.readingLibrary.delete(bookId);
        await renderBookLibrary(); // 刷新書庫列表
    }
}
/**
 * 【核心】處理導入的文本內容，更新狀態並刷新UI
 * @param {string} title - 書籍/檔案名
 * @param {string} textContent - 完整的文本內容
 */
function processImportedText(title, textContent) {
    const chatId = state.activeChatId;
    if (!chatId) return;

    const session = readingState[chatId];
    session.title = title.replace(/\.txt$/i, '');
    session.contentLines = textContent.split(/\r\n?|\n/);
    session.totalPages = Math.ceil(session.contentLines.length / session.linesPerPage);
    session.currentPage = 0;

    renderReadingRoom(chatId);
}

// ▲▲▲ 新增JS代碼結束 ▲▲▲
/**
 * 【V2.1 | 拖動與點擊相容修復版】讓一個元素變得可拖動
 * @param {HTMLElement} windowEl - 要拖動的視窗元素
 * @param {HTMLElement} headerEl - 拖動的手柄元素
 */
function makeDraggable(windowEl, headerEl) {
    let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
    let isDragging = false;
    let hasMoved = false; // 新增標誌位元，判斷是否發生過移動
    const phoneScreen = document.getElementById('phone-screen');

    const startDrag = (e) => {
        // 如果是主視窗，並且點擊的是內部按鈕，則不觸發拖動
        if (windowEl !== headerEl && e.target.closest('button')) {
            return;
        }

        isDragging = true;
        hasMoved = false; // 每次開始時重置移動狀態

        const event = e.type === 'touchstart' ? e.touches[0] : e;
        pos3 = event.clientX;
        pos4 = event.clientY;

        // 確保使用 top/left 定位，而不是 transform
        windowEl.style.top = `${windowEl.offsetTop}px`;
        windowEl.style.left = `${windowEl.offsetLeft}px`;
        windowEl.style.transform = '';

        document.addEventListener('mouseup', endDrag);
        document.addEventListener('mousemove', elementDrag);
        document.addEventListener('touchend', endDrag);
        // 【核心修復1】添加 passive: false 確保 preventDefault 生效
        document.addEventListener('touchmove', elementDrag, { passive: false });
    };

    const elementDrag = (e) => {
        if (!isDragging) return;

        const event = e.type === 'touchmove' ? e.touches[0] : e;
        const diffX = event.clientX - pos3;
        const diffY = event.clientY - pos4;

        // 【核心修復2】只有當移動距離超過一個微小閾值時，才判定為“拖動”
        if (!hasMoved && (Math.abs(diffX) > 5 || Math.abs(diffY) > 5)) {
            hasMoved = true;
        }

        // 只有在確定是拖動時，才阻止頁面滾動
        if (hasMoved && e.cancelable) {
            e.preventDefault();
        }

        pos1 = pos3 - event.clientX;
        pos2 = pos4 - event.clientY;
        pos3 = event.clientX;
        pos4 = event.clientY;

        let newTop = windowEl.offsetTop - pos2;
        let newLeft = windowEl.offsetLeft - pos1;

        const maxTop = phoneScreen.clientHeight - windowEl.offsetHeight - 10;
        const maxLeft = phoneScreen.clientWidth - windowEl.offsetWidth - 10;
        newTop = Math.max(10, Math.min(newTop, maxTop));
        newLeft = Math.max(10, Math.min(newLeft, maxLeft));

        windowEl.style.top = newTop + "px";
        windowEl.style.left = newLeft + "px";
    };

    const endDrag = () => {
        document.removeEventListener('mouseup', endDrag);
        document.removeEventListener('mousemove', elementDrag);
        document.removeEventListener('touchend', endDrag);
        document.removeEventListener('touchmove', elementDrag);

        if (!isDragging) return;
        isDragging = false;

        // 【核心修復3】如果從頭到尾都沒有發生有效移動，就判定為一次“點擊”
        if (!hasMoved) {
            // 手動觸發元素的點擊事件
            windowEl.click();
        }
    };

    headerEl.addEventListener('mousedown', startDrag);
    // 【核心修復4】為 touchstart 也添加 passive: false
    headerEl.addEventListener('touchstart', startDrag, { passive: false });
}


/**
 * 最小化讀書窗口
 */
function minimizeReadingRoom() {
    const session = readingState[state.activeChatId];
    if (!session || !session.isActive) return;

    document.getElementById('reading-window').classList.add('minimized');
    document.getElementById('reading-restore-btn').style.display = 'flex';
    session.isMinimized = true;
}

/**
 * 恢復讀書窗口
 */
function restoreReadingRoom() {
    const session = readingState[state.activeChatId];
    if (!session || !session.isActive) return;

    document.getElementById('reading-restore-btn').style.display = 'none';
    document.getElementById('reading-window').classList.remove('minimized');
    session.isMinimized = false;
}

// ▲▲▲ 新增JS代碼結束 ▲▲▲
// ▼▼▼ 【全新】這是實現“滾動感知”功能的核心代碼，請完整黏貼 ▼▼▼

/**
 * 【輔助函數】創建一個防抖函數
 * @param {Function} func - 需要防抖的函數
 * @param {number} delay - 延遲時間 (毫秒)
 * @returns {Function} - 經過防抖處理的新函數
 */
function debounce(func, delay) {
    let timeout;
    return function(...args) {
        const context = this;
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(context, args), delay);
    };
}
// ▼▼▼ 【V3.1 | 邏輯優化版】請用這個全新的函數，完整替換舊的 formatReadingStateForAI ▼▼▼

/**
 * 【全新 V3.1 | 邏輯優化版】將指定聊天的“一起讀書”狀態格式化為AI可讀的文本
 * @param {string} chatId - 目標聊天的ID
 * @returns {string} - 格式化後的上下文細節字串，如果沒有啟動的讀書會話則為空字串
 */
function formatReadingStateForAI(chatId) {
    const session = readingState[chatId];
    
    // 如果會話未啟動，或沒有內容，直接返回空字串
    if (!session || !session.isActive) {
        return "";
    }

    const title = session.title || '未知書籍';
    let contentForAI = '';
    let contextLabel = '';

    // (這部分獲取視野內容的邏輯保持不變)
    if (session.currentSnippet && session.currentSnippet.trim()) {
        contentForAI = session.currentSnippet;
        contextLabel = '你正在閱讀的段落';
    } else if (session.contentLines.length > 0) {
        const startLine = session.currentPage * session.linesPerPage;
        const endLine = startLine + session.linesPerPage;
        contentForAI = session.contentLines.slice(startLine, endLine).join('\n').substring(0, 200);
        contextLabel = '當前頁內容摘要';
    } else {
        contentForAI = '(無內容)';
        contextLabel = '內容';
    }

    // 【【【核心修改】】】
    // 不再返回完整的指令塊，而是只返回包含細節的、用於拼接的字串。
    // 注意前面的換行和縮進，以保持最終Prompt的美觀。
    return `
    - **書名**: 《${title}》
    - **${contextLabel}**: "${contentForAI}..."
    #一起讀書模式 | 行為鐵律
    1.  **角色定位**: 你【不是】書中的任何角色，你是【你自己】(${state.chats[chatId]?.originalName || 'AI角色'})，正在和用戶一起【閱讀和討論】這本書。
    2.  **行為準則**: 你的回復【必須】是作為讀者的【感想、評論、提問或聯想】。你可以：
        -   分享你對當前段落的看法。
        -   對書中的角色或情節發表評論。
        -   向使用者提問，詢問TA對內容的看法。
        -   根據書本內容，聯想到你自己的經歷或記憶。
    3.  **嚴禁**: 你的回復【絕對禁止】使用書中角色的口吻和人稱！【絕對禁止】扮演書中的任何角色！【絕對禁止】續寫或模仿書中的情節！你必須時刻記住，你只是一個讀者。    
`;
}

// ▲▲▲ 替換結束 ▲▲▲
// ▼▼▼ 【這是最終修復版】請用這個全新的函數，完整替換舊的 updateReadingContextOnScroll ▼▼▼

/**
 * 【全新 | V2.0 全視野版】當讀書視窗滾動時，更新當前視野中的【所有可見】文字片段
 */
function updateReadingContextOnScroll() {
    const chatId = state.activeChatId;
    if (!chatId || !readingState[chatId]) return;

    const session = readingState[chatId];
    const container = document.getElementById('reading-content');
    
    // --- ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
    //            這就是本次升級的核心所在！
    // --- ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★

    // 1. 獲取滾動容器的尺寸和位置資訊
    const scrollTop = container.scrollTop; // 捲軸距離頂部的距離
    const clientHeight = container.clientHeight; // 容器本身可見的高度
    const scrollBottom = scrollTop + clientHeight; // 可見區域的底部位置

    // 2. 估算每一行的大致高度 (這部分保持不變)
    const approximateLineHeight = 15 * 1.8; 

    // 3. 計算出視野範圍內的第一行和最後一行的行號
    const firstVisibleLine = Math.floor(scrollTop / approximateLineHeight);
    const lastVisibleLine = Math.ceil(scrollBottom / approximateLineHeight);

    // 4. 計算這些行在整本書中的絕對行號
    const absoluteStartIndex = (session.currentPage * session.linesPerPage) + firstVisibleLine;
    const absoluteEndIndex = (session.currentPage * session.linesPerPage) + lastVisibleLine;

    // 5. 安全檢查，確保索引在有效範圍內
    if (absoluteStartIndex < 0 || absoluteStartIndex >= session.contentLines.length) {
        return;
    }

    // 6. 截取從第一行到最後一行的所有內容，形成一個完整的“視野”
    const newSnippet = session.contentLines.slice(
        Math.max(0, absoluteStartIndex), 
        Math.min(session.contentLines.length, absoluteEndIndex)
    ).join('\n');
    
    // 7. 更新狀態，將這個完整的“視野”存起來
    session.currentSnippet = newSnippet;
}

// ▲▲▲ 替換結束 ▲▲▲
// ▼▼▼ 【全新】這是靜音播放功能的核心函數 ▼▼▼

/**
 * 嘗試播放用於後臺保活的靜音音訊
 */
function playSilentAudio() {
    const silentPlayer = document.getElementById('silent-audio-player');
    if (silentPlayer) {
        // play() 方法返回一個 Promise，我們需要處理它以避免流覽器報錯
        const playPromise = silentPlayer.play();
        if (playPromise !== undefined) {
            playPromise.then(_ => {
                console.log("靜音音訊已啟動，用於後臺活動保活。");
            }).catch(error => {
                // 在iOS上，首次播放需要使用者交互，這個錯誤是正常的。
                // 當使用者點擊開關並保存後，後續的播放通常會成功。
                console.warn("無法自動播放靜音音訊（這在iOS首次載入時是正常現象）:", error);
            });
        }
    }
}

/**
 * 停止播放靜音音訊
 */
function stopSilentAudio() {
    const silentPlayer = document.getElementById('silent-audio-player');
    if (silentPlayer && !silentPlayer.paused) {
        silentPlayer.pause();
        silentPlayer.currentTime = 0; // 重置音訊，以便下次能從頭開始
        console.log("靜音音訊已停止。");
    }
}

// ▲▲▲ 新增函數黏貼結束 ▲▲▲
async function playTtsAudio(bodyElement) {
    const text = decodeURIComponent(bodyElement.dataset.text);
    const voiceId = bodyElement.dataset.voiceId;
    const button = bodyElement.querySelector('.voice-play-btn'); // 即使沒有按鈕，也嘗試獲取
    const spinner = bodyElement.querySelector('.loading-spinner');

    const ttsPlayer = document.getElementById('tts-audio-player');
    if (!ttsPlayer.paused && ttsPlayer.dataset.currentText === text && ttsPlayer.dataset.currentVoiceId === voiceId) {
        ttsPlayer.pause();
        return;
    }

    ttsPlayer.pause();
    document.querySelectorAll('.voice-play-btn').forEach(btn => btn.textContent = '▶');

    const cacheKey = `tts_${voiceId}_${text}`;
    let cachedAudio = state.ttsCache.get(cacheKey);

    if (cachedAudio) {
        console.log("從緩存播放 TTS 音訊...");
        await playAudioFromData(cachedAudio.url, cachedAudio.type, text, voiceId, bodyElement); // 傳遞 bodyElement
        return;
    }

    console.log("無緩存，正在請求 Minimax TTS API...");
    if(button) button.style.display = 'none';
    spinner.style.display = 'block';

    const { minimaxGroupId, minimaxApiKey } = state.apiConfig;
    if (!minimaxGroupId || !minimaxApiKey) {
        await showCustomAlert("配置錯誤", "請先在API設置中填寫您的 Minimax Group ID 和 API Key。");
        spinner.style.display = 'none';
        if(button) button.style.display = 'flex';
        return;
    }

    try {
        const response = await fetch(`https://api.minimax.chat/v1/text_to_speech?GroupId=${minimaxGroupId}`, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${minimaxApiKey}`,
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                text: text,
                voice_id: voiceId,
                model: state.apiConfig.minimaxModel || "speech-01",
                speed: 1.0, vol: 1.0, pitch: 0,
            })
        });

        if (!response.ok) {
            let errorMsg = `API 返回錯誤: ${response.status}`;
            try {
                const errorData = await response.json();
                errorMsg = errorData.base_resp?.status_msg || JSON.stringify(errorData);
            } catch(e) {
                errorMsg = await response.text();
            }
            throw new Error(errorMsg);
        }

        const audioBlob = await response.blob();
        const audioUrl = URL.createObjectURL(audioBlob);
        await playAudioFromData(audioUrl, audioBlob.type, text, voiceId, bodyElement); // 傳遞 bodyElement

        const reader = new FileReader();
        reader.onloadend = function() {
            state.ttsCache.set(cacheKey, { url: reader.result, type: audioBlob.type });
            console.log("TTS 音訊已保存到緩存。");
        }
        reader.readAsDataURL(audioBlob);

    } catch (error) {
        console.error("Minimax TTS API 調用失敗:", error);
        await showCustomAlert("語音生成失敗", `錯誤: ${error.message}`);
    } finally {
        spinner.style.display = 'none';
        if(button) button.style.display = 'flex';
    }
}

// 用這個新版本替換舊的 playAudioFromData 函數
function playAudioFromData(audioSrc, audioType, text, voiceId, bodyElement) { // 參數從 button 改為 bodyElement
    return new Promise((resolve, reject) => {
        const ttsPlayer = document.getElementById('tts-audio-player');

        ttsPlayer.src = audioSrc;
        ttsPlayer.type = audioType;
        ttsPlayer.dataset.currentText = text;
        ttsPlayer.dataset.currentVoiceId = voiceId;

        const playPromise = ttsPlayer.play();

        if (playPromise !== undefined) {
            playPromise.then(() => {
                const button = bodyElement.querySelector('.voice-play-btn');
                if (button) button.textContent = '❚❚'; 


                resolve();
            }).catch(error => {
                console.error("音訊播放失敗:", error);
                reject(error);
            });
        }

        ttsPlayer.onended = () => {
            const button = bodyElement.querySelector('.voice-play-btn');
            if (button) button.textContent = '▶'; 
        };
        ttsPlayer.onpause = () => {
            const button = bodyElement.querySelector('.voice-play-btn');
            if (button) button.textContent = '▶';
        };
    });
}

// ▲▲▲ 全新JS代碼黏貼結束 ▲▲▲
// ▼▼▼ 【全新】這是專門為您自己的語音訊息創建的文本展開/折疊函數 ▼▼▼
/**
 * 切換使用者自己發送的語音訊息的文字顯示
 * @param {HTMLElement} bodyElement - 被點擊的 .voice-message-body 元素
 */
function toggleVoiceTranscript(bodyElement) {
    const bubble = bodyElement.closest('.message-bubble');
    if (!bubble) return;

    const transcriptEl = bubble.querySelector('.voice-transcript');
    const text = decodeURIComponent(bodyElement.dataset.text);

    if (transcriptEl.style.display === 'block') {
        // 如果文字已經是可見的，就隱藏它
        transcriptEl.style.display = 'none';
    } else {
        // 如果文字是隱藏的，就顯示它
        transcriptEl.textContent = text;
        transcriptEl.style.display = 'block';
    }
}
// ▲▲▲ 新增函數結束 ▲▲▲
// ▼▼▼ 【全新V2.0】這是商品分類和款式功能的【全部核心JS代碼】，請完整黏貼 ▼▼▼

/**
 * 【總入口】打開商品分類管理彈窗
 */
async function openProductCategoryManager() {
    await renderProductCategoriesInManager();
    document.getElementById('product-category-manager-modal').classList.add('visible');
}

/**
 * 在彈窗中渲染已存在的商品分類列表
 */
async function renderProductCategoriesInManager() {
    const listEl = document.getElementById('existing-product-categories-list');
    const categories = await db.shoppingCategories.toArray();
    listEl.innerHTML = '';
    if (categories.length === 0) {
        listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">還沒有任何分類</p>';
        return;
    }
    categories.forEach(cat => {
        const item = document.createElement('div');
        item.className = 'existing-group-item';
        item.innerHTML = `
            <span class="group-name">${cat.name}</span>
            <span class="delete-group-btn" data-id="${cat.id}">×</span>
        `;
        listEl.appendChild(item);
    });
}

/**
 * 添加一個新的商品分類
 */
async function addNewProductCategory() {
    const input = document.getElementById('new-product-category-name-input');
    const name = input.value.trim();
    if (!name) return alert('分類名不能為空！');
    const existing = await db.shoppingCategories.where('name').equals(name).first();
    if (existing) return alert(`分類 "${name}" 已經存在了！`);
    
    await db.shoppingCategories.add({ name });
    input.value = '';
    await renderProductCategoriesInManager();
}

/**
 * 刪除一個商品分類
 * @param {number} categoryId - 要刪除的分類的ID
 */
async function deleteProductCategory(categoryId) {
    const confirmed = await showCustomConfirm('確認刪除', '刪除分類後，該分類下的所有商品將變為“未分類”。確定嗎？', { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        await db.shoppingCategories.delete(categoryId);
        await db.shoppingProducts.where('categoryId').equals(categoryId).modify({ categoryId: null });
        await renderProductCategoriesInManager();
    }
}

/**
 * 動態創建一個商品款式的輸入塊
 * @param {object} variation - (可選) 用於預填充的款式資料
 * @returns {HTMLElement} - 創建好的DOM元素
 */
function addProductVariationInput(variation = {}) {
    const container = document.getElementById('product-variations-container');
    const block = document.createElement('div');
    block.className = 'message-editor-block variation-block'; // 複用樣式
    block.innerHTML = `
        <button class="delete-block-btn" title="刪除此款式">×</button>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
            <div class="form-group">
                <label style="font-size: 0.8em;">款式名稱</label>
                <input type="text" class="variation-name-input" placeholder="例如: 紅色" value="${variation.name || ''}">
            </div>
            <div class="form-group">
                <label style="font-size: 0.8em;">價格 (元)</label>
                <input type="number" class="variation-price-input" min="0" step="0.01" value="${variation.price || ''}">
            </div>
        </div>
        <div class="form-group">
            <label style="font-size: 0.8em;">款式圖片 (可選)</label>
            <div class="avatar-upload">
                <img class="variation-image-preview" src="${variation.imageUrl || 'https://i.postimg.cc/PqYp5T5M/image.png'}">
                <button type="button" class="form-button-secondary upload-variation-image-btn" style="margin: 0; padding: 8px 12px;">上傳</button>
                <input type="file" class="variation-image-input" accept="image/*" hidden>
            </div>
        </div>
    `;

    block.querySelector('.delete-block-btn').addEventListener('click', () => block.remove());
    block.querySelector('.upload-variation-image-btn').addEventListener('click', () => {
        block.querySelector('.variation-image-input').click();
    });
    block.querySelector('.variation-image-input').addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (re) => { block.querySelector('.variation-image-preview').src = re.target.result; };
            reader.readAsDataURL(file);
        }
    });
    
    container.appendChild(block);
    return block;
}

/**
 * 打開選擇商品款式的彈窗
 * @param {number} productId - 商品ID
 */
async function openVariationSelector(productId) {
    const product = await db.shoppingProducts.get(productId);
    if (!product || !product.variations || product.variations.length === 0) return;

    const modal = document.getElementById('variation-selection-modal');
    document.getElementById('variation-product-image').src = product.imageUrl;
    document.getElementById('variation-product-name').textContent = product.name;
    
    const optionsContainer = document.getElementById('variation-options-container');
    optionsContainer.innerHTML = '';
    
    product.variations.forEach((variation, index) => {
        const radio = document.createElement('input');
        radio.type = 'radio';
        radio.name = 'variation-select';
        radio.id = `var-${productId}-${index}`;
        radio.value = index;
        radio.style.display = 'none';
        if (index === 0) radio.checked = true;

        const label = document.createElement('label');
        label.htmlFor = `var-${productId}-${index}`;
        label.textContent = variation.name;
        label.style.cssText = `
            padding: 6px 12px;
            border: 1px solid #ccc;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.2s;
        `;
        
        optionsContainer.appendChild(radio);
        optionsContainer.appendChild(label);
    });

    const updateSelectionUI = () => {
        const selectedRadio = optionsContainer.querySelector('input[name="variation-select"]:checked');
        optionsContainer.querySelectorAll('label').forEach(lbl => {
            lbl.style.borderColor = '#ccc';
            lbl.style.color = '#333';
            lbl.style.backgroundColor = 'white';
        });
        if (selectedRadio) {
            const selectedLabel = optionsContainer.querySelector(`label[for="${selectedRadio.id}"]`);
            selectedLabel.style.borderColor = 'var(--accent-color)';
            selectedLabel.style.color = 'var(--accent-color)';
            selectedLabel.style.backgroundColor = '#e7f3ff';

            const selectedVariation = product.variations[parseInt(selectedRadio.value)];
            document.getElementById('variation-selected-price').textContent = `¥${selectedVariation.price.toFixed(2)}`;
            if (selectedVariation.imageUrl) {
                document.getElementById('variation-product-image').src = selectedVariation.imageUrl;
            } else {
                document.getElementById('variation-product-image').src = product.imageUrl;
            }
        }
    };
    
    optionsContainer.addEventListener('change', updateSelectionUI);
    updateSelectionUI(); // Initial call
    
    document.getElementById('variation-quantity-display').textContent = '1';
    
    // 綁定確認按鈕事件
    const confirmBtn = document.getElementById('confirm-variation-selection-btn');
    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
    newConfirmBtn.addEventListener('click', async () => {
        const selectedRadio = optionsContainer.querySelector('input[name="variation-select"]:checked');
        const quantity = parseInt(document.getElementById('variation-quantity-display').textContent);
        if (selectedRadio) {
            const selectedVariation = product.variations[parseInt(selectedRadio.value)];
            await addToCart(productId, quantity, selectedVariation);
            modal.classList.remove('visible');
            await showCustomAlert('成功', '已成功加入購物車！');
        }
    });

    modal.classList.add('visible');
}

// ▲▲▲ 全新JS代碼黏貼結束 ▲▲▲
// ▼▼▼ 【全新】這是購物中心AI生成功能的【全部核心JS代碼】，請完整黏貼 ▼▼▼

/**
 * 【總入口】打開購物中心生成設置彈窗
 */
function openShoppingSettingsModal() {
    const modal = document.getElementById('shopping-settings-modal');
    
    // 從全域設置中讀取已保存的值，如果沒有就使用預設值
    document.getElementById('shopping-category-count-input').value = state.globalSettings.shoppingCategoryCount || 3;
    document.getElementById('shopping-product-count-input').value = state.globalSettings.shoppingProductCount || 8;
    
    modal.classList.add('visible');
}

/**
 * 保存購物中心生成設置
 */
async function saveShoppingSettings() {
    const categoryInput = document.getElementById('shopping-category-count-input');
    const productInput = document.getElementById('shopping-product-count-input');
    
    const categoryCount = parseInt(categoryInput.value);
    const productCount = parseInt(productInput.value);

    // 資料驗證
    if (isNaN(categoryCount) || isNaN(productCount) || categoryCount < 1 || productCount < 1) {
        alert("請輸入有效的正整數！");
        return;
    }

    // 保存到全域狀態和資料庫
    state.globalSettings.shoppingCategoryCount = categoryCount;
    state.globalSettings.shoppingProductCount = productCount;
    await db.globalSettings.put(state.globalSettings);

    // 關閉彈窗並提示用戶
    document.getElementById('shopping-settings-modal').classList.remove('visible');
    await showCustomAlert('保存成功', '購物中心生成設置已更新！');
}

// ▼▼▼ 【請用這個全新的、支持角色上下文感知的 V3.0 版本】完整替換舊的 handleGenerateShoppingItems 函數 ▼▼▼
/**
 * 【核心 | V3.0 上下文感知版】處理AI生成購物中心商品的請求
 */
async function handleGenerateShoppingItems() {
    // 1. 【核心新增】檢查當前是否有活躍的聊天物件
    if (!state.activeChatId) {
        await showCustomAlert("操作失敗", "請先進入一個聊天頁面，再返回購物中心進行生成，以便AI瞭解要為哪個角色生成商品。");
        return;
    }
    const chat = state.chats[state.activeChatId];

    const confirmed = await showCustomConfirm(
        `為“${chat.name}”生成商品？`,
        '此操作將使用AI生成新的商品和分類，並【添加】到現有列表中。確定要繼續嗎？',
        { confirmText: '確認生成' }
    );

    if (!confirmed) return;

    await showCustomAlert("請稍候...", `正在根據“${chat.name}”的特點生成專屬商品...`);

    // (API選擇邏輯保持不變)
    const useSecondaryApi = state.apiConfig.secondaryProxyUrl && state.apiConfig.secondaryApiKey && state.apiConfig.secondaryModel;
    const { proxyUrl, apiKey, model } = useSecondaryApi 
        ? { proxyUrl: state.apiConfig.secondaryProxyUrl, apiKey: state.apiConfig.secondaryApiKey, model: state.apiConfig.secondaryModel } 
        : state.apiConfig;

    if (!proxyUrl || !apiKey || !model) {
        await showCustomAlert("API未配置", "請先在API設置中配置好（主或副）API。");
        return;
    }

    const categoryCount = state.globalSettings.shoppingCategoryCount || 3;
    const productCount = state.globalSettings.shoppingProductCount || 8;
    
    // 2. 【核心新增】構建完整的角色上下文，注入到Prompt中
    const userNickname = state.qzoneSettings.nickname || '我';
    const longTermMemoryContext = chat.longTermMemory?.map(mem => `- ${mem.content}`).join('\n') || '無';
    const recentHistoryContext = chat.history.slice(-10).map(msg => 
        `${msg.role === 'user' ? userNickname : chat.name}: ${String(msg.content).substring(0, 30)}...`
    ).join('\n');

    let worldBookContext = '';
    if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
        const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
            const worldBook = state.worldBooks.find(wb => wb.id === bookId);
            if (!worldBook || !Array.isArray(worldBook.content)) return '';
            const enabledEntries = worldBook.content
                .filter(entry => entry.enabled !== false)
                .map(entry => `- ${entry.content}`)
                .join('\n');
            return enabledEntries ? `\n## 來自《${worldBook.name}》:\n${enabledEntries}` : '';
        }).filter(Boolean).join('');

        if (linkedContents) {
            worldBookContext = `\n# 世界觀設定 (必須參考)\n${linkedContents}\n`;
        }
    }

    const systemPrompt = `
# 你的任務
你是一個虛擬的、極具創造力的商品規劃師。你的任務是為下面的角色“${chat.name}”量身打造一個專屬的商品列表。

# 核心規則
1.  **【角色定制(最高優先順序)】**: 你生成的所有商品和分類【必須】深度綁定角色的性格、記憶和最近的對話。它們應該是角色會真正感興趣、購買或製作的東西。
2.  **創造性與合理性**: 商品和分類必須合理且多樣化。
3.  **格式鐵律 (最高優先順序)**: 
    - 你的回復【必須且只能】是一個【單一的JSON物件】。
    - 你的回復必須以 \`{\` 開始，並以 \`}\` 結束。
    - 【絕對禁止】在JSON物件前後添加任何多餘的文字、解釋或 markdown 標記。
    - 格式【必須】如下:
    \`\`\`json
    {
      "categories": [
        {
          "name": "分類名稱1",
          "products": [
            {
              "name": "商品名稱1",
              "price": 99.80,
              "description": "這是商品的詳細描述，不少於50字...",
              "variations": [
                { "name": "款式1", "price": 108.80, "image_prompt": "款式1的圖片【英文】關鍵字..." },
                { "name": "款式2", "price": 118.80, "image_prompt": "款式2的圖片【英文】關鍵字..." }
              ],
              "image_prompt": "商品主圖的【英文】關鍵字, 風格為 realistic product photo, high quality, on a clean white background"
            }
          ]
        }
      ]
    }
    \`\`\`
    - **categories**: 生成 ${categoryCount} 個分類。
    - **products**: 每個分類下生成 ${productCount} 個商品。
    - **variations**: 每個商品【必須】包含【2到4個】不同的款式。

# 角色與上下文 (你的靈感來源)
- **角色名稱**: ${chat.name}
- **角色人設**: ${chat.settings.aiPersona}
- **長期記憶**: ${longTermMemoryContext}
- **世界書設定**: ${worldBookContext}
- **最近對話摘要**:
${recentHistoryContext}

現在，請根據以上【所有上下文資訊】，開始為“${chat.name}”生成這組【與角色高度相關】的商品資料。`;

    try {
        const messagesForApi = [{ role: 'user', content: "請根據以上設定，生成商品資料。" }];
        let isGemini = proxyUrl.includes('generativelanguage');
        // 3. 【核心新增】調用 toGeminiRequestData 來自動綁定溫度值
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
        
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, ...messagesForApi],
                    // 4. 【核心新增】為OpenAI相容API也綁定溫度值
                    temperature: state.globalSettings.apiTemperature || 0.9
                })
            });

        if (!response.ok) throw new Error(`API 錯誤: ${response.statusText}`);
        
        const data = await response.json();
        const aiResponseContent = getGeminiResponseText(data);
        
        const jsonMatch = aiResponseContent.match(/({[\s\S]*})/);
        if (!jsonMatch) throw new Error("AI返回的內容中未找到有效的JSON物件。");
        const generatedData = JSON.parse(jsonMatch[0]);

        if (!generatedData.categories || !Array.isArray(generatedData.categories)) {
            throw new Error("AI返回的JSON格式不正確，缺少 'categories' 陣列。");
        }

        // (增量添加邏輯保持不變)
        await db.transaction('rw', db.shoppingProducts, db.shoppingCategories, async () => {
            for (const category of generatedData.categories) {
                let categoryId;
                const existingCategory = await db.shoppingCategories.where('name').equalsIgnoreCase(category.name).first();
                if (existingCategory) {
                    categoryId = existingCategory.id;
                } else {
                    categoryId = await db.shoppingCategories.add({ name: category.name });
                }
                const productsToAdd = category.products.map(product => {
                    return {
                        name: product.name,
                        price: product.price || 0,
                        description: product.description || '',
                        imageUrl: `https://image.pollinations.ai/prompt/${encodeURIComponent(product.image_prompt)}`,
                        variations: (product.variations || []).map(v => ({
                            ...v,
                            imageUrl: `https://image.pollinations.ai/prompt/${encodeURIComponent(v.image_prompt)}`
                        })),
                        categoryId: categoryId
                    };
                });
                if (productsToAdd.length > 0) {
                    await db.shoppingProducts.bulkAdd(productsToAdd);
                }
            }
        });

        activeShoppingCategoryId = 'all';
        await renderShoppingProducts();
        await showCustomAlert('生成成功！', `為“${chat.name}”量身定制的商品已上架！`);

    } catch (error) {
        console.error("生成購物中心商品失敗:", error);
        await showCustomAlert("生成失敗", `無法生成商品，請檢查(主/副)API配置或稍後再試。\n錯誤: ${error.message}`);
    }
}
// ▲▲▲ 替換結束 ▲▲▲
/* ▼▼▼ 【全新】這是為小元件更換圖片功能添加的【全部核心JS代碼】 ▼▼▼ */

/**
 * 【總入口】處理使用者點擊小元件更換圖片的邏輯
 * @param {string} imageId - 被點擊的圖片元素的ID
 */
async function handleWidgetImageChange(imageId) {
    const element = document.getElementById(imageId);
    if (!element) return;

    // 1. 彈出選項，讓使用者選擇上傳方式
    const choice = await showChoiceModal("更換圖片", [
        { text: '📁 從本地上傳', value: 'local' },
        { text: '🌐 使用網路URL', value: 'url' }
    ]);

    let newUrl = null;

    // 2. 根據使用者的選擇執行不同操作
    if (choice === 'local') {
        // 調用我們現有的本地上傳輔助函數
        newUrl = await uploadImageLocally();
    } else if (choice === 'url') {
        // 彈出輸入框讓用戶輸入URL
        newUrl = await showCustomPrompt("更換圖片", "請輸入新的圖片URL：", element.src, "url");
    }

    // 3. 如果成功獲取到了新的圖片（無論是Base64還是URL），就更新並保存
    if (newUrl && newUrl.trim()) {
        const trimmedUrl = newUrl.trim();
        
        // a. 即時更新介面上的圖片
        element.src = trimmedUrl;
        
        // b. 將新圖片URL保存到全域設置中
        if (!state.globalSettings.widgetData) {
            state.globalSettings.widgetData = {};
        }
        state.globalSettings.widgetData[imageId] = trimmedUrl;
        
        // c. 將更新後的設置存入資料庫
        await db.globalSettings.put(state.globalSettings);
        
        // d. 給出成功提示
        await showCustomAlert("成功", "元件圖片已更新！");
    }
}

// 最後，將這個新函數暴露到全域，這樣HTML中的onclick才能找到它
window.handleWidgetImageChange = handleWidgetImageChange;

/* ▲▲▲ 新增JS代碼結束 ▲▲▲ */
/**
 * 使用資料流，將所有資料匯出到一個大檔中
 */
async function exportDataAsStream() {
    // 檢查庫是否已載入
    if (!window.streamSaver) {
        alert("流式下載庫 (StreamSaver.js) 未載入。請檢查網路連接或HTML檔配置。");
        return;
    }
    
    await showCustomAlert("正在準備...", "即將開始下載您的完整備份檔案。下載過程中請勿關閉頁面。");
    
    // 創建一個寫入流，並命名檔
    const fileStream = streamSaver.createWriteStream(`EPhone-Full-Backup-Streamed-${new Date().toISOString().split('T')[0]}.json`);
    const writer = fileStream.getWriter();
    const encoder = new TextEncoder(); // 用於將字串轉換為二進位資料

    try {
        // 手動寫入JSON檔的開頭結構
        await writer.write(encoder.encode('{\n"version": 3,\n"timestamp": ' + Date.now() + ',\n"data": {\n'));

        const tablesToBackup = await db.tables.map(t => t.name);
        
        for (let i = 0; i < tablesToBackup.length; i++) {
            const tableName = tablesToBackup[i];
            const table = db.table(tableName);

            // 寫入表名作為key
            await writer.write(encoder.encode(`"${tableName}": [\n`));
            
            let isFirstRecordInTable = true;
            // 使用Dexie的each方法，逐條讀取記錄，記憶體佔用極低
            await table.each(record => {
                if (!isFirstRecordInTable) {
                    writer.write(encoder.encode(',\n'));
                }
                // 將單條記錄轉換為JSON字串並寫入流
                writer.write(encoder.encode(JSON.stringify(record)));
                isFirstRecordInTable = false;
            });

            // 寫入表的結尾
            await writer.write(encoder.encode('\n]'));
            if (i < tablesToBackup.length - 1) {
                // 如果不是最後一張表，就加一個逗號
                await writer.write(encoder.encode(',\n'));
            }
        }

        // 手動寫入JSON檔的結尾結構
        await writer.write(encoder.encode('\n}\n}'));
        
    } catch (error) {
        console.error("流式匯出過程中出錯:", error);
        await showCustomAlert('匯出失敗', `在寫入檔流時發生錯誤: ${error.message}`);
    } finally {
        // 無論成功與否，都必須關閉寫入流
        await writer.close();
    }
}
/**
 * 【全新】使用傳統Blob方式，將所有資料匯出到一個檔中（作為備用方案）
 */
async function exportDataAsBlob() {
    await showCustomAlert("正在準備...", "正在讀取所有資料到記憶體中，請稍候...");

    try {
        const backupData = {
            version: 3, // 標記為新版結構
            timestamp: Date.now(),
            data: {} // 所有資料都將存放在這個 'data' 物件中
        };

        const tablesToBackup = db.tables.map(t => t.name);

        for (const tableName of tablesToBackup) {
            const tableData = await db.table(tableName).toArray();
            backupData.data[tableName] = tableData;
            console.log(`已打包表: ${tableName}, 記錄數: ${tableData.length}`);
        }
        
        const blob = new Blob(
            [JSON.stringify(backupData, null, 2)], 
            { type: 'application/json' }
        );
        
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `EPhone-Full-Backup-Legacy-${new Date().toISOString().split('T')[0]}.json`;
        link.click();
        URL.revokeObjectURL(url);
        
        await showCustomAlert('匯出成功', '已成功匯出所有資料！');

    } catch (error) {
        console.error("傳統匯出資料時出錯:", error);
        await showCustomAlert('匯出失敗', `發生了一個錯誤: ${error.message}`);
    }
}




              // ===================================================================
                // 4. 初始化函數 init()
                // ===================================================================
                async function init() {
        /**
         * 智慧導入處理器：自動識別檔案類型並調用相應的導入函數
         * @param {File} file - 用戶選擇的 .json 文件
         */
        async function handleWorldBookImport(file) {
            if (!file) return;
        
            try {
                const text = await file.text();
                const data = JSON.parse(text);
        
                // 檢查是否是 EPhone 的備份檔案
                if (data.type === 'EPhoneWorldBookBackup') {
                    console.log("檢測到 EPhone 備份檔案，執行標準導入...");
                    await importWorldBooks(data); // 注意：我們將修改 importWorldBooks 來接收解析後的資料
                } 
                // 檢查是否是 Tavern AI 的世界書檔
                else if (data.entries && typeof data.entries === 'object') {
                    console.log("檢測到 Tavern AI 世界書檔，執行相容導入...");
                    await importTavernWorldBook(data, file.name);
                } 
                // 如果兩種格式都不是
                else {
                    throw new Error("檔案格式無法識別。請確保您選擇的是有效的 EPhone 世界書備份或 Tavern AI 世界書檔。");
                }
        
            } catch (error) {
                console.error("導入世界書時出錯:", error);
                await showCustomAlert('導入失敗', `文件解析或應用失敗: ${error.message}`);
            }
        }
        
        /**
         * 【相容核心】從 Tavern AI 格式的資料創建一本新的世界書
         * @param {object} tavernData - 從 Tavern AI .json 檔解析出的資料
         * @param {string} fileName - 原始檔案名，用於生成默認書名
         */
        async function importTavernWorldBook(tavernData, fileName) {
            const bookNameSuggestion = fileName.replace(/\.json$/i, ''); // 從檔案名中提取建議名稱
        
            const newBookName = await showCustomPrompt(
                "導入 Tavern AI 世界書", 
                "請為這本設定集命名：",
                bookNameSuggestion
            );
        
            if (!newBookName || !newBookName.trim()) {
                alert("導入已取消，因為未提供書名。");
                return;
            }
        
            const newEntries = Object.values(tavernData.entries).map(entry => {
                // 將 Tavern 的資料結構轉換為 EPhone 的格式
                return {
                    keys: entry.key || [],
                    comment: entry.comment || '無備註',
                    content: entry.content || '',
                    enabled: !entry.disable // 注意：Tavern 的 disable 和 EPhone 的 enabled 邏輯是相反的
                };
            }).filter(entry => entry.content); // 過濾掉沒有內容的條目
        
            if (newEntries.length === 0) {
                alert("這個 Tavern AI 世界書中沒有找到任何有效的條目。");
                return;
            }
        
            const newWorldBook = {
                id: 'wb_' + Date.now(),
                name: newBookName.trim(),
                content: newEntries,
                categoryId: null // 默認不分類
            };
        
            await db.worldBooks.add(newWorldBook);
            state.worldBooks.push(newWorldBook); // 更新記憶體
            await renderWorldBookScreen(); // 刷新UI
        
            await showCustomAlert('導入成功！', `已成功從 Tavern AI 檔導入設定集《${newBookName}》。`);
        }


        async function exportWorldBooks() {
            try {
                const books = await db.worldBooks.toArray();
                const categories = await db.worldBookCategories.toArray();
        
                if (books.length === 0 && categories.length === 0) {
                    alert("沒有可匯出的世界書資料。");
                    return;
                }
        
                const backupData = {
                    type: 'EPhoneWorldBookBackup', // 特殊標記，用於導入時驗證
                    version: 1,
                    timestamp: Date.now(),
                    books: books,
                    categories: categories
                };
        
                const blob = new Blob(
                    [JSON.stringify(backupData, null, 2)], 
                    { type: 'application/json' }
                );
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `EPhone-WorldBooks-${new Date().toISOString().split('T')[0]}.json`;
                link.click();
                URL.revokeObjectURL(url);
                
                await showCustomAlert('匯出成功', '所有世界書資料已成功匯出！');
        
            } catch (error) {
                console.error("匯出世界書時出錯:", error);
                await showCustomAlert('匯出失敗', `發生了一個錯誤: ${error.message}`);
            }
        }
        
/**
         * 【已更新】導入 EPhone 世界書備份資料，並覆蓋現有資料
         * @param {object} data - 從備份檔案解析出的JSON數據
         */
        async function importWorldBooks(data) {
            // 這個函數現在直接接收解析好的資料，不再需要讀取檔
            try {
                if (data.type !== 'EPhoneWorldBookBackup' || !data.books) {
                    throw new Error("檔案格式不正確，這不是一個有效的世界書備份檔案。");
                }
        
                const confirmed = await showCustomConfirm(
                    '導入世界書',
                    '這將用檔中的資料【完全覆蓋】您當前所有的世界書和分類。此操作不可撤銷！',
                    { confirmButtonClass: 'btn-danger', confirmText: '確認覆蓋' }
                );
        
                if (!confirmed) return;
        
                await db.transaction('rw', db.worldBooks, db.worldBookCategories, async () => {
                    await db.worldBooks.clear();
                    await db.worldBookCategories.clear();
                    
                    if (Array.isArray(data.books)) {
                        await db.worldBooks.bulkPut(data.books);
                    }
                    if (Array.isArray(data.categories)) {
                        await db.worldBookCategories.bulkPut(data.categories);
                    }
                });
        
                // 更新記憶體中的 state 並重新渲染
                state.worldBooks = await db.worldBooks.toArray();
                await renderWorldBookScreen();
        
                await showCustomAlert('導入成功', '世界書資料已成功恢復！');
        
            } catch (error) {
                console.error("導入世界書時出錯:", error);
                await showCustomAlert('導入失敗', `文件解析或應用失敗: ${error.message}`);
            }
        }


    // 【核心修改1】在 `init` 函數的最開始，檢查並執行後臺活動模擬
    const lastActiveTimestamp = localStorage.getItem('ephoneLastActiveTimestamp');
    if (lastActiveTimestamp) {
        const minutesOffline = (Date.now() - parseInt(lastActiveTimestamp)) / (1000 * 60);
        // 如果離線超過5分鐘，才開始模擬
        if (minutesOffline > 5) {
            // 注意：我們在這裡調用類比函數，但不使用 await
            // 這樣它就會在後臺默默執行，不會卡住應用的啟動過程
            simulateBackgroundActivity(minutesOffline);
        }
    }
    // ▲▲▲ 新代碼黏貼結束 ▲▲▲
setupCharPlayerControls();
    // ▼▼▼ 【核心修復】將內建函式暴露到全域，以便HTML中的 onclick 可以調用它們 ▼▼▼
    window.showScreen = showScreen;
    window.openRenderingRulesScreen = openRenderingRulesScreen;
    window.handleListenTogetherClick = handleListenTogetherClick; // 為“一起聽”按鈕暴露函數
// ▼▼▼ 在這裡黏貼下面的新代碼 ▼▼▼
window.openCharacterSelector = openCharacterSelector;
window.openCharApp = openCharApp;
window.switchToMyPhone = switchToMyPhone;
window.switchToCharHomeScreen = switchToCharHomeScreen;
window.openNpcEditor = openNpcEditor; // <-- 新增這一行
// ▲▲▲ 黏貼結束 ▲▲▲
    // ▲▲▲ 修復結束 ▲▲▲
        // 在 init() 函數開頭添加
        const stickerActionBar = document.createElement('div');
        stickerActionBar.id = 'sticker-action-bar';
        stickerActionBar.innerHTML = '<button id="delete-selected-stickers-btn">刪除 (0)</button>';
        document.getElementById('sticker-panel').appendChild(stickerActionBar);
                    // ▼▼▼ 在這裡黏貼新代碼 ▼▼▼
                    const globalCssStyleTag = document.createElement('style');
                    globalCssStyleTag.id = 'global-custom-style';
                    document.head.appendChild(globalCssStyleTag);
                    // ▲▲▲ 新代碼黏貼結束 ▲▲▲
        // 在 init() 函數的開頭
        qzoneStickerPanelState.panelEl = document.getElementById('qzone-sticker-panel');
        qzoneStickerPanelState.gridEl = document.getElementById('qzone-sticker-grid');
            // ▼▼▼ 在 init() 函數的【最開頭】，黏貼下面這兩行代碼 ▼▼▼
            const savedTheme = localStorage.getItem('ephone-theme') || 'light'; // 預設為日間模式
            applyTheme(savedTheme);
            // ▲▲▲ 黏貼結束 ▲▲▲
        
            // ▼▼▼ 新增代碼 ▼▼▼
            const customBubbleStyleTag = document.createElement('style');
            customBubbleStyleTag.id = 'custom-bubble-style';
            document.head.appendChild(customBubbleStyleTag);
            // ▲▲▲ 新增結束 ▲▲▲
        
            // ▼▼▼ 新增代碼 ▼▼▼
            const previewBubbleStyleTag = document.createElement('style');
            previewBubbleStyleTag.id = 'preview-bubble-style';
            document.head.appendChild(previewBubbleStyleTag);
            // ▲▲▲ 新增結束 ▲▲▲
        
        
            // ▼▼▼ 修改這兩行 ▼▼▼
            applyScopedCss('', '#chat-messages', 'custom-bubble-style'); // 清除真實聊天介面的自訂樣式
            applyScopedCss('', '#settings-preview-area', 'preview-bubble-style'); // 清除預覽區的自訂樣式
            // ▲▲▲ 修改結束 ▲▲▲
                   window.openRenderingRulesScreen = openRenderingRulesScreen;
                    window.showScreen = showScreen;
                    window.renderChatListProxy = renderChatList;
                    window.renderApiSettingsProxy = renderApiSettings;
                    window.renderWallpaperScreenProxy = renderWallpaperScreen;
                    window.renderWorldBookScreenProxy = renderWorldBookScreen;
        
                    await loadAllDataFromDB();
                    applyStatusBarVisibility(); // <-- 新增這一行
                    // ▼▼▼ 【核心】在這裡添加下面這行新代碼 ▼▼▼
                    await migrateOldRedPacketData();
                    // ▲▲▲ 添加結束 ▲▲▲
                    // ▼▼▼ 在這裡黏貼新代碼 ▼▼▼
                    applyGlobalCss(state.globalSettings.globalCss);
                    // ▲▲▲ 新代碼黏貼結束 ▲▲▲
        
                    // 初始化未讀動態計數
                    const storedCount = parseInt(localStorage.getItem('unreadPostsCount')) || 0;
                    updateUnreadIndicator(storedCount);
                    
                    // ▲▲▲ 代碼添加結束 ▲▲▲
        
                    if (state.globalSettings && state.globalSettings.fontUrl) {
                        applyCustomFont(state.globalSettings.fontUrl);
                    }
        
                    updateClock();
                    setInterval(updateClock, 1000 * 30);
                    applyGlobalWallpaper();
                    initBatteryManager(); 
        
        applyAppIcons();
        applyWidgetData(); // <-- 添加這一行
        
                    // ==========================================================
                    // --- 各種事件監聽器 ---
                    // ==========================================================
        // ▼▼▼ 在 init() 的事件監聽器區域，添加這行新代碼 ▼▼▼
        document.getElementById('rules-tabs').addEventListener('click', (e) => {
            if (e.target.classList.contains('rules-tab')) {
                switchRuleCategory(e.target.dataset.categoryId);
            }
        });
        // ▲▲▲ 新增代碼結束 ▲▲▲
        // ▼▼▼ 在 init() 函數的事件監聽器區域，黏貼這段新代碼 ▼▼▼
        // 渲染規則功能事件綁定
        document.getElementById('add-new-rule-btn').addEventListener('click', () => openRuleEditor(null));
        document.getElementById('cancel-rule-editor-btn').addEventListener('click', () => {
            document.getElementById('rule-editor-modal').classList.remove('visible');
        });
        document.getElementById('save-rule-btn').addEventListener('click', saveRenderingRule);
        // ▲▲▲ 新代碼黏貼結束 ▲▲▲
        
        // ▼▼▼ 【全新】為單聊“拍一拍”按鈕綁定事件 ▼▼▼
        document.getElementById('pat-btn').addEventListener('click', () => {
            // 確保當前在單聊中
            if (state.activeChatId && !state.chats[state.activeChatId].isGroup) {
                const chat = state.chats[state.activeChatId];
                // 調用現有的拍一拍函數，並傳入正確的參數
                handleUserPat(chat.id, chat.originalName);
            }
        });
        // ▲▲▲ 新增代碼結束 ▲▲▲
        // ▼▼▼ 【這是您缺失的核心功能代碼，請黏貼在這裡】 ▼▼▼
        let activeAnnouncementId = null; // 用於暫存正在操作的公告ID
        
        /**
         * 點擊“...”時，顯示操作功能表（置頂/刪除）
         * @param {string} annoId - 公告的唯一ID
         */
        function showAnnouncementActions(annoId) {
            activeAnnouncementId = annoId;
            const chat = state.chats[state.activeChatId];
            const announcement = chat.announcements.find(a => a.id === annoId);
            if (!announcement) return;
        
            const pinButton = document.getElementById('announcement-action-pin');
            // 根據當前是否已置頂，動態改變按鈕文字
            pinButton.textContent = announcement.isPinned ? '取消置頂' : '置頂公告';
        
            document.getElementById('announcement-actions-modal').classList.add('visible');
        }
        
        /**
         * 處理“置頂/取消置頂”操作
         */
        async function handlePinAnnouncement() {
            if (!activeAnnouncementId) return;
            const chat = state.chats[state.activeChatId];
            const announcement = chat.announcements.find(a => a.id === activeAnnouncementId);
            if (announcement) {
                announcement.isPinned = !announcement.isPinned; // 切換置頂狀態
                await db.chats.put(chat);
                showAnnouncementBoard(); // 重新渲染公告板以更新UI
            }
            document.getElementById('announcement-actions-modal').classList.remove('visible');
        }
        
        /**
         * 處理“刪除公告”操作
         */
        async function handleDeleteAnnouncement() {
            if (!activeAnnouncementId) return;
        
            const confirmed = await showCustomConfirm("確認刪除", "確定要刪除這條公告嗎？此操作不可恢復。", { confirmButtonClass: 'btn-danger' });
        
            if (confirmed) {
                const chat = state.chats[state.activeChatId];
                // 從公告陣列中過濾掉要刪除的公告
                chat.announcements = chat.announcements.filter(a => a.id !== activeAnnouncementId);
                await db.chats.put(chat);
                showAnnouncementBoard(); // 重新渲染
            }
            document.getElementById('announcement-actions-modal').classList.remove('visible');
        }
        // ▲▲▲ 黏貼結束 ▲▲▲
                    document.getElementById('custom-modal-cancel').addEventListener('click', hideCustomModal);
                    document.getElementById('custom-modal-overlay').addEventListener('click', (e) => { if (e.target === modalOverlay) hideCustomModal(); });
                    document.getElementById('export-data-btn').addEventListener('click', async () => {
    // 彈出選擇框，讓用戶決定使用哪種匯出方式
    const choice = await showChoiceModal('選擇匯出方式', [
        { text: '智慧匯出 (推薦，速度快，記憶體佔用小)', value: 'stream' },
        { text: '傳統匯出 (相容舊版或記憶體小的流覽器)', value: 'blob' }
    ]);

    // 根據使用者的選擇，調用不同的匯出函數
    if (choice === 'stream') {
        exportDataAsStream();
    } else if (choice === 'blob') {
        exportDataAsBlob();
    }
    // 如果用戶點擊取消，則 choice 為 null，不做任何事
});
// ▼▼▼ 在這裡黏貼下面的新代碼 ▼▼▼
document.getElementById('cleanup-data-btn').addEventListener('click', cleanupRedundantData);
// ▲▲▲ 黏貼結束 ▲▲▲
document.getElementById('offline-mode-toggle').addEventListener('change', (e) => {
    // 根據開關的選中狀態，立即顯示或隱藏下方的“線下模式選項”區域
    document.getElementById('offline-mode-options').style.display = e.target.checked ? 'block' : 'none';
});
                    document.getElementById('import-btn').addEventListener('click', () => document.getElementById('import-data-input').click());
    document.getElementById('time-perception-toggle').addEventListener('change', (e) => {
        document.getElementById('time-zone-group').style.display = e.target.checked ? 'block' : 'none';
    });
                    // 新代碼
document.getElementById('import-data-input').addEventListener('change', e => handleSmartImport(e.target.files[0]));
                    document.getElementById('import-card-input').addEventListener('change', handleCardImport);
                    document.getElementById('back-to-list-btn').addEventListener('click', () => { 
               ruleCache = {};
            // ▼▼▼ 修改這兩行 ▼▼▼
            applyScopedCss('', '#chat-messages', 'custom-bubble-style'); // 清除真實聊天介面的自訂樣式
            applyScopedCss('', '#settings-preview-area', 'preview-bubble-style'); // 清除預覽區的自訂樣式
            // ▲▲▲ 修改結束 ▲▲▲
        
        exitSelectionMode(); state.activeChatId = null; showScreen('chat-list-screen'); });
                    
        // ▼▼▼ 【請用這個新版本】替換舊的 add-chat-btn 事件監聽器 ▼▼▼
        document.getElementById('add-chat-btn').addEventListener('click', async () => {
            // 使用我們現有的 showChoiceModal 函數來提供選項
            const choice = await showChoiceModal('創建新聊天', [
                { text: '手動創建角色', value: 'manual' },
                { text: '從角色卡導入 (.json/.png)', value: 'import_card' }
            ]);
        
            if (choice === 'manual') {
                // 如果用戶選擇手動，則執行原來的邏輯
                const remarkName = await showCustomPrompt('創建新聊天 (第1/2步)', '請輸入你想為Ta設置的【備註名】(例如: 哥哥)');
                if (!remarkName || !remarkName.trim()) return;
        
                const originalName = await showCustomPrompt('創建新聊天 (第2/2步)', '請輸入Ta的【本名】(例如: 李星辰，這個名字將用於AI識別)');
                if (!originalName || !originalName.trim()) return;
        
// 這是全新的、確保角色能正確顯示的代碼
const newChatId = 'chat_' + Date.now();
const newChat = {
    id: newChatId,
    name: remarkName.trim(),
    originalName: originalName.trim(),
    isGroup: false,
    isPinned: false, // 【修復】補充置頂狀態
    unreadCount: 0,  // 【修復】補充未讀消息計數
    relationship: { status: 'friend', blockedTimestamp: null, applicationReason: '' },
    status: { text: '線上', lastUpdate: Date.now(), isBusy: false },
    settings: {
        aiPersona: '這是一個通過手動創建的角色。',
        myPersona: '我是誰呀。',
        myNickname: '我',
        maxMemory: 10,
        aiAvatar: defaultAvatar,
        myAvatar: defaultAvatar,
        background: '',
        theme: 'default',
        fontSize: 13,
        customCss: '',
        linkedWorldBookIds: [],
        aiAvatarLibrary: [],
        myAvatarLibrary: [],
        enableBackgroundActivity: true, // 【修復】補充後臺活動開關
        actionCooldownMinutes: 15,    // 【修復】補充後臺活動冷卻時間
        enableTimePerception: true,     // 【修復】補充時間感知開關
        isOfflineMode: false,           // 【修復】補充線下模式開關
        offlineMinLength: 100,
        offlineMaxLength: 300,
        offlinePresetId: null,
        timeZone: 'Asia/Shanghai'       // 【修復】補充默認時區
    },
    history: [],
    musicData: { totalTime: 0 },
    longTermMemory: [],
    thoughtsHistory: [] // 【修復】補充心聲/散記歷史記錄
};
                state.chats[newChatId] = newChat;
                await db.chats.put(newChat);
                renderChatList();
                
            } else if (choice === 'import_card') {
                // 如果用戶選擇導入，就觸發我們新添加的隱藏檔輸入框
                document.getElementById('import-card-input').click();
            }
        });
        // ▲▲▲ 替換結束 ▲▲▲
        
                    // ▼▼▼ 【修正】創建群聊按鈕現在打開連絡人選擇器 ▼▼▼
        document.getElementById('add-group-chat-btn').addEventListener('click', openContactPickerForGroupCreate);
        // ▲▲▲ 替換結束 ▲▲▲                      
                    document.getElementById('transfer-cancel-btn').addEventListener('click', () => document.getElementById('transfer-modal').classList.remove('visible'));
                    document.getElementById('transfer-confirm-btn').addEventListener('click', sendUserTransfer);
        
                    document.getElementById('listen-together-btn').addEventListener('click', handleListenTogetherClick);
                    document.getElementById('music-exit-btn').addEventListener('click', () => endListenTogetherSession(true));
                    document.getElementById('music-return-btn').addEventListener('click', returnToChat);
                    document.getElementById('music-play-pause-btn').addEventListener('click', togglePlayPause);
                    document.getElementById('music-next-btn').addEventListener('click', playNext);
                    document.getElementById('music-prev-btn').addEventListener('click', playPrev);
                    document.getElementById('music-mode-btn').addEventListener('click', changePlayMode);
                    document.getElementById('music-playlist-btn').addEventListener('click', () => { updatePlaylistUI(); document.getElementById('music-playlist-panel').classList.add('visible'); });
                    document.getElementById('close-playlist-btn').addEventListener('click', () => document.getElementById('music-playlist-panel').classList.remove('visible'));
                    document.getElementById('add-song-url-btn').addEventListener('click', addSongFromURL);
                    document.getElementById('add-song-local-btn').addEventListener('click', () => document.getElementById('local-song-upload-input').click());
                    document.getElementById('local-song-upload-input').addEventListener('change', addSongFromLocal);
// ▼▼▼ 【全新】這是修復按鈕點擊無回應的核心代碼 ▼▼▼
document.getElementById('playlist-body').addEventListener('click', (e) => {
    const target = e.target;
    const trackIndex = parseInt(target.dataset.index);

    if (isNaN(trackIndex)) return;

    if (target.classList.contains('album-art-btn')) {
        handleChangeAlbumArt(trackIndex);
    } else if (target.classList.contains('lyrics-btn')) {
        handleManualLrcImport(trackIndex);
    } else if (target.classList.contains('bg-btn')) {
        handleChangeBackground(trackIndex);
    } else if (target.classList.contains('delete-track-btn')) {
        deleteTrack(trackIndex);
    }
});
// ▲▲▲ 新增代碼黏貼結束 ▲▲▲
                    audioPlayer.addEventListener('ended', () => {
    // 歌曲播放結束時，移除旋轉樣式
    document.getElementById('vinyl-view').classList.remove('spinning');
    playNext(); 
});
                    audioPlayer.addEventListener('ended', () => {
    // 歌曲播放結束時，移除旋轉樣式
    document.getElementById('vinyl-view').classList.remove('spinning');
    playNext(); 
});

audioPlayer.addEventListener('pause', () => { 
    if(musicState.isActive) { 
        musicState.isPlaying = false; 
        updatePlayerUI(); 
        // 音樂暫停時，移除旋轉樣式
        document.getElementById('vinyl-view').classList.remove('spinning');
    } 
});

audioPlayer.addEventListener('play', () => { 
    if(musicState.isActive) { 
        musicState.isPlaying = true; 
        updatePlayerUI(); 
        // 音樂開始播放時，添加旋轉樣式
        document.getElementById('vinyl-view').classList.add('spinning');
    } 
});
        
                    const chatInput = document.getElementById('chat-input');
                    // ▼▼▼ 找到 id="send-btn" 的 click 事件監聽器 ▼▼▼
// 【最終性能優化版】
document.getElementById('send-btn').addEventListener('click', () => { // 注意：移除了 async
    const content = chatInput.value.trim();
    if (!content || !state.activeChatId) return;

    const chat = state.chats[state.activeChatId];
    const msg = {
        role: 'user',
        content,
        timestamp: Date.now()
    };

    if (currentReplyContext) {
        msg.quote = currentReplyContext;
    }

    // 【優化1：先渲染，後保存】立即將消息顯示在螢幕上，給使用者即時回饋！
    appendMessage(msg, chat);

    // 【優化2：非同步處理耗時操作】將資料存儲和清單更新放到後臺，不阻塞使用者介面
    (async () => {
        chat.history.push(msg);
        await db.chats.put(chat); // 保存到資料庫
    renderChatList(); // <<<<< 修改為這一行

    })();

    // 清理工作（這部分很快，可以立即執行）
    chatInput.value = '';
    chatInput.style.height = 'auto';
    chatInput.focus();
    cancelReplyMode();
});
                    document.getElementById('wait-reply-btn').addEventListener('click', triggerAiResponse);
                    chatInput.addEventListener('keypress', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); document.getElementById('send-btn').click(); } });
                    //chatInput.addEventListener('input', () => { chatInput.style.height = 'auto'; chatInput.style.height = (chatInput.scrollHeight) + 'px'; });
        
                    document.getElementById('wallpaper-upload-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if(file) { const dataUrl = await new Promise((res, rej) => { const reader = new FileReader(); reader.onload = () => res(reader.result); reader.onerror = () => rej(reader.error); reader.readAsDataURL(file); }); newWallpaperBase64 = dataUrl; renderWallpaperScreen(); } });
        // ▼▼▼ 【請用這個已包含CPhone設置的最終版本】替換舊的 'save-wallpaper-btn' 事件監聽器 ▼▼▼
        document.getElementById('save-wallpaper-btn').addEventListener('click', async () => {
            // 保存 EPhone 壁紙
            if (newWallpaperBase64) {
                state.globalSettings.wallpaper = newWallpaperBase64;
            }
            
            // 【核心新增】將 state 中臨時的 CPhone 壁紙設置也一併保存
            // (注意：cphoneWallpaper已經在上傳時更新到state了, 這裡只需確保它被存入資料庫)

            state.globalSettings.globalCss = document.getElementById('global-css-input').value.trim();
            state.globalSettings.notificationSoundUrl = document.getElementById('notification-sound-url-input').value.trim();
            state.globalSettings.showStatusBar = document.getElementById('status-bar-toggle-switch').checked;
            
            // 一次性保存所有全域設置 (包括了EPhone和CPhone的所有新舊設置)
            await db.globalSettings.put(state.globalSettings);
            
            // 應用所有更改
            applyGlobalWallpaper();
            applyCPhoneWallpaper(); // <-- 新增調用
            newWallpaperBase64 = null; // 清空臨時壁紙變數

            applyAppIcons();
            applyCPhoneAppIcons(); // <-- 新增調用
            
            applyGlobalCss(state.globalSettings.globalCss);
            applyStatusBarVisibility();

            alert('外觀設置已保存並應用！');
            showScreen('home-screen');
        });
        // ▲▲▲ 替換結束 ▲▲▲
// ▼▼▼ 【核心修復】請用這段新代碼，替換舊的滾動事件監聽器 ▼▼▼
const messagesView = document.getElementById('messages-view'); // <--- 核心修改1：獲取正確的滾動容器
messagesView.addEventListener('scroll', () => { // <--- 核心修改2：在 messages-view 上監聽
    // 解構賦值獲取滾動相關的屬性
    const { scrollTop, scrollHeight, clientHeight } = messagesView;

    // 判斷條件：當捲軸距離底部的距離小於一個螢幕的高度時
    // 這個條件保持不變，是可靠的
    if (scrollHeight - scrollTop - clientHeight < clientHeight) {
        // 並且當前不處於載入狀態
        if (!isLoadingMoreChats) {
            // 就觸發載入下一頁
            loadMoreChats();
        }
    }
});
// ▲▲▲ 替換結束 ▲▲▲
        // ▼▼▼ 【請用這個新版本】替換舊的 save-api-settings-btn 事件監聽器 ▼▼▼
        document.getElementById('save-api-settings-btn').addEventListener('click', async () => {
            // 保存主API
            state.apiConfig.proxyUrl = document.getElementById('proxy-url').value.trim();
            state.apiConfig.apiKey = document.getElementById('api-key').value.trim();
            state.apiConfig.model = document.getElementById('model-select').value;
state.apiConfig.minimaxGroupId = document.getElementById('minimax-group-id').value.trim();
state.apiConfig.minimaxApiKey = document.getElementById('minimax-api-key').value.trim();  
state.apiConfig.minimaxModel = document.getElementById('minimax-model-select').value; // <-- 新增這一行          
            // 【核心新增】保存副API
            state.apiConfig.secondaryProxyUrl = document.getElementById('secondary-proxy-url').value.trim();
            state.apiConfig.secondaryApiKey = document.getElementById('secondary-api-key').value.trim();
            state.apiConfig.secondaryModel = document.getElementById('secondary-model-select').value;
            
            await db.apiConfig.put(state.apiConfig);
        
            // 後臺活動設置的保存邏輯保持不變
            const backgroundSwitch = document.getElementById('background-activity-switch');
            const intervalInput = document.getElementById('background-interval-input');
            const cooldownInput = document.getElementById('block-cooldown-input');
        
            state.globalSettings.enableBackgroundActivity = backgroundSwitch.checked;
            state.globalSettings.backgroundActivityInterval = parseInt(intervalInput.value) || 60;
            state.globalSettings.blockCooldownHours = parseFloat(cooldownInput.value) || 1;
            state.globalSettings.enableAiDrawing = document.getElementById('enable-ai-drawing-switch').checked;
           state.globalSettings.chatRenderWindow = parseInt(document.getElementById('chat-render-window-input').value) || 50;
            state.globalSettings.chatListRenderWindow = parseInt(document.getElementById('chat-list-render-window-input').value) || 30;
            state.globalSettings.apiTemperature = parseFloat(document.getElementById('api-temperature-slider').value);
            await db.globalSettings.put(state.globalSettings);
        
            stopBackgroundSimulation(); 
            if (state.globalSettings.enableBackgroundActivity) {
                startBackgroundSimulation();
                console.log(`後臺活動模擬已啟動，間隔: ${state.globalSettings.backgroundActivityInterval}秒`);
            } else {
                console.log("後臺活動模擬已停止。");
            }
            
            alert('所有API與後臺設置已保存!'); 
        });
        // ▲▲▲ 替換結束 ▲▲▲
        
                            // gemini 金鑰聚焦的時候顯示明文
                const ApiKeyInput = document.getElementById('api-key')
                ApiKeyInput.addEventListener('focus', (e) => {
                    e.target.setAttribute('type', 'text')
                })
                ApiKeyInput.addEventListener('blur', (e) => {
                    e.target.setAttribute('type', 'password')
                })
        
        
        // ▼▼▼ 【請用這整塊代碼】替換舊的 fetch-models-btn 事件監聽器 ▼▼▼
        
        // 封裝一個可複用的模型拉取函數
        async function fetchModels(urlInputId, keyInputId, selectId) {
            const url = document.getElementById(urlInputId).value.trim();
            const key = document.getElementById(keyInputId).value.trim();
            if (!url || !key) return alert('請先填寫對應的反代位址和金鑰');
            
            try {
                let isGemini = url === GEMINI_API_URL;
                const response = await fetch(isGemini ? `${GEMINI_API_URL}?key=${getRandomValue(key)}` : `${url}/v1/models`, isGemini ? undefined : { headers: { 'Authorization': `Bearer ${key}` } });
                if (!response.ok) throw new Error('無法獲取模型清單');
                const data = await response.json();
                let models = isGemini ? data.models.map(model => ({ id: model.name.split('/')[1] || model.name })) : data.data;
                
                const modelSelect = document.getElementById(selectId);
                modelSelect.innerHTML = '';
                // 【核心】根據是主/副模型，讀取正確的已保存模型
                const savedModel = selectId === 'model-select' ? state.apiConfig.model : state.apiConfig.secondaryModel;
        
                models.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model.id;
                    option.textContent = model.id;
                    if (model.id === savedModel) option.selected = true;
                    modelSelect.appendChild(option);
                });
                alert('模型清單已更新');
            } catch (error) {
                alert(`拉取模型失敗: ${error.message}`);
            }
        }
        
        // 綁定主模型拉取按鈕
        document.getElementById('fetch-models-btn').addEventListener('click', () => {
            fetchModels('proxy-url', 'api-key', 'model-select');
        });
        
        // 【核心新增】綁定副模型拉取按鈕
        document.getElementById('fetch-secondary-models-btn').addEventListener('click', () => {
            fetchModels('secondary-proxy-url', 'secondary-api-key', 'secondary-model-select');
        });
        // ▲▲▲ 替換結束 ▲▲▲
                    document.getElementById('add-world-book-btn').addEventListener('click', async () => { const name = await showCustomPrompt('創建世界書', '請輸入書名'); if (name && name.trim()) { const newBook = { id: 'wb_' + Date.now(), name: name.trim(), content: '' }; await db.worldBooks.add(newBook); state.worldBooks.push(newBook); renderWorldBookScreen(); openWorldBookEditor(newBook.id); } });
// ▼▼▼ 【全新 | iOS 相容版】請用這個新版本替換舊的 save-world-book-btn 事件監聽器 ▼▼▼
document.getElementById('save-world-book-btn').addEventListener('click', async () => {
    if (!editingWorldBookId) return;
    const book = state.worldBooks.find(wb => wb.id === editingWorldBookId);
    if (!book) return;

    // (這部分保存資料的邏輯保持不變)
    const newName = document.getElementById('world-book-name-input').value.trim();
    if (!newName) { alert('書名不能為空！'); return; }
    book.name = newName;
    const categoryId = document.getElementById('world-book-category-select').value;
    book.categoryId = categoryId ? parseInt(categoryId) : null;

    const entriesContainer = document.getElementById('world-book-entries-container');
    const entryBlocks = entriesContainer.querySelectorAll('.message-editor-block');
    const newEntries = [];

    entryBlocks.forEach(block => {
        const keysInput = block.querySelector('.entry-keys-input').value.trim();
        const content = block.querySelector('.entry-content-textarea').value.trim();
        const isEnabled = block.querySelector('.entry-enabled-switch').checked;
        if (content) {
            newEntries.push({
                comment: block.querySelector('.entry-comment-input').value.trim(),
                keys: keysInput ? keysInput.split(',').map(k => k.trim()).filter(k => k) : [],
                content: content,
                enabled: isEnabled
            });
        }
    });
    book.content = newEntries;

    // 1. 先將所有資料保存到資料庫
    await db.worldBooks.put(book);
    document.getElementById('world-book-editor-title').textContent = newName;
    editingWorldBookId = null;

    // 2. 【核心修復】先切換到目標螢幕
    showScreen('world-book-screen');
    
    // 3. 【核心修復】然後再非同步地渲染內容
    await renderWorldBookScreen();
});
// ▲▲▲ 替換結束 ▲▲▲
        // ▼▼▼ 【最終修復版】請用這整塊代碼，完整替換舊的 chat-messages 事件監聽器 ▼▼▼
        document.getElementById('chat-messages').addEventListener('click', async (e) => {
    // 優先處理帶 data-text 屬性的 tts_voice
const voiceBody = e.target.closest('.voice-message-body[data-text]');
if (voiceBody) {
    // 【核心修復1】首先獲取當前的聊天物件，這是所有判斷的基礎
    const chat = state.chats[state.activeChatId];
    if (!chat) return; // 安全檢查，如果找不到聊天物件則直接退出

    // 無論如何，都允許用戶點擊展開/折疊語音文字
    toggleVoiceTranscript(voiceBody);

    // 獲取後續判斷需要的元素
    const bubble = voiceBody.closest('.message-bubble');
    const transcriptEl = bubble ? bubble.querySelector('.voice-transcript') : null;

    // 只有當它是一個可播放的AI語音，並且文字是展開狀態時，才進入下一步判斷
    if (voiceBody.dataset.voiceId && transcriptEl && transcriptEl.style.display === 'block') {

        // 【核心修復2】雙重驗證：攔截不應發出請求的場景
        if (chat.isGroup) {
            console.log("這是一條群聊語音訊息，已禁止發起TTS請求。");
            return; // 如果是群聊，直接阻止後續操作
        }
        if (chat.settings.enableTts === false) {
            console.log(`“${chat.name}”的TTS功能已關閉，已禁止發起TTS請求。`);
            return; // 如果當前聊天的TTS開關是關閉的，也直接阻止
        }

        // 只有通過了以上所有驗證，才真正調用API去播放語音
        playTtsAudio(voiceBody);
    }

    return; // 處理完後立即退出
}
            // 檢查是否點擊了 "查看詳情" 按鈕
            const detailsBtn = e.target.closest('.waimai-details-btn');
            if (detailsBtn) {
                const bubble = detailsBtn.closest('.message-bubble');
                if (bubble) {
                    const timestamp = parseInt(bubble.dataset.timestamp);
                    if (!isNaN(timestamp)) {
                        showWaimaiDetails(timestamp); // 調用我們新加的函數
                        return; // 處理完後直接退出
                    }
                }
            }
            
            // ▼▼▼ 【【【核心新增代碼就在這裡！】】】 ▼▼▼
            // 檢查是否點擊了 "為Ta買單" 或 "殘忍拒絕" 按鈕
            const choiceBtn = e.target.closest('.waimai-user-actions button');
            if (choiceBtn) {
                const bubble = choiceBtn.closest('.message-bubble');
                if (bubble) {
                    const timestamp = parseInt(bubble.dataset.timestamp);
                    const choice = choiceBtn.dataset.choice; // 獲取 'paid' 或 'rejected'
                    if (!isNaN(timestamp) && choice) {
                        await handleWaimaiResponse(timestamp, choice); // 調用已有的處理函數
                        return; // 處理完後退出，避免觸發其他邏輯
                    }
                }
            }
        
            // --- 以下是您原來已有的所有其他點擊事件邏輯，保持不變 ---
            const deletedPostPlaceholder = e.target.closest('.post-deleted-placeholder');
            if (deletedPostPlaceholder) {
                const postId = parseInt(deletedPostPlaceholder.dataset.postId);
                if (!isNaN(postId)) {
                    const post = await db.qzonePosts.get(postId);
                    if (post) {
                        let originalContent = '';
                        const authorName = post.authorId === 'user' ? state.qzoneSettings.nickname : (state.chats[post.authorId]?.name || '未知作者');
                        
                        if(post.type === 'shuoshuo'){
                            originalContent = post.content;
                        } else {
                            originalContent = post.publicText || '';
                            if(post.imageUrl) originalContent += `\n[圖片]`;
                            if(post.hiddenContent) originalContent += `\n[文字圖內容: ${post.hiddenContent}]`;
                        }
                        
                        showCustomAlert(
                            `來自 ${authorName} 的已刪除動態`, 
                            originalContent.replace(/\n/g, '<br>')
                        );
                    } else {
                        showCustomAlert('提示', '這條動態的原始資料已被徹底清除。');
                    }
                }
                return;
            }
        
            const aiImage = e.target.closest('.ai-generated-image');
            if (aiImage) {
                const description = aiImage.dataset.description;
                if (description) showCustomAlert('照片描述', description);
                return;
            }
        
            const quoteBlock = e.target.closest('.quoted-message');
            if (quoteBlock && quoteBlock.dataset.originalTimestamp) {
                const originalTimestamp = parseInt(quoteBlock.dataset.originalTimestamp);
                if (!isNaN(originalTimestamp)) {
                    scrollToOriginalMessage(originalTimestamp);
                }
            }
            
            const giftCard = e.target.closest('.gift-card');
            if (giftCard) {
                const bubble = giftCard.closest('.message-bubble');
                if (bubble) {
                    showGiftReceipt(parseInt(bubble.dataset.timestamp));
                }
            }
        
            const packetCard = e.target.closest('.red-packet-card');
            if (packetCard) {
                const messageBubble = packetCard.closest('.message-bubble');
                if (messageBubble && messageBubble.dataset.timestamp) {
                    const timestamp = parseInt(messageBubble.dataset.timestamp);
                    handlePacketClick(timestamp);
                }
            }
            
            const pollCard = e.target.closest('.poll-card');
            if (pollCard) {
                const timestamp = parseInt(pollCard.dataset.pollTimestamp);
                if (isNaN(timestamp)) return;
                
                const optionItem = e.target.closest('.poll-option-item');
                if (optionItem && !pollCard.classList.contains('closed')) {
                    handleUserVote(timestamp, optionItem.dataset.option);
                    return;
                }
                
                const actionBtn = e.target.closest('.poll-action-btn');
                if (actionBtn) {
                    if (pollCard.classList.contains('closed')) {
                        showPollResults(timestamp);
                    } else {
                        endPoll(timestamp);
                    }
                    return;
                }
        
                if (pollCard.classList.contains('closed')) {
                    showPollResults(timestamp);
                }
            }
        

        
            const placeholder = e.target.closest('.recalled-message-placeholder');
            if (placeholder) {
                const chat = state.chats[state.activeChatId];
                const wrapper = placeholder.closest('.message-wrapper');
                if (chat && wrapper) {
                    const timestamp = parseInt(wrapper.dataset.timestamp);
                    const recalledMsg = chat.history.find(m => m.timestamp === timestamp);
                    
                    if (recalledMsg && recalledMsg.recalledData) {
                        let originalContentText = '';
                        const recalled = recalledMsg.recalledData;
                        
                        if (recalled.originalType === 'text') {
                            originalContentText = `原文: "${recalled.originalContent}"`;
                        } else {
                            originalContentText = `撤回了一條[${recalled.originalType}]類型的消息`;
                        }
                        showCustomAlert('已撤回的消息', originalContentText);
                    }
                }
            }
        
            const linkCard = e.target.closest('.link-share-card');
            if (linkCard && linkCard.closest('.message-bubble.is-link-share')) {
                const timestamp = parseInt(linkCard.dataset.timestamp);
                openSharedHistoryViewer(timestamp);
            }
        
            const bubble = e.target.closest('.message-bubble');
            if (bubble && bubble.classList.contains('ai') && bubble.classList.contains('is-transfer') && bubble.dataset.status === 'pending') {
                const timestamp = parseInt(bubble.dataset.timestamp);
                if (!isNaN(timestamp)) {
                    showTransferActionModal(timestamp);
                }
            }
        });
        // ▲▲▲ 替換結束 ▲▲▲
                    
                    const chatSettingsModal = document.getElementById('chat-settings-modal');
                    const worldBookSelectBox = document.querySelector('.custom-multiselect .select-box');
                    const worldBookCheckboxesContainer = document.getElementById('world-book-checkboxes-container');
        // ▼▼▼ 【請用這個新版本】替換舊的 updateWorldBookSelectionDisplay 函數 ▼▼▼
        function updateWorldBookSelectionDisplay() {
            const checkedBoxes = worldBookCheckboxesContainer.querySelectorAll('input:checked');
            const displayText = document.querySelector('.selected-options-text');
            
            if (checkedBoxes.length === 0) {
                displayText.textContent = '-- 點擊選擇 --';
            } else if (checkedBoxes.length > 2) {
                displayText.textContent = `已選擇 ${checkedBoxes.length} 本世界書`;
            } else {
                const displayItems = Array.from(checkedBoxes).map(cb => {
                    return cb.parentElement.textContent.trim();
                });
                displayText.textContent = displayItems.join(', ');
            }
        }
        // ▲▲▲ 替換結束 ▲▲▲   
                    
                    worldBookSelectBox.addEventListener('click', (e) => { e.stopPropagation(); worldBookCheckboxesContainer.classList.toggle('visible'); worldBookSelectBox.classList.toggle('expanded'); });
                    document.getElementById('world-book-checkboxes-container').addEventListener('change', updateWorldBookSelectionDisplay);
                    window.addEventListener('click', (e) => { if (!document.querySelector('.custom-multiselect').contains(e.target)) { worldBookCheckboxesContainer.classList.remove('visible'); worldBookSelectBox.classList.remove('expanded'); } });
        // ▼▼▼ 【請用這個 V3.0 最終修復版】替換舊的 chat-settings-btn 事件監聽器 ▼▼▼
        document.getElementById('chat-settings-btn').addEventListener('click', async () => {
            loadThemePresetsDropdown(); // <-- 新增這一行
            if (!state.activeChatId) return;
            const chat = state.chats[state.activeChatId];
            const isGroup = chat.isGroup;
        
            // --- （這部分與之前相同，保持不變） ---
            const switchGreetingGroup = document.getElementById('switch-greeting-group');
            if (!isGroup && chat.settings.alternateGreetings && chat.settings.alternateGreetings.length > 0) {
                switchGreetingGroup.style.display = 'block';
            } else {
                switchGreetingGroup.style.display = 'none';
            }
            
            document.getElementById('chat-name-group').style.display = 'block';
            document.getElementById('my-persona-group').style.display = 'block';
            document.getElementById('my-avatar-group').style.display = 'block';
            document.getElementById('my-group-nickname-group').style.display = isGroup ? 'block' : 'none';
            document.getElementById('my-nickname-group').style.display = isGroup ? 'none' : 'block';
            document.getElementById('group-avatar-group').style.display = isGroup ? 'block' : 'none';
            document.getElementById('group-members-group').style.display = isGroup ? 'block' : 'none';
            document.getElementById('ai-persona-group').style.display = isGroup ? 'none' : 'block';
            document.getElementById('ai-avatar-group').style.display = isGroup ? 'none' : 'block';
            document.getElementById('assign-group-section').style.display = isGroup ? 'none' : 'block';
            document.getElementById('ai-original-name-group').style.display = isGroup ? 'none' : 'block';
            document.getElementById('ai-voice-id-group').style.display = isGroup ? 'none' : 'block';
            document.getElementById('offline-mode-group').style.display = isGroup ? 'none' : 'block';
            document.getElementById('ai-cooldown-group').style.display = isGroup ? 'none' : 'block';
            document.getElementById('group-cooldown-group').style.display = isGroup ? 'block' : 'none';
            document.getElementById('chat-name-input').value = chat.name;
            document.getElementById('my-persona').value = chat.settings.myPersona;
            document.getElementById('my-avatar-preview').src = chat.settings.myAvatar || (isGroup ? defaultMyGroupAvatar : defaultAvatar);
            document.getElementById('max-memory').value = chat.settings.maxMemory;
            document.getElementById('linked-memory-count').value = chat.settings.linkedMemoryCount || 10;
            const bgPreview = document.getElementById('bg-preview');
            const removeBgBtn = document.getElementById('remove-bg-btn');
            if (chat.settings.background) {
                bgPreview.src = chat.settings.background;
                bgPreview.style.display = 'block';
                removeBgBtn.style.display = 'inline-block';
            } else {
                bgPreview.style.display = 'none';
                removeBgBtn.style.display = 'none';
            }
            document.getElementById('lyrics-position-group').style.display = isGroup ? 'none' : 'block';
// 【核心新增】根據是否為群聊，顯示或隱藏對應的後臺活動開關
document.getElementById('single-char-background-activity-group').style.display = isGroup ? 'none' : 'block';
document.getElementById('group-background-activity-group').style.display = isGroup ? 'block' : 'none';

// (後續的賦值邏輯，請用下面這整塊新代碼完整替換)
// 【新增代碼】讀取時間感知設置
// 【新增代碼】讀取時間感知設置並控制時區選擇器顯隱
const timePerceptionToggle = document.getElementById('time-perception-toggle');
const timeZoneGroup = document.getElementById('time-zone-group');
timePerceptionToggle.checked = chat.settings.enableTimePerception;
timeZoneGroup.style.display = timePerceptionToggle.checked ? 'block' : 'none';

// 填充時區下拉清單
const timezoneSelect = document.getElementById('time-zone-select');
// Intl.supportedValuesOf('timeZone') 是流覽器內置的API，可以獲取所有支援的時區
const timezones = Intl.supportedValuesOf('timeZone');
timezoneSelect.innerHTML = ''; // 清空舊選項
timezones.forEach(tz => {
    const option = document.createElement('option');
    option.value = tz;
    option.textContent = tz;
    timezoneSelect.appendChild(option);
});
// 設置當前選中的時區，如果沒設置過，則默認為上海
timezoneSelect.value = chat.settings.timeZone || 'Asia/Shanghai';
if (isGroup) {
    // 【核心新增】讀取並設置群聊開關的狀態
    document.getElementById('group-background-activity-switch').checked = chat.settings.enableBackgroundActivity;
    document.getElementById('my-group-nickname-input').value = chat.settings.myNickname || '';
    document.getElementById('group-avatar-preview').src = chat.settings.groupAvatar || defaultGroupAvatar;
    document.getElementById('group-action-cooldown-input').value = chat.settings.actionCooldownMinutes || 10;

    // 【核心新增】在群聊設置中，隱藏單聊的後臺活動開關
    document.getElementById('single-char-background-activity-group').style.display = 'none';
    renderGroupMemberSettings(chat.members);
} else {
    // 【核心新增】在單聊設置中，顯示並設置開關的當前狀態
    document.getElementById('single-char-background-activity-group').style.display = 'block';
    document.getElementById('char-background-activity-switch').checked = chat.settings.enableBackgroundActivity;

    // (其他單聊設置的讀取邏輯保持不變)
    const offlineModeToggle = document.getElementById('offline-mode-toggle');
    const offlineModeOptions = document.getElementById('offline-mode-options');
    const offlineMinInput = document.getElementById('offline-min-length-input');
    const offlineMaxInput = document.getElementById('offline-max-length-input');
    offlineModeToggle.checked = chat.settings.isOfflineMode || false;
    offlineModeOptions.style.display = offlineModeToggle.checked ? 'block' : 'none';
    offlineMinInput.value = chat.settings.offlineMinLength || 100;
    offlineMaxInput.value = chat.settings.offlineMaxLength || 300;
await renderOfflinePresetSelector(chat);
    document.getElementById('ai-original-name-input').value = chat.originalName;
document.getElementById('ai-voice-id-input').value = chat.settings.minimaxVoiceId || '';
document.getElementById('enable-tts-switch').checked = chat.settings.enableTts !== false;
    document.getElementById('ai-persona').value = chat.settings.aiPersona;
    document.getElementById('ai-avatar-preview').src = chat.settings.aiAvatar || defaultAvatar;
    document.getElementById('my-nickname-input').value = chat.settings.myNickname || '我';
    document.getElementById('ai-action-cooldown-input').value = chat.settings.actionCooldownMinutes || 10;
    const select = document.getElementById('assign-group-select');
    select.innerHTML = '<option value="">未分組</option>';
    const groups = await db.qzoneGroups.toArray();
    groups.forEach(group => {
        const option = document.createElement('option');
        option.value = group.id;
        option.textContent = group.name;
        if (chat.groupId === group.id) option.selected = true;
        select.appendChild(option);
    });
    const lyricsPos = chat.settings.lyricsPosition || { vertical: 'top', horizontal: 'center', offset: 10 };
    document.getElementById('lyrics-vertical-pos').value = lyricsPos.vertical;
    document.getElementById('lyrics-horizontal-pos').value = lyricsPos.horizontal;
    document.getElementById('lyrics-offset-input').value = lyricsPos.offset;
}
// ▲▲▲ 替換結束 ▲▲▲
            
            // --- 【【【核心修復從這裡開始】】】 ---
            const worldBookCheckboxesContainer = document.getElementById('world-book-checkboxes-container');
            worldBookCheckboxesContainer.innerHTML = ''; // 清空舊列表
        
            const [allCategories, allBooks] = await Promise.all([
                db.worldBookCategories.toArray(),
                db.worldBooks.toArray()
            ]);
        
            const linkedBookIds = new Set(chat.settings.linkedWorldBookIds || []);
        
            if (allBooks.length === 0) {
                worldBookCheckboxesContainer.innerHTML = '<p style="text-align:center; color: #8a8a8a;">還沒有創建任何世界書</p>';
            } else {
                // 1. 先按分類渲染書籍
                allCategories.forEach(cat => {
                    const booksInCategory = allBooks.filter(book => book.categoryId === cat.id);
                    if (booksInCategory.length > 0) {
                        const categoryHeader = document.createElement('h4');
                        categoryHeader.textContent = cat.name; // 分類名作為標題
                        categoryHeader.style.cssText = 'margin: 10px 0 5px; color: #555; border-bottom: 1px solid #eee; padding-bottom: 3px;';
                        worldBookCheckboxesContainer.appendChild(categoryHeader);
        
                        booksInCategory.forEach(book => {
                            const isChecked = linkedBookIds.has(book.id);
                            const label = document.createElement('label');
                            // 統一使用 book_ 首碼
                            label.innerHTML = `<input type="checkbox" value="book_${book.id}" ${isChecked ? 'checked' : ''}> ${book.name}`;
                            worldBookCheckboxesContainer.appendChild(label);
                        });
                    }
                });
        
                // 2. 渲染未分類的書籍
                const uncategorizedBooks = allBooks.filter(book => !book.categoryId);
                if (uncategorizedBooks.length > 0) {
                    const bookHeader = document.createElement('h4');
                    bookHeader.textContent = '未分類';
                    bookHeader.style.cssText = 'margin: 15px 0 5px; color: #555; border-bottom: 1px solid #eee; padding-bottom: 3px;';
                    worldBookCheckboxesContainer.appendChild(bookHeader);
        
                    uncategorizedBooks.forEach(book => {
                        const isChecked = linkedBookIds.has(book.id);
                        const label = document.createElement('label');
                        label.innerHTML = `<input type="checkbox" value="book_${book.id}" ${isChecked ? 'checked' : ''}> ${book.name}`;
                        worldBookCheckboxesContainer.appendChild(label);
                    });
                }
            }
            // --- 【【【核心修復到這裡結束】】】 ---
        
            updateWorldBookSelectionDisplay();

            const linkMemoryToggle = document.getElementById('link-memory-toggle'); const linkedMemorySelection = document.getElementById('linked-memory-selection'); const linkedChatsContainer = document.getElementById('linked-chats-checkboxes-container'); const linkedMemoryIds = chat.settings.linkedMemoryChatIds || []; linkMemoryToggle.checked = linkedMemoryIds.length > 0; linkedMemorySelection.style.display = linkMemoryToggle.checked ? 'block' : 'none'; linkedChatsContainer.innerHTML = ''; Object.values(state.chats).forEach(c => { if (c.id === chat.id) return; const isChecked = linkedMemoryIds.includes(c.id); const prefix = c.isGroup ? '[群聊]' : '[私聊]'; const label = document.createElement('label'); label.innerHTML = `<input type="checkbox" value="${c.id}" ${isChecked ? 'checked' : ''}> ${prefix} ${c.name}`; linkedChatsContainer.appendChild(label); }); function updateLinkedMemorySelectionDisplay() { const checkedBoxes = linkedChatsContainer.querySelectorAll('input:checked'); const displayText = linkedMemorySelection.querySelector('.selected-options-text'); if (checkedBoxes.length === 0) { displayText.textContent = '-- 點擊選擇 --'; } else if (checkedBoxes.length > 2) { displayText.textContent = `已選擇 ${checkedBoxes.length} 項`; } else { displayText.textContent = Array.from(checkedBoxes).map(cb => cb.parentElement.textContent.trim()).join(', '); } } updateLinkedMemorySelectionDisplay(); linkMemoryToggle.addEventListener('change', () => { linkedMemorySelection.style.display = linkMemoryToggle.checked ? 'block' : 'none'; }); const linkedMemorySelectBox = linkedMemorySelection.querySelector('.select-box'); const newLinkedMemorySelectBox = linkedMemorySelectBox.cloneNode(true); linkedMemorySelectBox.parentNode.replaceChild(newLinkedMemorySelectBox, linkedMemorySelectBox); newLinkedMemorySelectBox.addEventListener('click', (e) => { e.stopPropagation(); linkedChatsContainer.classList.toggle('visible'); newLinkedMemorySelectBox.classList.toggle('expanded'); }); linkedChatsContainer.addEventListener('change', updateLinkedMemorySelectionDisplay);
            const themeRadio = document.querySelector(`input[name="theme-select"][value="${chat.settings.theme || 'default'}"]`); if (themeRadio) themeRadio.checked = true;
            const fontSizeSlider = document.getElementById('font-size-slider'); fontSizeSlider.value = chat.settings.fontSize || 13; document.getElementById('font-size-value').textContent = `${fontSizeSlider.value}px`;
            const customCssInput = document.getElementById('custom-css-input'); customCssInput.value = chat.settings.customCss || '';
            updateSettingsPreview();
            document.getElementById('auto-memory-toggle').checked = chat.settings.enableAutoMemory || false;
            document.getElementById('auto-memory-interval').value = chat.settings.autoMemoryInterval || 20;
            showScreen('chat-settings-screen');
        });
        // ▲▲▲ 替換結束 ▲▲▲
                    
// ▼▼▼ 【V2.0 | 頭像最終修復版】請用這個新版本替換舊的 renderGroupMemberSettings 函數 ▼▼▼
function renderGroupMemberSettings(members) { 
    const container = document.getElementById('group-members-settings'); 
    container.innerHTML = ''; 
    members.forEach(member => { 
        const div = document.createElement('div'); 
        div.className = 'member-editor'; 
        div.dataset.memberId = member.id; 
        
        // ★★★★★ 這就是【核心修復 ①】★★★★★
        // 優先使用成員自己獨立的頭像(member.avatar)，如果沒有，再嘗試去單聊配置裡找，
        // 如果還沒有，最後才用默認頭像。這套邏輯能完美相容所有類型的成員。
        const memberAvatar = member.avatar || (state.chats[member.id] ? state.chats[member.id].settings.aiAvatar : defaultGroupMemberAvatar);

        div.innerHTML = `<img src="${memberAvatar}" alt="${member.groupNickname}"><div class="member-name">${member.groupNickname}</div>`;
        div.addEventListener('click', () => openMemberEditor(member.id)); 
        container.appendChild(div); 
    }); 
}
// ▲▲▲ 替換結束 ▲▲▲

// ▼▼▼ 【V2.0 | 頭像最終修復版】請用這個新版本替換舊的 saveMemberSettings 函數 ▼▼▼
document.getElementById('save-member-settings-btn').addEventListener('click', async () => {
    if (!editingMemberId) return; 
    const chat = state.chats[state.activeChatId]; 
    const member = chat.members.find(m => m.id === editingMemberId); 
    if (!member) return;

    const newNickname = document.getElementById('member-name-input').value.trim();
    if (!newNickname) {
        alert("群昵稱不能為空！");
        return;
    }
    member.groupNickname = newNickname; 
    member.persona = document.getElementById('member-persona-input').value; 
    
    const newAvatarUrl = document.getElementById('member-avatar-preview').src;

    // ★★★★★ 這就是【核心修復 ②】 ★★★★★
    // 無論成員是“真角色”還是“純NPC”，都【必須】將新頭像URL直接保存在群聊的成員資訊裡。
    member.avatar = newAvatarUrl;

    // 同時，如果這個成員是一個“真角色”，我們依然更新他的主配置，保持資料同步。
    const characterProfile = state.chats[member.id];
    if (characterProfile) {
        characterProfile.settings.aiAvatar = newAvatarUrl;
        await db.chats.put(characterProfile);
    }
    
    // 將包含最新成員資訊的【整個群聊物件】存回資料庫，讓NPC的頭像得以永久保存。
    await db.chats.put(chat);
    
    // 刷新UI並關閉彈窗
    renderGroupMemberSettings(chat.members); 
    document.getElementById('member-settings-modal').classList.remove('visible'); 
    editingMemberId = null;
});
// ▲▲▲ 替換結束 ▲▲▲
        
        // ▼▼▼ 【請用這個新版本】替換舊的 openMemberEditor 函數 ▼▼▼
        function openMemberEditor(memberId) { 
            editingMemberId = memberId; 
            const chat = state.chats[state.activeChatId]; 
            const member = chat.members.find(m => m.id === memberId); 
            if (!member) return; // 安全檢查
        
            document.getElementById('member-name-input').value = member.groupNickname; 
            document.getElementById('member-persona-input').value = member.persona; 
            
            // ★★★★★ 這就是【核心修復 ②】★★★★★
            // 使用與上面完全相同的邏輯來獲取並顯示正確的當前頭像。
            const memberAvatar = member.avatar || (state.chats[member.id] ? state.chats[member.id].settings.aiAvatar : defaultGroupMemberAvatar);
            document.getElementById('member-avatar-preview').src = memberAvatar;
        
            document.getElementById('member-settings-modal').classList.add('visible'); 
        }
        // ▲▲▲ 替換結束 ▲▲▲
                    document.getElementById('cancel-member-settings-btn').addEventListener('click', () => { document.getElementById('member-settings-modal').classList.remove('visible'); editingMemberId = null; });
                    // ▼▼▼ 將其【完整替換為】下面這段修正後的代碼 ▼▼▼
        // ▼▼▼ 【最終修復版】請用這整塊代碼，完整替換舊的 'save-member-settings-btn' 事件監聽器 ▼▼▼
        document.getElementById('save-member-settings-btn').addEventListener('click', async () => {
            if (!editingMemberId) return; 
            const chat = state.chats[state.activeChatId]; 
            const member = chat.members.find(m => m.id === editingMemberId); 
            if (!member) return;
        
            const newNickname = document.getElementById('member-name-input').value.trim();
            if (!newNickname) {
                alert("群昵稱不能為空！");
                return;
            }
            member.groupNickname = newNickname; 
            member.persona = document.getElementById('member-persona-input').value; 
            
            const newAvatarUrl = document.getElementById('member-avatar-preview').src;
        
            // ★★★★★ 這就是【核心修復】 ★★★★★
            // 無論成員是“真角色”還是“純NPC”，都【必須】將新頭像URL直接保存在群聊的成員資訊裡。
            member.avatar = newAvatarUrl;
        
            // 同時，如果這個成員是一個“真角色”，我們依然更新他的主配置，保持資料同步。
            const characterProfile = state.chats[member.id];
            if (characterProfile) {
                characterProfile.settings.aiAvatar = newAvatarUrl;
                await db.chats.put(characterProfile);
            }
            
            // 將包含最新成員資訊的【整個群聊物件】存回資料庫，讓NPC的頭像得以永久保存。
            await db.chats.put(chat);
            
            // 刷新UI並關閉彈窗
            renderGroupMemberSettings(chat.members); 
            document.getElementById('member-settings-modal').classList.remove('visible'); 
            editingMemberId = null;
        });
        // ▲▲▲ 替換結束 ▲▲▲
                    document.getElementById('reset-theme-btn').addEventListener('click', () => { document.getElementById('theme-default').checked = true; });
                   
        
// ▼▼▼ 【最終修復版】請用這個全新的函數，完整替換舊的 'save-chat-settings-btn' 事件監聽器 ▼▼▼
document.getElementById('save-chat-settings-btn').addEventListener('click', async () => {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    
    // --- 捕獲舊的線下模式狀態 ---
    const oldOfflineModeState = chat.settings.isOfflineMode || false;

    // --- (所有其他設置的保存邏輯保持不變) ---
    const newName = document.getElementById('chat-name-input').value.trim();
    if (!newName) return alert('備註名/群名不能為空！');
    if (!chat.isGroup && newName !== chat.name) {
        if (!chat.nameHistory) chat.nameHistory = [];
        if (!chat.nameHistory.includes(chat.name)) chat.nameHistory.push(chat.name);
    }
    chat.name = newName;
    const selectedThemeRadio = document.querySelector('input[name="theme-select"]:checked');
    chat.settings.theme = selectedThemeRadio ? selectedThemeRadio.value : 'default';
    chat.settings.fontSize = parseInt(document.getElementById('font-size-slider').value);
    chat.settings.customCss = document.getElementById('custom-css-input').value.trim();
    chat.settings.myPersona = document.getElementById('my-persona').value;
    chat.settings.myAvatar = document.getElementById('my-avatar-preview').src;
    chat.settings.maxMemory = parseInt(document.getElementById('max-memory').value) || 10;
    chat.settings.linkedMemoryCount = parseInt(document.getElementById('linked-memory-count').value) || 10;
    
    const checkedBookItems = document.querySelectorAll('#world-book-checkboxes-container input[type="checkbox"]:checked');
    const newLinkedBookIds = [];
    checkedBookItems.forEach(cb => {
        if (cb.value.startsWith('book_')) {
            newLinkedBookIds.push(cb.value.replace('book_', ''));
        }
    });
    chat.settings.linkedWorldBookIds = newLinkedBookIds;
    
    const linkMemoryToggleChecked = document.getElementById('link-memory-toggle').checked;
    if (linkMemoryToggleChecked) {
        const checkedChats = document.querySelectorAll('#linked-chats-checkboxes-container input:checked');
        chat.settings.linkedMemoryChatIds = Array.from(checkedChats).map(cb => cb.value);
    } else {
        chat.settings.linkedMemoryChatIds = [];
    }
    chat.settings.enableAutoMemory = document.getElementById('auto-memory-toggle').checked;
    chat.settings.autoMemoryInterval = parseInt(document.getElementById('auto-memory-interval').value) || 20;
    chat.settings.enableTimePerception = document.getElementById('time-perception-toggle').checked;
    chat.settings.timeZone = document.getElementById('time-zone-select').value;
    
    if (chat.isGroup) {
        chat.settings.enableBackgroundActivity = document.getElementById('group-background-activity-switch').checked;
        chat.settings.myNickname = document.getElementById('my-group-nickname-input').value.trim();
        chat.settings.groupAvatar = document.getElementById('group-avatar-preview').src;
        chat.settings.actionCooldownMinutes = parseInt(document.getElementById('group-action-cooldown-input').value) || 10;
    } else {
        chat.settings.enableBackgroundActivity = document.getElementById('char-background-activity-switch').checked;
        const newOfflineModeState = document.getElementById('offline-mode-toggle').checked;
        chat.settings.isOfflineMode = newOfflineModeState;

        // ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
        //            這就是本次修復的核心所在！
        // ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
        
        // 1. 檢查是否是從“線下(true)”切換到了“線上(false)”
        if (oldOfflineModeState === true && newOfflineModeState === false) {
            
            // 2. 如果是，就創建一個對使用者隱藏的系統指令
            const switchInstruction = {
                role: 'system',
                content: '[系統指令：模式已切換！你現在回到了線上聊天模式。你的回復【必須】嚴格遵守線上模式的JSON陣列格式，例如 [{"type": "text", "content": "你好"}]]',
                timestamp: Date.now(),
                isHidden: true // 這個標記確保使用者看不到這條指令，但AI能讀到
            };
            
            // 3. 將這條指令注入到聊天記錄的末尾
            chat.history.push(switchInstruction);
            console.log("已成功注入“切換到線上模式”的系統指令。");
        }
        
        // ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
        
        chat.settings.offlineMinLength = parseInt(document.getElementById('offline-min-length-input').value) || 100;
        chat.settings.offlineMaxLength = parseInt(document.getElementById('offline-max-length-input').value) || 300;
        chat.settings.offlinePresetId = document.getElementById('offline-preset-select').value || null;
        
        const newOriginalName = document.getElementById('ai-original-name-input').value.trim();
        if (!newOriginalName) return alert('對方本名不能為空！');
        chat.originalName = newOriginalName;
        chat.settings.aiPersona = document.getElementById('ai-persona').value;
        chat.settings.minimaxVoiceId = document.getElementById('ai-voice-id-input').value.trim();
chat.settings.enableTts = document.getElementById('enable-tts-switch').checked;
        chat.settings.aiAvatar = document.getElementById('ai-avatar-preview').src;
        chat.settings.myNickname = document.getElementById('my-nickname-input').value.trim() || '我';
        chat.settings.actionCooldownMinutes = parseInt(document.getElementById('ai-action-cooldown-input').value) || 10;
        chat.settings.lyricsPosition = {
            vertical: document.getElementById('lyrics-vertical-pos').value,
            horizontal: document.getElementById('lyrics-horizontal-pos').value,
            offset: parseInt(document.getElementById('lyrics-offset-input').value) || 10
        };
        const selectedGroupId = document.getElementById('assign-group-select').value;
        chat.groupId = selectedGroupId ? parseInt(selectedGroupId) : null;
    }

    await db.chats.put(chat);
    if (!chat.isGroup) {
        await syncCharacterNameInGroups(chat);
        await syncCharacterAvatarInGroups(chat);
    }
    applyLyricsBarPosition(chat);
    applyScopedCss(chat.settings.customCss, '#chat-messages', 'custom-bubble-style');
    showScreen('chat-interface-screen');
    renderChatInterface(state.activeChatId);
    renderChatList();
});
// ▲▲▲ 替換結束 ▲▲▲
        
        // ▼▼▼ 【這是最終的完整功能代碼，請用它替換掉舊的】 ▼▼▼
        
        // 為聊天設置裡的“更換頭像框”按鈕添加點擊事件


// 為聊天設置裡的“更換頭像框”按鈕添加點擊事件
document.getElementById('chat-settings-screen').addEventListener('click', (e) => {
    if (e.target.classList.contains('change-frame-btn')) {
        openFrameSelectorModal('chat');
    }
});
        
        // 為成員設置裡的“更換頭像框”按鈕添加點擊事件
        document.getElementById('member-settings-modal').addEventListener('click', (e) => {
            if (e.target.classList.contains('change-frame-btn')) { 
                openFrameSelectorModal('member');
            }
        });
        
        // --- 【新增】為頭像框選擇模態框的按鈕和標籤頁綁定事件 ---
        const frameModal = document.getElementById('avatar-frame-modal');
        const aiFrameTab = document.getElementById('ai-frame-tab');
        const myFrameTab = document.getElementById('my-frame-tab');
        const aiFrameContent = document.getElementById('ai-frame-content');
        const myFrameContent = document.getElementById('my-frame-content');
        
        // “保存”按鈕
        document.getElementById('save-frame-settings-btn').addEventListener('click', saveSelectedFrames);
        
        // “取消”按鈕
        document.getElementById('cancel-frame-settings-btn').addEventListener('click', () => {
            frameModal.classList.remove('visible');
            editingFrameForMember = false; // 確保重置狀態
        });
        
        // “對方的” 標籤頁
        aiFrameTab.addEventListener('click', () => {
            aiFrameTab.classList.add('active');
            myFrameTab.classList.remove('active');
            aiFrameContent.style.display = 'block';
            myFrameContent.style.display = 'none';
        });
        
        // “我的” 標籤頁
        myFrameTab.addEventListener('click', () => {
            myFrameTab.classList.add('active');
            aiFrameTab.classList.remove('active');
            myFrameContent.style.display = 'block';
            aiFrameContent.style.display = 'none';
        });
        
        // ▲▲▲ 替換結束 ▲▲▲
                    document.getElementById('clear-chat-btn').addEventListener('click', async () => { if (!state.activeChatId) return; const chat = state.chats[state.activeChatId]; const confirmed = await showCustomConfirm('清空聊天記錄', '此操作將永久刪除此聊天的所有消息，無法恢復。確定要清空嗎？', { confirmButtonClass: 'btn-danger' }); if (confirmed) { chat.history = []; await db.chats.put(chat); renderChatInterface(state.activeChatId); renderChatList(); chatSettingsModal.classList.remove('visible'); } });
                    
                    const setupFileUpload = (inputId, callback) => { document.getElementById(inputId).addEventListener('change', async (event) => { const file = event.target.files[0]; if (file) { const dataUrl = await new Promise((res, rej) => { const reader = new FileReader(); reader.onload = () => res(reader.result); reader.onerror = () => rej(reader.error); reader.readAsDataURL(file); }); callback(dataUrl); event.target.value = null; } }); };
                    setupFileUpload('ai-avatar-input', (base64) => document.getElementById('ai-avatar-preview').src = base64);
                    setupFileUpload('my-avatar-input', (base64) => document.getElementById('my-avatar-preview').src = base64);
                    setupFileUpload('group-avatar-input', (base64) => document.getElementById('group-avatar-preview').src = base64);
                    setupFileUpload('member-avatar-input', (base64) => document.getElementById('member-avatar-preview').src = base64);
                    setupFileUpload('bg-input', (base64) => { if(state.activeChatId) { state.chats[state.activeChatId].settings.background = base64; const bgPreview = document.getElementById('bg-preview'); bgPreview.src = base64; bgPreview.style.display = 'block'; document.getElementById('remove-bg-btn').style.display = 'inline-block'; } });
                    setupFileUpload('preset-avatar-input', (base64) => document.getElementById('preset-avatar-preview').src = base64);
                    document.getElementById('remove-bg-btn').addEventListener('click', () => { if (state.activeChatId) { state.chats[state.activeChatId].settings.background = ''; const bgPreview = document.getElementById('bg-preview'); bgPreview.src = ''; bgPreview.style.display = 'none'; document.getElementById('remove-bg-btn').style.display = 'none'; } });
        
                    const stickerPanel = document.getElementById('sticker-panel');
                    document.getElementById('open-sticker-panel-btn').addEventListener('click', () => { renderStickerPanel(); stickerPanel.classList.add('visible'); });
                    document.getElementById('close-sticker-panel-btn').addEventListener('click', () => stickerPanel.classList.remove('visible'));
                    // ▼▼▼ 【請用這整塊代碼】替換舊的 add-sticker-btn 事件監聽器 ▼▼▼
        
        // 【核心新增】為“批量”按鈕綁定新函數
        document.getElementById('add-sticker-batch-btn').addEventListener('click', openBatchStickerImportModal);
        
// ▼▼▼ 請用這個【已添加分類ID】的版本替換舊的事件監聽器 ▼▼▼
        document.getElementById('add-sticker-url-btn').addEventListener('click', async () => {
            const url = await showCustomPrompt("添加表情(URL)", "請輸入表情包的圖片URL");
            if (!url || !url.trim().startsWith('http')) {
                if (url) alert("請輸入有效的URL (以http開頭)");
                return;
            }
            const name = await showCustomPrompt("命名表情", "請為這個表情命名 (例如：開心、疑惑)");
            if (name && name.trim()) {
                const newSticker = { 
                    id: 'sticker_' + Date.now(), 
                    url: url.trim(), 
                    name: name.trim(),
                    // 【核心修改】將表情歸入當前分類
                    categoryId: (activeStickerCategoryId !== 'all' && activeStickerCategoryId !== 'uncategorized') ? activeStickerCategoryId : null
                };
                await db.userStickers.add(newSticker);
                state.userStickers.push(newSticker);
                renderStickerPanel();
            } else if (name !== null) {
                alert("表情名不能為空！");
            }
        });

        
        // ▲▲▲ 替換結束 ▲▲▲
                    document.getElementById('upload-sticker-btn').addEventListener('click', () => document.getElementById('sticker-upload-input').click());
                    document.getElementById('sticker-upload-input').addEventListener('change', async (event) => { 
            const file = event.target.files[0]; 
            if (!file) return; 
            const reader = new FileReader(); 
            reader.readAsDataURL(file); 
            reader.onload = async () => { 
                const base64Url = reader.result; 
                const name = await showCustomPrompt("命名表情", "請為這個表情命名 (例如：好耶、疑惑)"); 
                if (name && name.trim()) { 
                    const newSticker = { 
                        id: 'sticker_' + Date.now(), 
                        url: base64Url, 
                        name: name.trim(),
                        // 【核心修改】將表情歸入當前分類
                        categoryId: (activeStickerCategoryId !== 'all' && activeStickerCategoryId !== 'uncategorized') ? activeStickerCategoryId : null
                    }; 
                    await db.userStickers.add(newSticker); 
                    state.userStickers.push(newSticker); 
                    renderStickerPanel(); 
                } else if (name !== null) alert("表情名不能為空！"); 
            }; 
            event.target.value = null; 
        });
        
                    document.getElementById('upload-image-btn').addEventListener('click', () => document.getElementById('image-upload-input').click());
                    document.getElementById('image-upload-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if (!file || !state.activeChatId) return; const reader = new FileReader(); reader.onload = async (e) => { const base64Url = e.target.result; const chat = state.chats[state.activeChatId]; const msg = { role: 'user', content: [{ type: 'image_url', image_url: { url: base64Url } }], timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); }; reader.readAsDataURL(file); event.target.value = null; });
                    document.getElementById('voice-message-btn').addEventListener('click', async () => {
    if (!state.activeChatId) return;

    const text = await showCustomPrompt("發送語音", "請輸入你想說的內容：");
    if (text && text.trim()) {
        const chat = state.chats[state.activeChatId];
        
        // ★★★ 核心確認：類型必須是 'voice_message' ★★★
        const msg = {
            role: 'user',
            type: 'voice_message', // 確保這裡是 voice_message，而不是 tts_voice
            content: text.trim(),
            timestamp: Date.now()
        };
        
        chat.history.push(msg);
        await db.chats.put(chat);
        appendMessage(msg, chat);
        renderChatList();
    }
});
                    document.getElementById('send-photo-btn').addEventListener('click', async () => { if (!state.activeChatId) return; const description = await showCustomPrompt("發送照片", "請用文字描述您要發送的照片："); if (description && description.trim()) { const chat = state.chats[state.activeChatId]; const msg = { role: 'user', type: 'user_photo', content: description.trim(), timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); } });
        
const waimaiModal = document.getElementById('waimai-request-modal');

// 綁定工具列的“外賣”按鈕，用於打開彈窗
document.getElementById('send-waimai-request-btn').addEventListener('click', () => {
    waimaiModal.classList.add('visible');
});

// 【核心修改1】為彈窗的半透明背景添加點擊事件，實現點擊外部關閉
waimaiModal.addEventListener('click', (e) => {
    // 只有當點擊的是背景本身，而不是內容區域時，才關閉
    if (e.target === waimaiModal) {
        waimaiModal.classList.remove('visible');
    }
});

// 【核心修改2】為新的“為TA點外賣”按鈕綁定我們新創建的函數
document.getElementById('waimai-order-for-ai-btn').addEventListener('click', sendWaimaiOrderForAI);

// 綁定“發起代付請求”按鈕（這個邏輯保持不變）
document.getElementById('waimai-confirm-btn').addEventListener('click', async () => {
    if (!state.activeChatId) return;
    
    const productInfoInput = document.getElementById('waimai-product-info');
    const amountInput = document.getElementById('waimai-amount');
    
    const productInfo = productInfoInput.value.trim();
    const amount = parseFloat(amountInput.value);

    if (!productInfo || isNaN(amount) || amount <= 0) {
        alert('請填寫有效的商品資訊和金額！');
        return;
    }

    const chat = state.chats[state.activeChatId];
    const now = Date.now();
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    
    const msg = {
        role: 'user',
        senderName: myNickname, 
        type: 'waimai_request',
        productInfo: productInfo,
        amount: amount,
        status: 'pending',
        countdownEndTime: now + 15 * 60 * 1000,
        timestamp: now
    };

    chat.history.push(msg);
    await db.chats.put(chat);
    appendMessage(msg, chat);
    renderChatList();

    productInfoInput.value = '';
    amountInput.value = '';
    waimaiModal.classList.remove('visible');
});       
                    document.getElementById('open-persona-library-btn').addEventListener('click', openPersonaLibrary);
                    document.getElementById('close-persona-library-btn').addEventListener('click', closePersonaLibrary);
                    document.getElementById('add-persona-preset-btn').addEventListener('click', openPersonaEditorForCreate);
                    document.getElementById('cancel-persona-editor-btn').addEventListener('click', closePersonaEditor);
                    document.getElementById('save-persona-preset-btn').addEventListener('click', savePersonaPreset);
                    document.getElementById('preset-action-edit').addEventListener('click', openPersonaEditorForEdit);
                    document.getElementById('preset-action-delete').addEventListener('click', deletePersonaPreset);
                    document.getElementById('preset-action-cancel').addEventListener('click', hidePresetActions);
                    
                    document.getElementById('selection-cancel-btn').addEventListener('click', exitSelectionMode);
        
        // ▼▼▼ 【這是最終的完整功能代碼，請用它替換掉舊的】 ▼▼▼

        // 1. 為新的“刪除(通知AI)”按鈕綁定事件 (邏輯與舊版刪除完全相同)
        document.getElementById('selection-soft-delete-btn').addEventListener('click', async () => {
            if (selectedMessages.size === 0) return;
            const confirmed = await showCustomConfirm('刪除消息', `確定要刪除選中的 ${selectedMessages.size} 條消息嗎？這會通知AI這些消息已被刪除。`, { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                const chat = state.chats[state.activeChatId];
                let deletedPollsInfo = [];
                for (const timestamp of selectedMessages) {
                    const msg = chat.history.find(m => m.timestamp === timestamp);
                    if (msg && msg.type === 'poll') {
                        deletedPollsInfo.push(`關於“${msg.question}”的投票(時間戳記: ${msg.timestamp})`);
                    }
                }
                chat.history = chat.history.filter(msg => !selectedMessages.has(msg.timestamp));
                let forgetReason = "一些之前的消息已被使用者刪除。";
                if (deletedPollsInfo.length > 0) {
                    forgetReason += ` 其中包括以下投票：${deletedPollsInfo.join('；')}。`;
                }
                forgetReason += " 你應該像它們從未存在過一樣繼續對話，並相應地調整你的記憶和行為，不要再提及這些被刪除的內容。";
                const forgetInstruction = {
                    role: 'system',
                    content: `[系統提示：${forgetReason}]`,
                    timestamp: Date.now(),
                    isHidden: true
                };
                chat.history.push(forgetInstruction);
                await db.chats.put(chat);
                renderChatInterface(state.activeChatId);
                renderChatList();
            }
        });

        // 2. 為新增的“徹底刪除”按鈕綁定全新的、真正的刪除邏輯
        document.getElementById('selection-erase-btn').addEventListener('click', async () => {
            if (selectedMessages.size === 0) return;
            const confirmed = await showCustomConfirm(
                '徹底刪除消息', 
                `這將從歷史記錄中【永久抹除】這 ${selectedMessages.size} 條消息，AI將完全遺忘它們的存在。確定嗎？`, 
                { confirmButtonClass: 'btn-danger', confirmText: '確認抹除' }
            );
            if (confirmed) {
                const chat = state.chats[state.activeChatId];
                
                // 核心邏輯：直接過濾掉被選中的消息，不添加任何系統提示
                chat.history = chat.history.filter(msg => !selectedMessages.has(msg.timestamp));
                
                // 直接保存，AI的下一次請求將不會包含這些被刪除的消息
                await db.chats.put(chat);
                
                // 刷新UI
                renderChatInterface(state.activeChatId);
                renderChatList();
            }
        });
        // ▲▲▲ 替換結束 ▲▲▲
        
                    const fontUrlInput = document.getElementById('font-url-input');
                    fontUrlInput.addEventListener('input', () => applyCustomFont(fontUrlInput.value.trim(), true));
                    document.getElementById('save-font-btn').addEventListener('click', async () => {
                        const newFontUrl = fontUrlInput.value.trim();
                        if (!newFontUrl) { alert("請輸入有效的字體URL。"); return; }
                        applyCustomFont(newFontUrl, false);
                        state.globalSettings.fontUrl = newFontUrl;
                        await db.globalSettings.put(state.globalSettings);
                        alert('字體已保存並應用！');
                    });
                    document.getElementById('reset-font-btn').addEventListener('click', resetToDefaultFont);
        
                    document.querySelectorAll('#chat-list-bottom-nav .nav-item').forEach(item => { item.addEventListener('click', () => switchToChatListView(item.dataset.view)); });
                    document.getElementById('qzone-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));
                    document.getElementById('qzone-nickname').addEventListener('click', async () => { const newNickname = await showCustomPrompt("修改昵稱", "請輸入新的昵稱", state.qzoneSettings.nickname); if (newNickname && newNickname.trim()) { state.qzoneSettings.nickname = newNickname.trim(); await saveQzoneSettings(); renderQzoneScreen(); } });
                    document.getElementById('qzone-avatar-container').addEventListener('click', () => document.getElementById('qzone-avatar-input').click());
                    document.getElementById('qzone-banner-container').addEventListener('click', () => document.getElementById('qzone-banner-input').click());
                    document.getElementById('qzone-avatar-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if (file) { const dataUrl = await new Promise(res => { const reader = new FileReader(); reader.onload = () => res(reader.result); reader.readAsDataURL(file); }); state.qzoneSettings.avatar = dataUrl; await saveQzoneSettings(); renderQzoneScreen(); } event.target.value = null; });
                    document.getElementById('qzone-banner-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if (file) { const dataUrl = await new Promise(res => { const reader = new FileReader(); reader.onload = () => res(reader.result); reader.readAsDataURL(file); }); state.qzoneSettings.banner = dataUrl; await saveQzoneSettings(); renderQzoneScreen(); } event.target.value = null; });
        
        // ▼▼▼ 【修正後】的“說說”按鈕事件 ▼▼▼
        document.getElementById('create-shuoshuo-btn').addEventListener('click', async () => {
            // 1. 重置並獲取模態框
            resetCreatePostModal();
            const modal = document.getElementById('create-post-modal');
            
            // 2. 設置為“說說”模式
            modal.dataset.mode = 'shuoshuo';
            
            // 3. 隱藏與圖片/文字圖相關的部分
            modal.querySelector('.post-mode-switcher').style.display = 'none';
            modal.querySelector('#image-mode-content').style.display = 'none';
            modal.querySelector('#text-image-mode-content').style.display = 'none';
            
            // 4. 修改主輸入框的提示語，使其更符合“說說”的場景
            modal.querySelector('#post-public-text').placeholder = '分享新鮮事...';
            
            // 5. 準備並顯示模態框
            const visibilityGroupsContainer = document.getElementById('post-visibility-groups');
            visibilityGroupsContainer.innerHTML = '';
            const groups = await db.qzoneGroups.toArray();
            if (groups.length > 0) {
                groups.forEach(group => {
                    const label = document.createElement('label');
                    label.style.display = 'block';
                    label.innerHTML = `<input type="checkbox" name="visibility_group" value="${group.id}"> ${group.name}`;
                    visibilityGroupsContainer.appendChild(label);
                });
            } else {
                visibilityGroupsContainer.innerHTML = '<p style="color: var(--text-secondary);">沒有可用的分組</p>';
            }
            modal.classList.add('visible');
        });
        
        // ▼▼▼ 【修正後】的“動態”（圖片）按鈕事件 ▼▼▼
        document.getElementById('create-post-btn').addEventListener('click', async () => {
            // 1. 重置並獲取模態框
            resetCreatePostModal();
            const modal = document.getElementById('create-post-modal');
            
            // 2. 設置為“複雜動態”模式
            modal.dataset.mode = 'complex';
            
        // 3. 確保與圖片/文字圖相關的部分是可見的
        modal.querySelector('.post-mode-switcher').style.display = 'flex';
        // 顯式啟動“上傳圖片”模式...
        modal.querySelector('#image-mode-content').classList.add('active');
        // ...同時確保“文字圖”模式是隱藏的
        modal.querySelector('#text-image-mode-content').classList.remove('active');
            
            // 4. 恢復主輸入框的默認提示語
            modal.querySelector('#post-public-text').placeholder = '分享新鮮事...（非必填的公開文字）';
        
            // 5. 準備並顯示模態框（與“說說”按鈕的邏輯相同）
            const visibilityGroupsContainer = document.getElementById('post-visibility-groups');
            visibilityGroupsContainer.innerHTML = '';
            const groups = await db.qzoneGroups.toArray();
            if (groups.length > 0) {
                groups.forEach(group => {
                    const label = document.createElement('label');
                    label.style.display = 'block';
                    label.innerHTML = `<input type="checkbox" name="visibility_group" value="${group.id}"> ${group.name}`;
                    visibilityGroupsContainer.appendChild(label);
                });
            } else {
                visibilityGroupsContainer.innerHTML = '<p style="color: var(--text-secondary);">沒有可用的分組</p>';
            }
            modal.classList.add('visible');
        });
                    document.getElementById('open-album-btn').addEventListener('click', async () => { await renderAlbumList(); showScreen('album-screen'); });
                    document.getElementById('album-back-btn').addEventListener('click', () => { showScreen('chat-list-screen'); switchToChatListView('qzone-screen'); });
        
        // --- ↓↓↓ 從這裡開始複製 ↓↓↓ ---
        
        document.getElementById('album-photos-back-btn').addEventListener('click', () => {
            state.activeAlbumId = null;
            showScreen('album-screen');
        });
        
        document.getElementById('album-upload-photo-btn').addEventListener('click', () => document.getElementById('album-photo-input').click());
        
        document.getElementById('album-photo-input').addEventListener('change', async (event) => {
            if (!state.activeAlbumId) return;
            const files = event.target.files;
            if (!files.length) return;
        
            const album = await db.qzoneAlbums.get(state.activeAlbumId);
            
            for (const file of files) {
                const dataUrl = await new Promise(resolve => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.readAsDataURL(file);
                });
                await db.qzonePhotos.add({ albumId: state.activeAlbumId, url: dataUrl, createdAt: Date.now() });
            }
        
            const photoCount = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).count();
            const updateData = { photoCount };
            
            if (!album.photoCount || album.coverUrl.includes('placeholder')) {
                const firstPhoto = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).first();
                if(firstPhoto) updateData.coverUrl = firstPhoto.url;
            }
        
            await db.qzoneAlbums.update(state.activeAlbumId, updateData);
            await renderAlbumPhotosScreen();
            await renderAlbumList();
            
            event.target.value = null;
            alert('照片上傳成功！');
        });
        
        // --- ↑↑↑ 複製到這裡結束 ↑↑↑ ---
        
        // --- ↓↓↓ 從這裡開始複製，完整替換掉舊的 photos-grid-page 監聽器 ↓↓↓ ---
        
        document.getElementById('photos-grid-page').addEventListener('click', async (e) => {
            const deleteBtn = e.target.closest('.photo-delete-btn');
            const photoThumb = e.target.closest('.photo-thumb');
        
            if (deleteBtn) {
                e.stopPropagation(); // 阻止事件冒泡到圖片上
                const photoId = parseInt(deleteBtn.dataset.photoId);
                const confirmed = await showCustomConfirm(
                    '刪除照片',
                    '確定要刪除這張照片嗎？此操作不可恢復。',
                    { confirmButtonClass: 'btn-danger' }
                );
        
                if (confirmed) {
                    const deletedPhoto = await db.qzonePhotos.get(photoId);
                    if (!deletedPhoto) return;
                    
                    await db.qzonePhotos.delete(photoId);
        
                    const album = await db.qzoneAlbums.get(state.activeAlbumId);
                    const photoCount = (album.photoCount || 1) - 1;
                    const updateData = { photoCount };
                    
                    if (album.coverUrl === deletedPhoto.url) {
                        const nextPhoto = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).first();
                        updateData.coverUrl = nextPhoto ? nextPhoto.url : 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png';
                    }
                    
                    await db.qzoneAlbums.update(state.activeAlbumId, updateData);
                    await renderAlbumPhotosScreen();
                    await renderAlbumList();
                    alert('照片已刪除。');
                }
            } 
            else if (photoThumb) {
                // 這就是恢復的圖片點擊放大功能！
                openPhotoViewer(photoThumb.src);
            }
        });
        
        // 恢復圖片檢視器的控制事件
        document.getElementById('photo-viewer-close-btn').addEventListener('click', closePhotoViewer);
        document.getElementById('photo-viewer-next-btn').addEventListener('click', showNextPhoto);
        document.getElementById('photo-viewer-prev-btn').addEventListener('click', showPrevPhoto);
        
        // 恢復鍵盤左右箭頭和ESC鍵的功能
        document.addEventListener('keydown', (e) => {
            if (!photoViewerState.isOpen) return; 
        
            if (e.key === 'ArrowRight') {
                showNextPhoto();
            } else if (e.key === 'ArrowLeft') {
                showPrevPhoto();
            } else if (e.key === 'Escape') {
                closePhotoViewer();
            }
        });
        
        // --- ↑↑↑ 複製到這裡結束 ↑↑↑ ---
                 
        document.getElementById('create-album-btn-page').addEventListener('click', async () => { const albumName = await showCustomPrompt("創建新相冊", "請輸入相冊名稱"); if (albumName && albumName.trim()) { const newAlbum = { name: albumName.trim(), coverUrl: 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png', photoCount: 0, createdAt: Date.now() }; await db.qzoneAlbums.add(newAlbum); await renderAlbumList(); alert(`相冊 "${albumName}" 創建成功！`); } else if (albumName !== null) { alert("相冊名稱不能為空！"); } });
        
                    document.getElementById('cancel-create-post-btn').addEventListener('click', () => document.getElementById('create-post-modal').classList.remove('visible'));
                    document.getElementById('post-upload-local-btn').addEventListener('click', () => document.getElementById('post-local-image-input').click());
                    document.getElementById('post-local-image-input').addEventListener('change', (event) => { const file = event.target.files[0]; if (file) { const reader = new FileReader(); reader.onload = (e) => { document.getElementById('post-image-preview').src = e.target.result; document.getElementById('post-image-preview-container').classList.add('visible'); document.getElementById('post-image-desc-group').style.display = 'block'; }; reader.readAsDataURL(file); } });
                    document.getElementById('post-use-url-btn').addEventListener('click', async () => { const url = await showCustomPrompt("輸入圖片URL", "請輸入網路圖片的連結", "", "url"); if (url) { document.getElementById('post-image-preview').src = url; document.getElementById('post-image-preview-container').classList.add('visible'); document.getElementById('post-image-desc-group').style.display = 'block'; } });
                    document.getElementById('post-remove-image-btn').addEventListener('click', () => resetCreatePostModal());
                    const imageModeBtn = document.getElementById('switch-to-image-mode');
                    const textImageModeBtn = document.getElementById('switch-to-text-image-mode');
                    const imageModeContent = document.getElementById('image-mode-content');
                    const textImageModeContent = document.getElementById('text-image-mode-content');
                    imageModeBtn.addEventListener('click', () => { imageModeBtn.classList.add('active'); textImageModeBtn.classList.remove('active'); imageModeContent.classList.add('active'); textImageModeContent.classList.remove('active'); });
                    textImageModeBtn.addEventListener('click', () => { textImageModeBtn.classList.add('active'); imageModeBtn.classList.remove('active'); textImageModeContent.classList.add('active'); imageModeContent.classList.remove('active'); });
        
        // ▼▼▼ 【最終修正版】的“發佈”按鈕事件，已修復許可權漏洞 ▼▼▼
        document.getElementById('confirm-create-post-btn').addEventListener('click', async () => {
            const modal = document.getElementById('create-post-modal');
            const mode = modal.dataset.mode;
            
            // --- 1. 獲取通用的可見性設置 ---
            const visibilityMode = document.querySelector('input[name="visibility"]:checked').value;
            let visibleGroupIds = null;
            
            if (visibilityMode === 'include') {
                visibleGroupIds = Array.from(document.querySelectorAll('input[name="visibility_group"]:checked')).map(cb => parseInt(cb.value));
            }
        
            let newPost = {};
            const basePostData = {
                timestamp: Date.now(),
                authorId: 'user',
                // 【重要】在這裡就把許可權資訊存好
                visibleGroupIds: visibleGroupIds,
            };
        
            // --- 2. 根據模式構建不同的 post 物件 ---
            if (mode === 'shuoshuo') {
                const content = document.getElementById('post-public-text').value.trim();
                if (!content) {
                    alert('說說內容不能為空哦！');
                    return;
                }
                newPost = {
                    ...basePostData,
                    type: 'shuoshuo',
                    content: content,
                };
        
            } else { // 處理 'complex' 模式 (圖片/文字圖)
                const publicText = document.getElementById('post-public-text').value.trim();
                const isImageModeActive = document.getElementById('image-mode-content').classList.contains('active');
        
                if (isImageModeActive) {
                    const imageUrl = document.getElementById('post-image-preview').src;
                    const imageDescription = document.getElementById('post-image-description').value.trim();
                    if (!imageUrl || !(imageUrl.startsWith('http') || imageUrl.startsWith('data:'))) {
                        alert('請先添加一張圖片再發佈動態哦！');
                        return;
                    }
                    if (!imageDescription) {
                        alert('請為你的圖片添加一個簡單的描述（必填，給AI看的）！');
                        return;
                    }
                    newPost = {
                        ...basePostData,
                        type: 'image_post',
                        publicText: publicText,
                        imageUrl: imageUrl,
                        imageDescription: imageDescription,
                    };
                } else { // 文字圖模式
                    const hiddenText = document.getElementById('post-hidden-text').value.trim();
                    if (!hiddenText) {
                        alert('請輸入文字圖描述！');
                        return;
                    }
                    newPost = {
                        ...basePostData,
                        type: 'text_image',
                        publicText: publicText,
                        hiddenContent: hiddenText,
                    };
                }
            }
        
            // --- 3. 保存到資料庫 ---
            const newPostId = await db.qzonePosts.add(newPost);
            let postSummary = newPost.content || newPost.publicText || newPost.imageDescription || newPost.hiddenContent || "（無文字內容）";
            postSummary = postSummary.substring(0, 50) + (postSummary.length > 50 ? '...' : '');
        
            // --- 4. 【核心修正】帶有許可權檢查的通知迴圈 ---
            for (const chatId in state.chats) {
                const chat = state.chats[chatId];
                if (chat.isGroup) continue; // 跳過群聊
        
                let shouldNotify = false;
                const postVisibleGroups = newPost.visibleGroupIds;
        
                // 判斷條件1：如果動態是公開的 (沒有設置任何可見分組)
                if (!postVisibleGroups || postVisibleGroups.length === 0) {
                    shouldNotify = true;
                } 
                // 判斷條件2：如果動態設置了部分可見，並且當前角色在可見分組內
                else if (chat.groupId && postVisibleGroups.includes(chat.groupId)) {
                    shouldNotify = true;
                }
        
                // 只有滿足條件的角色才會被通知
                if (shouldNotify) {
        // ▼▼▼ 從這裡開始替換 ▼▼▼
        const historyMessage = {
            role: 'system',
            content: `[系統提示：使用者剛剛發佈了一條動態(ID: ${newPostId})，內容摘要是：“${postSummary}”。請你【結合自己的角色設定、世界觀和你們的最近聊天內容】，對這條動態發表一條自然的評論。]`,
            timestamp: Date.now(),
            isHidden: true
        };
        // ▲▲▲ 到這裡替換結束 ▲▲▲
                    chat.history.push(historyMessage);
                    await db.chats.put(chat);
                }
            }
            // --- 修正結束 ---
        
            await renderQzonePosts();
            modal.classList.remove('visible');
            alert('動態發佈成功！');
        });
        
        // ▼▼▼ 請用這【一整塊】包含所有滑動和點擊事件的完整代碼，替換掉舊的 postsList 事件監聽器 ▼▼▼
        
        const postsList = document.getElementById('qzone-posts-list');
        let swipeState = { isDragging: false, startX: 0, startY: 0, currentX: 0, activeContainer: null, swipeDirection: null, isClick: true };
        
        function resetAllSwipes(exceptThisOne = null) {
            document.querySelectorAll('.qzone-post-container').forEach(container => {
                if (container !== exceptThisOne) {
                    container.querySelector('.qzone-post-item').classList.remove('swiped');
                }
            });
        }
        // ▼▼▼ 【最終修復方案】請用這個全新的、使用增量更新的函數，完整替換舊的 handlePostClick ▼▼▼
        /**
         * 【全新】處理動態區域內所有點擊事件的統一入口
         */
        async function handlePostClick(e) {
            e.stopPropagation();
            const target = e.target;
        
            // --- 優先處理評論刪除按鈕的點擊 ---
const deleteBtn = target.closest('.comment-delete-btn');
if (deleteBtn) {
    const postContainer = deleteBtn.closest('.qzone-post-container');
    const postId = parseInt(postContainer.dataset.postId);
    const commentIndex = parseInt(deleteBtn.dataset.commentIndex);
    if (isNaN(postId) || isNaN(commentIndex)) return;

    const post = qzonePostsCache.find(p => p.id === postId);
    if (!post || !post.comments || !post.comments[commentIndex]) return;
    
    // 【【【核心新增代碼：第1步】】】
    // 在刪除前，先將這條要被刪除的評論的完整資訊保存下來
    const deletedComment = post.comments[commentIndex];
    
    const confirmed = await showCustomConfirm('刪除評論', '確定要刪除這條評論嗎？', { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        // 從動態的評論清單中移除
        post.comments.splice(commentIndex, 1);
        await db.qzonePosts.update(postId, { comments: post.comments });
        
        // 【【【核心新增代碼：第2步】】】
        // 現在，我們開始清理AI的記憶
        // 只有當刪除的是用戶自己的評論時，才需要去清理AI的記憶
        if (deletedComment && deletedComment.commenterName === state.qzoneSettings.nickname) {
            console.log("用戶刪除了自己的評論，開始清理AI記憶...");

            // a. 找到所有可能收到通知的AI（帖子作者和被回復者）
            const aiToNotifyIds = new Set();
            if (post.authorId !== 'user') {
                aiToNotifyIds.add(post.authorId);
            }
            if (deletedComment.replyTo) {
                const repliedToChat = Object.values(state.chats).find(c => c.originalName === deletedComment.replyTo);
                if (repliedToChat) {
                    aiToNotifyIds.add(repliedToChat.id);
                }
            }

            // b. 重新構建出當時發送給AI的那條系統通知的【精確內容】
            const postSummary = (post.publicText || post.content || '').substring(0, 30);
            const userNickname = state.qzoneSettings.nickname;
            let notificationText;
            const stickerMatch = state.userStickers.find(s => s.url === deletedComment.text);

            if (stickerMatch) {
                 notificationText = `用戶'${userNickname}'剛剛在你的動態“${postSummary}”下，發送了一個表情評論，意思是：“${stickerMatch.name}”。`;
            } else if (deletedComment.replyTo) {
                 const repliedToDisplayName = getDisplayNameByOriginalName(deletedComment.replyTo);
                 notificationText = `用戶'${userNickname}'剛剛在你的動態“${postSummary}”下，回復了'${repliedToDisplayName}'的評論，內容是：“${deletedComment.text}”。`;
            } else {
                 notificationText = `用戶'${userNickname}'剛剛評論了你的動態“${postSummary}”，內容是：“${deletedComment.text}”。`;
            }
            const fullSystemContent = `[系統提示：${notificationText}請你對此作出回應。]`;

            // c. 遍歷所有相關的AI，從他們的歷史記錄中移除這條通知
            for (const aiId of aiToNotifyIds) {
                const chat = state.chats[aiId];
                if (chat) {
                    const originalLength = chat.history.length;
                    // 使用 filter 方法，保留所有與那條系統通知【內容不符】的消息
                    chat.history = chat.history.filter(msg => 
                        !(msg.isHidden && msg.role === 'system' && msg.content === fullSystemContent)
                    );
                    // 如果歷史記錄的長度變短了，說明我們成功刪除了，就把更新後的資料存回資料庫
                    if (chat.history.length < originalLength) {
                        console.log(`在角色 "${chat.name}" 的記憶中清除了1條關於已刪除評論的通知。`);
                        await db.chats.put(chat);
                    }
                }
            }
        }
        // 【【【新增代碼結束】】】

        await updateSinglePostInDOM(postId); // 刷新動態UI
    }
    
    return; // 處理完後必須退出
}
            
            // --- 所有彈窗和非DOM更新的邏輯保持不變 ---
            const stickerBtn = target.closest('.comment-sticker-btn');
            if (stickerBtn) {
                const postContainer = stickerBtn.closest('.qzone-post-container');
                if (!postContainer) return;
                const postId = parseInt(postContainer.dataset.postId);
                if (qzoneStickerPanelState.isOpen && qzoneStickerPanelState.activePostId === postId) {
                    closeQzoneStickerPanel();
                } else {
                    openQzoneStickerPanel(postId, stickerBtn);
                }
                return; 
            }
            const commentItem = target.closest('.comment-item');
            if (commentItem) {
                const postId = parseInt(commentItem.dataset.postId);
                const commenterOriginalName = commentItem.dataset.commenterOriginalName;
                const commenterDisplayName = commentItem.dataset.commenterDisplayName;
        
                if (!commenterOriginalName || !commenterDisplayName || commenterOriginalName === state.qzoneSettings.nickname) {
                    clearQzoneReplyContext(commentItem.closest('.qzone-post-container'));
                    return;
                }
                currentQzoneReplyContext = { postId, replyToName: commenterOriginalName, replyToDisplayName: commenterDisplayName };
                const postContainer = commentItem.closest('.qzone-post-container');
                const commentInput = postContainer.querySelector('.comment-input');
                commentInput.placeholder = `回復 ${commenterDisplayName}:`;
                commentInput.focus();
                return; 
            }
            if (target.classList.contains('post-actions-btn')) {
                const container = target.closest('.qzone-post-container');
                if (container && container.dataset.postId) showPostActions(parseInt(container.dataset.postId));
                return;
            }
            if (target.tagName === 'IMG' && target.dataset.hiddenText) {
                showCustomAlert("圖片內容", target.dataset.hiddenText.replace(/<br>/g, '\n'));
                return;
            }
        
            // --- 【核心性能優化】開始，處理所有會更新DOM的事件 ---
            const postContainer = target.closest('.qzone-post-container');
            if (!postContainer) return;
            const postId = parseInt(postContainer.dataset.postId);
            if (isNaN(postId)) return;
        
            if (target.closest('.qzone-post-delete-action')) {
                const confirmed = await showCustomConfirm('刪除動態', '確定要永久刪除這條動態嗎？', { confirmButtonClass: 'btn-danger' });
                if (confirmed) {
                    postContainer.style.transition = 'all 0.3s ease';
                    postContainer.style.transform = 'scale(0.8)';
                    postContainer.style.opacity = '0';
                    setTimeout(async () => {
                         await db.qzonePosts.delete(postId);
                         const notificationIdentifier = `(ID: ${postId})`;
                         for (const chatId in state.chats) {
                             const chat = state.chats[chatId];
                             const originalHistoryLength = chat.history.length;
                             chat.history = chat.history.filter(msg => !(msg.role === 'system' && msg.content.includes(notificationIdentifier)));
                             if (chat.history.length < originalHistoryLength) await db.chats.put(chat);
                         }
                         await renderQzonePosts(); // 刪除需要全量重繪
                         alert('動態已刪除。');
                    }, 300);
                }
                return;
            }
        
            const icon = target.closest('.action-icon');
            if (icon) {
                if (icon.classList.contains('repost')) { openRepostModal(postId); return; }
                if (icon.classList.contains('like')) {
                    const post = qzonePostsCache.find(p => p.id === postId);
                    if (!post) return;
                    if (!post.likes) post.likes = [];
                    const userOriginalName = state.qzoneSettings.nickname;
                    const userLikeIndex = post.likes.indexOf(userOriginalName);
                    if (userLikeIndex > -1) {
                        post.likes.splice(userLikeIndex, 1);
                    } else {
                        post.likes.push(userOriginalName);
                        icon.classList.add('animate-like');
                        icon.addEventListener('animationend', () => icon.classList.remove('animate-like'), { once: true });
                    }
                    await db.qzonePosts.update(postId, { likes: post.likes });
                    await updateSinglePostInDOM(postId); // 【性能優化】調用增量更新
                }
                if (icon.classList.contains('favorite')) {
                    const existingFavorite = await db.favorites.where({ type: 'qzone_post', 'content.id': postId }).first();
                    if (existingFavorite) {
                        await db.favorites.delete(existingFavorite.id);
                        await showCustomAlert('提示', '已取消收藏');
                    } else {
                        const postToSave = await db.qzonePosts.get(postId);
                        if (postToSave) {
                            await db.favorites.add({ type: 'qzone_post', content: postToSave, timestamp: Date.now() });
                            await showCustomAlert('提示', '收藏成功！');
                        }
                    }
                    await updateSinglePostInDOM(postId); // 【性能優化】調用增量更新
                }
                return;
            }
        
            const sendBtn = target.closest('.comment-send-btn');
            if (sendBtn) {
                const commentInput = postContainer.querySelector('.comment-input');
                const commentText = commentInput.value.trim();
                if (!commentText) return alert('評論內容不能為空哦！');
                
                const post = qzonePostsCache.find(p => p.id === postId);
                if (!post) return;
        
                if (!post.comments) post.comments = [];
                
                const newComment = {
                    commenterName: state.qzoneSettings.nickname,
                    text: commentText,
                    timestamp: Date.now(),
                    replyTo: (currentQzoneReplyContext && currentQzoneReplyContext.postId === postId) ? currentQzoneReplyContext.replyToName : null
                };
                
                post.comments.push(newComment);
                await db.qzonePosts.update(postId, { comments: post.comments });
                
                let postSummary = (post.publicText || post.content || '').substring(0, 30);
                const userNickname = state.qzoneSettings.nickname;
                const notifiedAiIds = new Set();
                if (post.authorId !== 'user') notifiedAiIds.add(post.authorId);
                if (newComment.replyTo && newComment.replyTo !== userNickname) {
                    const repliedToChat = Object.values(state.chats).find(c => c.originalName === newComment.replyTo);
                    if (repliedToChat) notifiedAiIds.add(repliedToChat.id);
                }
                for (const aiId of notifiedAiIds) {
                    const chat = state.chats[aiId];
                    if (chat && !chat.isGroup) {
                        const stickerMatch = state.userStickers.find(s => s.url === commentText);
                        let notificationText = stickerMatch ? `用戶'${userNickname}'剛剛在你的動態“${postSummary}”下，發送了一個表情評論，意思是：“${stickerMatch.name}”。`
                            : newComment.replyTo ? `用戶'${userNickname}'剛剛在你的動態“${postSummary}”下，回復了'${currentQzoneReplyContext.replyToDisplayName}'的評論，內容是：“${commentText}”。`
                            : `用戶'${userNickname}'剛剛評論了你的動態“${postSummary}”，內容是：“${commentText}”。`;
                        const historyMessage = { 
                            role: 'system', 
                            content: `[系統提示：${notificationText}請你對此作出回應。]`, 
                            timestamp: Date.now(), 
                            isHidden: true 
                        };
                        chat.history.push(historyMessage);
                        await db.chats.put(chat);
                    }
                }
                
                commentInput.value = '';
                clearQzoneReplyContext(postContainer); 
                await updateSinglePostInDOM(postId); // 【性能優化】調用增量更新
                return;
            }
        }
        // ▲▲▲ 替換結束 ▲▲▲
        
        
        // ▼▼▼ 【性能優化方案】請用這一整塊全新的代碼，替換所有舊的滑動處理函數和事件監聽器 ▼▼▼
        
        // --- 1. 全新的、更智慧的滑動開始函數 ---
        const handleSwipeStart = (e) => {
            const target = e.target;
            // 檢查點擊目標是否是交互區域，如果是，則不啟動滑動
            if (target.closest('.post-footer, .post-feedback-icons, .post-actions-btn, .post-comments-container, .reposted-content-wrapper')) {
                return;
            }
            const targetContainer = e.target.closest('.qzone-post-container');
            if (!targetContainer) return;
        
            resetAllSwipes(targetContainer);
            swipeState.activeContainer = targetContainer;
            swipeState.isDragging = true;
            swipeState.isClick = true;
            swipeState.swipeDirection = null;
            swipeState.startX = e.type.includes('mouse') ? e.pageX : e.touches[0].pageX;
            swipeState.startY = e.type.includes('mouse') ? e.pageY : e.touches[0].pageY;
            swipeState.activeContainer.querySelector('.qzone-post-item').style.transition = 'none';
        
            // 【核心優化】只在滑動開始時，才動態繫結移動和結束的監聽器
            document.addEventListener('mousemove', handleSwipeMove);
            document.addEventListener('mouseup', handleSwipeEnd);
            document.addEventListener('touchmove', handleSwipeMove, { passive: false });
            document.addEventListener('touchend', handleSwipeEnd);
        };
        
        // --- 2. 滑動移動函數（微調） ---
        const handleSwipeMove = (e) => {
            if (!swipeState.isDragging || !swipeState.activeContainer) return;
        
            const currentX = e.type.includes('mouse') ? e.pageX : e.touches[0].pageX;
            const currentY = e.type.includes('mouse') ? e.pageY : e.touches[0].pageY;
            const diffX = currentX - swipeState.startX;
            const diffY = currentY - swipeState.startY;
            
            if (swipeState.isClick && (Math.abs(diffX) > 5 || Math.abs(diffY) > 5)) {
                swipeState.isClick = false;
            }
        
            if (!swipeState.swipeDirection) {
                if (Math.abs(diffX) > Math.abs(diffY)) {
                    swipeState.swipeDirection = 'horizontal';
                } else {
                    swipeState.swipeDirection = 'vertical';
                }
            }
            
            if (swipeState.swipeDirection === 'horizontal') {
                e.preventDefault(); // 只在確定是水準滑動時才阻止默認行為
                swipeState.currentX = currentX;
                let translation = Math.min(0, Math.max(-90, diffX)); // 限制滑動範圍
                swipeState.activeContainer.querySelector('.qzone-post-item').style.transform = `translateX(${translation}px)`;
            }
        };
        
        // --- 3. 滑動結束函數（重構） ---
        const handleSwipeEnd = (e) => {
            // 【核心優化】無論如何，都在滑動結束後移除監聽器
            document.removeEventListener('mousemove', handleSwipeMove);
            document.removeEventListener('mouseup', handleSwipeEnd);
            document.removeEventListener('touchmove', handleSwipeMove);
            document.removeEventListener('touchend', handleSwipeEnd);
        
            if (!swipeState.isDragging || !swipeState.activeContainer) return;
            
            const postItem = swipeState.activeContainer.querySelector('.qzone-post-item');
            postItem.style.transition = 'transform 0.3s ease';
        
            if (swipeState.swipeDirection === 'horizontal' && !swipeState.isClick) {
                const finalX = e.type.includes('touchend') ? e.changedTouches[0].pageX : e.pageX;
                const diffX = finalX - swipeState.startX;
                if (diffX < -40) { // 滑動超過40圖元就觸發
                    postItem.classList.add('swiped');
                } else {
                    postItem.classList.remove('swiped');
                }
            }
            
            postItem.style.transform = ''; // 恢復原位，讓CSS class接管
            
            // 重置狀態
            swipeState.isDragging = false;
            swipeState.activeContainer = null;
            swipeState.swipeDirection = null;
            swipeState.isClick = true;
        };
        
        // --- 4. 在 init() 函數中綁定事件 ---
        // postsList.addEventListener('click', handlePostClick); // 這行您應該已經有了
        // postsList.addEventListener('mousedown', handleSwipeStart); // 綁定滑鼠按下
        // postsList.addEventListener('touchstart', handleSwipeStart, { passive: true }); // 綁定觸摸開始
        
        // ▲▲▲ 替換結束 ▲▲▲
        
        
        
        // 【最終版】動態清單事件綁定
        postsList.addEventListener('click', handlePostClick);
        postsList.addEventListener('mousedown', handleSwipeStart);
        postsList.addEventListener('touchstart', handleSwipeStart, { passive: true }); // 使用 passive 提升滾動性能
        // --- 綁定所有點擊事件 ---
        
        // ▼▼▼ 【全新】為動態清單添加“載入更多”的事件委託 ▼▼▼
        postsList.addEventListener('click', (e) => {
            // 檢查被點擊的是否是我們的“載入更多”按鈕
            if (e.target && e.target.id === 'load-more-qzone-btn') {
                loadMoreQzonePosts();
            }
        });
        // ▲▲▲ 新增代碼結束 ▲▲▲
        // 【全新】為長期記憶“精煉”按鈕綁定事件
        document.getElementById('refine-memory-btn-header').addEventListener('click', () => {
            if(state.activeChatId) {
                summarizeExistingLongTermMemory(state.activeChatId);
            }
        });
                    // ▼▼▼ 【全新】API預設功能事件監聽器 ▼▼▼
                    document.getElementById('api-preset-select').addEventListener('change', handlePresetSelectionChange);
                    document.getElementById('save-api-preset-btn').addEventListener('click', saveApiPreset);
                    document.getElementById('delete-api-preset-btn').addEventListener('click', deleteApiPreset);
                    // ▲▲▲ 新增結束 ▲▲▲
        // ▼▼▼ 在 init() 的事件監聽器區域添加這行代碼 ▼▼▼
        document.getElementById('add-world-book-entry-btn').addEventListener('click', () => {
            const container = document.getElementById('world-book-entries-container');
            // 如果之前有提示語，先清空
            if (container.querySelector('p')) {
                container.innerHTML = '';
            }
            const newBlock = createWorldBookEntryBlock(); // 創建一個空塊
            container.appendChild(newBlock);
            newBlock.querySelector('.entry-content-textarea').focus(); // 自動聚焦到新塊的內容區
        });
        // ▲▲▲ 新增事件綁定結束 ▲▲▲
                    // ▼▼▼ 在 init() 函數的事件監聽器區域，黏貼下面這兩行 ▼▼▼
        document.getElementById('switch-greeting-btn').addEventListener('click', handleSwitchGreeting);
        // ▼▼▼ 【全新】為心聲歷史列表添加“載入更多”的事件委託 ▼▼▼
        document.getElementById('thoughts-history-list').addEventListener('click', (e) => {
            if (e.target && e.target.id === 'load-more-thoughts-btn') {
                loadMoreThoughts();
            }
        });
        // ▲▲▲ 新增代碼結束 ▲▲▲
        // 在 init() 的事件監聽器區域添加
        
        // ▼▼▼ 【核心修改】將事件監聽綁定到新的圖示按鈕上 ▼▼▼
        document.getElementById('profile-history-icon-btn').addEventListener('click', showThoughtsHistory);
        // ▲▲▲ 替換結束 ▲▲▲
        document.getElementById('history-back-btn').addEventListener('click', hideThoughtsHistory);
        document.getElementById('character-profile-modal').addEventListener('click', (e) => {
            // 如果點擊的是深色背景本身，而不是內容區域，就關閉彈窗
            if (e.target.id === 'character-profile-modal') {
                e.target.classList.remove('visible');
            }
        });
        // ▼▼▼ 【全新】表情批量刪除事件綁定 ▼▼▼
        document.getElementById('manage-stickers-btn').addEventListener('click', toggleStickerManagementMode);
        document.getElementById('delete-selected-stickers-btn').addEventListener('click', executeBatchDeleteStickers);
        // ▲▲▲ 新增結束 ▲▲▲
                    // 綁定動態頁和收藏頁的返回按鈕
                    document.getElementById('qzone-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));
                    document.getElementById('favorites-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));
        
                    // ▲▲▲ 添加結束 ▲▲▲
        
                    // ▼▼▼ 在 init() 函數的事件監聽器區域，檢查並確保你有這段完整的代碼 ▼▼▼
        
                    // 收藏頁搜索功能
                    const searchInput = document.getElementById('favorites-search-input');
                    const searchClearBtn = document.getElementById('favorites-search-clear-btn');
        
                    searchInput.addEventListener('input', () => {
                        const searchTerm = searchInput.value.trim().toLowerCase();
                        
                        // 控制清除按鈕的顯示/隱藏
                        searchClearBtn.style.display = searchTerm ? 'block' : 'none';
        
                        if (!searchTerm) {
                            displayFilteredFavorites(allFavoriteItems); // 如果搜索框為空，顯示所有
                            return;
                        }
        
                        // 篩選邏輯
                        const filteredItems = allFavoriteItems.filter(item => {
                            let contentToSearch = '';
                            let authorToSearch = '';
        
                            if (item.type === 'qzone_post') {
                                const post = item.content;
                                contentToSearch += (post.publicText || '') + ' ' + (post.content || '');
                                if (post.authorId === 'user') {
                                    authorToSearch = state.qzoneSettings.nickname;
                                } else if (state.chats[post.authorId]) {
                                    authorToSearch = state.chats[post.authorId].name;
                                }
                            } else if (item.type === 'chat_message') {
                                const msg = item.content;
                                if (typeof msg.content === 'string') {
                                    contentToSearch = msg.content;
                                }
                                const chat = state.chats[item.chatId];
                                if (chat) {
                                   if (msg.role === 'user') {
                                        authorToSearch = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
                                   } else {
                                        authorToSearch = chat.isGroup ? msg.senderName : chat.name;
                                   }
                                }
                            }
                            
                            // 同時搜索內容和作者，並且不區分大小寫
                            return contentToSearch.toLowerCase().includes(searchTerm) || 
                                   authorToSearch.toLowerCase().includes(searchTerm);
                        });
        
                        displayFilteredFavorites(filteredItems);
                    });
        
                    // 清除按鈕的點擊事件
                    searchClearBtn.addEventListener('click', () => {
                        searchInput.value = '';
                        searchClearBtn.style.display = 'none';
                        displayFilteredFavorites(allFavoriteItems);
                        searchInput.focus();
                    });
        
                    // ▲▲▲ 代碼檢查結束 ▲▲▲
        
                    // ▼▼▼ 新增/修改的事件監聽器 ▼▼▼
                    
                    // 為聊天介面的批量收藏按鈕綁定事件
                                // 為聊天介面的批量收藏按鈕綁定事件 (已修正)
                    document.getElementById('selection-favorite-btn').addEventListener('click', async () => {
                        if (selectedMessages.size === 0) return;
                        const chat = state.chats[state.activeChatId];
                        if (!chat) return;
        
                        const favoritesToAdd = [];
                        const timestampsToFavorite = [...selectedMessages];
        
                        for (const timestamp of timestampsToFavorite) {
                            // 【核心修正1】使用新的、高效的索引進行查詢
                            const existing = await db.favorites.where('originalTimestamp').equals(timestamp).first();
                            
                            if (!existing) {
                                const messageToSave = chat.history.find(msg => msg.timestamp === timestamp);
                                if (messageToSave) {
                                    favoritesToAdd.push({
                                        type: 'chat_message',
                                        content: messageToSave,
                                        chatId: state.activeChatId,
                                        timestamp: Date.now(), // 這是收藏操作發生的時間
                                        originalTimestamp: messageToSave.timestamp // 【核心修正2】保存原始消息的時間戳記到新欄位
                                    });
                                }
                            }
                        }
        
                        if (favoritesToAdd.length > 0) {
                            await db.favorites.bulkAdd(favoritesToAdd);
                            allFavoriteItems = await db.favorites.orderBy('timestamp').reverse().toArray(); // 更新全域收藏緩存
                            await showCustomAlert('收藏成功', `已成功收藏 ${favoritesToAdd.length} 條消息。`);
                        } else {
                            await showCustomAlert('提示', '選中的消息均已收藏過。');
                        }
                        
                        exitSelectionMode();
                    });
        
                    // 收藏頁面的"編輯"按鈕事件 (已修正)
                    const favoritesEditBtn = document.getElementById('favorites-edit-btn');
                    const favoritesView = document.getElementById('favorites-view');
                    const favoritesActionBar = document.getElementById('favorites-action-bar');
                    const mainBottomNav = document.getElementById('chat-list-bottom-nav'); // 獲取主巡覽列
                    const favoritesList = document.getElementById('favorites-list'); // 獲取收藏列表
                    
                    favoritesEditBtn.addEventListener('click', () => {
                        isFavoritesSelectionMode = !isFavoritesSelectionMode;
                        favoritesView.classList.toggle('selection-mode', isFavoritesSelectionMode);
        
                        if (isFavoritesSelectionMode) {
                            // --- 進入編輯模式 ---
                            favoritesEditBtn.textContent = '完成';
                            favoritesActionBar.style.display = 'block'; // 顯示刪除操作欄
                            mainBottomNav.style.display = 'none'; // ▼ 新增：隱藏主巡覽列
                            favoritesList.style.paddingBottom = '80px'; // ▼ 新增：給列表底部增加空間
                        } else {
                            // --- 退出編輯模式 ---
                            favoritesEditBtn.textContent = '編輯';
                            favoritesActionBar.style.display = 'none'; // 隱藏刪除操作欄
                            mainBottomNav.style.display = 'flex';  // ▼ 新增：恢復主巡覽列
                            favoritesList.style.paddingBottom = ''; // ▼ 新增：恢復列表默認padding
        
                            // 退出時清空所有選擇
                            selectedFavorites.clear();
                            document.querySelectorAll('.favorite-item-card.selected').forEach(card => card.classList.remove('selected'));
                            document.getElementById('favorites-delete-selected-btn').textContent = `刪除 (0)`;
                        }
                    });
        
        // ▼▼▼ 將它【完整替換】為下面這段修正後的代碼 ▼▼▼
        // 收藏列表的點擊選擇事件 (事件委託)
        document.getElementById('favorites-list').addEventListener('click', (e) => {
            const target = e.target;
            const card = target.closest('.favorite-item-card');
        
            // 【新增】處理文字圖點擊，這段邏輯要放在最前面，保證任何模式下都生效
            if (target.tagName === 'IMG' && target.dataset.hiddenText) {
                const hiddenText = target.dataset.hiddenText;
                showCustomAlert("圖片內容", hiddenText.replace(/<br>/g, '\n'));
                return; // 處理完就退出，不繼續執行選擇邏輯
            }
            
            // 如果不在選擇模式，則不執行後續的選擇操作
            if (!isFavoritesSelectionMode) return;
        
            // --- 以下是原有的選擇邏輯，保持不變 ---
            if (!card) return;
        
            const favId = parseInt(card.dataset.favid);
            if (isNaN(favId)) return;
        
            // 切換選擇狀態
            if (selectedFavorites.has(favId)) {
                selectedFavorites.delete(favId);
                card.classList.remove('selected');
            } else {
                selectedFavorites.add(favId);
                card.classList.add('selected');
            }
            
            // 更新底部刪除按鈕的計數
            document.getElementById('favorites-delete-selected-btn').textContent = `刪除 (${selectedFavorites.size})`;
        });
        
        // ▼▼▼ 將它【完整替換】為下面這段修正後的代碼 ▼▼▼
        // 收藏頁面批量刪除按鈕事件
        document.getElementById('favorites-delete-selected-btn').addEventListener('click', async () => {
            if (selectedFavorites.size === 0) return;
        
            const confirmed = await showCustomConfirm(
                '確認刪除', 
                `確定要從我的最愛中移除這 ${selectedFavorites.size} 條內容嗎？`, 
                { confirmButtonClass: 'btn-danger' }
            );
        
            if (confirmed) {
                const idsToDelete = [...selectedFavorites];
                await db.favorites.bulkDelete(idsToDelete);
                await showCustomAlert('刪除成功', '選中的收藏已被移除。');
                
                // 【核心修正1】從前端緩存中也移除被刪除的項
                allFavoriteItems = allFavoriteItems.filter(item => !idsToDelete.includes(item.id));
                
                // 【核心修正2】使用更新後的緩存，立即重新渲染列表
                displayFilteredFavorites(allFavoriteItems);
                
                // 最後，再退出編輯模式
                favoritesEditBtn.click(); // 類比點擊"完成"按鈕來退出編輯模式
            }
        });
        
        // ▼▼▼ 在 init() 函數末尾添加 ▼▼▼
        if (state.globalSettings.enableBackgroundActivity) {
            startBackgroundSimulation();
            console.log("後臺活動模擬已自動啟動。");
        }
        // ▲▲▲ 添加結束 ▲▲▲
        
        // ▼▼▼ 【這是最終的正確代碼】請黏貼這段代碼到 init() 的事件監聽器區域末尾 ▼▼▼
        
        // --- 統一處理所有影響預覽的控制項的事件 ---
        
        // 1. 監聽主題選擇
        document.querySelectorAll('input[name="theme-select"]').forEach(radio => {
            radio.addEventListener('change', updateSettingsPreview);
        });
        
        // 2. 監聽字體大小滑塊
        const fontSizeSlider = document.getElementById('font-size-slider');
        fontSizeSlider.addEventListener('input', () => {
            // a. 即時更新數值顯示
            document.getElementById('font-size-value').textContent = `${fontSizeSlider.value}px`;
            // b. 更新預覽
            updateSettingsPreview();
        });
        
        // 3. 監聽自訂CSS輸入框
        const customCssInputForPreview = document.getElementById('custom-css-input');
        customCssInputForPreview.addEventListener('input', updateSettingsPreview);
        
        // 4. 監聽重新開機按鈕
        document.getElementById('reset-theme-btn').addEventListener('click', () => {
            document.getElementById('theme-default').checked = true;
            updateSettingsPreview();
        });
        
        document.getElementById('reset-custom-css-btn').addEventListener('click', () => {
            document.getElementById('custom-css-input').value = '';
            updateSettingsPreview();
        });
        
        // ▲▲▲ 黏貼結束 ▲▲▲
        // 【請確保這段代碼在您的 init() 函數內】
        document.getElementById('lyrics-vertical-pos').addEventListener('change', updateSettingsPreview);
        document.getElementById('lyrics-horizontal-pos').addEventListener('change', updateSettingsPreview);
        document.getElementById('lyrics-offset-input').addEventListener('input', updateSettingsPreview);
        // ▼▼▼ 請將這段【新代碼】黏貼到 init() 的事件監聽器區域末尾 ▼▼▼
        document.querySelectorAll('input[name="visibility"]').forEach(radio => {
            radio.addEventListener('change', function() {
                const groupsContainer = document.getElementById('post-visibility-groups');
                if (this.value === 'include' || this.value === 'exclude') {
                    groupsContainer.style.display = 'block';
                } else {
                    groupsContainer.style.display = 'none';
                }
            });
        });
        // ▲▲▲ 新代碼黏貼結束 ▲▲▲
        
        // ▼▼▼ 請將這段【新代碼】黏貼到 init() 的事件監聽器區域末尾 ▼▼▼
        document.getElementById('manage-groups-btn').addEventListener('click', openGroupManager);
        document.getElementById('close-group-manager-btn').addEventListener('click', () => {
            document.getElementById('group-management-modal').classList.remove('visible');
            // 刷新聊天設置裡的分組列表
            const chatSettingsBtn = document.getElementById('chat-settings-btn');
            if (document.getElementById('chat-settings-modal').classList.contains('visible')) {
               chatSettingsBtn.click(); // 再次點擊以重新打開
            }
        });
        
        document.getElementById('add-new-group-btn').addEventListener('click', addNewGroup);
        document.getElementById('existing-groups-list').addEventListener('click', (e) => {
            if (e.target.classList.contains('delete-group-btn')) {
                const groupId = parseInt(e.target.dataset.id);
                deleteGroup(groupId);
            }
        });
        // ▲▲▲ 新代碼黏貼結束 ▲▲▲
        
        // ▼▼▼ 請將這段【新代碼】黏貼到 init() 的事件監聽器區域末尾 ▼▼▼
        // 消息操作功能表的按鈕事件
        document.getElementById('cancel-message-action-btn').addEventListener('click', hideMessageActions);
        // ▼▼▼ 【修正】使用新的編輯器入口 ▼▼▼
        document.getElementById('edit-message-btn').addEventListener('click', openAdvancedMessageEditor);
        // ▲▲▲ 替換結束 ▲▲▲
        document.getElementById('copy-message-btn').addEventListener('click', copyMessageContent);
        
        // ▼▼▼ 在這裡添加新代碼 ▼▼▼
        document.getElementById('recall-message-btn').addEventListener('click', handleRecallClick);
        // ▲▲▲ 添加結束 ▲▲▲
        
        // ▼▼▼ 請用這段【修正後】的代碼替換舊的 select-message-btn 事件監聽器 ▼▼▼
        document.getElementById('select-message-btn').addEventListener('click', () => {
            // 【核心修復】在關閉菜單前，先捕獲時間戳記
            const timestampToSelect = activeMessageTimestamp; 
            hideMessageActions();
            // 使用捕獲到的值
            if (timestampToSelect) {
                enterSelectionMode(timestampToSelect);
            }
        });
        // ▲▲▲ 替換結束 ▲▲▲
        // ▼▼▼ 在 init() 的事件監聽器區域添加 ▼▼▼
        
        // 監聽聊天區域的點擊，專門用於處理AI發來的轉帳
        document.getElementById('chat-messages').addEventListener('click', (e) => {
            // 1. 向上查找被點擊的元素是否在一個消息氣泡內
            const bubble = e.target.closest('.message-bubble');
            if (!bubble) return; // 如果不在，就退出
        
            // 2. 檢查是否是AI的、待處理的轉帳消息
            if (bubble.classList.contains('ai') && 
                bubble.classList.contains('is-transfer') && 
                bubble.dataset.status === 'pending') {
                
                // 3. 只有滿足所有條件，才顯示操作功能表
                const timestamp = parseInt(bubble.dataset.timestamp);
                if (!isNaN(timestamp)) {
                    showTransferActionModal(timestamp);
                }
            }
        });
        
        // 綁定新轉帳操作模態框的按鈕
        document.getElementById('transfer-action-accept').addEventListener('click', () => handleUserTransferResponse('accepted'));
        document.getElementById('transfer-action-decline').addEventListener('click', () => handleUserTransferResponse('declined'));
        document.getElementById('transfer-action-cancel').addEventListener('click', hideTransferActionModal);
        
        // ▲▲▲ 添加結束 ▲▲▲
        // ▼▼▼ 在 init() 函數的事件監聽器區域末尾添加 ▼▼▼
        
        // 動態操作功能表的按鈕事件
        document.getElementById('edit-post-btn').addEventListener('click', openPostEditor);
        document.getElementById('copy-post-btn').addEventListener('click', copyPostContent);
        document.getElementById('cancel-post-action-btn').addEventListener('click', hidePostActions);
        
        // ▲▲▲ 添加結束 ▲▲▲
        
        // ▼▼▼ 【新增】連絡人選擇器事件綁定 ▼▼▼
        document.getElementById('cancel-contact-picker-btn').addEventListener('click', () => {
            showScreen('chat-list-screen');
        });
        
        document.getElementById('contact-picker-list').addEventListener('click', (e) => {
            const item = e.target.closest('.contact-picker-item');
            if (!item) return;
        
            const contactId = item.dataset.contactId;
            item.classList.toggle('selected');
            
            if (selectedContacts.has(contactId)) {
                selectedContacts.delete(contactId);
            } else {
                selectedContacts.add(contactId);
            }
            updateContactPickerConfirmButton();
        });
        
        // ▼▼▼ 【新增】綁定“管理群成員”按鈕事件 ▼▼▼
        document.getElementById('manage-members-btn').addEventListener('click', () => {
            // 在切換螢幕前，先隱藏當前的聊天設置彈窗
            //document.getElementById('chat-settings-modal').classList.remove('visible');
            // 然後再打開成員管理螢幕
            openMemberManagementScreen();
        });
        // ▲▲▲ 新增代碼結束 ▲▲▲
        
        // ▼▼▼ 【最終完整版】群成員管理功能事件綁定 ▼▼▼
        document.getElementById('back-from-member-management').addEventListener('click', () => {
        
            showScreen('chat-interface-screen');    
            document.getElementById('chat-settings-btn').click();
        });
        // ▲▲▲ 替換結束 ▲▲▲
        
        document.getElementById('member-management-list').addEventListener('click', (e) => {
            // 【已恢復】移除成員的事件
            if (e.target.classList.contains('remove-member-btn')) {
                removeMemberFromGroup(e.target.dataset.memberId);
            }
        });
        
        document.getElementById('add-existing-contact-btn').addEventListener('click', async () => {
            // 【已恢復】從好友列表添加的事件
            // 【關鍵】為“完成”按鈕綁定“拉人入群”的邏輯
            const confirmBtn = document.getElementById('confirm-contact-picker-btn');
            // 使用克隆節點方法清除舊的事件監聽器，防止重複綁定
            const newConfirmBtn = confirmBtn.cloneNode(true);
            confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
            newConfirmBtn.addEventListener('click', handleAddMembersToGroup);
            
            await openContactPickerForAddMember();
        });
        
        document.getElementById('create-new-member-btn').addEventListener('click', createNewMemberInGroup);
        // ▲▲▲ 替換結束 ▲▲▲
        
        // ▼▼▼ 【全新】視頻通話功能事件監聽器 ▼▼▼
        
        // 綁定單聊和群聊的發起按鈕
        document.getElementById('video-call-btn').addEventListener('click', handleInitiateCall);
        document.getElementById('group-video-call-btn').addEventListener('click', handleInitiateCall);
        
        // 綁定“掛斷”按鈕
        document.getElementById('hang-up-btn').addEventListener('click', endVideoCall);
        
        // 綁定“取消呼叫”按鈕
        document.getElementById('cancel-call-btn').addEventListener('click', () => {
            videoCallState.isAwaitingResponse = false;
            showScreen('chat-interface-screen');
        });
        
        // 【全新】綁定“加入通話”按鈕
        document.getElementById('join-call-btn').addEventListener('click', handleUserJoinCall);
        
        // ▼▼▼ 用這個【已修復並啟動旁觀模式】的版本替換舊的 decline-call-btn 事件監聽器 ▼▼▼
        // 綁定來電請求的“拒絕”按鈕
        document.getElementById('decline-call-btn').addEventListener('click', async () => {
            hideIncomingCallModal();
            const chat = state.chats[videoCallState.activeChatId];
            if (!chat) return;
            
            // 【核心修正】在這裡，我們將拒絕的邏輯與API調用連接起來
            if (videoCallState.isGroupCall) {
                videoCallState.isUserParticipating = false; // 標記使用者為旁觀者
                
                // 1. 創建一條隱藏消息，通知AI使用者拒絕了
                const systemNote = {
                    role: 'system',
                    content: `[系統提示：用戶拒絕了通話邀請，但你們可以自己開始。請你們各自決策是否加入。]`,
                    timestamp: Date.now(),
                    isHidden: true
                };
                chat.history.push(systemNote);
                await db.chats.put(chat);
                
                // 2. 【關鍵】觸發AI回應，讓它們自己決定要不要開始群聊
                // 這將會在幕後處理，如果AI們決定開始，最終會調用 startVideoCall()
                await triggerAiResponse(); 
                
            } else { // 單聊拒絕邏輯保持不變
                const declineMessage = { role: 'user', content: '我拒絕了你的視頻通話請求。', timestamp: Date.now() };
                chat.history.push(declineMessage);
                await db.chats.put(chat);
                
                // 回到聊天介面並顯示拒絕消息
                showScreen('chat-interface-screen');
                appendMessage(declineMessage, chat);
                
                // 讓AI對你的拒絕做出回應
                triggerAiResponse();
            }
            
            // 清理狀態，以防萬一
            videoCallState.isAwaitingResponse = false;
        });
        // ▲▲▲ 替換結束 ▲▲▲
        
        // ▼▼▼ 用這個【已修復重複頭像BUG】的版本替換舊的 accept-call-btn 事件監聽器 ▼▼▼
        // 綁定來電請求的“接聽”按鈕
        document.getElementById('accept-call-btn').addEventListener('click', async () => {
            hideIncomingCallModal();
            
            videoCallState.initiator = 'ai';
            videoCallState.isUserParticipating = true;
            videoCallState.activeChatId = state.activeChatId;
            
            // 【核心修正】我們在這裡不再手動添加用戶到 participants 列表
            if (videoCallState.isGroupCall) {
                // 對於群聊，我們只把【發起通話的AI】加入參與者列表
                const chat = state.chats[videoCallState.activeChatId];
                const requester = chat.members.find(m => m.name === videoCallState.callRequester);
                if (requester) {
                    // 清空可能存在的舊資料，然後只添加發起者
                    videoCallState.participants = [requester];
                } else {
                    videoCallState.participants = []; // 如果找不到發起者，就清空
                }
            }
            
            // 無論單聊還是群聊，直接啟動通話介面！
            startVideoCall();
        });
        // ▲▲▲ 替換結束 ▲▲▲
        
        
        // ▼▼▼ 請用這個【已增加用戶高亮】的全新版本，完整替換舊的 user-speak-btn 事件監聽器 ▼▼▼
        // 綁定使用者在通話中發言的按鈕
        document.getElementById('user-speak-btn').addEventListener('click', async () => {
            if (!videoCallState.isActive) return;
        
            // ★★★★★ 核心新增：在彈出輸入框前，先找到並高亮用戶頭像 ★★★★★
            const userAvatar = document.querySelector('.participant-avatar-wrapper[data-participant-id="user"] .participant-avatar');
            if (userAvatar) {
                userAvatar.classList.add('speaking');
            }
        
            const userInput = await showCustomPrompt('你說', '請輸入你想說的話...');
            
            // ★★★★★ 核心新增：無論用戶是否輸入，只要關閉輸入框就移除高亮 ★★★★★
            if (userAvatar) {
                userAvatar.classList.remove('speaking');
            }
        
            if (userInput && userInput.trim()) {
                triggerAiInCallAction(userInput.trim());
            }
        });
        // ▲▲▲ 替換結束 ▲▲▲
        
        // ▼▼▼ 【新增】回憶錄相關事件綁定 ▼▼▼
        // 1. 將“回憶”頁簽和它的視圖連接起來
        document.querySelector('.nav-item[data-view="memories-view"]').addEventListener('click', () => {
            // 在切換前，確保"收藏"頁面的編輯模式已關閉
            if (isFavoritesSelectionMode) {
                document.getElementById('favorites-edit-btn').click(); 
            }
            switchToChatListView('memories-view');
            renderMemoriesScreen(); // 點擊時渲染
        });
        
        // 2. 綁定回憶錄介面的返回按鈕
        document.getElementById('memories-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));
        
        // ▲▲▲ 新增結束 ▲▲▲
        
        // ▼▼▼ 在 init() 函數的事件監聽器區域找到這個按鈕的監聽器 ▼▼▼
        document.getElementById('confirm-create-countdown-btn').addEventListener('click', async () => {
            const title = document.getElementById('countdown-title-input').value.trim();
            const dateValue = document.getElementById('countdown-date-input').value;
            
            if (!title || !dateValue) {
                alert('請填寫完整的約定標題和日期！');
                return;
            }
        
            const targetDate = new Date(dateValue);
            if (isNaN(targetDate) || targetDate <= new Date()) {
                alert('請輸入一個有效的、未來的日期！');
                return;
            }
        
            // ▼▼▼ 將其【替換為】下面這段【新代碼】▼▼▼
            const newCountdown = {
                authorId: 'user', // 【核心修復2】不再存 authorName，而是用 'user' 作為您的專屬ID
                description: title,
                timestamp: Date.now(),
                type: 'countdown',
                targetDate: targetDate.getTime()
            };
            // ▲▲▲ 替換結束 ▲▲▲
            
            await db.memories.add(newCountdown);
            document.getElementById('create-countdown-modal').classList.remove('visible');
            renderMemoriesScreen();
        });
        
        // 【全新】拉黑功能事件綁定
        document.getElementById('block-chat-btn').addEventListener('click', async () => {
            if (!state.activeChatId || state.chats[state.activeChatId].isGroup) return;
        
            const chat = state.chats[state.activeChatId];
            const confirmed = await showCustomConfirm(
                '確認拉黑', 
                `確定要拉黑“${chat.name}”嗎？拉黑後您將無法向其發送消息，直到您將Ta移出黑名單，或等待Ta重新申請好友。`,
                { confirmButtonClass: 'btn-danger' }
            );
        
            if (confirmed) {
                chat.relationship.status = 'blocked_by_user';
                chat.relationship.blockedTimestamp = Date.now();
        
                // ▼▼▼ 在這裡添加下面的代碼 ▼▼▼
                const hiddenMessage = {
                    role: 'system',
                    content: `[系統提示：你剛剛被用戶拉黑了。在對方解除拉黑之前，你無法再主動發起對話，也無法回應。]`,
                    timestamp: Date.now() + 1,
                    isHidden: true
                };
                chat.history.push(hiddenMessage);
                // ▲▲▲ 添加結束 ▲▲▲
        
                await db.chats.put(chat);
                
                // 關閉設置彈窗，並刷新聊天介面
                document.getElementById('chat-settings-modal').classList.remove('visible');
                renderChatInterface(state.activeChatId);
                // 刷新聊天列表，可能會有UI變化
                renderChatList();
            }
        });
        
        document.getElementById('chat-lock-overlay').addEventListener('click', async (e) => {
            const chat = state.chats[state.activeChatId];
            if (!chat) return;
        
            if (e.target.id === 'force-apply-check-btn') {
                alert("正在手動觸發好友申請流程，請稍後...\n如果API調用成功，將彈出提示。如果失敗，也會有錯誤提示。如果長時間無反應，說明AI可能決定暫時不申請。");
                await triggerAiFriendApplication(chat.id);
                renderChatInterface(chat.id); 
                return;
            }
        
            if (e.target.id === 'unblock-btn') {
                chat.relationship.status = 'friend';
                chat.relationship.blockedTimestamp = null;
        
                // ▼▼▼ 在這裡添加下面的代碼 ▼▼▼
                const hiddenMessage = {
                    role: 'system',
                    content: `[系統提示：用戶剛剛解除了對你的拉黑。現在你們可以重新開始對話了。]`,
                    timestamp: Date.now(),
                    isHidden: true
                };
                chat.history.push(hiddenMessage);
                // ▲▲▲ 添加結束 ▲▲▲
        
                await db.chats.put(chat);
                renderChatInterface(chat.id);
                renderChatList();
                triggerAiResponse(); // 【可選但推薦】解除後讓AI主動說點什麼
            }
        else if (e.target.id === 'accept-friend-btn') {
                // 1. 核心修正：不再觸發AI響應，避免邏輯混亂
                // triggerAiResponse(); // <-- 刪除或注釋掉這一行
        
                // 2. 直接更新關係狀態
                chat.relationship.status = 'friend';
                chat.relationship.applicationReason = '';
        
                // 3. 新增：直接在前端生成一條對使用者可見的系統消息，告知操作成功
                const systemMessage = {
                    role: 'system',
                    type: 'pat_message', // 複用居中樣式
                    content: `你通過了“${chat.name}”的好友請求`,
                    timestamp: Date.now()
                };
                chat.history.push(systemMessage);
        
                // 4. 新增：類比AI發來一條自然的歡迎消息，讓交互更流暢
                const welcomeMessage = {
                    role: 'assistant',
                    senderName: chat.name,
                    content: '太好了！我們又可以聊天啦！',
                    timestamp: Date.now() + 1 // 時間戳記+1確保在系統消息之後
                };
                chat.history.push(welcomeMessage);
        
                // 5. 一次性將所有更改保存到資料庫
                await db.chats.put(chat);
        
                // 6. 刷新UI，顯示最新的狀態和消息
                renderChatInterface(chat.id);
                renderChatList();
            }
            else if (e.target.id === 'reject-friend-btn') {
                chat.relationship.status = 'blocked_by_user';
                chat.relationship.blockedTimestamp = Date.now();
                chat.relationship.applicationReason = '';
                await db.chats.put(chat);
                renderChatInterface(chat.id);
            }
            // 【新增】處理申請好友按鈕的點擊事件
            else if (e.target.id === 'apply-friend-btn') {
                const reason = await showCustomPrompt(
                    '發送好友申請', 
                    `請輸入你想對“${chat.name}”說的申請理由：`,
                    "我們和好吧！"
                );
                // 只有當使用者輸入了內容並點擊“確定”後才繼續
                if (reason !== null) {
                    // 更新關係狀態為“等待AI批准”
                    chat.relationship.status = 'pending_ai_approval';
                    chat.relationship.applicationReason = reason;
                    await db.chats.put(chat);
        
                    // 刷新UI，顯示“等待通過”的介面
                    renderChatInterface(chat.id);
                    renderChatList();
                    
                    // 【關鍵】觸發AI回應，讓它去處理這個好友申請
                    triggerAiResponse();
                }
            }
        });
        
        // ▼▼▼ 【全新】紅包功能事件綁定 ▼▼▼
        
        // 1. 將原有的轉帳按鈕(￥)的點擊事件，重定向到新的總入口函數
        document.getElementById('transfer-btn').addEventListener('click', handlePaymentButtonClick);
        
        // 2. 紅包模態框內部的控制按鈕
        document.getElementById('cancel-red-packet-btn').addEventListener('click', () => {
            document.getElementById('red-packet-modal').classList.remove('visible');
        });
        document.getElementById('send-group-packet-btn').addEventListener('click', sendGroupRedPacket);
        document.getElementById('send-direct-packet-btn').addEventListener('click', sendDirectRedPacket);
        
        // 3. 紅包模態框的頁簽切換邏輯
        const rpTabGroup = document.getElementById('rp-tab-group');
        const rpTabDirect = document.getElementById('rp-tab-direct');
        const rpContentGroup = document.getElementById('rp-content-group');
        const rpContentDirect = document.getElementById('rp-content-direct');
        
        rpTabGroup.addEventListener('click', () => {
            rpTabGroup.classList.add('active');
            rpTabDirect.classList.remove('active');
            rpContentGroup.style.display = 'block';
            rpContentDirect.style.display = 'none';
        });
        rpTabDirect.addEventListener('click', () => {
            rpTabDirect.classList.add('active');
            rpTabGroup.classList.remove('active');
            rpContentDirect.style.display = 'block';
            rpContentGroup.style.display = 'none';
        });
        
        // 4. 即時更新紅包金額顯示
        document.getElementById('rp-group-amount').addEventListener('input', (e) => {
            const amount = parseFloat(e.target.value) || 0;
            document.getElementById('rp-group-total').textContent = `¥ ${amount.toFixed(2)}`;
        });
        document.getElementById('rp-direct-amount').addEventListener('input', (e) => {
            const amount = parseFloat(e.target.value) || 0;
            document.getElementById('rp-direct-total').textContent = `¥ ${amount.toFixed(2)}`;
        });
        
        // ▲▲▲ 新事件綁定結束 ▲▲▲
        
        // ▼▼▼ 【全新添加】使用事件委託處理紅包點擊，修復失效問題 ▼▼▼
        document.getElementById('chat-messages').addEventListener('click', (e) => {
            // 1. 找到被點擊的紅包卡片
            const packetCard = e.target.closest('.red-packet-card');
            if (!packetCard) return; // 如果點擊的不是紅包，就什麼也不做
        
            // 2. 從紅包卡片的父級.message-bubble獲取時間戳記
            const messageBubble = packetCard.closest('.message-bubble');
            if (!messageBubble || !messageBubble.dataset.timestamp) return;
        
            // 3. 調用我們現有的處理函數
            const timestamp = parseInt(messageBubble.dataset.timestamp);
            handlePacketClick(timestamp);
        });
        // ▲▲▲ 新增代碼結束 ▲▲▲
        
        // ▼▼▼ 【全新】投票功能事件監聽器 ▼▼▼
        // 在輸入框工具列添加按鈕
        document.getElementById('send-poll-btn').addEventListener('click', openCreatePollModal);
        
        // 投票創建模態框的按鈕
        document.getElementById('add-poll-option-btn').addEventListener('click', addPollOptionInput);
        document.getElementById('cancel-create-poll-btn').addEventListener('click', () => {
            document.getElementById('create-poll-modal').classList.remove('visible');
        });
        document.getElementById('confirm-create-poll-btn').addEventListener('click', sendPoll);
        
        // 使用事件委託處理投票卡片內的所有點擊事件
        document.getElementById('chat-messages').addEventListener('click', (e) => {
            const pollCard = e.target.closest('.poll-card');
            if (!pollCard) return;
        
            const timestamp = parseInt(pollCard.dataset.pollTimestamp);
            if (isNaN(timestamp)) return;
            
            // 點擊了選項
            const optionItem = e.target.closest('.poll-option-item');
            if (optionItem && !pollCard.classList.contains('closed')) {
                handleUserVote(timestamp, optionItem.dataset.option);
                return;
            }
            
            // 點擊了動作按鈕（結束投票/查看結果）
            const actionBtn = e.target.closest('.poll-action-btn');
            if (actionBtn) {
                if (pollCard.classList.contains('closed')) {
                    showPollResults(timestamp);
                } else {
                    endPoll(timestamp);
                }
                return;
            }
        
            // 如果是已結束的投票，點擊卡片任何地方都可以查看結果
            if (pollCard.classList.contains('closed')) {
                showPollResults(timestamp);
            }
        });
        // ▲▲▲ 新事件監聽器黏貼結束 ▲▲▲
        
          // ▼▼▼ 【全新】AI頭像庫功能事件綁定 ▼▼▼
        document.getElementById('manage-ai-avatar-library-btn').addEventListener('click', openAiAvatarLibraryModal);
        // ▼▼▼ 【全新】為批量導入按鈕綁定事件 ▼▼▼
        // 綁定AI頭像庫的“批量”按鈕
        document.getElementById('add-ai-avatar-batch-btn').addEventListener('click', () => openBatchImportModal('ai'));
        
        // 綁定群頭像庫的“批量”按鈕
        document.getElementById('add-group-avatar-batch-btn').addEventListener('click', () => openBatchImportModal('group'));
        // ▲▲▲ 新增結束 ▲▲▲
        // ▼▼▼ 【請用這整塊代碼】替換舊的 add-ai-avatar-btn 事件監聽器 ▼▼▼
        // 綁定“URL”按鈕，調用我們剛剛重命名的函數
        document.getElementById('add-ai-avatar-url-btn').addEventListener('click', addAvatarToLibraryFromURL);
        
        // 【核心新增】綁定“上傳”按鈕，觸發隱藏的檔選擇器
        document.getElementById('add-ai-avatar-upload-btn').addEventListener('click', () => {
            document.getElementById('ai-avatar-upload-input').click();
        });
        
        // 【核心新增】為檔選擇器綁定 change 事件，這是處理上傳的核心入口
        document.getElementById('ai-avatar-upload-input').addEventListener('change', handleLocalAvatarUpload);
        // ▲▲▲ 替換結束 ▲▲▲
        document.getElementById('close-ai-avatar-library-btn').addEventListener('click', closeAiAvatarLibraryModal);
        // ▲▲▲ 新增結束 ▲▲▲
        // ▼▼▼ 【全新】群頭像庫功能事件綁定 ▼▼▼
        document.getElementById('manage-group-avatar-library-btn').addEventListener('click', openGroupAvatarLibraryModal);
        // ▼▼▼ 【請用這整塊代碼】替換舊的 add-group-avatar-btn 事件監聽器 ▼▼▼
        
        // 綁定“URL”按鈕，調用我們剛剛重命名的函數
        document.getElementById('add-group-avatar-url-btn').addEventListener('click', addAvatarToGroupLibraryFromURL);
        
        // 【核心新增】綁定“上傳”按鈕，觸發隱藏的檔選擇器
        document.getElementById('add-group-avatar-upload-btn').addEventListener('click', () => {
            document.getElementById('group-avatar-upload-input').click();
        });
        
        // 【核心新增】為檔選擇器綁定 change 事件，這是處理上傳的核心入口
        document.getElementById('group-avatar-upload-input').addEventListener('change', handleLocalGroupAvatarUpload);
        
        // ▲▲▲ 替換結束 ▲▲▲
        document.getElementById('close-group-avatar-library-btn').addEventListener('click', closeGroupAvatarLibraryModal);
        // ▲▲▲ 新增結束 ▲▲▲
        // ▼▼▼ 在 init() 的事件監聽區域，黏貼這段【新代碼】▼▼▼
// 為 EPhone 圖示設置網格綁定事件委託
document.getElementById('icon-settings-grid').addEventListener('click', (e) => {
    if (e.target.classList.contains('change-icon-btn')) {
        const item = e.target.closest('.icon-setting-item');
        const iconId = item.dataset.iconId;
        if (iconId) {
            handleIconChange(iconId, 'ephone', item);
        }
    }
});
        // ▲▲▲ 新代碼黏貼結束 ▲▲▲
        
        // ▼▼▼ 在 init() 函數的末尾，黏貼這段【全新的事件監聽器】 ▼▼▼
        
            document.getElementById('chat-messages').addEventListener('click', (e) => {
                // 使用 .closest() 向上查找被點擊的卡片
                const linkCard = e.target.closest('.link-share-card');
                if (linkCard) {
                    const timestamp = parseInt(linkCard.dataset.timestamp);
                    if (!isNaN(timestamp)) {
                        openBrowser(timestamp); // 調用我們的函數
                    }
                }
            });
        
            // 流覽器返回按鈕的事件監聽，確保它只綁定一次
            document.getElementById('browser-back-btn').addEventListener('click', () => {
                showScreen('chat-interface-screen');
            });
        
        // ▲▲▲ 新代碼黏貼結束 ▲▲▲
        // ▼▼▼ 請用這個【新代碼塊】替換舊的 qzoneStickerPanelState.panelEl.addEventListener ▼▼▼
        qzoneStickerPanelState.panelEl.addEventListener('click', async (e) => {
            const stickerItem = e.target.closest('.sticker-item');
            if (stickerItem && qzoneStickerPanelState.activePostId !== null) {
                // 從背景圖片樣式中提取URL
                const stickerUrl = stickerItem.style.backgroundImage.slice(5, -2);
                
                // 【核心修改】根據URL從全域表情狀態中找到完整的表情物件
                const stickerObject = state.userStickers.find(s => s.url === stickerUrl);
        
                if (stickerObject) {
                    // 將完整的表情物件傳遞給處理函數
                    await sendQzoneStickerComment(qzoneStickerPanelState.activePostId, stickerObject);
                } else {
                    console.warn("在動態評論區點擊了表情，但在表情庫中未找到對象:", stickerUrl);
                }
            }
        });
        
        // ▲▲▲ 替換結束 ▲▲▲
        
        // 【全新】全域點擊監聽，用於關閉打開的表情面板
        document.addEventListener('click', (e) => {
            if (qzoneStickerPanelState.isOpen && 
                !qzoneStickerPanelState.panelEl.contains(e.target) && 
                !e.target.closest('.comment-sticker-btn')) {
                closeQzoneStickerPanel();
            }
        });
        // ▼▼▼ 在 init() 函數的末尾，黏貼這段【全新的事件監聽器】 ▼▼▼
        
            // 1. 綁定輸入框上方“分享連結”按鈕的點擊事件
            document.getElementById('share-link-btn').addEventListener('click', openShareLinkModal);
        
            // 2. 綁定模態框中“取消”按鈕的點擊事件
            document.getElementById('cancel-share-link-btn').addEventListener('click', () => {
                document.getElementById('share-link-modal').classList.remove('visible');
            });
        
            // 3. 綁定模態框中“分享”按鈕的點擊事件
            document.getElementById('confirm-share-link-btn').addEventListener('click', sendUserLinkShare);
        
        // ▲▲▲ 新代碼黏貼結束 ▲▲▲
        
        document.getElementById('theme-toggle-switch').addEventListener('change', toggleTheme);
        

        // ▼▼▼ 在 init() 的事件監聽器區域添加這行代碼 ▼▼▼
        document.getElementById('share-location-btn').addEventListener('click', sendLocationShare);
        // 在你的 init() 函數的事件監聽器區域...
        

        // ▼▼▼ 用這段【新代碼】替換舊的通話記錄事件綁定 ▼▼▼
        
        document.getElementById('chat-list-title').addEventListener('click', renderCallHistoryScreen);
        
        // 2. 綁定通話記錄頁面的“返回”按鈕
        document.getElementById('call-history-back-btn').addEventListener('click', () => {
            // 【核心修改】返回到聊天清單頁面，而不是聊天介面
            showScreen('chat-list-screen');
        });
        
        // 3. 監聽卡片點擊的邏輯保持不變
        document.getElementById('call-history-list').addEventListener('click', (e) => {
            const card = e.target.closest('.call-record-card');
            if (card && card.dataset.recordId) {
                showCallTranscript(parseInt(card.dataset.recordId));
            }
        });
        
        // 4. 關閉詳情彈窗的邏輯保持不變
document.getElementById('close-call-transcript-btn').addEventListener('click', () => {
    document.getElementById('call-transcript-modal').classList.remove('visible');
});
        
        // ▲▲▲ 替換結束 ▲▲▲
        

        
        document.getElementById('chat-header-status').addEventListener('click', handleEditStatusClick);
        
        // 在 init() 的事件監聽器區域添加
        document.getElementById('selection-share-btn').addEventListener('click', () => {
            if (selectedMessages.size > 0) {
                openShareTargetPicker(); // 打開我們即將創建的目標選擇器
            }
        });
        document.getElementById('selection-screenshot-btn').addEventListener('click', handleLongScreenshot);
        // 在 init() 的事件監聽器區域添加
        document.getElementById('confirm-share-target-btn').addEventListener('click', async () => {
            const sourceChat = state.chats[state.activeChatId];
            const selectedTargetIds = Array.from(document.querySelectorAll('.share-target-checkbox:checked'))
                                           .map(cb => cb.dataset.chatId);
        
            if (selectedTargetIds.length === 0) {
                alert("請至少選擇一個要分享的聊天。");
                return;
            }
        
            // 1. 打包聊天記錄
            const sharedHistory = [];
            const sortedTimestamps = [...selectedMessages].sort((a, b) => a - b);
            for (const timestamp of sortedTimestamps) {
                const msg = sourceChat.history.find(m => m.timestamp === timestamp);
                if (msg) {
                    sharedHistory.push(msg);
                }
            }
            
            // 2. 創建分享卡片消息物件
            const shareCardMessage = {
                role: 'user',
                senderName: sourceChat.isGroup ? (sourceChat.settings.myNickname || '我') : '我',
                type: 'share_card',
                timestamp: Date.now(),
                payload: {
                    sourceChatName: sourceChat.name,
                    title: `來自“${sourceChat.name}”的聊天記錄`,
                    sharedHistory: sharedHistory
                }
            };
        
            // 3. 迴圈發送到所有目標聊天
            for (const targetId of selectedTargetIds) {
                const targetChat = state.chats[targetId];
                if (targetChat) {
                    targetChat.history.push(shareCardMessage);
                    await db.chats.put(targetChat);
                }
            }
            
            // 4. 收尾工作
            document.getElementById('share-target-modal').classList.remove('visible');
            exitSelectionMode(); // 退出多選模式
            await showCustomAlert("分享成功", `聊天記錄已成功分享到 ${selectedTargetIds.length} 個會話中。`);
            renderChatList(); // 刷新清單，可能會有新消息提示
        });
        
        // 綁定取消按鈕
        document.getElementById('cancel-share-target-btn').addEventListener('click', () => {
            document.getElementById('share-target-modal').classList.remove('visible');
        });
        
        // 在 init() 的事件監聽器區域添加
        document.getElementById('chat-messages').addEventListener('click', (e) => {
            // ...你已有的其他點擊事件邏輯...
        
            // 新增邏輯：處理分享卡片的點擊
            const shareCard = e.target.closest('.link-share-card[data-timestamp]');
            if (shareCard && shareCard.closest('.message-bubble.is-link-share')) {
                const timestamp = parseInt(shareCard.dataset.timestamp);
                openSharedHistoryViewer(timestamp);
            }
        });
        
        // 綁定檢視器的關閉按鈕
        document.getElementById('close-shared-history-viewer-btn').addEventListener('click', () => {
            document.getElementById('shared-history-viewer-modal').classList.remove('visible');
        });
        
        // 創建新函數來處理渲染邏輯
        function openSharedHistoryViewer(timestamp) {
            const chat = state.chats[state.activeChatId];
            const message = chat.history.find(m => m.timestamp === timestamp);
            if (!message || message.type !== 'share_card') return;
        
            const viewerModal = document.getElementById('shared-history-viewer-modal');
            const viewerTitle = document.getElementById('shared-history-viewer-title');
            const viewerContent = document.getElementById('shared-history-viewer-content');
        
            viewerTitle.textContent = message.payload.title;
            viewerContent.innerHTML = ''; // 清空舊內容
        
            // 【核心】複用 createMessageElement 來渲染每一條被分享的消息
            message.payload.sharedHistory.forEach(sharedMsg => {
                // 注意：這裡我們傳入的是 sourceChat 物件，以確保頭像、昵稱等正確
                const sourceChat = Object.values(state.chats).find(c => c.name === message.payload.sourceChatName) || chat;
                const bubbleEl = createMessageElement(sharedMsg, sourceChat);
                if (bubbleEl) {
                    viewerContent.appendChild(bubbleEl);
                }
            });
        
            viewerModal.classList.add('visible');
        }
        
        audioPlayer.addEventListener('timeupdate', updateMusicProgressBar);
        
        audioPlayer.addEventListener('pause', () => { 
            if(musicState.isActive) { 
                musicState.isPlaying = false; 
                updatePlayerUI(); 
            } 
        });
        audioPlayer.addEventListener('play', () => { 
            if(musicState.isActive) { 
                musicState.isPlaying = true; 
                updatePlayerUI(); 
            } 
        });
        
// ▼▼▼ 【最終修復版】請用這個全新的事件監聽器，替換舊的 playlist-body 監聽器 ▼▼▼

document.getElementById('playlist-body').addEventListener('click', async (e) => {
    const target = e.target;
    // 【【【核心新增邏輯就在這裡！】】】
    // 點擊“專輯”按鈕
    const albumArtBtn = target.closest('.album-art-btn');
    if (albumArtBtn) {
        const index = parseInt(albumArtBtn.dataset.index);
        if (!isNaN(index)) {
            // 調用我們剛剛添加的新函數
            await handleChangeAlbumArt(index);
        }
        return; // 處理完後直接退出
    }
    // 點擊“詞”按鈕
    const lyricsBtn = target.closest('.lyrics-btn');
    if (lyricsBtn) {
        const index = parseInt(lyricsBtn.dataset.index);
        if (isNaN(index)) return;

        // 【核心修復】我們現在只調用函數，不再需要處理它的返回值。
        // 因為所有必要的邏輯（包括保存）都已經在函數內部完成了。
        await handleManualLrcImport(index);

        return; // 處理完後直接退出
    }

    // 點擊“刪除”按鈕 (這部分邏輯不變)
    const deleteBtn = target.closest('.delete-track-btn');
    if (deleteBtn) {
        const index = parseInt(deleteBtn.dataset.index);
        if (isNaN(index)) return;
        const track = musicState.playlist[index];
        const confirmed = await showCustomConfirm('刪除歌曲', `確定要從播放清單中刪除《${track.name}》嗎？`);
        if (confirmed) {
            deleteTrack(index);
        }
        return;
    }

    // 點擊歌曲資訊區域 -> 播放歌曲 (這部分邏輯不變)
    const itemInfo = target.closest('.playlist-item-info');
    if (itemInfo) {
        const item = itemInfo.closest('.playlist-item');
        const index = Array.from(item.parentElement.children).indexOf(item);
        if (index > -1) {
            playSong(index);
        }
    }
});
// ▲▲▲ 替換結束 ▲▲▲
        
        document.querySelector('.progress-bar').addEventListener('click', (e) => {
            if (!audioPlayer.duration) return;
            const progressBar = e.currentTarget;
            const barWidth = progressBar.clientWidth;
            const clickX = e.offsetX;
            audioPlayer.currentTime = (clickX / barWidth) * audioPlayer.duration;
        });
        
        // ▼▼▼ 在 init() 函數的事件監聽器區域，黏貼這段新代碼 ▼▼▼
        
        // 使用事件委託來處理所有“已撤回消息”的點擊事件
        document.getElementById('chat-messages').addEventListener('click', (e) => {
            // 檢查被點擊的元素或其父元素是否是“已撤回”提示
// ▼▼▼ 【這是最終修復版】請用這整塊代碼，完整替換舊的 .recalled-message-placeholder 點擊事件邏輯 ▼▼▼
const placeholder = e.target.closest('.recalled-message-placeholder');
if (placeholder) {
    const chat = state.chats[state.activeChatId];
    const wrapper = placeholder.closest('.message-wrapper');
    if (chat && wrapper) {
        const timestamp = parseInt(wrapper.dataset.timestamp);
        const recalledMsg = chat.history.find(m => m.timestamp === timestamp);

        if (recalledMsg && recalledMsg.recalledData) {
            let originalContentText = '';
            const recalled = recalledMsg.recalledData;

            // --- 核心修復：在這裡添加對更多消息類型的判斷 ---
            switch (recalled.originalType) {
                case 'text':
                    originalContentText = `原文: "${recalled.originalContent}"`;
                    break;
                case 'user_photo':
                case 'ai_image':
                case 'text_image':
                    originalContentText = `[圖片/文字圖] 描述: "${recalled.originalContent}"`;
                    break;
                case 'voice_message':
                    originalContentText = `[語音] 內容: "${recalled.originalContent}"`;
                    break;
                case 'sticker':
                    // 對於表情，同時顯示含義和圖片URL
                    originalContentText = `[表情] 含義: "${recalled.originalMeaning || '(無)'}" \n URL: ${recalled.originalContent}`;
                    break;
                case 'transfer':
                    originalContentText = `一條[轉帳]消息已被撤回。`;
                    break;
                default:
                    // 對於其他未知類型，顯示類型和原始內容
                    originalContentText = `撤回了一條[${recalled.originalType}]類型的消息。\n內容: ${JSON.stringify(recalled.originalContent)}`;
                    break;
            }
            // --- 修復結束 ---

            showCustomAlert('已撤回的消息', originalContentText);
        }
    }
}
});
        
        // ▲▲▲ 新代碼黏貼結束 ▲▲▲
        
        // ▼▼▼ 在 init() 的事件監聽器區域，黏貼這段新代碼 ▼▼▼
        document.getElementById('manage-world-book-categories-btn').addEventListener('click', openCategoryManager);
        document.getElementById('close-category-manager-btn').addEventListener('click', () => {
            document.getElementById('world-book-category-manager-modal').classList.remove('visible');
            renderWorldBookScreen(); // 關閉後刷新主列表
        });
        document.getElementById('add-new-category-btn').addEventListener('click', addNewCategory);
        document.getElementById('existing-categories-list').addEventListener('click', (e) => {
            if (e.target.classList.contains('delete-group-btn')) {
                const categoryId = parseInt(e.target.dataset.id);
                deleteCategory(categoryId);
            }
        });
        // ▼▼▼ 在 init() 的事件監聽器區域末尾，添加這部分代碼 ▼▼▼
        document.getElementById('repost-cancel-btn').addEventListener('click', hideRepostModal);
        document.getElementById('repost-confirm-btn').addEventListener('click', handleConfirmRepost);
        // ▲▲▲ 添加結束 ▲▲▲

        // 在 init() 的事件監聽器區域末尾
        // ...
        // 綁定消息操作功能表中的“引用”按鈕
        document.getElementById('quote-message-btn').addEventListener('click', startReplyToMessage);
        
        // 綁定回復預覽欄中的“取消”按鈕
        document.getElementById('cancel-reply-btn').addEventListener('click', cancelReplyMode);
        // ...
        // ▲▲▲ 新代碼黏貼結束 ▲▲▲
        
                // ===================================================================
                // 5. 啟動！
        // 在第 9660 行，showScreen('home-screen'); 的前面，黏貼下面的代碼
        
            // ▼▼▼ 【請將這段全新的代碼黏貼進去】 ▼▼▼
            
            // 使用事件委託，為動態評論區的@功能綁定事件
            document.getElementById('qzone-posts-list').addEventListener('input', (e) => {
                if (!e.target.matches('.comment-input')) return;
        
                const commentInput = e.target;
                const postContainer = commentInput.closest('.qzone-post-container');
                if (!postContainer) return;
                
                const popup = postContainer.querySelector('.at-mention-popup');
                const value = commentInput.value;
                const atMatch = value.match(/@([\p{L}\w]*)$/u);
        
                if (atMatch) {
                    const namesToMention = new Set();
                    const authorNickname = postContainer.querySelector('.post-nickname')?.textContent;
                    if (authorNickname) namesToMention.add(authorNickname);
                    postContainer.querySelectorAll('.commenter-name').forEach(nameEl => {
                        namesToMention.add(nameEl.textContent.replace(':', ''));
                    });
                    namesToMention.delete(state.qzoneSettings.nickname);
        
                    popup.innerHTML = '';
                    if (namesToMention.size > 0) {
                        const searchTerm = atMatch[1];
                        namesToMention.forEach(name => {
                            if (name.toLowerCase().includes(searchTerm.toLowerCase())) {
                                const item = document.createElement('div');
                                item.className = 'at-mention-item';
                                item.textContent = name;
                                item.addEventListener('mousedown', (evt) => {
                                    evt.preventDefault();
                                    const newText = value.substring(0, atMatch.index) + `@${name} `;
                                    commentInput.value = newText;
                                    popup.style.display = 'none';
                                    commentInput.focus();
                                });
                                popup.appendChild(item);
                            }
                        });
                        popup.style.display = popup.children.length > 0 ? 'block' : 'none';
                    } else {
                        popup.style.display = 'none';
                    }
                } else {
                    popup.style.display = 'none';
                }
            });
        
            document.getElementById('qzone-posts-list').addEventListener('focusout', (e) => {
                if (e.target.matches('.comment-input')) {
                    const postContainer = e.target.closest('.qzone-post-container');
                    if (postContainer) {
                        const popup = postContainer.querySelector('.at-mention-popup');
                        if (popup) {
                            setTimeout(() => { popup.style.display = 'none'; }, 200);
                        }
                    }
                }
            });
        
            // ▲▲▲ 【新代碼黏貼結束】 ▲▲▲  
        // ▼▼▼ 把下面這段新代碼完整黏貼到 showScreen('home-screen'); 的前面 ▼▼▼
        
        // 【全新】為【主聊天輸入框】添加@功能
        const chatInputForMention = document.getElementById('chat-input');
        const chatMentionPopup = document.getElementById('chat-at-mention-popup');
        
        chatInputForMention.addEventListener('input', () => {
            // 1. 首先，檢查當前是否在群聊中
            if (!state.activeChatId || !state.chats[state.activeChatId].isGroup) {
                chatMentionPopup.style.display = 'none';
                return;
            }
            
            const chat = state.chats[state.activeChatId];
            const value = chatInputForMention.value;
            const atMatch = value.match(/@([\p{L}\w]*)$/u);
        
            if (atMatch) {
                // 2. 收集群成員名單 (排除自己)
                const myNickname = chat.settings.myNickname || '我';
                const namesToMention = chat.members
                    .map(member => member.groupNickname)
                    .filter(name => name !== myNickname);
        
                chatMentionPopup.innerHTML = '';
                if (namesToMention.length > 0) {
                    const searchTerm = atMatch[1];
                    // 3. 篩選並生成列表
                    namesToMention.forEach(name => {
                        if (name.toLowerCase().includes(searchTerm.toLowerCase())) {
                            const item = document.createElement('div');
                            item.className = 'at-mention-item';
                            item.textContent = name;
                            // 4. 綁定點擊事件
                            item.addEventListener('mousedown', (e) => {
                                e.preventDefault();
                                const newText = value.substring(0, atMatch.index) + `@${name} `;
                                chatInputForMention.value = newText;
                                chatMentionPopup.style.display = 'none';
                                chatInputForMention.focus();
                            });
                            chatMentionPopup.appendChild(item);
                        }
                    });
                    // 5. 顯示或隱藏彈窗
                    chatMentionPopup.style.display = chatMentionPopup.children.length > 0 ? 'block' : 'none';
                } else {
                    chatMentionPopup.style.display = 'none';
                }
            } else {
                chatMentionPopup.style.display = 'none';
            }
        });
        
        // 當輸入框失去焦點時，隱藏彈窗
        chatInputForMention.addEventListener('blur', () => {
            setTimeout(() => { chatMentionPopup.style.display = 'none'; }, 200);
        });
        // ▲▲▲ 新代碼黏貼到這裡結束 ▲▲▲     
        // ▼▼▼ 【全新】新版群公告事件綁定 ▼▼▼
        document.getElementById('publish-to-announcement-btn').addEventListener('click', publishToAnnouncementBoard);
        document.getElementById('show-announcement-board-btn').addEventListener('click', showAnnouncementBoard);
        document.getElementById('close-announcement-board-btn').addEventListener('click', () => {
            document.getElementById('announcement-board-modal').classList.remove('visible');
        });
        // ▲▲▲ 新增結束 ▲▲▲  
        // ▼▼▼ 【全新】公告板內部事件委託與操作功能表事件綁定 ▼▼▼
        document.getElementById('announcement-board-content').addEventListener('click', (e) => {
            if (e.target.classList.contains('announcement-item-actions')) {
                const annoId = e.target.dataset.annoId;
                if (annoId) {
                    showAnnouncementActions(annoId);
                }
            }
        });
        
        document.getElementById('announcement-action-pin').addEventListener('click', handlePinAnnouncement);
        document.getElementById('announcement-action-delete').addEventListener('click', handleDeleteAnnouncement);
        document.getElementById('announcement-action-cancel').addEventListener('click', () => {
            document.getElementById('announcement-actions-modal').classList.remove('visible');
        });
        // ▲▲▲ 新增結束 ▲▲▲   
                    // ▼▼▼ 把新代碼完整黏貼在這裡 ▼▼▼
                    document.getElementById('reset-global-css-btn').addEventListener('click', () => {
                        document.getElementById('global-css-input').value = '';
                        // (可選) 如果希望點擊重置後立刻看到效果，可以加上下面這行
                        // applyGlobalCss('');
                    });
        // ▼▼▼ 【最終修復版】請用這個全新的事件監聽器，替換舊的長期記憶功能事件綁定 ▼▼▼
        // 聊天介面頂部新按鈕 -> 打開全屏頁面
        document.getElementById('open-memory-screen-btn').addEventListener('click', openLongTermMemoryScreen);
        
        // 長期記憶頁面返回按鈕 -> 返回聊天介面
        document.getElementById('memory-screen-back-btn').addEventListener('click', () => {
            showScreen('chat-interface-screen');
        });
        
        // 長期記憶頁面頂部“+”按鈕 -> 手動添加
        document.getElementById('add-manual-memory-btn-header').addEventListener('click', handleAddManualMemory);
        
        // 長期記憶頁面頂部“總結”按鈕 -> 手動總結
        document.getElementById('summarize-recent-btn-header').addEventListener('click', handleManualSummary);
        
        // 【【【核心修復就在這裡！】】】
document.getElementById('memory-list-container').addEventListener('click', (e) => {
    const editBtn = e.target.closest('.edit-memory-btn');
    if (editBtn) {
        handleEditMemory(editBtn.dataset.authorId, parseInt(editBtn.dataset.memoryTimestamp));
        return;
    }
    const deleteBtn = e.target.closest('.delete-memory-btn');
    if (deleteBtn) {
        handleDeleteMemory(deleteBtn.dataset.authorId, parseInt(deleteBtn.dataset.memoryTimestamp));
        return;
    }
});
        // ▲▲▲ 替換結束 ▲▲▲
        // ▼▼▼ 【全新】五子棋功能事件監聽器 ▼▼▼
        document.getElementById('gomoku-btn').addEventListener('click', toggleGomokuBoard);
        document.getElementById('close-gomoku-btn').addEventListener('click', closeGomokuBoard);
        
        const gomokuCanvas = document.getElementById('gomoku-board');
        gomokuCanvas.addEventListener('mousemove', handleBoardHover);
        gomokuCanvas.addEventListener('mouseout', () => renderGomokuBoard(state.activeChatId)); // Clear hover on exit
        gomokuCanvas.addEventListener('click', handleBoardClick);
        // ▲▲▲ 新增代碼結束 ▲▲▲
        // ▼▼▼ 【這是修復代碼】請將這段代碼黏貼到 init() 函數的事件監聽器區域末尾 ▼▼▼
        document.getElementById('add-countdown-btn').addEventListener('click', () => {
            // 清空輸入框
            document.getElementById('countdown-title-input').value = '';
            document.getElementById('countdown-date-input').value = '';
            // 顯示新建約定彈窗
            document.getElementById('create-countdown-modal').classList.add('visible');
        });
        
        // 為新建約定彈窗的“取消”按鈕也綁定事件
        document.getElementById('cancel-create-countdown-btn').addEventListener('click', () => {
            document.getElementById('create-countdown-modal').classList.remove('visible');
        });
        // ▲▲▲ 修復代碼黏貼結束 ▲▲▲
        
                    // ▼▼▼ 【全新】視頻通話消息操作事件綁定 ▼▼▼
        document.getElementById('edit-call-message-btn').addEventListener('click', openCallMessageEditor);
        document.getElementById('delete-call-message-btn').addEventListener('click', deleteCallMessage);
        document.getElementById('cancel-call-message-action-btn').addEventListener('click', hideCallMessageActions);
        // ▲▲▲ 新增結束 ▲▲▲
        // ▼▼▼ 【全新】導演模式事件綁定 ▼▼▼
        document.getElementById('edit-last-response-btn').addEventListener('click', openAiResponseEditor);
        document.getElementById('cancel-ai-response-editor-btn').addEventListener('click', () => {
            document.getElementById('ai-response-editor-modal').classList.remove('visible');
        });
        document.getElementById('save-ai-response-editor-btn').addEventListener('click', saveEditedAiResponse);
        document.getElementById('add-ai-response-block-btn').addEventListener('click', () => {
            // 點擊添加按鈕時，創建一個空的、帶範本的編輯塊
            const container = document.getElementById('ai-response-editor-container');
            const newBlock = createAiResponseEditorBlock('{\n  "type": "text",\n  "content": "在這裡輸入新消息..."\n}');
            container.appendChild(newBlock);
            newBlock.querySelector('textarea').focus();
        });
        // ▲▲▲ 新增事件綁定結束 ▲▲▲
        // ▼▼▼ 【全新】“我的”頭像庫功能事件綁定 ▼▼▼
        document.getElementById('manage-my-avatar-library-btn').addEventListener('click', openMyAvatarLibraryModal);
        document.getElementById('close-my-avatar-library-btn').addEventListener('click', closeMyAvatarLibraryModal);
        document.getElementById('add-my-avatar-url-btn').addEventListener('click', addAvatarToMyLibraryFromURL);
        document.getElementById('add-my-avatar-upload-btn').addEventListener('click', () => {
            document.getElementById('my-avatar-upload-input').click();
        });
        document.getElementById('my-avatar-upload-input').addEventListener('change', handleLocalMyAvatarUpload);
        document.getElementById('add-my-avatar-batch-btn').addEventListener('click', async () => {
            const placeholderText = `請按照以下格式黏貼，一行一個：\n\n焦慮 2a9wte.jpeg\n大驚失色 or8qf4.png\n沒有靈感 njwujh.jpeg`;
            const pastedText = await showCustomPrompt('批量導入頭像', placeholderText, '', 'textarea');
            if (pastedText && pastedText.trim()) {
                await handleBatchImportForMyAvatar(pastedText);
            }
        });
        // ▲▲▲ 新增結束 ▲▲▲
        // ▼▼▼ 【全新】購物功能事件綁定 (V6.0 - 支援指定收禮人) ▼▼▼
        document.getElementById('open-shopping-btn').addEventListener('click', openShoppingScreen);
        document.getElementById('shopping-back-btn').addEventListener('click', () => showScreen('chat-interface-screen'));
        document.getElementById('go-to-cart-btn').addEventListener('click', openCartScreen);
        document.getElementById('cart-back-btn').addEventListener('click', openShoppingScreen);
        document.getElementById('checkout-btn').addEventListener('click', handleCheckout);
        document.getElementById('close-receipt-btn').addEventListener('click', () => {
            document.getElementById('gift-receipt-modal').classList.remove('visible');
        });
        
        // "管理"按鈕
document.getElementById('manage-products-btn').addEventListener('click', () => {
    isProductManagementMode = !isProductManagementMode;
    const btn = document.getElementById('manage-products-btn');
    const actionBar = document.getElementById('shopping-action-bar');
    const gridEl = document.getElementById('product-grid');

    btn.style.color = isProductManagementMode ? 'var(--accent-color)' : 'var(--text-primary)';

    if (isProductManagementMode) {
        actionBar.style.display = 'flex'; // 顯示操作欄
        gridEl.style.paddingBottom = '80px'; // 為操作欄留出空間
    } else {
        actionBar.style.display = 'none'; // 隱藏操作欄
        gridEl.style.paddingBottom = ''; // 恢復默認
        // 退出時清空選擇
        selectedProducts.clear();
        document.querySelectorAll('.product-item.selected').forEach(item => item.classList.remove('selected'));
        document.getElementById('delete-selected-products-btn').textContent = `刪除 (0)`;
        document.getElementById('select-all-products-checkbox').checked = false;
    }

    // 【重要】在切換模式後，重繪商品清單以顯示或隱藏對應的UI
    renderShoppingProducts();
});
        
        // “添加商品”按鈕
        document.getElementById('add-new-product-btn').addEventListener('click', () => {
            if (isProductManagementMode) {
                openProductEditor(null);
            } else {
                alert("請先點擊扳手圖示進入管理模式，才能添加新商品。");
            }
        });
        
        // 商品列表事件委託
// ▼▼▼ 【請用這個新版本】替換舊的 'product-grid' 事件監聽器 ▼▼▼
        document.getElementById('product-grid').addEventListener('click', async e => {
            const productItem = e.target.closest('.product-item');
            if (!productItem) return;
            const productId = parseInt(productItem.dataset.id);
            if (isNaN(productId)) return;

            // 【核心修改】處理管理模式下的邏輯
            if (isProductManagementMode) {
                // 如果點擊的是“編輯”按鈕，則執行編輯並停止
                if (e.target.classList.contains('edit-product-btn')) {
                    openProductEditor(productId);
                    return;
                }
                // 如果點擊的是“刪除”按鈕，則執行刪除並停止
                if (e.target.classList.contains('delete-product-btn')) {
                    const product = await db.shoppingProducts.get(productId);
                    if (!product) return;
                    const confirmed = await showCustomConfirm('刪除商品', `確定要永久刪除商品 “${product.name}” 嗎？`, { confirmButtonClass: 'btn-danger' });
                    if(confirmed) {
                         await db.shoppingProducts.delete(productId);
                         await renderShoppingProducts(); // 刷新列表
                         alert("商品已刪除。");
                    }
                    return;
                }
                
                // 如果點擊的不是以上按鈕，才執行“選擇”操作
                productItem.classList.toggle('selected');
                if (selectedProducts.has(productId)) {
                    selectedProducts.delete(productId);
                } else {
                    selectedProducts.add(productId);
                }
                document.getElementById('delete-selected-products-btn').textContent = `刪除 (${selectedProducts.size})`;
                return;
            }

            // --- 非管理模式下的邏輯 (保持不變) ---
            if (e.target.classList.contains('add-to-cart-btn')) {
                const product = await db.shoppingProducts.get(productId);
                if (product.variations && product.variations.length > 0) {
                    openVariationSelector(productId);
                } else {
                    await addToCart(productId);
                    await showCustomAlert('成功', '已成功加入購物車！');
                }
                return;
            }

            // 點擊卡片本身，未來可以用於查看詳情
            if (productItem.contains(e.target)) {
                 console.log(`點擊了商品卡片: ${productId}`);
            }
        });
// ▲▲▲ 替換結束 ▲▲▲
        
        // 購物車列表事件委託
        document.getElementById('cart-items-list').addEventListener('click', e => {
            const target = e.target;
            if (target.classList.contains('decrease-qty-btn')) {
                updateCartItemQuantity(parseInt(target.dataset.id), -1);
            }
            if (target.classList.contains('increase-qty-btn')) {
                updateCartItemQuantity(parseInt(target.dataset.id), 1);
            }
            if (target.classList.contains('cart-item-checkbox')) {
                updateCartTotal();
            }
        });
        
        // 購物車清空按鈕
        document.getElementById('clear-cart-btn').addEventListener('click', async () => {
            if (shoppingCart.length === 0) return;
            const confirmed = await showCustomConfirm('清空購物車', '確定要清空購物車中的所有商品嗎？');
            if (confirmed) {
                shoppingCart = [];
                updateCartCount();
                renderCartItems();
            }
        });
        
        // 購物車全選
        document.getElementById('select-all-cart-items').addEventListener('change', function(e) {
            document.querySelectorAll('.cart-item-checkbox').forEach(cb => {
                cb.checked = e.target.checked;
            });
            updateCartTotal();
        });
        
        // 商品編輯器彈窗按鈕
        document.getElementById('cancel-product-editor-btn').addEventListener('click', () => {
            document.getElementById('product-editor-modal').classList.remove('visible');
        });
        document.getElementById('save-product-btn').addEventListener('click', saveProduct);
        document.getElementById('product-image-input').addEventListener('change', e => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (re) => { document.getElementById('product-image-preview').src = re.target.result; };
                reader.readAsDataURL(file);
            }
        });
        
        // 聊天介面禮物卡片點擊事件
        document.getElementById('chat-messages').addEventListener('click', e => {
            const giftCard = e.target.closest('.gift-card');
            if (giftCard) {
                const bubble = giftCard.closest('.message-bubble');
                if (bubble) {
                    showGiftReceipt(parseInt(bubble.dataset.timestamp));
                }
            }
        });
        
        // 【全新】禮物接收人選擇彈窗的事件綁定
        document.getElementById('cancel-gift-recipient-btn').addEventListener('click', () => {
            document.getElementById('gift-recipient-modal').classList.remove('visible');
        });
        
        // ▼▼▼ 請用這個【已修復】的新事件監聽器替換舊的 'confirm-gift-recipient-btn' 監聽器 ▼▼▼
        document.getElementById('confirm-gift-recipient-btn').addEventListener('click', async () => {
            // 步驟 1: (保持不變) 獲取選中的收禮人
            const selectedRecipients = Array.from(document.querySelectorAll('#gift-recipient-list .contact-picker-item.selected'))
                .map(item => item.dataset.recipientName);
            
            if (selectedRecipients.length === 0) {
                alert("請至少選擇一位收禮人。");
                return;
            }
            
            // 步驟 2: 【【【核心修復】】】 在這裡，重新從購物車獲取一次選中的商品
            const selectedItems = shoppingCart.filter(item => 
                document.querySelector(`.cart-item-checkbox[data-id="${item.productId}"]:checked`)
            );
            
            // 步驟 3: (保持不變) 調用發送函數，此時兩個參數都是正確的
            await sendGiftMessage(selectedItems, selectedRecipients);
            
            // 步驟 4: (保持不變) 關閉彈窗
            document.getElementById('gift-recipient-modal').classList.remove('visible');
        });
        // ▲▲▲ 替換結束 ▲▲▲
        
        document.getElementById('gift-recipient-list').addEventListener('click', (e) => {
            const item = e.target.closest('.contact-picker-item');
            if (item) {
                item.classList.toggle('selected');
            }
        });
        
        document.getElementById('select-all-recipients').addEventListener('change', function(e) {
            const isChecked = e.target.checked;
            document.querySelectorAll('#gift-recipient-list .contact-picker-item').forEach(item => {
                item.classList.toggle('selected', isChecked);
            });
        });
        // ▲▲▲ 新增事件綁定結束 ▲▲▲
        // ▼▼▼ 【全新】為重新生成按鈕綁定事件 ▼▼▼
        document.getElementById('regenerate-btn').addEventListener('click', handleRegenerateResponse);
        document.getElementById('regenerate-call-btn').addEventListener('click', handleRegenerateCallResponse);
        // ▲▲▲ 新增事件綁定結束 ▲▲▲  
        // ▼▼▼ 【全新】為推進劇情按鈕綁定事件 ▼▼▼
        document.getElementById('propel-btn').addEventListener('click', handlePropelAction);
        // 下面這行代碼已被安全地注釋掉，因為它對應的HTML按鈕不存在
        // document.getElementById('propel-call-btn').addEventListener('click', handlePropelCallAction);
        // ▲▲▲ 新增事件綁定結束 ▲▲▲
// 在 init() 函數的事件監聽器區域...

// 【全新】消息提示音設置事件
document.getElementById('test-sound-btn').addEventListener('click', () => {
    const player = document.getElementById('notification-sound-player');
    const url = document.getElementById('notification-sound-url-input').value.trim() || DEFAULT_NOTIFICATION_SOUND;
    player.src = url;
    player.play().catch(e => alert('播放失敗，請檢查URL是否正確或流覽器是否支持該格式。'));
});

document.getElementById('reset-sound-btn').addEventListener('click', () => {
    document.getElementById('notification-sound-url-input').value = '';
    alert('已重置為默認提示音，點擊“保存所有外觀設置”後生效。');
});
    // ▼▼▼ 【全新】為小元件編輯功能添加事件監聽器 (使用事件委託) ▼▼▼
    document.getElementById('home-screen').addEventListener('click', (e) => {
        const target = e.target;
        // 檢查點擊的是否是可編輯的文字
        if (target.classList.contains('editable-text')) {
            handleEditText(target);
        }
        // 檢查點擊的是否是可編輯的圖片
        if (target.classList.contains('editable-image')) {
            handleEditImage(target);
        }
    });
    // ▲▲▲ 新增事件監聽器結束 ▲▲▲  
document.getElementById('add-song-search-btn').addEventListener('click', addSongFromSearch);    
// ▼▼▼ 【全新】為BGM搜索結果彈窗添加事件監聽 ▼▼▼
document.getElementById('cancel-music-search-btn').addEventListener('click', () => {
    document.getElementById('music-search-results-modal').classList.remove('visible');
});

// ▼▼▼ 【全新】BGM搜索結果彈窗事件綁定 (多選版) ▼▼▼
document.getElementById('add-song-search-btn').addEventListener('click', addSongFromSearch);

document.getElementById('cancel-music-search-btn').addEventListener('click', () => {
    document.getElementById('music-search-results-modal').classList.remove('visible');
});

// "全選" 功能
document.getElementById('select-all-music-search').addEventListener('change', function(e) {
    document.querySelectorAll('#search-results-list .music-search-checkbox').forEach(cb => {
        cb.checked = e.target.checked;
    });
});

// 點擊清單項切換選中狀態
document.getElementById('search-results-list').addEventListener('click', (e) => {
    const item = e.target.closest('.search-result-item');
    if (item) {
        const checkbox = item.querySelector('.music-search-checkbox');
        if (checkbox) {
            // 如果點擊的不是核取方塊本身，就手動切換它的狀態
            if (e.target !== checkbox) {
                checkbox.checked = !checkbox.checked;
            }
        }
    }
});

// "添加選中" 按鈕功能
document.getElementById('add-selected-music-btn').addEventListener('click', async () => {
    const selectedItems = document.querySelectorAll('.music-search-checkbox:checked');
    if (selectedItems.length === 0) {
        alert("請先選擇要添加的歌曲。");
        return;
    }

    document.getElementById('music-search-results-modal').classList.remove('visible');
    await showCustomAlert("請稍候...", `正在批量添加 ${selectedItems.length} 首歌曲...`);

    const songDataList = Array.from(selectedItems).map(cb => JSON.parse(cb.closest('.search-result-item').dataset.songJson));
    
    let successCount = 0;
    let failedNames = [];

    // 使用 Promise.all 並行處理所有歌曲的詳情獲取
    const songDetailPromises = songDataList.map(songData => getPlayableSongDetails(songData));
    const fullSongObjects = await Promise.all(songDetailPromises);

    fullSongObjects.forEach((songObject, index) => {
        if (songObject) {
            musicState.playlist.push(songObject);
            successCount++;
        } else {
            failedNames.push(songDataList[index].name);
        }
    });

    if (successCount > 0) {
        await saveGlobalPlaylist();
        updatePlaylistUI();
        if (musicState.currentIndex === -1) {
            musicState.currentIndex = musicState.playlist.length - successCount;
            updatePlayerUI();
        }
    }

    let resultMessage = `添加完成！\n\n成功添加 ${successCount} 首歌曲。`;
    if (failedNames.length > 0) {
        resultMessage += `\n\n${failedNames.length} 首歌曲獲取失敗:\n- ${failedNames.join('\n- ')}`;
    }
    await showCustomAlert("操作結果", resultMessage);
});
// ▲▲▲ 新增事件綁定結束 ▲▲▲
// ▲▲▲ 新增事件綁定結束 ▲▲▲
// ▼▼▼ 【全新】為唱片/歌詞容器綁定切換事件 ▼▼▼
document.getElementById('music-visual-container').addEventListener('click', () => {
    document.getElementById('music-visual-container').classList.toggle('lyrics-active');
});
// ▲▲▲ 新增事件結束 ▲▲▲

// ▼▼▼ 【全新】BGM搜索結果彈窗事件綁定 ▼▼▼
document.getElementById('add-song-search-btn').addEventListener('click', addSongFromSearch);
document.getElementById('cancel-music-search-btn').addEventListener('click', () => {
    document.getElementById('music-search-results-modal').classList.remove('visible');
});

document.getElementById('search-results-list').addEventListener('click', (e) => {
    const item = e.target.closest('.search-result-item');
    if (item && item.dataset.songJson) {
        const songData = JSON.parse(item.dataset.songJson);
        handleSearchResultClick(songData);
    }
});
// ▲▲▲ 新增事件綁定結束 ▲▲▲

// ▼▼▼ 【全新】清理無效歌曲事件綁定 ▼▼▼
document.getElementById('cleanup-songs-btn').addEventListener('click', cleanupInvalidSongs);
document.getElementById('toggle-blur-btn').addEventListener('click', toggleBackgroundBlur);
 document.getElementById('toggle-fullscreen-btn').addEventListener('click', togglePlayerFullscreen);
document.getElementById('show-avatars-btn').addEventListener('click', toggleMusicPlayerAvatars);
// ▲▲▲ 新增事件綁定結束 ▲▲▲
// ▼▼▼ 【全新】為狀態列開關添加即時預覽事件 ▼▼▼
document.getElementById('status-bar-toggle-switch').addEventListener('change', () => {
    // 每次點擊開關時，也調用這個函數來即時切換 class
    state.globalSettings.showStatusBar = document.getElementById('status-bar-toggle-switch').checked;
    applyStatusBarVisibility();
});
// ▲▲▲ 新增事件結束 ▲▲▲
// 為“三點”按鈕綁定新的入口函數
document.getElementById('qzone-more-actions-btn').addEventListener('click', openClearPostsSelectorModal);

// 為新模態框的按鈕綁定事件
document.getElementById('cancel-clear-posts-btn').addEventListener('click', () => {
    document.getElementById('clear-posts-modal').classList.remove('visible');
});
document.getElementById('confirm-clear-posts-btn').addEventListener('click', handleConfirmClearPosts);

// 使用事件委託，為列表項添加勾選/取消勾選的點擊邏輯
document.getElementById('clear-posts-list').addEventListener('click', (e) => {
    const item = e.target.closest('.clear-posts-item');
    if (item) {
        item.classList.toggle('selected');
    }
});
// ▼▼▼ 【全新】全域聊天背景事件綁定 ▼▼▼
document.getElementById('global-bg-input').addEventListener('change', async (event) => {
    const file = event.target.files[0];
    if (file) {
        const dataUrl = await new Promise(resolve => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.readAsDataURL(file);
        });
        // 將上傳的圖片臨時保存在 state 中，等待用戶點擊“保存”
        state.globalSettings.globalChatBackground = dataUrl;
        // 即時更新外觀設置頁面的預覽
        renderWallpaperScreen();
    }
    event.target.value = null; // 清空以便下次選擇
});

document.getElementById('remove-global-bg-btn').addEventListener('click', () => {
    // 移除背景並更新預覽
    state.globalSettings.globalChatBackground = '';
    renderWallpaperScreen();
});

// ▼▼▼ 【重要】更新“保存所有外觀設置”按鈕的邏輯 ▼▼▼
document.getElementById('save-wallpaper-btn').addEventListener('click', async () => {
    // 保存個人主頁壁紙
    if (newWallpaperBase64) {
        state.globalSettings.wallpaper = newWallpaperBase64;
    }
    // 【核心修改】全域聊天背景已經在上傳或移除時更新到 state 中了，
    // 所以這裡我們只需要將包含所有最新設置的 globalSettings 物件完整地保存一次即可。
    
    state.globalSettings.globalCss = document.getElementById('global-css-input').value.trim();
    state.globalSettings.notificationSoundUrl = document.getElementById('notification-sound-url-input').value.trim();
    state.globalSettings.showStatusBar = document.getElementById('status-bar-toggle-switch').checked;
    
    // 一次性保存所有全域設置
    await db.globalSettings.put(state.globalSettings);
    
    // 應用所有更改
    applyGlobalWallpaper();
    newWallpaperBase64 = null;
    applyAppIcons();
    applyGlobalCss(state.globalSettings.globalCss);
    applyStatusBarVisibility();

    alert('外觀設置已保存並應用！');
    showScreen('home-screen');
});
// ▲▲▲ 新增代碼結束 ▲▲▲
// ▼▼▼ 【全新】這是為“網路URL”按鈕添加的功能，請黏貼到 init() 函數的事件監聽器區域 ▼▼▼
document.getElementById('upload-global-bg-url-btn').addEventListener('click', async () => {
    // 1. 彈出一個輸入框，讓用戶輸入URL
    const url = await showCustomPrompt("網路圖片", "請輸入背景圖片的URL", "", "url");

    // 2. 如果用戶輸入了有效的URL並點擊了“確定”
    if (url && url.trim()) {
        // a. 將獲取到的URL更新到全域設置的狀態中
        state.globalSettings.globalChatBackground = url.trim();
        
        // b. 立刻刷新外觀設置頁面的預覽，讓用戶能馬上看到效果
        renderWallpaperScreen();
    } else if (url !== null) {
        // 如果使用者輸入了無效內容（不是null，說明沒點取消）
        alert("請輸入有效的URL。");
    }
});
// ▲▲▲ 新增代碼黏貼結束 ▲▲▲
document.getElementById('upload-ephone-bg-url-btn').addEventListener('click', async () => {
    const url = await showCustomPrompt("網路圖片 (EPhone)", "請輸入EPhone主螢幕的背景圖片URL", "", "url");
    if (url && url.trim()) {
        // EPhone的壁紙更新邏輯是先存到一個臨時變數中
        newWallpaperBase64 = url.trim();
        // 然後刷新預覽
        renderWallpaperScreen();
    } else if (url !== null) {
        alert("請輸入有效的URL。");
    }
});

// 2. 為 CPhone 的“網路URL”按鈕綁定事件
document.getElementById('upload-cphone-bg-url-btn').addEventListener('click', async () => {
    const url = await showCustomPrompt("網路圖片 (CPhone)", "請輸入CPhone的背景圖片URL", "", "url");
    if (url && url.trim()) {
        // CPhone的壁紙更新邏輯是直接修改全域狀態
        state.globalSettings.cphoneWallpaper = url.trim();
        // 然後刷新預覽
        renderWallpaperScreen();
    } else if (url !== null) {
        alert("請輸入有效的URL。");
    }
});
// ▼▼▼ 【全新】這是為EPhone和CPhone壁紙移除功能添加的JS，請黏貼到 init() 函數的事件監聽器區域 ▼▼▼

// 1. 為 EPhone 的“移除壁紙”按鈕綁定事件
document.getElementById('remove-ephone-bg-btn').addEventListener('click', () => {
    // 將臨時變數和全域狀態都清空
    newWallpaperBase64 = null;
    state.globalSettings.wallpaper = '';
    // 刷新預覽，它會自動恢復為默認漸變色
    renderWallpaperScreen();
});

// 2. 為 CPhone 的“移除壁紙”按鈕綁定事件
document.getElementById('remove-cphone-bg-btn').addEventListener('click', () => {
    // 直接清空全域狀態中的 CPhone 壁紙設置
    state.globalSettings.cphoneWallpaper = '';
    // 刷新預覽
    renderWallpaperScreen();
});

// ▲▲▲ 新增JS代碼黏貼結束 ▲▲▲
        // ▼▼▼ 【全新】全域CSS預設功能事件監聽器 ▼▼▼
        document.getElementById('css-preset-select').addEventListener('change', handleCssPresetSelectionChange);
        document.getElementById('save-css-preset-btn').addEventListener('click', saveCssPreset);
        document.getElementById('delete-css-preset-btn').addEventListener('click', deleteCssPreset);
        // ▲▲▲ 新增結束 ▲▲▲
        // ▼▼▼ 【全新】字體預設功能事件監聽器 ▼▼▼
        document.getElementById('font-preset-select').addEventListener('change', handleFontPresetSelectionChange);
        document.getElementById('save-font-preset-btn').addEventListener('click', saveFontPreset);
        document.getElementById('delete-font-preset-btn').addEventListener('click', deleteFontPreset);
        // ▲▲▲ 新增結束 ▲▲▲
        // ▼▼▼ 【全新】氣泡主題預設功能事件監聽器 ▼▼▼
        document.getElementById('theme-preset-select').addEventListener('change', handleThemePresetSelectionChange);
        document.getElementById('save-theme-preset-btn').addEventListener('click', saveThemePreset);
        document.getElementById('delete-theme-preset-btn').addEventListener('click', deleteThemePreset);
        // ▲▲▲ 新增結束 ▲▲▲
        // ▼▼▼ 【全新】這是表情分類功能的【全部事件監聽器】，請黏貼到 init() 函數中 ▼▼▼
        
        // 1. 綁定表情面板頂部的“分類”按鈕，用於打開管理彈窗
        document.getElementById('manage-sticker-categories-btn').addEventListener('click', openStickerCategoryManager);

        // 2. 綁定分類管理彈窗的“完成”按鈕
        document.getElementById('close-sticker-category-manager-btn').addEventListener('click', () => {
            document.getElementById('sticker-category-manager-modal').classList.remove('visible');
            renderStickerPanel(); // 關閉後刷新主面板的頁簽
        });

        // 3. 綁定“添加新分類”按鈕
        document.getElementById('add-new-sticker-category-btn').addEventListener('click', addNewStickerCategory);

        // 4. 使用事件委託處理分類的刪除
        document.getElementById('existing-sticker-categories-list').addEventListener('click', (e) => {
            if (e.target.classList.contains('delete-group-btn')) {
                const categoryId = parseInt(e.target.dataset.id);
                deleteStickerCategory(categoryId);
            }
        });
        
        // 5. 使用事件委託處理表情面板的頁簽切換
        document.getElementById('sticker-category-tabs').addEventListener('click', (e) => {
            if (e.target.classList.contains('sticker-category-tab')) {
                const categoryId = e.target.dataset.categoryId;
                // 將字串ID轉換為數位，除非是 'all' 或 'uncategorized'
                const finalId = (categoryId !== 'all' && categoryId !== 'uncategorized') ? parseInt(categoryId) : categoryId;
                switchStickerCategory(finalId);
            }
        });

        // ▲▲▲ 新增事件綁定結束 ▲▲▲
        document.getElementById('select-all-stickers-checkbox').addEventListener('change', handleSelectAllStickers);
// ▼▼▼ 【全新】單個聊天導入匯出事件綁定 ▼▼▼
document.getElementById('export-single-chat-btn').addEventListener('click', exportSingleChat);

document.getElementById('import-single-chat-btn').addEventListener('click', () => {
    document.getElementById('import-single-chat-input').click();
});

document.getElementById('import-single-chat-input').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
        importSingleChat(file);
    }
    e.target.value = null; // 清空以便下次能選擇同一個文件
});
// ▲▲▲ 新增代碼結束 ▲▲▲
// ▼▼▼ 【全新】Cphone功能事件綁定 ▼▼▼
document.getElementById('add-char-memo-btn').addEventListener('click', () => openMemoEditor());
document.getElementById('add-char-diary-btn').addEventListener('click', () => openDiaryEditor());
document.getElementById('favorite-diary-btn').addEventListener('click', toggleDiaryFavorite);
// ▲▲▲ 新增事件綁定結束 ▲▲▲
        // “重新生成”按鈕
// 新代碼 (解決方案)
document.getElementById('regenerate-char-qq-btn').addEventListener('click', async () => {
    // 為了更好的用戶體驗，先彈出一個提示
    showCustomAlert("正在執行...", "正在生成新的類比聊天記錄，並同時讓角色思考如何與你繼續對話...");

    try {
        // 使用 Promise.all 可以讓兩個獨立的API請求併發執行，效率更高
        await Promise.all([
            handleGenerateSimulatedQQ(),
            handleContinueRealConversationFromCPhone()
        ]);

        console.log("CPhone QQ類比記錄生成 和 主聊天推進 已同時完成。");

    } catch (error) {
        console.error("在同時執行兩個函數時出錯:", error);
        await showCustomAlert("操作失敗", `在執行組合操作時遇到錯誤: ${error.message}`);
    }
});

        // 使用事件委託，處理模擬聊天【列表】的點擊事件
        document.getElementById('char-chat-list').addEventListener('click', (e) => {
            const item = e.target.closest('.chat-list-item');
            if (item && item.dataset.conversationIndex) {
                const index = parseInt(item.dataset.conversationIndex);
                if (!isNaN(index)) {
                    // 【核心修改】現在調用新函數，打開全屏頁面
                    openCharSimulatedConversation(index);
                }
            }
        });



        document.getElementById('back-to-char-qq-list-btn').addEventListener('click', () => {
            switchToCharScreen('char-qq-screen');
        });
// ▼▼▼ 【最終修復版】這是為CPhone鏡像聊天視窗恢復“向上滾動載入”功能的代碼 ▼▼▼

        // 1. 獲取聊天記錄的容器元素
        const charConversationMessages = document.getElementById('char-conversation-messages');

        // 2. 定義滾動事件的處理函數
        const cphoneScrollHandler = () => {
            // 3. 核心判斷：只有當打開的對話是與使用者的私聊時，才執行載入邏輯
            if (cphoneActiveConversationType !== 'private_user') {
                return; // 如果是NPC或群聊，則不執行任何操作
            }
            
            // 4. 檢查是否滾動到頂部，並且當前沒有正在載入
            if (charConversationMessages.scrollTop < 1 && !isLoadingMoreCphoneMessages) {
                const totalMessages = state.chats[activeCharacterId]?.history.length || 0;
                // 檢查是否還有更多歷史記錄可供載入
                if (totalMessages > cphoneRenderedCount) {
                    // 調用載入函數
                    loadMoreMirroredMessages();
                }
            }
        };

        // 5. 將這個處理函數綁定到滾動事件上
        charConversationMessages.addEventListener('scroll', cphoneScrollHandler);

        // ▲▲▲ 修復代碼黏貼結束 ▲▲▲
        // 【新增】為類比對話頁面的“發送”按鈕綁定提示事件
        document.getElementById('char-simulated-send-btn').addEventListener('click', () => {
            alert("這是類比對話，無法發送消息哦~");
        });

        // ▲▲▲ 新增事件綁定結束 ▲▲▲
        // 1. 為“重新生成”按鈕綁定我們剛剛創建的核心函數
        document.getElementById('regenerate-char-album-btn').addEventListener('click', handleGenerateSimulatedAlbum);

        // 2. 使用事件委託，為整個相冊網格添加點擊事件
        document.getElementById('char-album-grid').addEventListener('click', (e) => {
            // 檢查被點擊的是否是一張照片
            const photoItem = e.target.closest('.char-photo-item');
            
            // 如果是，並且它身上存有我們之前放進去的“照片詳情”
            if (photoItem && photoItem.dataset.description) {
                const description = photoItem.dataset.description;
                
                // 就用一個漂亮的彈窗把詳情顯示出來
                showCustomAlert("照片詳情", description.replace(/\n/g, '<br>'));
            }
        });
        document.getElementById('regenerate-char-browser-btn').addEventListener('click', handleGenerateBrowserHistory);
        // 1. 將“重新生成”按鈕與AI生成函數綁定
        document.getElementById('regenerate-char-taobao-btn').addEventListener('click', handleGenerateTaobaoHistory);
       
        
        // 3. 使用事件委託，為購買記錄清單添加點擊事件，用於顯示“購買理由”
        document.getElementById('char-product-grid').addEventListener('click', (e) => {
            const item = e.target.closest('.char-product-item');
            if (item && item.dataset.reason) {
                const reason = item.dataset.reason;
                showCustomAlert("TA的想法...", reason.replace(/\n/g, '<br>'));
            }
        });
        
        // 4. 【核心】將 openCharWallet 函數暴露到全域，以便 onclick 可以調用
        window.openCharWallet = openCharWallet;
document.getElementById('regenerate-char-memo-btn').addEventListener('click', handleGenerateSimulatedMemos);
document.getElementById('char-memo-detail-back-btn').addEventListener('click', () => switchToCharScreen('char-memo-screen'));
// 在 init() 的事件監聽器區域添加
document.getElementById('regenerate-char-diary-btn').addEventListener('click', handleGenerateSimulatedDiaries);
document.getElementById('add-char-diary-btn').addEventListener('click', handleWriteNewDiaryEntry);
document.getElementById('char-diary-detail-back-btn').addEventListener('click', () => switchToCharScreen('char-diary-screen'));
document.getElementById('regenerate-char-amap-btn').addEventListener('click', handleGenerateAmapHistory);
document.getElementById('regenerate-char-usage-btn').addEventListener('click', handleGenerateAppUsage);
        document.getElementById('regenerate-char-music-btn').addEventListener('click', handleGenerateSimulatedMusic);
        document.getElementById('close-char-music-player-btn').addEventListener('click', closeCharMusicPlayer);
document.getElementById('regenerate-douban-btn').addEventListener('click', handleGenerateDoubanPosts);
document.getElementById('regenerate-douban-btn').addEventListener('click', handleGenerateDoubanPosts);
document.getElementById('douban-detail-back-btn').addEventListener('click', () => showScreen('douban-screen'));
document.getElementById('douban-send-comment-btn').addEventListener('click', handleSendDoubanComment);
document.getElementById('douban-wait-reply-btn').addEventListener('click', handleDoubanWaitReply);
        // 1. 為CPhone的壁紙上傳輸入框綁定事件
        document.getElementById('cphone-wallpaper-upload-input').addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (file) {
                const dataUrl = await new Promise((res) => {
                    const reader = new FileReader();
                    reader.onload = () => res(reader.result);
                    reader.readAsDataURL(file);
                });
                // 直接更新 state 中的值，等待用戶點擊“保存”
                state.globalSettings.cphoneWallpaper = dataUrl;
                // 即時刷新預覽
                renderWallpaperScreen();
            }
        });
        
        // 2. 為CPhone的圖示設置網格綁定事件委託
// 為 CPhone 圖示設置網格綁定事件委託
document.getElementById('cphone-icon-settings-grid').addEventListener('click', (e) => {
    if (e.target.classList.contains('change-icon-btn')) {
        const item = e.target.closest('.icon-setting-item');
        const iconId = item.dataset.iconId;
        if (iconId) {
            handleIconChange(iconId, 'cphone', item);
        }
    }
});
document.getElementById('import-appearance-btn').addEventListener('click', () => {
    document.getElementById('import-appearance-input').click();
});

document.getElementById('import-appearance-input').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
        importAppearanceSettings(file);
    }
    e.target.value = null; 
});

// ▼▼▼ 【全新】這是記錄應用關閉時間的核心代碼，請黏貼進去 ▼▼▼
/**
 * 監聽流覽器的可見性變化事件。
 * 當用戶將PWA切換到後臺或關閉流覽器標籤頁時，這個事件會被觸發。
 */
document.addEventListener('visibilitychange', () => {
    // 如果頁面變得不可見 (用戶切換走了)
    if (document.visibilityState === 'hidden') {
        // 我們就在 localStorage 中存下當前的時間戳記
        localStorage.setItem('ephoneLastActiveTimestamp', Date.now());
        console.log("應用已切換到後臺，記錄當前時間。");
    }
});
// ▲▲▲ 新代碼黏貼結束 ▲▲▲
        document.getElementById('export-world-book-btn').addEventListener('click', exportWorldBooks);
        document.getElementById('import-world-book-btn').addEventListener('click', () => {
            document.getElementById('import-world-book-input').click();
        });
document.getElementById('import-world-book-input').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                handleWorldBookImport(file); // 【核心修改】現在調用新的智慧處理器
            }
            e.target.value = null;
        });
        document.getElementById('enable-ai-drawing-switch').addEventListener('change', async (e) => {
            const isEnabled = e.target.checked;
            state.globalSettings.enableAiDrawing = isEnabled;
            await db.globalSettings.put(state.globalSettings);

            // 檢查當前在哪個螢幕，並刷新它
            const activeScreen = document.querySelector('.screen.active');
            if (activeScreen) {
                switch (activeScreen.id) {
                    case 'chat-interface-screen':
                        renderChatInterface(state.activeChatId);
                        break;
                    case 'chat-list-screen':
                        // 刷新動態頁
                        if(document.getElementById('qzone-screen').classList.contains('active')) renderQzonePosts();
                        // 刷新收藏頁
                        if(document.getElementById('favorites-view').classList.contains('active')) renderFavoritesScreen();
                        break;
                    case 'douban-screen':
                        renderDoubanScreen();
                        break;
                    case 'douban-post-detail-screen':
                        openDoubanPostDetail(activeDoubanPostId);
                        break;
                    // Cphone內部的刷新
                    case 'character-phone-screen':
                        const activeCharScreen = document.querySelector('.char-screen.active');
                        if (activeCharScreen) {
                            switch(activeCharScreen.id) {
                                case 'char-album-screen': renderCharAlbum(); break;
                                case 'char-taobao-screen': renderCharTaobao(); break;
                                case 'char-browser-article-screen': 
                                    const char = state.chats[activeCharacterId];
                                    const history = char.simulatedBrowserHistory || [];
                                    const lastArticleIndex = history.length > 0 ? history.length - 1 : 0; // 簡單示例，實際可能需要更精確的索引
                                    renderCharArticle(history[lastArticleIndex]);
                                    break;
                                case 'char-usage-screen': renderCharAppUsage(); break;
                                case 'char-qq-screen': renderCharSimulatedQQ(); break;
                                case 'char-qq-conversation-screen': 
                                    const convoIndex = document.querySelector('#char-chat-list .chat-list-item')?.dataset.conversationIndex || 0;
                                    openCharSimulatedConversation(parseInt(convoIndex));
                                    break;
                            }
                        }
                        break;
                }
            }
            showCustomAlert('設置已應用', `AI生圖功能已${isEnabled ? '開啟' : '關閉'}。`);
        });
// ▼▼▼ 【全新】聊天記錄搜索功能事件綁定 ▼▼▼
document.getElementById('search-history-btn').addEventListener('click', openSearchHistoryScreen);
document.getElementById('search-history-back-btn').addEventListener('click', () => {
    showScreen('chat-settings-screen');
});
document.getElementById('execute-search-btn').addEventListener('click', handleSearchHistory);
document.getElementById('clear-search-btn').addEventListener('click', clearSearchFilters);
// ▲▲▲ 新增事件綁定結束 ▲▲▲
// ▼▼▼ 【全新】自訂頭像框功能事件綁定 ▼▼▼

// 綁定彈窗頭部的“上傳”和“批量”按鈕
document.getElementById('upload-custom-frame-btn').addEventListener('click', handleUploadFrame);
document.getElementById('batch-import-frames-btn').addEventListener('click', handleBatchUploadFrames);

// 使用事件委託，為整個彈窗內容區綁定點擊事件，專門用於處理刪除按鈕
document.querySelector('#avatar-frame-modal .modal-body').addEventListener('click', (e) => {
    // 檢查被點擊的是否是刪除按鈕
    if (e.target.classList.contains('delete-btn')) {
        const frameId = parseInt(e.target.dataset.id);
        if (!isNaN(frameId)) {
            handleDeleteCustomFrame(frameId);
        }
    }
});

// ▲▲▲ 新增事件綁定結束 ▲▲▲
        // ▼▼▼ 【全新】這是主螢幕分頁和“預設”App的【全部事件監聽器】，請完整黏貼 ▼▼▼

        // 1. 初始化主螢幕分頁功能
        setupHomeScreenPagination();

        // 2. 將“預設”App的全域調用函數暴露給 window，以便 onclick 可以找到它
        window.openPresetScreen = openPresetScreen;

        // 3. 綁定“預設”App內部的所有按鈕事件
        document.getElementById('add-preset-btn').addEventListener('click', async () => {
            const name = await showCustomPrompt('創建新預設', '請輸入預設名稱');
            if (name && name.trim()) {
                const newPreset = { id: 'preset_' + Date.now(), name: name.trim(), content: [] };
                await db.presets.add(newPreset);
                await renderPresetScreen();
                openPresetEditor(newPreset.id);
            }
        });

        document.getElementById('manage-preset-categories-btn').addEventListener('click', openPresetCategoryManager);
        
        document.getElementById('add-preset-entry-btn').addEventListener('click', () => {
            const container = document.getElementById('preset-entries-container');
            if (container.querySelector('p')) {
                container.innerHTML = '';
            }
            const newBlock = createPresetEntryBlock();
            container.appendChild(newBlock);
            newBlock.querySelector('.entry-content-textarea').focus();
        });

// ▼▼▼ 【全新 | iOS 相容版】請用這個新版本替換舊的 save-preset-btn 事件監聽器 ▼▼▼
document.getElementById('save-preset-btn').addEventListener('click', async () => {
    if (!editingPresetId) return;
    const preset = await db.presets.get(editingPresetId);
    if (!preset) return;

    // (這部分保存資料的邏輯保持不變)
    const newName = document.getElementById('preset-name-input').value.trim();
    if (!newName) { alert('預設名稱不能為空！'); return; }
    preset.name = newName;
    preset.categoryId = parseInt(document.getElementById('preset-category-select').value) || null;

    const entriesContainer = document.getElementById('preset-entries-container');
    const entryBlocks = entriesContainer.querySelectorAll('.message-editor-block');
    const newEntries = [];
    entryBlocks.forEach(block => {
        const content = block.querySelector('.entry-content-textarea').value.trim();
        if (content) {
            newEntries.push({
                comment: block.querySelector('.entry-comment-input').value.trim(),
                keys: (block.querySelector('.entry-keys-input').value.trim() || '').split(',').map(k => k.trim()).filter(Boolean),
                content: content,
                enabled: block.querySelector('.entry-enabled-switch').checked
            });
        }
    });
    preset.content = newEntries;

    // 1. 先將所有資料保存到資料庫
    await db.presets.put(preset);
    editingPresetId = null;

    // 2. 【核心修復】先切換到目標螢幕
    showScreen('preset-screen');
    
    // 3. 【核心修復】然後再非同步地、從容地渲染那個螢幕上的內容
    // 這就給了流覽器足夠的時間來處理螢幕切換動畫，避免了崩潰
    await renderPresetScreen();
});
// ▲▲▲ 替換結束 ▲▲▲

        // ▲▲▲ 新增事件綁定結束 ▲▲▲
        // ▼▼▼ 【全新】為“預設”App的導入功能綁定事件 ▼▼▼
        document.getElementById('import-preset-btn').addEventListener('click', () => {
            document.getElementById('import-preset-input').click();
        });

        document.getElementById('import-preset-input').addEventListener('change', handlePresetImport);
        // ▲▲▲ 新增事件綁定結束 ▲▲▲
document.getElementById('reset-button-order-btn').addEventListener('click', resetButtonOrder);
// ▼▼▼ 【全新V2.0 | 已修復】高級資料清理功能事件綁定 ▼▼▼
document.getElementById('clear-specific-data-btn').addEventListener('click', openDataClearWizard);

// 嚮導第一步的按鈕
document.getElementById('cancel-clear-wizard-btn-step1').addEventListener('click', () => {
    document.getElementById('data-clear-wizard-modal').classList.remove('visible');
});
document.getElementById('go-to-clear-step2-btn').addEventListener('click', handleDataClearNext);

// 嚮導第二步的按鈕
document.getElementById('back-to-clear-step1-btn').addEventListener('click', handleDataClearBack);
document.getElementById('cancel-clear-wizard-btn-step2').addEventListener('click', () => {
    document.getElementById('data-clear-wizard-modal').classList.remove('visible');
});
document.getElementById('confirm-final-clear-btn').addEventListener('click', handleConfirmDataClear);

// 【核心新增】使用事件委託處理兩個列表的勾選/取消勾選 和 全選
document.getElementById('data-clear-wizard-modal').addEventListener('click', (e) => {
    const item = e.target.closest('.clear-posts-item');
    if (item) {
        // 阻止事件冒泡，避免觸發下面的change事件
        e.stopPropagation();
        item.classList.toggle('selected');
    }
});
document.getElementById('data-clear-wizard-modal').addEventListener('change', (e) => {
    // 全選角色
    if (e.target.id === 'select-all-chars-for-clear') {
        const isChecked = e.target.checked;
        document.querySelectorAll('#data-clear-char-list .clear-posts-item').forEach(item => {
            item.classList.toggle('selected', isChecked);
        });
    } 
    // 全選資料類型
    else if (e.target.id === 'select-all-types-for-clear') {
        const isChecked = e.target.checked;
        document.querySelectorAll('#data-clear-type-list .clear-posts-item').forEach(item => {
            item.classList.toggle('selected', isChecked);
        });
    }
});
// ▲▲▲ 新增事件綁定結束 ▲▲▲
document.getElementById('compress-images-btn').addEventListener('click', compressAllLocalImages);
// ▼▼▼ 在 init() 的事件監聽器區域，找到 #copy-message-btn 的監聽器，在它後面黏貼新代碼 ▼▼▼
document.getElementById('copy-message-btn').addEventListener('click', copyMessageContent);

// 【核心修改】為新按鈕綁定新的功能函數
document.getElementById('copy-timestamp-btn').addEventListener('click', copyMessageTimestamp);
// ▲▲▲ 黏貼結束 ▲▲▲
document.getElementById('npc-list-back-btn').addEventListener('click', () => {
    // 當這個按鈕被點擊時，調用我們定義在“私密作用域”裡的函數
    switchToChatListView('messages-view');
});

// 綁定NPC列表頁頂部的“+”按鈕
document.getElementById('add-npc-btn').addEventListener('click', () => openNpcEditor(null));

// 綁定NPC編輯器彈窗的“保存”和“取消”按鈕
document.getElementById('save-npc-btn').addEventListener('click', saveNpc);
document.getElementById('cancel-npc-editor-btn').addEventListener('click', () => {
    document.getElementById('npc-editor-modal').classList.remove('visible');
});

// 綁定NPC頭像上傳
document.getElementById('npc-avatar-input').addEventListener('change', (event) => {
    const file = event.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = (e) => {
            document.getElementById('npc-avatar-preview').src = e.target.result;
        };
        reader.readAsDataURL(file);
    }
});
document.getElementById('chat-lock-overlay').addEventListener('click', (e) => {
    // 檢查點擊的是否是“重Roll”按鈕
    if (e.target.id === 'spectator-reroll-btn') {
        handleSpectatorReroll();
    }
    // 檢查點擊的是否是“剪輯”按鈕
    else if (e.target.id === 'spectator-edit-btn') {
        // 直接複用現有的“導演剪輯室”打開函數
        openAiResponseEditor();
    }
    // (注意：主按鈕 spectator-propel-btn 的事件已在 renderChatInterface 中直接綁定，這裡無需處理)
});
addLongPressListener(document.getElementById('music-visual-container'), () => { if (musicState.currentIndex > -1) { handleChangeAlbumArt(musicState.currentIndex); } });
document.getElementById('douban-settings-btn').addEventListener('click', openDoubanSettingsModal);
document.getElementById('save-douban-settings-btn').addEventListener('click', saveDoubanSettings);
document.getElementById('cancel-douban-settings-btn').addEventListener('click', () => {
    document.getElementById('douban-settings-modal').classList.remove('visible');
});
// ▼▼▼ 【全新】為時區搜索框添加事件監聽 ▼▼▼
document.getElementById('time-zone-search-input').addEventListener('input', (e) => {
    const searchTerm = e.target.value.toLowerCase();
    const selectEl = document.getElementById('time-zone-select');
    
    // 遍歷下拉清單中的每一個選項
    for (const option of selectEl.options) {
        const optionText = option.textContent.toLowerCase();
        
        // 如果選項的文本內容包含了使用者輸入的搜索詞，就顯示它
        if (optionText.includes(searchTerm)) {
            option.style.display = ''; // 恢復顯示
        } else {
            // 否則就隱藏它
            option.style.display = 'none';
        }
    }
});
// ▲▲▲ 新增JS代碼結束 ▲▲▲
// ▼▼▼ 【全新】狼人殺遊戲事件監聽器 ▼▼▼
    
// 遊戲小屋入口
// (這個已經在HTML的onclick裡處理了, 但最好也在這裡暴露一下函數)
window.openWerewolfLobby = openWerewolfLobby;

// 聊天工具列入口
document.getElementById('werewolf-game-btn').addEventListener('click', () => openWerewolfLobby('group'));

// 大廳按鈕
document.getElementById('cancel-werewolf-lobby-btn').addEventListener('click', () => {
    document.getElementById('werewolf-lobby-modal').classList.remove('visible');
});
document.getElementById('start-werewolf-game-btn').addEventListener('click', initializeWerewolfGame);

// 【全新】為新彈窗的取消/關閉按鈕綁定事件
        document.getElementById('werewolf-role-confirm-btn').addEventListener('click', () => {
            document.getElementById('werewolf-role-modal').classList.remove('visible');
            executeNightPhase(); // 確認身份後，正式進入夜晚
        });
        
        document.getElementById('exit-werewolf-game-btn').addEventListener('click', async () => {
            const confirmed = await showCustomConfirm('退出遊戲', '確定要退出當前這局狼人殺嗎？遊戲進度將不會被保存。', {confirmButtonClass: 'btn-danger'});
            if (confirmed) {
                werewolfGameState.isActive = false;
                // 根據遊戲是從哪裡發起的，返回到不同的介面
                showScreen(werewolfGameState.chatId ? 'chat-interface-screen' : 'home-screen');
            }
        });

        document.getElementById('werewolf-game-over-close-btn').addEventListener('click', () => {
            document.getElementById('werewolf-game-over-modal').classList.remove('visible');
            showScreen(werewolfGameState.chatId ? 'chat-list-screen' : 'home-screen');
        });

// ▲▲▲ 新增事件監聽器結束 ▲▲▲
// ▼▼▼ 在 init() 的事件監聽器區域添加 ▼▼▼
document.getElementById('cancel-wolf-kill-btn').addEventListener('click', () => {
    document.getElementById('werewolf-kill-modal').classList.remove('visible');
});
// ▲▲▲ 新增代碼結束 ▲▲▲

// ▼▼▼ 在 init() 函數的事件監聽器區域添加 ▼▼▼
document.getElementById('cancel-werewolf-lobby-btn').addEventListener('click', () => {
    document.getElementById('werewolf-lobby-modal').classList.remove('visible');
});
// ▲▲▲ 新增代碼結束 ▲▲▲
document.getElementById('werewolf-retry-btn').addEventListener('click', handleWerewolfRetry);
document.getElementById('manual-werewolf-summary-btn').addEventListener('click', handleManualWerewolfSummary);
document.getElementById('check-and-fix-data-btn').addEventListener('click', checkAndFixData);
// ▼▼▼ 【全新】這是為刪除世界書功能添加的事件監聽器 ▼▼▼
document.getElementById('delete-world-books-btn').addEventListener('click', openWorldBookDeletionModal);

// 為新彈窗的按鈕和清單綁定事件
document.getElementById('cancel-delete-world-books-btn').addEventListener('click', () => {
    document.getElementById('delete-world-books-modal').classList.remove('visible');
});
document.getElementById('confirm-delete-world-books-btn').addEventListener('click', handleConfirmWorldBookDeletion);

document.getElementById('delete-world-books-modal').addEventListener('click', (e) => {
    // 處理列表項的勾選/取消勾選
    const item = e.target.closest('.clear-posts-item');
    if (item) {
        item.classList.toggle('selected');
    }
    // 處理“全選”核取方塊
    if (e.target.id === 'select-all-world-books-for-clear') {
        const isChecked = e.target.checked;
        document.querySelectorAll('#delete-world-books-list .clear-posts-item').forEach(el => {
            el.classList.toggle('selected', isChecked);
        });
    }
});
// ▲▲▲ 新增事件監聽器結束 ▲▲▲
// ▼▼▼ 【全新】表情包搜索功能事件綁定 ▼▼▼
document.getElementById('sticker-search-input').addEventListener('input', () => {
    // 用戶輸入時，只需要重繪表情網格，不需要重繪頂部的頁簽
    renderStickerPanel(false); 
});

// 【修正】當切換分類時，清空搜索框並刷新
document.getElementById('sticker-category-tabs').addEventListener('click', (e) => {
    if (e.target.classList.contains('sticker-category-tab')) {
        const categoryId = e.target.dataset.categoryId;
        const finalId = (categoryId !== 'all' && categoryId !== 'uncategorized') ? parseInt(categoryId) : categoryId;
        
        // 清空搜索框的值
        document.getElementById('sticker-search-input').value = ''; 
        
        // 調用我們現有的切換函數
        switchStickerCategory(finalId);
    }
});
// ▲▲▲ 新增代碼結束 ▲▲▲
// ▼▼▼ 【全新】無限滾動事件監聽器 ▼▼▼

// --- 1. 聊天記錄的滾動載入 ---
const chatMessagesContainer = document.getElementById('chat-messages');
chatMessagesContainer.addEventListener('scroll', () => {
    // 當滾動到頂部時觸發
    if (chatMessagesContainer.scrollTop < 1 && !isLoadingMoreMessages) {
        const totalMessages = state.chats[state.activeChatId]?.history.length || 0;
        // 檢查是否還有更多消息可供載入
        if (totalMessages > currentRenderedCount) {
             loadMoreMessages();
        }
    }
});

// --- 2. 心聲歷史的滾動載入 ---
const thoughtsHistoryList = document.getElementById('thoughts-history-list');
thoughtsHistoryList.addEventListener('scroll', () => {
    const { scrollTop, scrollHeight, clientHeight } = thoughtsHistoryList;
    // 當滾動到底部時觸發
    if (scrollHeight - scrollTop <= clientHeight + 50 && !isLoadingMoreThoughts) { // 增加50px的緩衝距離
        const totalItems = state.chats[state.activeChatId]?.thoughtsHistory.length || 0;
        if (totalItems > thoughtsHistoryRenderCount) {
            loadMoreThoughts();
        }
    }
});

// --- 3. 好友動態的滾動載入 ---
const qzoneContent = document.querySelector('#qzone-screen .qzone-content');
qzoneContent.addEventListener('scroll', () => {
    const { scrollTop, scrollHeight, clientHeight } = qzoneContent;
    // 當滾動到底部時觸發
    if (scrollHeight - scrollTop <= clientHeight + 100 && !isLoadingMorePosts) { // 增加100px的緩衝距離
        if (qzonePostsCache.length > qzonePostsRenderCount) {
            loadMoreQzonePosts();
        }
    }
});

// ▲▲▲ 新增事件監聽器結束 ▲▲▲
// ▼▼▼ 【V2.0 | 全新】一起讀書功能事件綁定 ▼▼▼
document.getElementById('read-together-btn').addEventListener('click', openReadingRoom);
const restoreBtn = document.getElementById('reading-restore-btn');
// 調用我們現有的拖動函數，將小球本身作為拖動目標和拖動把手
makeDraggable(restoreBtn, restoreBtn);
document.getElementById('close-reading-btn').addEventListener('click', closeReadingRoom);
document.getElementById('open-reading-library-btn').addEventListener('click', openBookLibrary);
document.getElementById('next-page-btn').addEventListener('click', showNextPage);
document.getElementById('prev-page-btn').addEventListener('click', showPrevPage);
document.getElementById('book-upload-input').addEventListener('change', handleBookFileUpload);

// 新增：為最小化和恢復按鈕綁定事件
document.getElementById('minimize-reading-btn').addEventListener('click', minimizeReadingRoom);
document.getElementById('reading-restore-btn').addEventListener('click', restoreReadingRoom);

// 新增：初始化視窗的拖動功能
makeDraggable(document.getElementById('reading-window'), document.querySelector('#reading-window .reading-header'));
// ▲▲▲ 新增事件綁定結束 ▲▲▲
// ▼▼▼ 【全新】為讀書功能的新按鈕綁定事件 ▼▼▼
document.getElementById('open-reading-library-btn').addEventListener('click', openBookLibrary);
// ▼▼▼ 【全新】為書庫彈窗的頭部SVG按鈕綁定事件 ▼▼▼
document.getElementById('close-reading-library-btn-header').addEventListener('click', () => {
    document.getElementById('reading-library-modal').classList.remove('visible');
});
document.getElementById('import-new-book-btn-header').addEventListener('click', importBook);
// ▲▲▲ 替換結束 ▲▲▲

// 使用事件委託處理書庫列表中的點擊事件
document.getElementById('reading-library-list').addEventListener('click', (e) => {
    const target = e.target;
    if (target.classList.contains('group-name')) { // 點擊書名 -> 閱讀
        const bookId = parseInt(target.dataset.bookId);
        loadBookFromLibrary(bookId);
    } else if (target.classList.contains('delete-group-btn')) { // 點擊刪除按鈕
        const bookId = parseInt(target.dataset.bookId);
        deleteBookFromLibrary(bookId);
    }
});
// ▲▲▲ 新增事件綁定結束 ▲▲▲
document.getElementById('page-indicator').addEventListener('click', handlePageJump);
document.getElementById('reading-library-search-input').addEventListener('input', (e) => {
    // 當使用者輸入時，調用渲染函數並傳入搜索詞
    renderBookLibrary(e.target.value);
});
const debouncedUpdateReadingContext = debounce(updateReadingContextOnScroll, 300); // 停止滾動300毫秒後觸發

// 2. 將這個新函數綁定到讀書視窗內容區的滾動事件上
document.getElementById('reading-content').addEventListener('scroll', debouncedUpdateReadingContext);
document.getElementById('api-temperature-slider').addEventListener('input', (e) => {
    document.getElementById('api-temperature-value').textContent = e.target.value;
});
const chatListContainer = document.getElementById('messages-view');
chatListContainer.addEventListener('scroll', () => {
    const { scrollTop, scrollHeight, clientHeight } = chatListContainer;
    // 當捲軸距離底部小於 150px 時觸發載入
    if (scrollHeight - scrollTop <= clientHeight + 150 && !isLoadingMoreChats) {
        loadMoreChats();
    }
});
// ▼▼▼ 【全新V2.0】這是商品分類和款式功能的【全部事件監聽器】，請完整黏貼 ▼▼▼
        
        // 綁定“管理分類”按鈕
        document.getElementById('manage-product-categories-btn').addEventListener('click', openProductCategoryManager);
document.getElementById('close-product-category-manager-btn').addEventListener('click', () => {
    document.getElementById('product-category-manager-modal').classList.remove('visible');
    // 核心修復：關閉分類管理器後，立即重新渲染商品編輯器
    // 這會重新從資料庫載入最新的分類清單，並更新下拉清單
    openProductEditor(editingProductId); 
});
        document.getElementById('add-new-product-category-btn').addEventListener('click', addNewProductCategory);
        document.getElementById('existing-product-categories-list').addEventListener('click', (e) => {
            if (e.target.classList.contains('delete-group-btn')) {
                deleteProductCategory(parseInt(e.target.dataset.id));
            }
        });

        // 綁定“添加新的一款”按鈕
        document.getElementById('add-product-variation-btn').addEventListener('click', () => addProductVariationInput());

        // 綁定“選擇款式”彈窗的取消和數量控制按鈕
        document.getElementById('cancel-variation-selection-btn').addEventListener('click', () => {
            document.getElementById('variation-selection-modal').classList.remove('visible');
        });
        document.getElementById('variation-decrease-qty').addEventListener('click', () => {
            const display = document.getElementById('variation-quantity-display');
            let qty = parseInt(display.textContent);
            if (qty > 1) display.textContent = qty - 1;
        });
        document.getElementById('variation-increase-qty').addEventListener('click', () => {
            const display = document.getElementById('variation-quantity-display');
            display.textContent = parseInt(display.textContent) + 1;
        });
document.getElementById('product-category-tabs').addEventListener('click', (e) => {
    // 檢查被點擊的是否是一個頁簽按鈕
    if (e.target.classList.contains('product-category-tab')) {
        // 從被點擊的按鈕上，獲取我們之前儲存的分類ID
        const categoryId = e.target.dataset.categoryId === 'all' ? 'all' : parseInt(e.target.dataset.categoryId);
        
        // 調用切換分類的函數 (這個函數您上一輪已經添加過了)
        switchShoppingCategory(categoryId);
    }
});
document.getElementById('generate-shopping-items-btn').addEventListener('click', handleGenerateShoppingItems);
document.getElementById('shopping-settings-btn').addEventListener('click', openShoppingSettingsModal);
document.getElementById('save-shopping-settings-btn').addEventListener('click', saveShoppingSettings);
document.getElementById('cancel-shopping-settings-btn').addEventListener('click', () => {
    document.getElementById('shopping-settings-modal').classList.remove('visible');
});
document.getElementById('select-all-products-checkbox').addEventListener('change', (e) => {
    const isChecked = e.target.checked;
    // 獲取當前分類下所有可見的商品
    const visibleItems = document.querySelectorAll('#product-grid .product-item');

    visibleItems.forEach(item => {
        const productId = parseInt(item.dataset.id);
        item.classList.toggle('selected', isChecked);
        if (isChecked) {
            selectedProducts.add(productId);
        } else {
            selectedProducts.delete(productId);
        }
    });
    document.getElementById('delete-selected-products-btn').textContent = `刪除 (${selectedProducts.size})`;
});

// 批量刪除按鈕事件
document.getElementById('delete-selected-products-btn').addEventListener('click', async () => {
    if (selectedProducts.size === 0) {
        alert("請先選擇要刪除的商品。");
        return;
    }

    const confirmed = await showCustomConfirm(
        '確認刪除',
        `確定要永久刪除選中的 ${selectedProducts.size} 個商品嗎？此操作不可恢復。`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        await db.shoppingProducts.bulkDelete([...selectedProducts]);

        // 退出管理模式並刷新
        document.getElementById('manage-products-btn').click(); 
        // 重新渲染以顯示更改
        await renderShoppingProducts();

        await showCustomAlert("成功", "選中的商品已成功刪除。");
    }
});
// ▼▼▼ 【全新】外觀預設功能事件監聽器 ▼▼▼
document.getElementById('appearance-preset-select').addEventListener('change', handleAppearancePresetSelectionChange);
document.getElementById('save-appearance-preset-btn').addEventListener('click', saveAppearancePreset);
document.getElementById('delete-appearance-preset-btn').addEventListener('click', deleteAppearancePreset);
// ▲▲▲ 新增結束 ▲▲▲
document.getElementById('manage-frames-btn').addEventListener('click', toggleFrameManagementMode);
document.getElementById('select-all-frames-checkbox').addEventListener('change', handleSelectAllFrames);
document.getElementById('delete-selected-frames-btn').addEventListener('click', executeBatchDeleteFrames);


    checkForUpdates();

                    showScreen('home-screen');
                }
        
                init();
            });
        
    </script>
    <div id="qzone-sticker-panel">
        <div id="qzone-sticker-grid"></div>
    </div>
    <!-- ▼▼▼ 【全新 V2.0 | 支持上傳】請用這整塊代碼，完整替換舊的 avatar-frame-modal ▼▼▼ -->
<div id="avatar-frame-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <span>選擇頭像框</span>
            <div class="header-actions">
                <!-- 【核心新增1】這就是新的“管理”按鈕 -->
                <button id="manage-frames-btn" class="action-button">管理</button>
                <button id="upload-custom-frame-btn" class="action-button">上傳</button>
                <button id="batch-import-frames-btn" class="action-button">批量</button>
            </div>
        </div>
        <div class="modal-body">
            <div class="frame-tabs">
                <div id="ai-frame-tab" class="frame-tab active">對方的</div>
                <div id="my-frame-tab" class="frame-tab">我的</div>
            </div>
            <div id="ai-frame-content" class="frame-content">
                <div id="ai-frame-grid" class="frame-grid">
                </div>
            </div>
            <div id="my-frame-content" class="frame-content" style="display: none;">
                <div id="my-frame-grid" class="frame-grid">
                </div>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-frame-settings-btn">取消</button>
            <button class="save" id="save-frame-settings-btn">保存</button>
        </div>
        <!-- 【核心新增2】這是底部批量操作欄 -->
        <div id="frame-action-bar" style="display: none;">
            <label class="select-all-label" style="display: flex; align-items: center; gap: 5px;">
                <input type="checkbox" id="select-all-frames-checkbox"> 全選
            </label>
            <button id="delete-selected-frames-btn" class="action-bar-btn">刪除 (0)</button>
        </div>
    </div>
</div>
<!-- 【核心新增】用於本地上傳的隱藏檔輸入框 -->
<input type="file" id="custom-frame-upload-input" accept="image/*" hidden>
    <!-- ▲▲▲ 替換結束 ▲▲▲ -->

<div id="character-profile-modal" class="modal">
    <div class="character-profile-content">
        <!-- 右上角的歷史記錄圖示按鈕 -->
        <button id="profile-history-icon-btn" title="查看歷史心聲">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path>
                <path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path>
            </svg>
        </button>
        
        <!-- 主資料頁 -->
        <div id="profile-main-content">
            <!-- （這裡的內容結構與上次類似，但被包裹在了卡片內部） -->
            <div id="profile-timestamp" class="thought-header"></div>
            <div class="thought-content">
                <div class="voice">
                    <div class="label">
                        <svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>
                        心聲
                    </div>
                    <p id="profile-heartfelt-voice" class="text"></p>
                </div>
                <div class="jottings">
                    <div class="label">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19l7-7 3 3-7 7-3-3z"></path><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"></path><path d="M2 2l7.586 7.586"></path></svg>
                        散記
                    </div>
                    <p id="profile-random-jottings" class="text"></p>
                </div>
            </div>
        </div>

        <!-- 歷史記錄頁 (保持不變，但現在也在卡片內切換) -->
        <div id="profile-thoughts-history-view">
            <div class="profile-header">
                <span>心聲記錄</span>
                <button id="history-back-btn" title="返回">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"></polyline></svg>
                </button>
            </div>
            <div id="thoughts-history-list"></div>
        </div>
    </div>
</div>
    <!-- ▲▲▲ 新HTML黏貼結束 ▲▲▲ -->
    <!-- ▼▼▼ 【全新】“我的”頭像庫專用文件上傳輸入框 ▼▼▼ -->
    <input type="file" id="my-avatar-upload-input" accept="image/*" hidden>
    <!-- ▲▲▲ 新HTML黏貼結束 ▲▲▲ -->
    <!-- ▼▼▼ 【全新】這是選擇禮物接收人的彈窗，請黏貼到 body 底部 ▼▼▼ -->
    <div id="gift-recipient-modal" class="modal">
        <div class="modal-content" style="height: 70%;">
            <div class="modal-header">
                <span>選擇收禮人</span>
                <label style="font-size: 14px; font-weight: normal; display: flex; align-items: center; gap: 5px;">
                    <input type="checkbox" id="select-all-recipients"> 全選 </label>
            </div>
            <div class="modal-body" id="gift-recipient-list" style="padding: 0;">
                <!-- 群成員清單將由JS動態生成在這裡 -->
            </div>
            <div class="modal-footer">
                <button class="cancel" id="cancel-gift-recipient-btn">取消</button>
                <button class="save" id="confirm-gift-recipient-btn">確認送出</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->

<!-- ▼▼▼ 請將這個【全新的 <audio> 標籤】黏貼到 <body> 標籤的最末尾，緊鄰 </body> 之前 ▼▼▼ -->
<audio id="notification-sound-player" preload="auto"></audio>
<!-- ▲▲▲ 黏貼結束 ▲▲▲ -->
<!-- ▼▼▼ 【全新V2版】BGM搜索結果彈窗 (支持多選) ▼▼▼ -->
<div id="music-search-results-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span>搜索結果</span>
            <!-- 核心修改1：添加“全選”核取方塊 -->
            <label style="font-size: 14px; font-weight: normal; display: flex; align-items: center; gap: 5px;">
                <input type="checkbox" id="select-all-music-search"> 全選
            </label>
        </div>
        <div class="modal-body" id="search-results-list" style="padding: 0;">
            <!-- 搜索結果將由JS動態生成在這裡 -->
        </div>
        <div class="modal-footer">
            <!-- 核心修改2：更新頁腳按鈕 -->
            <button class="cancel" id="cancel-music-search-btn">取消</button>
            <button class="save" id="add-selected-music-btn">添加選中</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 替換結束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】這是豆瓣設置的彈窗，請黏貼到 body 底部 ▼▼▼ -->
<div id="douban-settings-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <span>豆瓣設置</span>
        </div>
        <div class="modal-body">
            <div class="form-group douban-settings-item">
                <label for="douban-min-posts-input">
                    每次生成帖子數範圍
                    <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
                        設置AI在豆瓣頁面一次性生成帖子的最小和最大數量。
                    </p>
                </label>
                <div class="douban-settings-controls">
                    <input type="number" id="douban-min-posts-input" min="1" value="12">
                    <span>到</span>
                    <input type="number" id="douban-max-posts-input" min="1" value="20">
                    <span>篇</span>
                </div>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-douban-settings-btn">取消</button>
            <button class="save" id="save-douban-settings-btn">保存</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->
<audio id="char-audio-player" preload="auto"></audio>
<!-- ▼▼▼ 【全新】豆瓣角色選擇彈窗 ▼▼▼ -->
<div id="douban-cast-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span>選擇參與豆瓣的角色</span>
        </div>
        <div class="modal-body" id="douban-cast-list" style="padding: 0;">
            <!-- 角色清單將由JS動態生成在這裡 -->
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-douban-cast-btn">取消</button>
            <button class="save" id="save-douban-cast-btn">保存並刷新</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】這是為“預設”功能新增的檔導入輸入框 ▼▼▼ -->
<input type="file" id="import-preset-input" accept=".json" hidden>
<!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】這是更新通知彈窗的HTML結構 ▼▼▼ -->
<div id="update-notice-modal">
    <div class="update-notice-content">
        <div class="update-notice-body" id="update-notice-body">
            <!-- 更新內容將由JS動態載入到這裡 -->
        </div>
        <div class="update-notice-footer">
            <button id="update-notice-confirm-btn">我知道了</button>
            <button id="update-notice-dismiss-btn">不再提示</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->
<div id="delete-world-books-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span>選擇要刪除的世界書</span>
            <label style="font-size: 14px; font-weight: normal; display: flex; align-items: center; gap: 5px;">
                <input type="checkbox" id="select-all-world-books-for-clear"> 全選
            </label>
        </div>
        <div class="modal-body" id="delete-world-books-list" style="padding: 0;">
            </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-delete-world-books-btn">取消</button>
            <button class="save btn-danger" id="confirm-delete-world-books-btn">確認刪除</button>
        </div>
    </div>
</div>
<!-- ▼▼▼ 【全新】狼人殺夜晚刀人彈窗 ▼▼▼ -->
<div id="werewolf-kill-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header"><span>狼人請選擇刀人物件</span></div>
        <div class="modal-body" id="werewolf-kill-selection-list" style="padding: 0;"></div>
        <div class="modal-footer">
             <button class="cancel" id="cancel-wolf-kill-btn">放棄</button>
             <button class="save btn-danger" id="confirm-wolf-kill-btn">確認刀人</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->
<div id="werewolf-lobby-modal" class="modal">
    <div class="modal-content" style="height: 80%;">
        <div class="modal-header">
            <span>選擇玩家開始狼人殺</span>
        </div>
        <div class="modal-body" id="werewolf-player-selection-list" style="padding: 0;">
            </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-werewolf-lobby-btn">取消</button>
            <button class="save" id="start-werewolf-game-btn">開始遊戲</button>
        </div>
    </div>
</div>

<!-- ▼▼▼ 【全新V2.0 | 交互修復版】請用這整塊代碼，完整替換舊的 werewolf-game-screen ▼▼▼ -->


<div id="werewolf-role-modal" class="modal">
    <div class="modal-content" style="width: 280px; height: auto; text-align: center; padding: 20px;">
        <h3 id="werewolf-role-title" style="margin-top: 0;">你的身份是</h3>
        <div id="werewolf-role-card" style="margin: 15px 0;">
            <!-- 【核心修復】在這裡添加了缺失的 h2 和 p 標籤 -->
            <h2 id="werewolf-role-name" style="margin: 0 0 10px 0;"></h2>
            <p id="werewolf-role-description" style="font-size: 14px; line-height: 1.6; color: #555; margin: 0;"></p>
        </div>
        <button id="werewolf-role-confirm-btn" class="form-button">我準備好了</button>
    </div>
</div>

<div id="werewolf-prophet-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header"><span>預言家請選擇查驗物件</span></div>
        <div class="modal-body" id="werewolf-prophet-selection-list" style="padding: 0;"></div>
        <div class="modal-footer">
             <button class="save" id="confirm-prophet-check-btn">確認查驗</button>
        </div>
    </div>
</div>

<div id="werewolf-hunter-modal" class="modal">
     <div class="modal-content" style="height: 70%;">
        <div class="modal-header"><span>獵人請選擇開槍物件</span></div>
        <div class="modal-body" id="werewolf-hunter-selection-list" style="padding: 0;"></div>
        <div class="modal-footer">
             <button class="save btn-danger" id="confirm-hunter-shot-btn">確認開槍</button>
        </div>
    </div>
</div>

<!-- ▼▼▼ 【全新】這是你缺失的“投票”彈窗，請黏貼到此處 ▼▼▼ -->
<div id="werewolf-vote-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header"><span>請投票放逐一名玩家</span></div>
        <div class="modal-body" id="werewolf-vote-selection-list" style="padding: 0;"></div>
        <div class="modal-footer">
             <button class="save" id="confirm-vote-btn">確認投票</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->
<!-- ▼▼▼ 【全新V2.0】這是你缺失的所有狼人殺角色操作彈窗，請完整黏貼 ▼▼▼ -->

<!-- 1. 守衛選擇彈窗 -->
<div id="werewolf-guard-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header"><span>守衛請選擇今晚要守護的玩家</span></div>
        <div class="modal-body" id="werewolf-guard-selection-list" style="padding: 0;"></div>
        <div class="modal-footer">
             <button class="save" id="confirm-guard-selection-btn">確認守護</button>
        </div>
    </div>
</div>

<!-- 2. 女巫操作彈窗 (資訊提示 + 毒人選擇) -->
<div id="werewolf-witch-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header"><span id="witch-modal-title">女巫請睜眼</span></div>
        <div class="modal-body" id="werewolf-witch-selection-list" style="padding: 0;">
            </div>
        <div class="modal-footer">
             <button class="cancel" id="witch-do-nothing-btn">什麼都不做</button>
             <button class="save btn-danger" id="confirm-witch-poison-btn" style="display: none;">確認用毒</button>
        </div>
    </div>
</div>


<!-- 3. 獵人開槍彈窗 (之前缺失) -->
<div id="werewolf-hunter-modal" class="modal">
     <div class="modal-content" style="height: 70%;">
        <div class="modal-header"><span>獵人請選擇開槍物件</span></div>
        <div class="modal-body" id="werewolf-hunter-selection-list" style="padding: 0;"></div>
        <div class="modal-footer">
             <button class="save btn-danger" id="confirm-hunter-shot-btn">確認開槍</button>
        </div>
    </div>
</div>

<!-- 4. 投票彈窗 (之前缺失) -->
<div id="werewolf-vote-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header"><span>請投票放逐一名玩家</span></div>
        <div class="modal-body" id="werewolf-vote-selection-list" style="padding: 0;"></div>
        <div class="modal-footer">
             <button class="save" id="confirm-vote-btn">確認投票</button>
        </div>
    </div>
</div>

<!-- ▼▼▼ 【全新V2.0 | 已添加身份公佈】請用這整塊代碼，完整替換舊的 werewolf-game-over-modal ▼▼▼ -->
<div id="werewolf-game-over-modal" class="modal">
    <div class="modal-content" style="width: 300px; height: auto; text-align: center; padding: 20px;">
        <h2 id="werewolf-game-over-title">遊戲結束</h2>
        <p id="werewolf-game-over-reason" style="font-size: 16px; margin: 20px 0;"></p>
        
        <!-- 【【【核心新增：身份公佈列表】】】 -->
        <div id="werewolf-role-reveal-list" style="max-height: 250px; overflow-y: auto; margin: 20px 0; border-top: 1px solid #444; padding-top: 10px;">
            <!-- 玩家身份將由JS動態生成在這裡 -->
        </div>
        
        <button id="werewolf-game-over-close-btn" class="form-button">返回大廳</button>
      <button id="manual-werewolf-summary-btn" class="form-button form-button-secondary" style="margin-top: 10px;">手動總結記憶</button>
    </div>
</div>
<!-- ▲▲▲ 替換結束 ▲▲▲ -->
<div id="reading-library-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span>我的書庫</span>
            <div class="header-actions">
                <span class="action-btn" id="import-new-book-btn-header" title="導入新書">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
                </span>
                <span class="action-btn" id="close-reading-library-btn-header" title="關閉">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                </span>
            </div>
        </div>

        <div id="reading-library-search-container">
            <input type="search" id="reading-library-search-input" placeholder="搜索書名...">
        </div>

        <div class="modal-body" style="padding: 0; flex-grow: 1; overflow-y: auto;">
            <div id="reading-library-list">
                </div>
        </div>

        </div>
</div>
<div id="product-category-manager-modal" class="modal">
    <div class="modal-content" style="height: 60%;">
        <div class="modal-header">
            <span>管理商品分類</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label>新建分類</label>
                <div style="display: flex; gap: 10px;">
                    <input type="text" id="new-product-category-name-input" placeholder="輸入分類名..." style="flex-grow: 1;">
                    <button id="add-new-product-category-btn" class="form-button" style="width: auto; margin-top: 0; padding: 0 15px;">添加</button>
                </div>
            </div>
            <hr style="opacity: 0.2;">
            <div id="existing-product-categories-list" style="display: flex; flex-direction: column; gap: 10px;">
                </div>
        </div>
        <div class="modal-footer">
            <button class="save" id="close-product-category-manager-btn" style="width: 100%;">完成</button>
        </div>
    </div>
</div>
<div id="variation-selection-modal" class="modal">
    <div class="modal-content" style="width: 320px; height: auto;">
        <div class="modal-header" style="padding-bottom: 0;">
            </div>
        <div class="modal-body">
            <div id="variation-product-info" style="display: flex; align-items: flex-start; gap: 12px; margin-bottom: 15px;">
                <img id="variation-product-image" style="width: 80px; height: 80px; border-radius: 6px; object-fit: cover;">
                <div>
                    <p id="variation-product-name" style="font-weight: 500; margin: 0;"></p>
                    <p id="variation-selected-price" style="color: #ff5722; font-weight: bold; font-size: 18px; margin: 8px 0 0;"></p>
                </div>
            </div>
            <div class="form-group">
                <label>選擇款式</label>
                <div id="variation-options-container" style="display: flex; flex-wrap: wrap; gap: 8px;">
                    </div>
            </div>
            <div class="form-group">
                <label>購買數量</label>
                <div class="quantity-control" style="justify-content: flex-start;">
                    <button class="quantity-btn" id="variation-decrease-qty">-</button>
                    <span class="quantity-display" id="variation-quantity-display">1</span>
                    <button class="quantity-btn" id="variation-increase-qty">+</button>
                </div>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-variation-selection-btn">取消</button>
            <button class="save" id="confirm-variation-selection-btn">加入購物車</button>
        </div>
    </div>
</div>
<div id="shopping-settings-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <span>購物中心生成設置</span>
        </div>
        <div class="modal-body">
            <div class="form-group douban-settings-item">
                <label for="shopping-category-count-input">
                    生成分類數量
                    <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
                        設置AI一次性生成多少個商品分類。
                    </p>
                </label>
                <div class="douban-settings-controls">
                    <input type="number" id="shopping-category-count-input" min="1" max="10" value="3">
                    <span>個</span>
                </div>
            </div>
            <div class="form-group douban-settings-item">
                <label for="shopping-product-count-input">
                    每個分類商品數量
                    <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
                        設置每個分類下生成多少個商品。
                    </p>
                </label>
                <div class="douban-settings-controls">
                    <input type="number" id="shopping-product-count-input" min="2" max="10" value="8">
                    <span>個</span>
                </div>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-shopping-settings-btn">取消</button>
            <button class="save" id="save-shopping-settings-btn">保存</button>
        </div>
    </div>
</div>
<!-- ▼▼▼ 【全新】這是用於iOS後臺保活的靜音播放機，請黏貼到 body 末尾 ▼▼▼ -->
<audio id="silent-audio-player" loop preload="auto" style="display:none;">
    <source src="https://phoebeboo.github.io/mewoooo/1-second-of-silence.mp3" type="audio/mpeg">
</audio>
<!-- ▲▲▲ 新增代碼黏貼結束 ▲▲▲ -->
<audio id="tts-audio-player" style="display:none;"></audio>
</body>
</html>

